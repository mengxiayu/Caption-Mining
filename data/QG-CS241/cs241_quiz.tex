
%%Q1 [signals]
\question{3} 
\variant
Choose the best response. The signal {\tt SIGCHLD} is an example of ...
\begin{answers}
\answer A signal that is generated by a process and can be caught by the target process's chosen signal handler
\answer A signal that is typically generated by a process, delivered to the kernel, and cannot be caught by a signal handler
\correctanswer A signal that is generated by the kernel and can be caught by the target process's chosen signal handler
\answer A signal that is used internally by the kernel and never delivered to a target process
\answer A signal that is delivered to a network interface when there is a connection error 
\end{answers}
\begin{solution}
\end{solution}

%%Q2 [signals]
\question{3}
\variant
Choose the best response. The signal {\tt SIGKILL} is an example of ...
\begin{answers}
\answer A signal that is generated by a process and can be caught by the target process's chosen signal handler
\correctanswer A signal that is typically generated by a process, delivered to the kernel, and cannot be caught by a signal handler
\answer A signal that is generated by the kernel and can be caught by the target process's chosen signal handler
\answer A signal that is used internally by the kernel and never delivered to a target process
\answer A signal that is delivered to a network interface when there is a connection error 
\end{answers}
\begin{solution}
\end{solution}



%% Student Q
%%Q3 [heap allocator]
\question{3}
\variant
Riddle me this! I find new memory for you but won't stop until I find the smallest piece that's at least as large as the size you're looking for! I am:
\begin{answers}
\answer Impossible fit allocator
\answer First fit allocator
\answer Buddy allocator
\correctanswer Best fit allocator
\answer Worst fit allocator
\end{answers}
\begin{solution}
\end{solution}

%%Q4 [chmod]
%% Student Q
\question{3}
\variant
I have a file {\tt good.txt}. How do I change the permissions of my file such that:
\begin{verbatim}
The owner (me) has full permission: Read, write, and execute
The group has read and write permissions
Everyone else has read permission
\end{verbatim}
\begin{answers}
\correctanswer chmod 764 good.txt
\answer chown rwx-rw--r good.txt
\answer chown 671 good.txt
\answer perm good.txt 317 
\answer perm good.txt rwx-rw--r
\end{answers}
\begin{solution}
\end{solution}



%%Q5 [malloc]
\question{3}
\variant
Which of the following lines is most likely to crash at runtime or cause a compile-time error?
\begin{verbatim}
1. int* f(void) {
2.     int* x = (int*) malloc (10000 * sizeof(int));
3.     return & x[5];
4. }
5. int main(int argc, char** argv) {
6.     int* p = f();
7.     int y = *p;
8.     free(p);
9. }
\end{verbatim}

\begin{answers}
\answer Line 2
\answer Line 3
\answer Line 6
\answer Line 7
\correctanswer Line 8
\end{answers}
\begin{solution}
\end{solution}

%%Q6 [malloc]
\question{3}
\variant
In the code below, suppose that when malloc is called, the {\em system has no more memory to allocate}.  In this case, which of the lines is most likely to crash the program (terminating the program, not just returning an error)?
\begin{verbatim}
1. int* f(void) {
2.     int* x = (int*) malloc (100000 * sizeof(int));
3.     return x + 5;
4. }
5. int main(int argc, char** argv) {
6.     int* p = f();
7.     int y = *p;
8.     free(p);
9. }
\end{verbatim}
\begin{answers}
\answer Line 2
\answer Line 3
\answer Line 6
\correctanswer Line 7
\answer Line 8
\end{answers}
\begin{solution}
\end{solution}

%%Q7 [VM]
\question{3}
\variant
Suppose Program A prints out the virtual memory address of one of its variables, and Program B reads this address value.  Typically, well-written programs do not share their virtual memory addresses in this way.  Why not?
\begin{answers}
\answer Program B can use this address to illegally access private data of Program A.
\answer Program B can use this address to access data of Program A, which may cause a problem if the data is not protected with a synchronization primitive.
\correctanswer The virtual memory address has no meaning in Program B's memory address space and is essentially a garbage pointer.
\answer This is not possible to implement: when Program A tries to print out an address, it will be translated to a physical address, and is not a virtual address.

\end{answers}
\begin{solution}
\end{solution}


%%Q8 [page tables]
\question{3}
\variant
A memory address is split up into a page number and a page offset. On a 32-bit byte-addressable machine where each page contains 4 KB of data, how many bits are used for the page number?
\begin{answers}
\answer 8
\answer 12
\answer 16
\correctanswer 20
\answer 28
\end{answers}
\begin{solution}
\end{solution}

\variant
A memory address is split up into a page number and a page offset. On a 32-bit byte-addressable machine where each page contains 2 KB of data, how many bits are used for the page offset?
\begin{answers}
\answer 10
\answer 12
\answer 21
\correctanswer 11
\answer 16
\end{answers}
\begin{solution}
\end{solution}

\variant
A memory address is split up into a page number and a page offset. On a 64-bit byte-addressable machine where each page contains 8 KB of data, how many bits are used for the page number?
\begin{answers}
\answer 13
\answer 8
\answer 56
\correctanswer 51
\answer 64
\end{answers}
\begin{solution}
\end{solution}

%%Q9 [c strings, variable scope]
\question{3}
\variant
Consider the following functions.  Recall that {\tt strcpy(dest, s2)} copies the string {\tt s2} into {\tt dest}.
\begin{verbatim}
char *func_1(char *fname) {
  char * buffer = (char *)malloc(strlen(fname));
  strcpy(buffer, fname);
  return buffer;
}
char *func_2(char *fname) {
  char buffer[1024];
  strcpy(buffer, fname);
  return buffer;
}
char *func_3(char *fname) {
  char * buffer = (char *)malloc(sizeof(fname) + 1);
  strcpy(buffer, fname);
  return buffer;
}
\end{verbatim}

When used as part of a larger program, which of the functions above use memory correctly?
\begin{answers}
\answer {\tt Only func_1}
\answer {\tt Only func_2}
\answer {\tt Only func_3}
\answer {\tt Only func_1} and {\tt func_2}
\correctanswer All three functions use memory incorrectly
\end{answers}
\begin{solution}
\end{solution}

%%Q10 [signals]
\question{3}
\variant
Solve my poetic riddle! There once was a process named Thor who tore through big data galore. Now one day an {\tt alarm()} sent him possible harm
\begin{answers}
\answer But he blocked it with a semaphore
\correctanswer But he'd signal()'d a handler before
\answer He segfaulted and promptly dumped core
\answer So he utilized the standard POSIX syscall to return a process to running state after it is terminated, {\tt fork_restore()}
\end{answers}
\begin{solution}
\end{solution}

%%Q11 [thread control]
\question{3}
\variant
A worker thread with id {\tt tid} calls {\tt pthread_exit(x)} where {\tt x} is a pointer to a buffer allocated on the heap. Which one of the following is true?
\begin{answers}
\correctanswer The main thread can get the buffer pointer using {\tt pthread_join(tid,\&ptr)}.
\answer When the thread exits, all heap memory is reclaimed; the buffer is invalid.
\answer Other threads need to use {\tt pthread_get_attr()} to read from the buffer.
\answer The process will exit if the x value is {\tt NULL}.
\answer Only the main thread may call {\tt pthread_exit}.
\end{answers}
\begin{solution}
\end{solution}

%%Q12 [variable scope]
\question{3}
\variant
In the code below, function {\tt foo()} has a stack variable {\tt x} and calls the function worker with argument \&x as the entry point to a new thread. Once {\tt worker()} starts running, is its argument {\tt arg} a valid memory pointer?
\begin{verbatim}
void* worker(void* arg) {
    int y;
    ...
    return arg;
}
void foo(void){
    char x = 'A';
    void* result;
    pthread_t tid;
    pthread_create(&tid, 0, worker, (void*)&x);
    pthread_join(tid, (void*) &result);
}
\end{verbatim}
\begin{answers}
\correctanswer Yes
\answer No
\answer Maybe: may depend on nondeterministic events at runtime
\answer African or European swallow?
\answer This is not the response you are looking for
\end{answers}
\begin{solution}
\end{solution}

\variant
Function {\tt worker()} has a stack variable {\tt y} and returns \&y. After {\tt foo()} starts the thread, it calls {\tt pthread_join()} to collect the return value of {\tt worker()}.  At this point, is the return value of {\tt worker()} a valid memory pointer?
\begin{verbatim}
void* worker(void* arg) {
    int y;
    ...
    return &y;
}
void foo(void){
    char x='A';
    void* result;
    pthread_t tid;
    pthread_create(&tid, 0, worker, (void*)&x);
    pthread_join(tid,&result);
}
\end{verbatim}
\begin{answers}
\answer Yes
\correctanswer No 
\answer Maybe: may depend on nondeterministic events at runtime
\answer Only when compiled using a C99 compiler
\answer Only when compiled using a C89 compiler
\end{answers}
\begin{solution}
\end{solution}

%%Q13 [context switch]
\question{3}
\variant
Choose the most complete answer:  When reassigning a CPU from one process to another, the OS must always...
\begin{answers}
\answer change some register values
\correctanswer change some register values and update the page table in the MMU
\answer change some register values, update the page table in the MMU, and write pages to disk
\answer change some register values, update the page table in the MMU, write pages to disk, and put the old process on the ``blocked" queue
\end{answers}
\begin{solution}
\end{solution}




%%Q14 [Security - new 2019 Spring]
\question{3}
\variant
What is ``C.I.A." from a secure development practices point of view?

\begin{answers}
\correctanswer Protect the Confidentiality, Integrity and Availability of the data and service.
\answer Security-aware code reviews should be Complete, Intelligent and Audacious.
\answer Security automated tests should be Comprehensive, Intensive and Accuate.
\answer roduction features - Complete, Debug features - Inoperative, and Documentation - Accurate.
\end{answers}
\begin{solution}
\end{solution}



%%Q15 [CSP]
\question{3}
\variant
Consider pseudo-code executed potentially multiple times by two different threads, Thread 1 and Thread 2, around a critical section.  In all cases, assume that all variables are initialized to zero when the threads start. In answering the question, you should consider all possible scenarios including scenarios where a thread executes the code more than once (sequentially) and scenarios where only one of the two threads remains, while the other has terminated. Which of the following statements is true about the code segment below?
\begin{verbatim}
Thread 1 :
   while (!done) {
      while (x > 0) { /*repeat*/ }
      atomic increment x;
      CRITICAL SECTION
      atomic decrement x;
      
      // Do other computation for a random amount of time
   }
\end{verbatim}

\begin{verbatim}
Thread 2 :
   while (!done) {
      while (x > 0) { /*repeat*/ }
      atomic increment x;
      CRITICAL SECTION
      atomic decrement x;
      
      // Do other computation for a random amount of time
   }
\end{verbatim}

\begin{answers}
\answer Mutual Exclusion and Progress are both NOT guaranteed
\answer Mutual Exclusion is guaranteed but Progress is NOT guaranteed
\correctanswer Mutual Exclusion is NOT guaranteed but Progress is guaranteed
\answer Mutual Exclusion and Progress are both guaranteed
\end{answers}
\begin{solution}
\end{solution}



%%Q16 [CSP]
\question{3}
\variant
What are Meltdown, Spectre and Heartbleed?

\begin{answers}
\correctanswer These are vulnerabilities that allow an unauthorized access to confidential information.
\answer These are all examples of ssl protocol vulnerabilities.
\answer These are all examples of CPU vulnerabilities that affect the integrity of the data.
\answer These are all examples of network vulnerabilities  that affect the availability of the data.
\answer None of the other responses are correct.
\end{answers}
\begin{solution}
\end{solution}


%%Q17 [resource allocation graphs]
\question{3}
\variant
A resource allocation graph is typically used for which purpose by the operating system?
\begin{answers}
\answer Create deadlocks for test purposes
\correctanswer Find or minimize deadlocks
\answer Allocate TCP server graphs
\answer Allocate UDP server graphs
\answer Allocate shared memory
\end{answers}
\begin{solution}
\end{solution}

%%Q18 [race conditions]
\question{3}
\variant
What term is used to describe an error condition particular to concurrent programming where the results of a multi-threaded application change as the relative schedule (sequence of operations) of different threads varies?
\begin{answers}
\answer Memory Leak
\correctanswer Race Condition
\answer Loose Semaphore
\answer Dining Philosopher Problem
\answer Deadlock
\end{answers}
\begin{solution}
\end{solution}


%%Q19 [deadlock]
\question{3}
\variant
Suppose, for some system, an ordering of resources is defined and all processes/threads acquire resources in the defined order. Would deadlock be avoided?
\begin{answers}
\correctanswer Yes
\answer No
\end{answers}
\begin{solution}
\end{solution}


%%Q20 [not a process context switch]
\question{3}
\variant
Choose the most complete answer:  When reassigning a CPU from one thread to another thread in the same process, the OS must always...
\begin{answers}
\correctanswer change some register values
\answer change some register values and update the page table in the memory management unit (MMU)
\answer change some register values, update the page table in the MMU, and write pages to disk
\answer change some register values, update the page table in the MMU, write pages to disk, and put the old thread on the ``blocked" queue
\end{answers}
\begin{solution}
\end{solution}


%%Q21 [mutexes]
\question{3}
%% Mutex locks
\variant
Two threads call {\tt pthread_mutex_lock} on the same mutex. Which one of the following best describes what happens next?
\begin{answers}
\answer The result is undefined
\answer The mutex lock is increased by two
\answer The mutex lock is decreased by two
\correctanswer One thread will continue, the other thread must wait until the mutex is unlocked
\end{answers}
\begin{solution}
\end{solution}


%%Q22 [dining philosophers]
\question{3}
\variant
Assume in the Dining Philosophers problem, each philosopher repeatedly thinks for some length of time and then decides to eat. To eat, they attempt to lock the left chopstick, then lock the right chopstick, eat, then unlock in the reverse order (right, then left). With N philosophers and N plates sitting around a circular table this can cause deadlock. Which of the following changes are sufficient to eliminate \textbf{deadlock} ? 

\begin{verbatim}
1. Having N seats (each including a chopstick) and N/2 philosophers.
2. Having N seats (each including a chopstick) and N-1 philosophers.
3. If the right chopstick is locked, put the left chopstick down and go back to thinking
\end{verbatim}

\begin{answers}
\answer Only change 1 would prevent deadlock
\answer Only change 2 would prevent deadlock
\answer Only change 3 would prevent deadlock
\correctanswer Any of the changes would prevent deadlock
\answer Only changes 1 and 3 would prevent deadlock
\end{answers}
\begin{solution}
\end{solution}

%%Q23 [scheduling]
\question{3}
\variant
Which of the following scheduling policies is likely to achieve the best response time?
\begin{answers}
\answer Non-preemptive First Come First Serve (FCFS)
\answer Non-preemptive priority scheduling
\answer Non-preemptive shortest job first
\answer Round Robin with a large quantum
\correctanswer Round Robin with a small quantum
\end{answers}
\begin{solution}
\end{solution}


%%Q24 [pipes]
\question{3}
\variant
Which response best describes stream interface(s) (similar to a TCP connection) that can be used for IPC?
\begin{answers}
\correctanswer pipes
\answer mmap
\answer signals
\answer fstreams
\answer All of the other responses are correct
\end{answers}
\begin{solution}
\end{solution}



%%Q25 [signals]
\question{3}
\variant
When the code is stuck in the infinite loop at Line 7, the user presses {\tt Ctrl+C} three times in attempt to kill the program.  What best describes what happens?

\begin{verbatim}
01 void handler(int sig) {
02     write(1,"No!",3);
03 }
04 
05 void main() {
06     signal(SIGINT, handler);
07     while (1) { }
08 }
\end{verbatim}

\begin{answers}

\answer The program does nothing.
\answer The program exits due to a segmentation fault caused by {\tt Ctrl+C}.
\answer The program exits normally, the {\tt Ctrl+C} breaks the code out of an infinite loop.
\answer The program prints out {\tt No!} exactly three times, and keeps looping.
\correctanswer The program prints out {\tt No!} one to three times, and keeps looping. 
\end{answers}
\begin{solution}
\end{solution}


%%Q26 [network ports]
\question{3}
\variant
Each machine only has a limited number of network port numbers that are shared globally between all users of the machine.  Which one of the following is true about ports?
\begin{verbatim}
1. The port numbers are limited to 65,536 on EWS machines only because they are 64-bit machines.
2. All ports are equivalent and any user on any machine may access any port.
3. Ports below 1024 are reserved for well-established protocols run by users with root privileges.
\end{verbatim}
\begin{answers}
\answer Only statements 1 and 2 are true
\answer Only statements 1 and 3 are true
\correctanswer Only statement 3 is true
\answer Only statement 2 is true
\answer Only statement 1 is true
\end{answers}
\begin{solution}
\end{solution}

%%Q27 [HTTP]
\question{3}
\variant
 Which of the following statements about HTTP is FALSE?
\begin{answers}
\answer HTTP can be used on top of a TCP connection.
\answer Only one HTTP request can be sent per connection using non-persistent HTTP.
\answer An HTTP client can store user-specific information in the form of cookies.
\answer GET is a valid method of an HTTP request.
\correctanswer HTTP/1.0 headers are binary encoded and not human readable.
\end{answers}
\begin{solution}
\end{solution}

%%Q28 [TCP]
\question{3}
\variant
 Which one of the following features is NOT a feature provided by TCP? 
\begin{answers}
\answer Retransmission of lost packets
\answer Duplicate packet detection
\correctanswer Encryption of application data
\answer Flow control
\answer Ordered delivery
\end{answers}
\begin{solution}
\end{solution}

%%Q29 [file system representation]
\question{3}
\variant
 A file system has 4-KB blocks and 4-byte disk addresses. The inode of a file uses 8 direct entries and a single-indirect table which is half full.  How large is the file in blocks? 
\begin{answers}
\answer 16 blocks
\answer 264 blocks
\correctanswer 520 blocks
\answer 1032 blocks
\answer 5004 blocks
\end{answers}
\begin{solution}
\end{solution}

%%Q30 [procfs]
\question{3}
\variant
Which response best describes the purpose of {\tt /sys} and {\tt /proc} virtual filesystems?
\begin{answers}
\correctanswer To provide a filesystem view of kernel objects and resources currently used by the kernel and user processes
\answer To provide standard area to mount temporary devices such as USB keys and DVDs
\answer To provide networked filesystem control
\answer None of the other responses are correct
\answer To provide thread and synchronization control of kernel tasks
\end{answers}
\begin{solution}
\end{solution}


\question{3}
\variant
The manual page for {\tt strpbrk()} can be found after the function prototypes at
the end of the exam.    What would the following code print?
\begin{verbatim}
char *s = "hello";
char *r = strpbrk(s, NULL);
printf("%d\n", r == NULL ? -1 : (int)(r-s));
\end{verbatim}

\begin{answers}
\answer -1
\answer 0
\answer 5
\answer The behavior is undefined, but is guaranteed not to cause a segfault.
\correctanswer The behavior is undefined, and it may cause a segfault.
\end{answers}
\begin{solution}
\end{solution}

\variant
The manual page for {\tt strpbrk()} can be found after the function prototypes at
the end of the exam.  What would the following code print?
\begin{verbatim}
char *s = "asteroids";
char *r = strpbrk(s, "ids");
printf("%d\n", r == NULL ? -1 : (int)(r-s));
\end{verbatim}
\begin{answers}
\answer -1
\answer 0
\answer Undefined
\answer 6 
\correctanswer 1
\end{answers}
\begin{solution}
\end{solution}

\variant
The manual page for {\tt strpbrk()} can be found after the function prototypes at
the end of the exam.  What would the following code print?
\begin{verbatim}
char *s = "galaga";
char *r = strpbrk(s, "tempest");
printf("%d\n", r == NULL ? -1 : (int)(r-s));
\end{verbatim}
\begin{answers}
\answer 1
\answer 0
\answer Undefined
\answer 6 
\correctanswer -1
\end{answers}
\begin{solution}
\end{solution}


%%%%%%%%%%%%%%%%%%%%%%% Begin Quiz 1 revenge %%%%%%%%%%%%%%%%%%%%%

%%Q31
\question{3}

%% EDK - fun but useless trivia
%% \variant
%% Which one of the following is NOT correct?
%% \begin{answers}
%% \answer {\tt cat abc} will print the contents of the file {\tt abc} to the terminal
%% \answer {\tt ./bitcoin > coins }  runs a program named {\tt bitcoin} but redirects standard output to a file named {\tt coins}
%% \answer A C string is just an array of {\tt char}s which is terminated with a null character
%% \answer A single variable of C type {\tt char} is not sufficient to store an international unicode (16 bit) character
%% \correctanswer The C ANSI standard defines a byte to be exactly 8 bits
%% \end{answers}
%% \begin{solution}
%% \end{solution}


% sizeof char
\variant
Which one of the following is IMPOSSIBLE?
\begin{answers}
\correctanswer sizeof(char) is 2
\answer sizeof(int) is 8
\answer sizeof(int*) is 4
\answer sizeof(char*) is 8
\answer sizeof(void*) is 4
\end{answers}
\begin{solution}
\end{solution}


\variant
Which one of the following does not depend on the computer architecture?
\begin{answers}
\correctanswer sizeof(char)
\answer sizeof(int)
\answer sizeof(int*)
\answer sizeof(char*)
\answer sizeof(void*)
\end{answers}
\begin{solution}
\end{solution}


% integers can be > 4bytes. malloc and free
\variant
Which of the following best describes the C code below? Assume this is part of a C main method and malloc returns a non-NULL value.
\begin{verbatim}
1  int* ptr = (int*) malloc(4);
2  *ptr = 42;
3  free(ptr);
4  ptr = (int*) 42;
\end{verbatim}
\begin{answers}
\correctanswer May crash at line 2 if an integer requires more than 4 bytes of storage
\answer C uses `new' and `delete' not `malloc' and `free'
\answer Allocates 4 bytes of memory on the stack
\answer  Will always crash at line 3
\answer Will always crash at line 4
\end{answers}
\begin{solution}
\end{solution}

\variant
Which of the following best describes the C code below? Assume this is part of a C main method and malloc returns a non-NULL value.
\begin{verbatim}
1  int* ptr = (int*) malloc(sizeof(int));
2  *ptr = 42;
3  free(ptr);
4  ptr = (int*) 42;
5  free(ptr);
\end{verbatim}
\begin{answers}
\answer May crash at line 2 if an integer requires more than 4 bytes of storage
\answer C uses `new' and `delete' not `malloc' and `free'
\answer Allocates 4 bytes of memory on the stack
\answer  Will always crash at line 3
\correctanswer Will always crash at line 5
\end{answers}
\begin{solution}
\end{solution}


% double free
\variant
Which of the following best describes the C code below? Assume this is part of a C main method and malloc returns a non-NULL value.
\begin{verbatim}
1  void* v = malloc(4);
2  free(v);
3  free(v);
\end{verbatim}

\begin{answers}
\correctanswer Is a memory allocation error described as ``double free"
\answer Is a memory allocation error described as ``free after malloc"
\answer Allocates 4 bytes of memory on the stack
\answer Is valid and error-free
\answer To be error free line 1 requires a cast to an int or character pointer
\end{answers}
\begin{solution}
\end{solution}


% free(NULL)
\variant
Which one of the following best describes the {\tt free} call in the following code example?
\begin{verbatim}
1  int* v = NULL;
2  free(v);
\end{verbatim}

\begin{answers}
\correctanswer The above {\tt free} call has no effect and is error free
\answer Frees up all previously allocated memory
\answer Is invalid and commonly described as a `NULL-free' error
\answer Is invalid and commonly described as a `free-on-null' error

\end{answers}
\begin{solution}
\end{solution}



% sizeof vs strlen
\variant
The following expression uses {\tt sizeof} and {\tt strlen} function. What is the value of result?
\begin{verbatim}
 int result = 1 + sizeof("abc") + ( sizeof("abc") * strlen("abc") );
\end{verbatim}

\begin{answers}
\correctanswer $17$
\answer $16$
\answer $13$
\answer $21$
\answer None of the other responses are correct
\end{answers}
\begin{solution}
\end{solution}

%Pointer dereferencing

\variant
The following C code is executed as part of a main method. Which line, if any, will likely cause the program to crash?
\begin{verbatim}
1  char * ptr = (char*) rand(); /* rand() returns an random integer value */
2  int * b = (int*) ptr;
3  b = b + 1;
4  ptr = (char*) rand();
5  *ptr = (char) rand();
\end{verbatim}

\begin{answers}
\correctanswer $5$
\answer $4$
\answer $3$
\answer $2$
\answer None of the other responses are correct
\end{answers}
\begin{solution}
\end{solution}


% C String length - NUL byte search
\variant
Which one of the following best describes how to find the length of a C string?
\begin{answers}
\correctanswer Requires O(N) search to find the terminating null character {\tt \textbackslash0}
\answer  Requires O(1) lookup to read the length byte
\answer Is compiler dependent and not part of the C specification
\answer Requires O(N) reverse linear search
\answer None of the other responses are correct
\end{answers}
\begin{solution}
\end{solution}


% C String length - malloc + NUL byte search
\variant
Which one of the following correctly allocates enough bytes on the heap to copy an existing string pointed to by a character pointer, {\tt char* src}?
\begin{answers}
\correctanswer {\tt malloc( strlen(src) + 1); }
\answer  {\tt malloc( sizeof(src) + 1); }
\answer  {\tt new string( sizeof(src) + 1); }
\answer  {\tt char array[ strlen(src) ]; }
\answer None of the other responses are correct
\end{answers}
\begin{solution}
\end{solution}


% malloc can fail
\variant
Which one of the following best describes {\tt malloc}?
\begin{answers}
\correctanswer {\tt malloc} will return {\tt NULL } if it cannot reserve sufficient heap memory
\answer {\tt malloc} will return $-1$ if it cannot reserve sufficient stack memory
\answer   {\tt malloc} will throw an exception if there is insufficient free ram
\answer   {\tt malloc} will always successfully allocate heap memory
\answer None of the other responses are correct
\end{answers}
\begin{solution}
\end{solution}



% print format
% EDK: changed from printing a pointer value (0x38a) to printing a float, because
% you can't guarantee what the value of the pointer will be.
\variant
My C program prints {\tt Hello 42 3.14}. Which response is the best choice for the next line?
\begin{verbatim}
1 char* ptr = "Hello";
2 int x = 84 >>1;
3 double d = 3.14159265;
3 ?
\end{verbatim}
\begin{answers}
\correctanswer {\tt printf("\%s \%d \%.2f",ptr,x,d); }
\answer  {\tt write(ptr,5);write(x,2); write(\&d,3);}
\answer    {\tt  cout <<ptr<<" "<<x<<" "<<\&d;}
\answer   {\tt  printf("\$1s \$2d \$1f",ptr,x,d); }
\answer   {\tt  printf("\$\{ptr\} \$\{x\} \$\{d\}"); }
\end{answers}
\begin{solution}
\end{solution}


\variant
Which one of the following is true for typical layout of a process's memory?
\begin{answers}
 
\answer Program constants are stored in the stack
\answer Writing to read-only memory is ignored by the operating system
\answer Program code is not stored in the process's memory
\answer All of the process's memory address maps to physical RAM address
\correctanswer Program constants are read-only

\end{answers}
\begin{solution}
\end{solution}


% Nul byte + buffer overflow no protection
\variant
Which one of the following best describes the following C code?
\begin{verbatim}
1 char array[] = "ABC";
2 char x = array[3];
3 char y = array[4];
4 x = y;
\end{verbatim}
\begin{answers}
\answer Buffer overflow at line $2$. {\tt x} may contain data from another variable
\correctanswer Buffer overflow at line $3$. {\tt y} may contain data from another variable 
\answer The program will not compile
\answer The program will crash at line $2$ 
\answer The program will throw an exception
\end{answers}
\begin{solution}
\end{solution}

\variant
Which one of the following best describes for the following C code?
\begin{verbatim}
1 char array[] = "ABCD";
2 char x = array[5];
3 char y = array[0];
4 x = y;
\end{verbatim}
\begin{answers}
\correctanswer Buffer overflow at line $2$. {\tt x} may contain data from another variable
\answer Buffer overflow at line $3$. {\tt y} may contain data from another variable 
\answer The program will not compile
\answer The program will crash at line $4$ 
\answer None of the other responses are correct
\end{answers}
\begin{solution}
\end{solution}


% printf - write
\variant
Which one of the following is correct?
\begin{answers} 
\answer {\tt write} always calls {\tt printf} when it is called
\correctanswer {\tt printf} uses a buffer so may not call {\tt write} every time it is called
\answer {\tt printf} always calls {\tt write} when it is called with more than one argument
\answer {\tt write} and {\tt printf} are identical and have the same function prototype
\answer {\tt printf} is a system call, {\tt write} is a C library call
\end{answers}
\begin{solution}
\end{solution}


% include stdio.h
\variant
The {\tt printf} function declaration can be included in your C program by writing...
\begin{answers}
\correctanswer {\tt \#include <stdio.h> }
\answer {\tt \#include <iostream> }
\answer {\tt \#define iostream.h(printf)}
\answer   {\tt \#define "sys/printf.h" }
\answer None of the other responses are correct
\end{answers}
\begin{solution}
\end{solution}


\variant
Carefully read the following C code and determine how often it will print {\tt lucky}.
\begin{verbatim}
int a = rand(); /* returns a random int */
if( a = 4) printf("You're lucky!");
\end{verbatim}
\begin{answers}
\correctanswer You are always lucky
\answer You are never lucky
\answer You have a small chance of being lucky
\end{answers}
\begin{solution}
\end{solution}

\variant
Carefully read the following C code and determine how often it will print {\tt lucky}.
\begin{verbatim}
int a = rand(); /* returns a random int */
if( a = 0) printf("You're lucky!");
\end{verbatim}
\begin{answers}
\answer You are always lucky
\correctanswer You are never lucky
\answer You have a small chance of being lucky
\end{answers}
\begin{solution}
\end{solution}


% Pointer arith
\variant
If {\tt sizeof(int)} is $2$ what will be the expected output of the following C code? 
\begin{verbatim}
char* ptr = "ABCDEF";
int * x = (int*) ptr;
printf("%s", x + 1 );
\end{verbatim}
\begin{answers}
\correctanswer  {\tt CDEF}
\answer  {\tt ABCDEF1}
\answer  {\tt EF}
\answer  {\tt BCDEF}
\answer  {\tt Segmentation Fault}
\end{answers}
\begin{solution}
\end{solution}


% Pointer casting
\variant
Which response best describes the following code? Assume {\tt ptr} holds the address {\tt 0x8400}.
\begin{verbatim}
1 void* ptr =   /* code not shown */
2 char* ptr2 = (char*)ptr;
3 void* x = & ptr2 + 1;
4 int result = *(ptr2 +1);  
\end{verbatim}
\begin{answers}
\correctanswer  One byte of memory at address 0x8401 is read at line 4
\answer  One byte of memory at address 0x8401 is read at line 3
\answer  One byte of memory at address 0x8400 is read at line 2
\answer  None of the other responses are correct
\answer  Line 4 has a syntax error
\end{answers}
\begin{solution}
\end{solution}


% O/S Design Goals
\variant
Which of the following best describes the design goal(s) of an operating system?
\begin{answers}
\correctanswer  All of the other responses are correct
\answer  An operating system provides security and guards against malfunctioning user programs
\answer  An operating system provides a level of abstraction above low-level hardware interfaces
\answer  An operating system provides a set of services to user programs that can be accessed by system calls
\answer  An operating system must efficiently manage scarce resources (CPU cores, RAM,...)
\end{answers}
\begin{solution}
\end{solution}


% O/S Memory isolated
\variant
In the Linux operating system, which is based on the POSIX standard, which one of the following is true?
\begin{answers}
\correctanswer  Each process is isolated and runs in its own virtual memory space
\answer  Processes can write directly into another processes memory to easily crash the other process
\answer  A program can only be run by a single user at a time
\answer Shell utilities (e.g. {\tt cat ls make}) are written in assembler
\answer  The overhead of a system calls is the same as a C library call
\end{answers}
\begin{solution}
\end{solution}



\variant
Which response best describes the behavior of the following code?
\begin{verbatim}
int mystery(char *start) {
  if( start == NULL) return NULL;
  char* p= start;
  while (*p !='q') p++;
  return p - start;
}
\end{verbatim}
\begin{answers}
\correctanswer  {\tt mystery("ABC") } is undefined (and may crash)
\answer  {\tt mystery("q") } returns 1
\answer  {\tt mystery("q") } returns 2
\answer  {\tt mystery(NULL) }  is undefined (and may crash)
\answer  {\tt mystery(NULL) }  returns 1
\end{answers}
\begin{solution}
\end{solution}


\variant
Which response best describes the following student code that attempts to implement string copy?
\begin{verbatim}
1 void mystery(char *dest, char *src) {
2  if( src == NULL || dest==NULL) return;
3  while (src) { 
4    *dest = *src; 
5    src ++; dest++;
6  } 
7  *dest = (char)0;
8 }
\end{verbatim}
\begin{answers}
\correctanswer  The function will be correct by changing a small error at line $3$
\answer  The function will be correct by changing a small error at line $7$
\answer  The function will be correct by changing a small error at line $4$
\answer  The function will be correct by changing a small error at line $5$
\answer  The function will be correct by changing two small errors at line $4$ and $5$
\end{answers}
\begin{solution}
\end{solution}

\variant
Which response best describes the following student code that attempts to implement string copy?
\begin{verbatim}
1 void mystery(char *dest, char *src) {
2  if (src == NULL || dest==NULL) return;
3  while (*src) { 
4    dest = src; 
5    src++; dest++;
6  } 
7  *dest = (char)0;
8 }
\end{verbatim}
\begin{answers}
\correctanswer  The function will be correct by changing a small error at line $4$
\answer  The function will be correct by changing a small error at line $7$
\answer  The function will be correct by changing a small error at line $3$
\answer  The function will be correct by changing a small error at line $5$
\answer  The function will be correct by changing two small errors at line $4$ and $5$
\end{answers}
\begin{solution}
\end{solution}

\variant
Which response best describes the following student code that attempts to implement string copy?
\begin{verbatim}
1 void mystery(char *dest, char *src) {
2  if (src == NULL || dest==NULL) return;
3  while (*src) { 
4    *dest = *src; 
5    src ++; dest++;
6  } 
7  *src = (char)0;
8 }
\end{verbatim}
\begin{answers}
\answer  The function will be correct by changing a small error at line $3$
\correctanswer   The function will be correct by changing a small error at line $7$
\answer  The function will be correct by changing a small error at line $4$
\answer  The function will be correct by changing a small error at line $5$
\answer  The function will be correct by changing two small errors at line $4$ and $5$
\end{answers}
\begin{solution}
\end{solution}


%%%%%%%%%% QUIZ 2 REVENGE


\variant
Which one of the following best describes the code below?
\begin{verbatim}
int *p = (int*) malloc(sizeof(int));
p = NULL;
free(p);
\end{verbatim}
\begin{answers}
\answer Compiler error: {\tt free} cant be applied on NULL pointer
\correctanswer Memory leak
\answer Dangling pointer
\answer The program may crash as {\tt free()} is called on a NULL pointer
\answer There are no errors in the code
\end{answers}
\begin{solution}
The original allocation is never freed,so the code has a memory leak. Note, {\tt free(NULL)} does nothing. 
\end{solution}


%scanf gotcha

\variant
Which one of the following best describes the correct line $4$  to read the line and store the result in the buffer and score variables?
\begin{verbatim}
1  char* buffer = (char*) malloc(16);
2  int score,res;
3  char* line = "Pointers 123";
4  _______  ?
\end{verbatim}
\begin{answers}
\correctanswer {\tt res = sscanf(line, "\%15s \%d",buffer, \&score); }
\answer {\tt res = sscanf(line, "\%15s \%d",buffer, score); }
\answer {\tt res = sscanf(line, "\%15s \%d", \&buffer, \&score); }
\answer {\tt res = sscanf(line, "\%15s \%d", \&buffer, score); }
\answer {\tt res = sscanf(line, "\%15s \%d", *buffer, *score); }
\end{answers}
\begin{solution}
The {\tt buffer} variable points to the memory that we wish {\tt sscanf} to write into, whereas {\tt score} is the integer that we wish to change, so we need its address.
\end{solution}


\variant
Which one of the following is most likely to print {\tt Hi} only once?
\begin{answers}
\answer {\tt fork(); write(1,"Hi",2); }
\correctanswer {\tt execl("nosuchfile","nss",(char*)NULL); write(1,"Hi",2); }
\answer {\tt execl("/bin/ls","ls",(char*)NULL); write(1,"Hi",2); }
\answer {\tt puts("Hi");if(1) puts("Hi"); }
\end{answers}
\begin{solution}
We need {\tt exec} to fail! The incorrect response {\tt execl("/bin/ls","ls",(char*)NULL); } will replace the running process with the {\tt /bin/ls} program and the {\tt write} call will never be executed.
\end{solution}



\variant
When will {\tt fork()} return a positive integer (a process id) ?
\begin{answers}
\correctanswer In the parent process
\answer In the child process
\answer If an error occurs
\answer When a child needs to be restarted
\answer When the parent needs to be signalled
\end{answers}
\begin{solution}
{\tt fork} returns -1 (fail! No fork for you!) or: 0 in the child and a positive integer in the parent -  so the parent can store the process id the newly created child.
\end{solution}

\variant
When will {\tt fork()} return $0$ ?
\begin{answers}
\answer In the parent process
\correctanswer In the child process
\answer If an error occurs
\answer When a child needs to be restarted
\answer When the parent is the first process
\end{answers}
\begin{solution}
{\tt fork} returns -1 (fail! No fork for you!) or: 0 in the child and a positive integer in the parent -  so the parent can store the process id the newly created child.
\end{solution}

\variant
When will {\tt fork()} return $-1$ ?
\begin{answers}
\answer In the parent process
\answer In the child process
\correctanswer If {\tt fork} failed
\answer When a child needs to be restarted
\answer When the parent is the first process
\end{answers}
\begin{solution}
{\tt fork} returns -1 (fail! No fork for you!) or: 0 in the child and a positive integer in the parent -  so the parent can store the process id the newly created child.
\end{solution}



\variant
{\tt puts(ptr)} is equivalent to
\begin{answers}
\correctanswer {\tt printf("\%s\textbackslash n",ptr) }
\answer {\tt scanf("\%s\textbackslash n",ptr) }
\answer {\tt ptr=getchar() }
\answer {\tt fprintf(stderr,"\%s\textbackslash  n",ptr) }
\answer {\tt signal(SIGINT,ptr) }
\end{answers}
\begin{solution}
\end{solution}



\variant
Which one of the following is NOT true for a child process created by {\tt fork}?
\begin{answers}
\answer Gets its own complete copy of the parent's process memory
\answer Inherits (shares) the parent's open file streams
\answer Inherits signal handlers defined using {\tt signal}
\correctanswer Cannot start until the parent process has finished
\end{answers}
\begin{solution}
\end{solution}

%%%% AFTER





\variant
Which one of the following is true for {\tt gets}?
\begin{answers}
\answer The function {\tt gets} is the recommended function to read lines of input into a buffer
\correctanswer Allows a buffer overflow if the input line is longer than the buffer
\answer Can only read text data from a file
\answer Can only read binary data from a file
\answer Returns an integer pointer
\end{answers}
\begin{solution}
\end{solution}


\variant
How many times will {\tt !} be printed?
\begin{verbatim}
  fork(); printf("!\n"); fork();
\end{verbatim}
\begin{answers}
\answer $1$
\correctanswer $2$
\answer $3$
\answer $4$
\answer $5$ or more
\end{answers}
\begin{solution}
The first {\tt fork} creates two processes. Then we print {\tt !} and flush the output to the terminal. The second {\tt fork} is executed by both processes, so now there are four processes, however there is no more output processing at this point.
\end{solution}

\variant
How many times will {\tt !} be printed?
\begin{verbatim}
  fork();  fork(); printf("!\n"); exit(0);
\end{verbatim}
\begin{answers}
\answer $1$
\correctanswer $4$
\answer $3$
\answer $2$
\answer $5$ or more
\end{answers}
\begin{solution}
The first {\tt fork} creates two processes.  The second {\tt fork} is executed by both processes, so now there are four processes.
Then all four processes print {\tt !} and flush the output to the terminal.

\end{solution}

\variant
How many times will {\tt !} be printed?
\begin{verbatim}
  printf("!"); fork();  fork(); exit(0);
\end{verbatim}
\begin{answers}
\answer $1$
\correctanswer $4$
\answer $3$
\answer $2$
\answer $5$ or more
\end{answers}
\begin{solution}
The printf does not flush the buffer, so the process memory contains {\tt !} in its buffer.
The first {\tt fork} creates two processes.  The second {\tt fork} is executed by both processes, so now there are four processes.
At exit all four processes flush their buffer to the terminal.
\end{solution}




\variant
A zombie is created when
\begin{answers}
\correctanswer A parent doesn't wait on a finished child
\answer A child doesn't wait on a parent
\answer A child calls {\tt exec}
\answer The parent finishes before the child process
\answer A parent sends the child process a {\tt SIGZOMB} signal
\end{answers}
\begin{solution}
If the parent finishes first then the child's parent will become process 1 (init) which will correctly wait on processes.
\end{solution}



\variant
Which one of the following is NOT true for the following line?
\begin{verbatim}
waitpid(id,&status,0); // Assume waitpid is successful
\end{verbatim}
\begin{answers}
\answer The status variable is an {\tt int; \&status} means the address of the integer
\answer If the child exited normally then {\tt status} it includes the lowest 8 bits of the child's exit value
\answer The {\tt status} variable can be queried with macros {\tt WIFEXITED,WIFSIGNALED,WEXITSTATUS}  to extract the status of the child process
\answer Is used to cleanup zombies from the kernel's process table
\correctanswer Is used to prevent child processes from starting immediately
\end{answers}
\begin{solution}
\end{solution}


\variant
Which one of the following is NOT true?
\begin{answers}
\answer Dead processes (zombies) still take up space in the system's process table. If the system table is full no new processes can be created.
\answer {\tt alarm(5) } will send an asynchronous signal {\tt SIGALRM} to the process in $5$ seconds
\correctanswer The default SIGALRM handler does nothing
\answer Standard error stream (std err, file descriptor 2) is not buffered
\answer If {\tt open} succeeds it will return the smallest unused non-negative integer
\end{answers}
\begin{solution}
The default action of SIGALRM is to kill the process.
\end{solution}


\variant
Which response bests describes the common system programming pattern to run another program and wait for it to finish?
\begin{answers}
\correctanswer Parent process forks then child execs and parent waits
\answer Parent process forks then parent execs and child waits
\answer Parent process execs then child forks and child waits
\answer Child process execs then child forks and child waits
\answer Child process waits then parent exec and child forks 
\end{answers}
\begin{solution}
Note, this common system programming pattern has the insightful name "fork-exec-wait."
\end{solution}



\variant
Which one of the following is true for {\tt fork()} ?
\begin{answers}
\answer Creates a new process by reloading the program - the child starts at {\tt main() }
\correctanswer Creates a new process by cloning the existing process; the child starts by {\tt fork()} returning $0$
\answer Creates a new file handle for standard out
\answer Creates a new file handle for standard int
\answer Installs a new fork handler
\end{answers}
\begin{solution}
The cloning of the process happens at the moment of calling {\tt fork}. The process is not restarted. Looking backwards in time, it is as if two processes showed the same history. Looking forwards in time, both processes have their own address space - changes to variables in one process will not affect the other.
\end{solution}


\variant
Which response best describes the following buggy code that, when executed on a 32 bit machine, is suppose to create a 16x16 2D character array?
\begin{verbatim}
1  char ** array;
2  array = (char**) malloc(16 * sizeof(char));
3  if(!array) return 1; // malloc failed
4  int i= 0;
5  for(; i < 16;i++) 
6    array[i] = malloc(16 * sizeof(16));
\end{verbatim}
\begin{answers}
\answer Insufficient memory allocated (line $2$) causes a buffer overflow when i is $0$
\correctanswer Insufficient memory allocated (line $2$) causes a buffer overflow when i is $4$ and higher
\answer Insufficient memory allocated (line $2$) causes a buffer overflow when i is $8$ and higher
\answer Insufficient memory allocated (line $2$) causes a buffer overflow when i is $12$ and higher
\answer Insufficient memory allocated (line $2$) causes a buffer overflow when i is $16$ and higher
\end{answers}
\begin{solution}
16 bytes are allocated on the heap. On a 32 bit machine each pointer uses 4 bytes, thus there is sufficient space for 4 pointers. The fifth pointer (i=4) and higher, will be stored beyond the edge of the buffer.
\end{solution}



\variant
Which of the following is FALSE for {\tt getline}?
\begin{answers}
\answer {\tt getline} arguments include a pointer to an int and a pointer to a pointer to char, so it can modify their contents.
\answer Th character pointer is typically set to {\tt NULL} before the first call to {\tt getline}
\answer To avoid a memory leak, call {\tt free} on the buffer after the last call to {\tt getline}
\answer {\tt getline} returns the number of characters read (possibly including a newline character at the end)
\correctanswer Is used to convert a character array into integer and floating point values
\end{answers}
\begin{solution}
\end{solution}


\variant
Which one of the following is the best description of POSIX process control? When a child process finishes (or temporarily stops) ...

\begin{answers}
\answer The init (process $1$) is sent a {\tt SIGUSR1} signal
\correctanswer The parent process is sent a {\tt SIGCHLD} signal
\answer The child process is re-assigned a new parent process
\answer All siblings are notified with a {\tt SIGQUIT} signal
\answer The process is automatically restarted
\end{answers}
\begin{solution}
\end{solution}



\variant
Which one of the following is NOT true?
\begin{answers}
\answer The default action of {\tt SIGCHLD} is to do nothing
\answer The default action of {\tt SIGALRM} is to quit the process
\answer Pressing {\tt CTRL-C} will send a {\tt SIGINT} signal to the process
\answer Signals are software interrupts - they are handled concurrently by signal handlers.
\correctanswer Signals can be sent to other processes using the `signal' function
\end{answers}
\begin{solution}
Signals are sent to other processes using {\tt kill}
\end{solution}


\variant
What will be the last thing printed by the following program?
\begin{verbatim}
1 int main() {
2    int c = fork();
3    printf("c=%d : pid=%d ppid=%d\n",c, getpid(),getppid() );
4    if(c>0) return 97;
5    sleep(4); printf("Answer: %d\n",getppid());
6    return 80;
7  }
OUTPUT:
c=0 : pid=97 ppid=90
c=97 : pid=90 ppid=80
____ ?
\end{verbatim}
\begin{answers}
\correctanswer {\tt Answer: 1}
\answer  {\tt Answer: 80}
\answer  {\tt Answer: 90}
\answer  {\tt Answer: 97}
\answer None of the other responses are correct
\end{answers}
\begin{solution}
When a process is orphaned because its parent has already finished it is adopted by {\tt init} (process 1). {\tt init} ensures there are no zombies (i.e. it will call {\tt wait} or {\tt waited} for every SIGCHLD signal).
\end{solution}




\variant
If {\tt malloc} fails (returns NULL)  will the following program crash (seg fault)? If so, where?
\begin{verbatim}
1 void * ptr1 = (void*) malloc(16);
2 int ** ptr2 = (int**) ptr1;
3 int *** ptr3 = & ptr2;
4 void* ptr4= (void*) &ptr1;
\end{verbatim}
\begin{answers}
\answer Line $1$
\answer  Line $2$
\answer  Line $3$
\answer  Line $4$
\correctanswer None of the other responses are correct
\end{answers}
\begin{solution}
{\tt ptr1} is cast but never de-referenced: It is never used to attempt to read/write memory at address 0. The other lines of code get the address of the variable but do not read/write address held by of ptr1.
\end{solution}


\variant
Which one of the following changes the process's current directory to the user's home directory?
\begin{answers}
\correctanswer {\tt chdir( getenv("HOME") )}
\answer  {\tt pwd( environ[0] )}
\answer  {\tt chdir( environ[ getenv("HOME")] )}
\answer  {\tt pwd( environ[UHOME] )}
\answer None of the other responses are correct
\end{answers}
\begin{solution}
\end{solution}


\variant
Which one of the following is NOT true?
\begin{answers}
\correctanswer {\tt static} variables are automatic
\answer The last entry of string arrays {\tt argv} and {\tt environ} is always {\tt NULL}
\answer {\tt malloc} allocates memory on the heap
\answer {\tt char** environ} should be declared {\tt extern} 
\answer {\tt argv[1] } is the first argument because {\tt argv[0] } is the program name 
\end{answers}
\begin{solution}
{\tt static} variables are stored in the data segment, not the stack or heap. They are valid for the lifetime of the process.
\end{solution}



\variant
Which one of the following is the best choice for the missing code? Choose the correct snippet so that the program uses a {\tt string.h} function to display a help message when the program is started with {\tt "-h"} option

\begin{verbatim}
1  int main(int argc, char*argv[]) {
2    // If no arguments or just -h, then show a message and quit:
3    if(argc ==1 ||   _______    ) help_message_and_quit();
\end{verbatim}
\begin{answers}
\correctanswer {\tt 0==strcmp(argv[1],"-h")}
\answer {\tt 0==strcmp(argv[0],"-h")}
\answer {\tt argv[1] == "-h"}
\answer {\tt argv[0] == "-h"}
\answer {\tt 0==streq(argv[0],"-h")}
\end{answers}
\begin{solution}
{\tt argv[0] } holds the program name.
{\tt strcmp} returns 0 if the two arguments are equal.
\end{solution}




\variant
Four students were asked to write four alternative ways to print {\tt Hello World!} to standard output. 
Carefully read the four functions below and for each one, decide if it will print {\tt Hello World!} without error.
Choose the most accurate response below.
\begin{verbatim}
void A() { char *s=(char*)malloc(100); strcpy(s,"Hello World!\n"); puts(s); free(s); }
void B() { char s[100]; *s=0; strcat(s, "Hello World!\n"); puts(s); }
void C() { static char s[100]; sprintf(s,"Hello "); strcat(s,"World!\n"); write(1,s,strlen(s)); }
void D() { char *s = "Hello "; strcat(s, "World!"); printf("%s\n", s); }
\end{verbatim}
\begin{answers}
\answer None of the functions are correct
\answer Only $1$ function is correct
\answer $2$ functions are correct
\correctanswer $3$ functions are correct
\answer All $4$ functions are correct
\end{answers}
\begin{solution}
{\tt D()} will segfault at strcat because {\tt s} points to readonly memory (the string constant).
\end{solution}




\variant
Which one of the following prints {\tt H} to the standard output stream?
\begin{verbatim}
1 char* ptr = "H";
2 ________?
\end{verbatim}
\begin{answers}
\correctanswer {\tt write(1,ptr,strlen(ptr)); }
\answer {\tt printf("\%p",ptr); }
\answer {\tt write(sizeof(ptr), ptr, stdout); }
\answer {\tt fprintf(stderr,"\%s",ptr); }
\answer {\tt puts(* ptr); }
\end{answers}
\begin{solution}
\end{solution}

%%%%%%%%%%%%%%%% Revenge of Quiz 3 %%%%%%%%%%%%%%%%%

%%Q32
\question{3}
\variant
Which one of the following is NOT true for the Buddy allocator compared to other memory allocators?
\begin{answers}
\answer Uses a hierarchy of allocation blocks of size $2^n$
\correctanswer Minimizes fragmentation
\answer Optimizes for performance
\answer Can be used as a heap allocator
\end{answers}
\begin{solution}
\end{solution}

\variant
Which one of the following is NOT true for {\tt calloc}?
\begin{answers}
\answer Memory allocated by {\tt calloc} will be initialized to zero
\answer {\tt calloc(4,4)} is identical to {\tt calloc(1,16)}
\answer Returns {\tt NULL} if memory allocation failed
\answer Use {\tt free} to release (de-allocate) memory reserved by {\tt calloc}.
\correctanswer Allocates memory in a character stack
\end{answers}
\begin{solution}
\end{solution}

\variant
Which expression is the best choice to set the value of {\tt result} to $5.0$ ?
\begin{verbatim}
double* ptrA = malloc(sizeof(double));
*ptrA= 5.0;
double* ptrB = (double*) realloc(ptrA, sizeof(double)*2);
double result = ______;
\end{verbatim}
\begin{answers}
\correctanswer {\tt ptrB[0] }
\answer {\tt ptrA[0] } 
\answer None of other responses are correct;
\answer {\tt *(ptrA + 0) }
\answer {\tt ptrA[1] }
\end{answers}
\begin{solution}
{\tt realloc} may return a new address if the original allocation cannot be expanded.
\end{solution}


\variant
Which line,if any, will likely crash the program?
\begin{verbatim}
1 int main() {
2  int a = 10,**c, *d;
3  c = &d;
4  *c = &a;
5  **c= 5;
6  d = NULL;
7  return 0;
}
\end{verbatim}
\begin{answers}
\answer 5
\answer 6
\correctanswer The program will not crash
\answer 3
\answer 4
\end{answers}
\begin{solution}
\end{solution}

\variant
Which of the following will NOT reserve enough memory for 10 character pointers. Assume a character pointer requires 8 bytes of storage
\begin{answers}
\answer {\tt malloc(80);}
\answer {\tt calloc(10,8);}
\correctanswer {\tt malloc(sizeof(char)* 10);}
\answer {\tt calloc(10, sizeof(char*));}
\answer All of the other responses reserve sufficient memory
\end{answers}
\begin{solution}
{\tt malloc(sizeof(char)* 10);} which only reserves 10 bytes because {\tt sizeof(char) != sizeof(char*)}.
\end{solution}


%% Pthreads

\variant
Which of the following is FALSE for pthreads?
\begin{answers}
\answer Include {\tt pthread.h} to get declarations for {\tt pthread_create} etc
\answer Add the {\tt "-pthread"} gcc compiler option to build multi-threaded programs
\correctanswer A running thread can be transferred from a child to its parent process
\answer Multi-threaded programs can still be executed on machines with a single CPU
\end{answers}
\begin{solution}
\end{solution}


\variant
Which of the following will NOT cause a multi-threaded process (with multiple threads currently running) to terminate?
\begin{answers}
\answer The process is delivered a {\tt SIGTERM} signal
\answer A background thread writes to address zero
\answer A background thread calls {\tt exit}
\correctanswer The original thread calls {\tt pthread_exit} from {\tt main}
\answer The original thread {\tt return}s from {\tt main}
\end{answers}
\begin{solution}
{\tt pthread_exit} never returns; it terminates the calling thread. Only if all threads have now exited will the process exit (with value 0). However in this question, there are other threads running so the process will remain.
\end{solution}



\variant
Complete the following code to print {\tt Hello}. What is the missing line at line $8$?
\begin{verbatim}
1   void* func(void*p) {
2      return p;
3   }
4   int main() {
5    pthread_t id;
6    pthread_create(&id,NULL, func,"Hello");
7    void *r;
8    ????
9    puts( r); return 0;
10 }
\end{verbatim}
\begin{answers}
\correctanswer  {\tt pthread_join(id, \& r); }
\answer {\tt pthread_exit(\&r); }
\answer  {\tt r = pthread_exit(id); }
\answer {\tt pthread_join(\&id, r); }
\answer {\tt pthread_wait(NULL,r); }
\end{answers}
\begin{solution}
Use {\tt pthread_join} to wait for a thread to finish and to find its return value (or the value it passed to {\tt pthread_exit}).
Note the correct answer must be  pthread_join(id, \& r);  because we need to pass the {\em address of} {\tt r}; If you just passed ``r" then you are passing whatever address r happens to contain (which is an arbitrary value).
\end{solution}


% Thread-safe; basic concept
\variant
Which of the following is NOT true?
\begin{answers}
\answer Some C library functions e.g. {\tt asctime}, {\tt strtok} are not thread-safe
\answer Two threads can use the function at the same time if it is ``thread-safe"
\answer A function that uses static (global) variable to hold a result value is not thread-safe
\correctanswer If a function is documented as ``not thread-safe" then it must not be used in multi-threaded programs
\end{answers}
\begin{solution}
\end{solution}



\variant
Which one of the following items is NOT stored on the stack?
\begin{answers}
\answer  A value for the CPU's Program Counter (return address)
\answer Parameter values of the function
\answer Automatic (local) variables
\correctanswer static variables
\end{answers}
\begin{solution}
static variables are stored in the data segment (just below the heap).
\end{solution}

\variant
Which response best fills in the three blanks: When a program calls {\tt pthread_create}, a new ? and ? are created ? the current process.
\begin{answers}
\correctanswer thread ; stack ; inside
\answer thread ; heap ; inside
\answer process ; stack ; outside
\answer process ; thread ; by forking
\answer thread ; heap ; outside
\end{answers}
\begin{solution}
\end{solution}


\variant
In a POSIX system (such as LINUX) which one of the following is TRUE by default?
\begin{answers}
\correctanswer Processes are isolated and run inside their own virtual memory space
\answer Parent processes can write into the child process
\answer Child processes can write into the parent process
\answer While a process is running it is allocated the entire physical memory (RAM)
\answer A process can only use a single CPU at a time
\end{answers}
\begin{solution}
\end{solution}


\variant
For a linked-list heap allocator which response best describes the following statements about explicit free lists compared to implicit free lists?
\begin{verbatim}
1 Can decrease allocation time
2 Find-first allocation algorithm can be mapped onto different placement strategies
3 Require separate storage outside of the heap for the linked list
4 Require additional operating system support to manage the heap
\end{verbatim}
\begin{answers}
\correctanswer Only $1$ and $2$ are correct
\answer Only $1$ is correct
\answer Only $2$ is correct
\answer Only $3$ and $4$ are correct
\answer Only $1$ $3$ and $4$ are correct
\end{answers}
\begin{solution}
\end{solution}


\variant
Which response does NOT describe a Boundary Tags -based allocator described by Donald Knuth?
\begin{answers}
\answer Traverse allocated blocks by using their size
\answer Store size of block at the beginning and end of the block. 
\answer Is an implicit linked list implementation
\correctanswer Requires a buddy allocator to coalesce adjacent blocks
\answer Coalesces blocks to prevent false-fragmentation 
\end{answers}
\begin{solution}
\end{solution}

\variant
When a heap allocator requires more heap memory it calls
\begin{answers}
\answer {\tt Ghostbusters}. Just kidding. Hint this response is incorrect.
\correctanswer {\tt sbrk}
\answer {\tt malloc}
\answer No system call is required; heap space is allocated automatically by the MMU
\answer {\tt heap_alloc}
\end{answers}
\begin{solution}
\end{solution}




\variant
Which one of the following is FALSE?
\begin{answers}
\correctanswer {\tt pthread_exit} waits until all other threads finish before returning
\answer Each thread requires its own stack space
\answer pthreads are peers; there is no hierarchy of threads in the same process
\answer Creating threads is faster than forking process
\answer pthreads in the same process share the same heap and the same virtual memory address space
\end{answers}
\begin{solution}
 {\tt pthread_exit}  never returns.
\end{solution}



\variant
Using an initial heap size of $2^{10}$ bytes (1KB) and a binary buddy-allocator, how many memory allocation requests of 68 bytes can be completed before the allocator requires additional heap memory?
\begin{answers}
\correctanswer $9$ or fewer
\answer $14$
\answer $13$
\answer $15$
\answer $16$ or greater
\end{answers}
\begin{solution}
Round allocation requests up to nearest $2^n$ i.e. 128 bytes ($2^7$)
\end{solution}

%%%%%%%%%%%%% Revenge of Quiz 4 %%%%%%%%%%%%%%%%%%%%

%%Q35 - disabled, because it also appears in the new question block

%% \question{3}
%% \variant
%% Two threads call {\tt pthread_mutex_lock} on the same mutex. Which one of the following best describes what happens next?
%% \begin{answers}
%% \answer The result is undefined
%% \answer The mutex lock is increased by two
%% \answer The mutex lock is decreased by two
%% \correctanswer One thread will continue, the other thread must wait until the mutex is unlocked
%% \end{answers}
%% \begin{solution}
%% \end{solution}


\variant
The statement ``{\tt pthread_mutex_lock} is an atomic operation"  ...
\begin{answers}
\answer is a warning that the lock may explode if the lock is not correctly initialized
\correctanswer means the locking operation behaves as if it is a single uninterruptible operation
\answer is a warning that the mutex can only be locked once
\answer means that only one lock can be locked at at time
\answer means it can only be used on single CPU systems
\end{answers}
\begin{solution}
\end{solution}


\variant
Which one of the following is TRUE for a correctly written multi-threaded program that has locked a mutex of type {\tt pthread_mutex_t}?
\begin{answers}
\answer The thread that initialized the mutex must have also locked it
\answer The lock can now be destroyed using {\tt pthread_mutex_destroy} 
\answer The lock was initialized with a positive count
\correctanswer The same thread that locked the mutex must unlock it
\answer A call to {\tt pthread_mutex_lock} on the same mutex by other threads will return with an error
\end{answers}
\begin{solution}
\end{solution}


\variant
Complete the following. Which best describes two well known solutions to the {\em The Critical Section Problem}?
\begin{answers}
\correctanswer Dekker published the first correct solution. Later, Peterson published a simple solution.
\answer Peterson published the first correct solution. Later, Dekker published a simple solution.
\answer Turing published the first correct solution. Later, Dijkstra published a simple solution.
\answer Hopcroft published the first correct solution. Later, Dijkstra published a simple solution. 
\answer von Neumann published the first correct solution. Later, Ullman published a simple solution. 
\end{answers}
\begin{solution}
\end{solution}


\variant
Which response best describes ``Bounded Wait"?
\begin{answers}
\correctanswer If a thread is waiting to enter the critical section (CS), then other threads may only enter the CS first, a finite number of times.
\answer If a thread is waiting to enter the critical section (CS), then atomic exchange assures waiting time is limited to less then N CPU instructions.
\answer A thread inside the critical section may only sleep for a finite number of milliseconds before continuing.
\answer Multi-threaded performance is only guaranteed if threads do not sleep inside the critical section.
\answer Before sleeping or performing slow I/O during a critical section, threads must preemptively unlock the mutex.
\end{answers}
\begin{solution}
\end{solution}


\variant
Which response best describes ``Mutual Exclusion"?
\begin{answers}
\correctanswer Only one thread may be executing code inside the critical section at a time.
\answer Two threads may not be executing the same line of code at the same time.
\answer Two threads may not perform I/O at the same time.
\answer Multi-threaded performance is only guaranteed if one thread sleeps during I/O actions of the second thread.
\answer Before sleeping or performing slow I/O during a critical section, threads must preemptively unlock the mutex.
\end{answers}
\begin{solution}
\end{solution}


\variant
Which response best describes ``Progress"?
\begin{answers}
\correctanswer If there are no threads inside the critical section, a thread should be able to enter immediately.
\answer The CPU clock may not be reset to an earlier time.
\answer Two threads may not perform terminal I/O at the same time.
\answer Only one thread may lock a mutex lock a time.
\answer In a multi-threaded program, a thread must preemptively unlock the mutex if it is required by another thread.
\end{answers}
\begin{solution}
\end{solution}



\variant
Which response is an example of ``Deadlock"?
\begin{answers}
\correctanswer When two threads cannot continue because they are both waiting for the other one to finish.
\answer When a mutex is destroyed but another thread calls {\tt pthread_mutex_lock} on the same mutex.
\answer When a mutex cannot be unlocked because it was locked from another thread.
\answer When a mutex is transformed into an inconsistent state because it was initialized twice.
\answer When a mutex is transformed into an inconsistent state because it was destroyed and then re-initialized.
\end{answers}
\begin{solution}
\end{solution}


\variant
Complete the following by choosing the best response. On modern processors, implementations of mutex locks require hardware support. For example x86 (Intel) processors implement the XCHG CPU instruction. The relevant characteristics of this instruction are that ...
\begin{answers}
\correctanswer it exchanges the contents of a register and memory and is atomic.
\answer it exchanges the contents of two data registers and is non-atomic.
\answer it exchanges the contents of a data register and PC register and satisfies bounded waiting.
\answer it exchanges the contents of a data register and stack pointer and satisfies progress.
\answer it inverts the bit pattern stored in one byte of memory and will never deadlock.
\end{answers}
\begin{solution}
\end{solution}


\variant
Complete the following by choosing the best response. Simple implementations of correct solutions to the critical section problem may fail on some architectures because ...
\begin{answers}
\correctanswer For performance, the CPU and compiler may re-order instructions and cache reads may be stale.
\answer Memory reads can deadlock.
\answer CPU speeds (instructions per second) are now faster than main-memory read-write access.
\answer Some programs are only single threaded.
\answer It is not possible to implement critical section problem solutions in real software.
\end{answers}
\begin{solution}
\end{solution}



\variant
Solve my riddle! Four threads call my $X$ function but only two may continue; the other two threads must wait! Later my $Y$ function is called once more and one of the two waiting threads is allowed to continue. What am I and what is $X$ and $Y$?
\begin{answers}
\correctanswer I am counting semaphore, $X$ is wait and $Y$ is post.
\answer I am a mutex, $X$ is lock and $Y$ is unlock. 
\answer I am a critical section, $X$ is start and $Y$ is end. 
\answer I am a condition variable, $X$ is signal and $Y$ is wait. 
\answer I am a mutex, $X$ is signal and $Y$ is waitpid. 
\end{answers}
\begin{solution}
\end{solution}


\variant
Solve my riddle! Whenever a thread calls my $X$ function it must always wait in jail! Later when my $Y$ function is called then one waiting thread (if there is one) is released and allowed to continue. What am I and what is $X$ and $Y$? Hint: I occasionally release jailed threads for no reason!
\begin{answers}
\answer I am counting semaphore, $X$ is wait and $Y$ is post.
\answer I am a mutex, $X$ is lock and $Y$ is unlock. 
\answer I am a critical section, $X$ is start and $Y$ is end. 
\correctanswer I am a condition variable, $X$ is wait and $Y$ is signal. 
\answer I am a mutex, $X$ is signal and $Y$ is waitpid. 
\end{answers}
\begin{solution}
\end{solution}


\variant
Which response best describes the following code?
\begin{verbatim}
int b = 0;  /* shared between threads */

void lock() { 
  while( b ) {/* busy wait*/}; 
  b = 1;
}
void unlock() { b = 0; }
\end{verbatim}
\begin{answers}
\answer A correct implementation of a mutex lock
\answer Incorrect lock implementation (suffers from a race condition) and does not satisfy Progress (may deadlock)
\correctanswer  Incorrect lock implementation (suffers from a race condition) and does not satisfy Mutual Exclusion
\answer  Incorrect lock implementation (suffers from a race condition) and does not satisfy Bounded Wait
\answer This implementation is equivalent to Peterson's solution
\end{answers}
\begin{solution}
Consider two threads calling {\tt lock()} at the same time. Both would see a $b$ value of zero (0). Both would continue. 
\end{solution}


\variant
Which of the following is FALSE for condition variables?
\begin{answers}
\answer Occasionally a call to {\tt pthread_cond_wait()} may return even without any corresponding {\tt pthread_cond_signal()} or {\tt pthread_cond_broadcast()} call
\answer Condition variables use a helper mutex lock which must be locked before calling {\tt pthread_cond_wait()} 
\answer During {\tt pthread_cond_wait()} the mutex is automatically unlocked and later relocked before returning
\answer A thread can wake up one or all threads that are waiting on a condition variable
\correctanswer Condition variables are initialized with a user-supplied condition callback function that returns 0(wait) or 1(continue).
\end{answers}
\begin{solution}
\end{solution}


\variant
Which response best describes the code below? Each process or thread has it's own flag plus there is a shared-variable named {\tt turn}.
Identify the two missing pieces to complete Dekker's N=2 solution.
\begin{verbatim}
raise my flag
while your flag is raised :
   if it's your turn to win :
      lower my flag
      wait while your turn
      raise my flag
// Do Critical Section stuff
set your turn to win
lower my flag
\end{verbatim}
\begin{answers}
\correctanswer  This is Dekker's solution for 2 processes
\answer Does not satisfy mutual exclusion
\answer Does not satisfy progress but satisfies mutual exclusion
\answer Does not satisfy bounded wait but satisfies mutual exclusion
\answer This is Peterson's N=2 solution
\end{answers}
\begin{solution}
\end{solution}




\variant
Which response best describes the code below? Each process or thread has it's own flag plus there is a shared-variable named {\tt turn}.
\begin{verbatim}
raise my flag
Set turn to you
wait while (your flag is raised and it's your turn)
// Do Critical Section stuff
lower my flag
\end{verbatim}
\begin{answers}
\correctanswer This is Peterson's solution for 2 processes
\answer Does not satisfy mutual exclusion
\answer Does not satisfy progress but satisfies mutual exclusion
\answer Does not satisfy bounded wait but satisfies mutual exclusion
\answer This is Dekker's solution for 2 processes
\end{answers}
\begin{solution}
\end{solution}


\variant
Solve my riddle! Whenever a thread calls my $X$ function it should later call my $Y$ function. If two or more threads call $X$ then I shall declare a winner and the other(s) will have to wait! What am I and what is $X$ and $Y$?
\begin{answers}
\answer I am counting semaphore, $X$ is wait and $Y$ is post.
\correctanswer I am a mutex, $X$ is lock and $Y$ is unlock. 
\answer I am a critical section, $X$ is start and $Y$ is end. 
\answer I am a condition variable, $X$ is wait and $Y$ is signal. 
\answer I am a mutex, $X$ is signal and $Y$ is waitpid. 
\end{answers}
\begin{solution}
\end{solution}






\variant
Which response best describes the following code to `solve' the Critical Section Problem? Assume both flags are initially down.
\begin{verbatim}
raise your flag
lower my flag
wait until my flag is up
// Perform critical section activities
raise my flag
lower your flag
\end{verbatim}
\begin{answers}
\answer This is Turing's solution
\answer This is correct only for multi-threaded processes
\answer Does not satisfy mutual exclusion
\correctanswer Does not satisfy progress but mutual exclusion is satisfied
\answer Does not satisfy bounded wait but mutual exclusion is satisfied
\end{answers}
\begin{solution}
\end{solution}



\variant
Which response best describes the following attempt to solve the Critical Section Problem for two processes (or threads)? Assume both flags are initially down.
\begin{verbatim}
wait while my flag is up
raise your flag
// Perform critical section activities
lower your flag
\end{verbatim}
\begin{answers}
\correctanswer Does not satisfy mutual exclusion
\answer Does not satisfy progress but mutual exclusion is satisfied
\answer Does not satisfy bounded wait but mutual exclusion is satisfied
\end{answers}
\begin{solution}
\end{solution}


\variant
Which one of the following is NOT TRUE?
\begin{answers}
\answer A pthread mutex lock can be easily replaced with a counting semaphore (albeit with a slight loss of performance)
\correctanswer A condition variable is initialized with an integer counter.
\answer A counting semaphore can be implemented with a mutex lock and condition variable
\answer Underflow and overflow of a queue data structure can be prevented using counting semaphores
\answer Waiting on a condition variable should be wrapped in a loop (in part due to spurious wake ups)
\end{answers}
\begin{solution}
\end{solution}


\variant
Which one of the following is NOT TRUE?
\begin{answers}
\correctanswer {\tt PTHREAD_MUTEX_INITIALIZER} can be used on memory allocated from the heap
\answer {\tt pthread_mutex_init} is an alternative function to initialize a mutex
\answer Not calling {\tt pthread_mutex_destroy} can lead to resource leaks because the mutex may include a pointer to a system-based synchronization primitive
\answer Programs should not use the contents of pthread_mutex_t directly
\answer A program may {\tt fork()} after initializing a mutex but by default the mutex is not shared between processes 
\end{answers}
\begin{solution}
{\tt  PTHREAD_MUTEX_INITIALIZER} can only be used with static (global) variables.
\begin{verbatim}
pthread_mutex_t m =  PTHREAD_MUTEX_INITIALIZER;
int dostuff() {
  pthread_mutex_lock(&m);
  pthread_mutex_unlock(&m);
}
\end{verbatim}
\begin{verbatim}
int dostuff2() {
  pthread_mutex_t m2;
  pthread_mutex_init(&m2, NULL);
  pthread_mutex_lock(&m2);
  // Do Critical Section stuff here
  pthread_mutex_unlock(&m2);
  pthread_mutex_lock(&m2);
}
\end{verbatim}
\end{solution}


%%%%%%%%%%%%%%%%%% Revenge of quiz 5 %%%%%%%%%%%%%%%

%%Q33
\question{3}
\variant
Analyze the following synchronization code carefully. Which response best describes the following student implementation of a multithreaded stack push and pop function when used with ONE producer thread and ONE consumer thread? Assume {\tt sem_post} and {\tt sem_wait} are never interrupted by a POSIX signal, and the mutex and semaphores are initialized to reasonable values when possible.
%% Bad Circular Buffer e.g. Deadlock. eg. flip wait-post e.g. flip wait-wait, miss mutex lock
\\
\begin{tabular}{ | p{7cm} | p{7cm} | }
\hline \begin{verbatim}void push(double value) {
  pthread_mutex_lock(&m);
  sem_wait(&s1);
  stack[ count++ ] = value;
  sem_post(&s2);
  pthread_mutex_unlock(&m);
} \end{verbatim} & \begin{verbatim}
double pop() {
  pthread_mutex_lock(&m);
  sem_wait(&s2);
  double result = stack[ --count ];
  sem_post(&s1);
  pthread_mutex_unlock(&m);
  return result;
}\end{verbatim} \\ \hline
\end{tabular}
\begin{answers}
\answer Is valid implementation but only if there is one producer and one consumer thread
\answer Has a race condition except when the stack is full or empty, that can cause data corruption
\answer {\tt pop} and {\tt push} are implemented correctly (will block until the stack is non-empty or non-full)
\correctanswer Will deadlock but only when the stack is full or empty
\answer Has a race condition but only when the stack is full or empty that can cause data corruption
\end{answers}
\begin{solution}
{\tt sem_wait} is called {\em after} the mutex is locked, but the  other thread will then deadlock because it is waiting (forever) to lock the mutex.
\end{solution}






\variant
What are the correct initial values for the three counting semaphores sA,sB,SC so that the following are correct multithreaded stack push and pop functions? Assume {\tt sem_post} and {\tt sem_wait}  are never interrupted by a POSIX signal, and N = maximum capacity of array.
\\
\begin{tabular}{ | p{7cm} | p{7cm} | }
\hline \begin{verbatim}void push(double value) {
  sem_wait(&sA);
  sem_wait(&sC);
  stack[ count++ ] = value;
  sem_post(&sC);
  sem_post(&sB);
} \end{verbatim} & \begin{verbatim}
double pop() {
  sem_wait(&sB);
  sem_wait(&sC)
  double result = stack[ --count ];
  sem_post(&sC);
  sem_post(&sA);
  return result;
}\end{verbatim} \\ \hline
\end{tabular}
\\
\begin{answers}
\answer {\tt sA(1), sB(N) sC(N)}
\answer {\tt sA(0), sB(N) sC(1)}
\answer {\tt sA(0), sB(N) sC(0)}
\answer {\tt sA(N), sB(0) sC(0)}
\correctanswer {\tt sA(N), sB(0) sC(1)}
\end{answers}
\begin{solution}
{\tt sA} represents the number of free slots, {\tt sB} represents the number of items, {\tt sC} is being used to ensure mutual exclusion
\end{solution}





\variant
Which one of the following is NOT true for the Reader Writer Problem
\begin{answers}
\answer There can be multiple active readers
\correctanswer There can be multiple active writers
\answer When there is an active writer the number of active readers must be zero
\answer If there is an active reader the number of active writers must be zero
\answer A writer must wait until current active readers have finished
\end{answers}
\begin{solution}
\end{solution}


\variant
Which one of the following is not one of the Deadlock Coffman conditions?
\begin{answers}
\answer No Pre-emption
\answer Mutual Exclusion
\answer Circular Wait
\answer Hold and Wait
\correctanswer No Starvation
\end{answers}
\begin{solution}
\end{solution}



\variant
Identify the following definition: ``The resources can not be shareable between processes at the same time"
\begin{answers}
\answer No Pre-emption 
\correctanswer Mutual Exclusion
\answer Circular Wait 
\answer Hold and Wait
\answer Livelock
\end{answers}
\begin{solution}
\end{solution}





\variant
Identify the following definition: ``There exists a set of process {P1,P2,...} such that there is a process dependency cycle in the Resource Allocation Graph"
\begin{answers}
\answer No Pre-emption 
\answer Mutual Exclusion
\correctanswer Circular Wait 
\answer Hold and Wait
\answer Livelock
\end{answers}
\begin{solution}
\end{solution}



\variant
Identify the following definition: ``Once a process acquires a resource, it will retain the resource and wait for the next resource"
\begin{answers}
\answer No Pre-emption 
\answer Mutual Exclusion
\answer Circular Wait 
\correctanswer Hold and Wait
\answer Livelock
\end{answers}
\begin{solution}
\end{solution}



\variant
Identify the following definition: ``Once a process acquires a resource, another process cannot force the original process to release it"
\begin{answers}
\correctanswer No Pre-emption 
\answer Mutual Exclusion
\answer Circular Wait 
\answer Hold and Wait
\answer Livelock
\end{answers}
\begin{solution}
\end{solution}


\variant
Identify the following definition ``A process is not deadlocked but is never able to acquire all necessary resources to make progress"
\begin{answers}
\answer No Pre-emption 
\answer Mutual Exclusion
\answer Circular Wait 
\answer Hold and Wait
\correctanswer Livelock
\end{answers}
\begin{solution}
\end{solution}


%%%%%%%%%%%%%


\variant
Two singers each need a drummer and keyboard player to complete their bands for a concert. The first singer has enrolled the best drummer, while the second singer has enrolled the best keyboard player. To avoid deadlock the first singer steals the keyboard player from the second singer. Deadlock was avoided by breaking which condition? (Choose the best response)
\begin{answers}
\correctanswer No Pre-emption 
\answer Mutual Exclusion
\answer Circular Wait 
\answer Hold and Wait
\answer None of the other responses are correct.
\end{answers}
\begin{solution}
\end{solution}


\variant
Two singers each need a drummer and keyboard player to complete their bands for a concert. The drummer and keyboard player decide to work for both. Deadlock is avoided by breaking which condition? (Choose the best response)
\begin{answers}
\answer No Pre-emption 
\correctanswer Mutual Exclusion
\answer Circular Wait 
\answer Hold and Wait
\answer None of the other responses are correct.
\end{answers}
\begin{solution}
\end{solution}



\variant
Two singers each need a drummer and keyboard player to complete their bands for a concert. Both singers hire a drummer first,then hire a keyboard player second. Deadlock is avoided by breaking which condition? (Choose the best response)
\begin{answers}
\answer No Pre-emption 
\answer Mutual Exclusion
\correctanswer Circular Wait 
\answer Hold and Wait
\answer None of the other responses are correct.
\end{answers}
\begin{solution}
\end{solution}



\variant
Two singers each need a drummer and keyboard player to complete their bands for a concert. The singers wait until both resources are available before hiring.  Deadlock was avoided by breaking which condition? (Choose the best response)
\begin{answers}
\answer No Pre-emption 
\answer Mutual Exclusion
\answer Circular Wait 
\correctanswer Hold and Wait
\answer None of the other responses are correct.
\end{answers}
\begin{solution}
\end{solution}


\variant
Review the multi-threaded code below for synchronization errors. The two methods are used to increase or decrease {\tt money}. The {\tt withdraw} method should block until there are sufficient funds in the account {\tt (money >= amount)}, Note {\tt PTHREAD_COND_INITIALIZER} is equivalent to {\tt pthread_cond_init}, and the argument {\tt amount} will always contain a positive value.
\begin{verbatim}
01  int money = 100; /* Must be positive */
02  pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;
03  pthread_cond_t cv = PTHREAD_COND_INITIALIZER; 
04
05  void deposit(int amount) { /* add money */
06   pthread_mutex_lock(&m);
07   money =  money + amount;
08   pthread_mutex_unlock(&m);
09  }
10  // withdraw() will block;
11  // It will return only when there is sufficient money in the account!
12  void withdraw(int amount) { /* reduce money */
13    if(money < amount) pthread_cond_wait(&cv,m);
14    else pthread_cond_signal(&cv);
15    money = money - amount;
16  }
\end{verbatim}

Which one of the following is a true statement about the synchronization used in above functions?
\begin{answers}
\answer The {\tt deposit} method needs to call {\tt pthread_cond_wait}.
\answer The {\tt withdraw} method has no synchronization errors.
\answer If {\tt pthread_cond_signal} is wrapped inside a while loop then the code is correct.
\answer The {\tt withdraw} method must call {\tt pthread_mutex_lock} on the mutex after {\tt pthread_cond_wait} returns.
\correctanswer None of the ofter responses are correct.
\end{answers}
\begin{solution}
The above code is horribly broken. The {\tt deposit} call should call broadcast after incrementing money, but before unlocking the mutex
The  {\tt withdraw} function should lock the mutex for the whole function and use {\tt while(money<amount)} not {\tt if} and the signal call is unnecessary.
\end{solution}



\variant
Spot the error(s)! $10$ threads will call {\tt barrier} once. The first $9$ threads should sleep until the 10\textsuperscript{th}  thread calls {\tt barrier}, then all $10$ threads should continue.
Review the multi-threaded code below for synchronization errors. Note {\tt PTHREAD_COND_INITIALIZER} is equivalent to {\tt pthread_cond_init}
\begin{verbatim}
01  int count=10;
02  pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;
03  pthread_cond_t cv = PTHREAD_COND_INITIALIZER; 
04
05  void barrier() { 
06    pthread_mutex_lock(&m);
07    count--;
08    if(count >0) {
09        while(count>0) pthread_cond_wait(&m,&cv);
10    } else {
11         pthread_cond_signal(&cv);
12    }
13    pthread_mutex_unlock(&m);
14  }
\end{verbatim}
Which one of the following is true for the code above?
\begin{answers}
\correctanswer When the 10\textsuperscript{th} thread calls {\tt barrier}, 2 threads will continue executing code after the {\tt barrier} call
\answer When the 10\textsuperscript{th} thread calls {\tt barrier}, 10 threads will continue executing code after the {\tt barrier} call
\answer Two or more threads can continue executing code after the {\tt barrier} call before the 10\textsuperscript{th} thread calls {\tt barrier} 
\answer One thread can continue executing code after the barrier call before the 10\textsuperscript{th} thread calls {\tt barrier} 
\answer When the 10\textsuperscript{th} thread calls {\tt barrier}, no threads will continue executing code after the {\tt barrier} call
\end{answers}
\begin{solution}
\end{solution}



\variant
Solve the Condition Variables riddle. Once upon a time The FAR-PAR chef tweeted `Wakeup students the food is ready!' But at that precise moment another student had just checked their messages (None!) and decided to nap just at the moment the chef sent his tweet! Which answer best explains how Condition Variables prevent this race condition?
\begin{answers}
\correctanswer Condition Variables require a locked mutex before {\tt signal} and {\tt wait} calls to ensure the signal is not lost
\answer Condition Variables do not prevent this race condition. The signal should be sent twice or more (use a loop around signal)
\answer Condition Variables require a counting semaphore to ensure the signal is received by all the waiting threads
\answer Condition Variables use a Reader Writer pattern to ensure the signal is queued and received by all the waiting threads
\answer Condition Variables must be correctly initialized
\end{answers}
\begin{solution}
Note: Also the first two steps {\tt pthread_cond_wait} of unlocking the mutex and sleeping (until a signal) is performed atomically.
\end{solution}


\variant


Five philosophers are invited to sit at a circular table. Each philosopher's brain has only two states:  Either thinking or hungry! Around the table I place five chopsticks (one chopstick between each philosopher). A philosopher can eat once they are exclusively holding the two chopsticks that are nearest to them. If a philosopher is unable to pick up the other chopstick after 60 seconds, then they will put their first chopstick down and think for 60 seconds before trying again. Unfortunately being too smart they all use the timers on their smart-watches and all attempt to pick up one chopstick on their left at the same time, then wait for another chopstick, give up, release their first chopstick, and try again, and again and again for ever... This scenarios is best described as 
\begin{answers}
\correctanswer Starvation due to livelock
\answer Deadlock due to hold and wait
\answer Deadlock due to pre-emption
\answer A solution to the Dining Philosophers problem
\answer Starvation due to deadlock
\end{answers}
\begin{solution}
\end{solution}

%%%%%%%%%%%%%%%%%% Revenge of Quiz 6 %%%%%%%%%%%%%%%%%%

%%Q34
\question{3}
\variant
Spot the error! When run, the {\tt go} function causes a segfault during the {\tt qsort} call. Assume  {\tt comp_fn} is correctly written. Which response best describes the bug that caused the segfault?
\begin{verbatim}
 1    pthread_t tid;
 2    void* result;
 3    void* func(void*m) {
 4       qsort(m, 100000, sizeof(int), comp_fn);
 5       return NULL;
 6    }
 7    void go() { 
 8       void* mem=calloc(100000, sizeof(int));      
 9       pthread_create(&tid,NULL,func,mem);
10       free(mem);
11       pthread_join(tid,&result);
12    }
\end{verbatim}
\begin{answers}
\answer {\tt qsort} can not be used with heap memory
\answer Line $11$: {\tt pthread_join} should be {\tt pthread_exit}
\correctanswer Line $10$ and $11$ need to be swapped
\answer {\tt qsort} must not be called in a second thread
\answer Line $8$ and $9$ need to be swapped
\end{answers}
\begin{solution}
\end{solution}



\variant
Which response best describes the following code segment?
\begin{verbatim}
int main() {
  FILE*fh=fopen("results.txt","w+");
  fprintf(fh, "%d",12345);
  fflush(fh);
  fseek( fh, 0, SEEK_SET);
  pid_t child = fork();
  if(child==0) { /* I'm the child */
    fseek( fh, 0, SEEK_END);
    fclose(fh); 
    exit(0); // does not return
  }
  waitpid(child,NULL,0);

  fprintf(fh, "%d",99);
  fclose(fh);
  return 0;
}

\end{verbatim}
\begin{answers}
\correctanswer $99$ will be written at the end of the file
\answer The parent process will segfault because the file was already closed
\answer $99$ will be written at the start of the file
\answer The parent will never successfully write $99$ to the file
\answer The child process will truncate the file to zero bytes
\end{answers}
\begin{solution}
\end{solution}




\variant
Which order of calls can be used to determine a file size (for files $<$ 2GB)?
\begin{answers}
\correctanswer {\tt fseek(fh,0,SEEK_END)} then {\tt ftell(fh)}
\answer {\tt fseek(fh,-1,SEEK_APP)} then {\tt fpos(fh)}
\answer {\tt fpos(fh)} then {\tt fseek(fh,-1,SEEK_APP)}
\answer {\tt fset(fh)} then {\tt fseek(fh,0,SEEK_SET)}
\answer {\tt fseekend(fh)} then {\tt flength(fh)} 
\end{answers}
\begin{solution}
\end{solution}


\variant
Which one of the following might be used to re-read the first line of a file? Assume {\tt fh} refers to a valid file handle and the line will be parsed using {\tt fscanf} or {\tt fgets}.
\begin{answers}
\correctanswer {\tt fseek(fh,0,SEEK_SET)}
\answer {\tt frepo(fh,-1)} 
\answer {\tt fpos(fh)} 
\answer {\tt freread(fh)} 
\answer {\tt freadat(fh,0)} 
\end{answers}
\begin{solution}
\end{solution}



\variant
Spot the error(s)! $5$ threads will call {\tt barrier} once. The first $4$ threads should sleep until the 5\textsuperscript{th}  thread calls {\tt barrier}, then all $5$ threads should continue. A student wrote the following code and wonders if it will work correctly.
Carefully review the multi-threaded code below for synchronization errors. Note {\tt PTHREAD_COND_INITIALIZER} is equivalent to {\tt pthread_cond_init}.
\begin{verbatim}
01  int count=5;
02  pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;
03  pthread_cond_t cv = PTHREAD_COND_INITIALIZER; 
04
05  void barrier() { 
06    pthread_mutex_lock(&m);
07    count--;
08    pthread_cond_broadcast(&cv);
09    while(count>0) 
10              pthread_cond_wait(&cv, &m);
11    pthread_mutex_unlock(&m);
12  }
\end{verbatim}
Decide if each statement is true or false and select the appropriate response.\\
$S1$:  ``The code suffers from a race condition if two or more threads call {\tt barrier} at the same time.\\
$S2$:  ``It is possible that some threads can continue {\em before} the $5$\textsuperscript{th} thread calls {\tt barrier}"\\
$S3$:  ``It is possible that one or more of the first four threads may get stuck inside the barrier function even {\em after} the $5$\textsuperscript{th} thread calls {\tt barrier}."

\begin{answers}
\answer Only $S1$ is true
\answer Only $S2$ is true
\answer Only $S3$ is true
\answer Exactly two statements are true
\correctanswer None of the other responses are correct
\end{answers}
\begin{solution}
The code implements a barrier albeit an inefficient one: It's certainly inefficient that all threads unnecessarily call broadcast - even before the count is zero. However this will cause threads to wake up and check the count (not yet zero!) and go back to waiting. A better solution would only broadcast when {\tt count==0}
\end{solution}





\variant
A pipe will generate a POSIX signal (SIGPIPE) ...
\begin{verbatim}
\end{verbatim}
\begin{answers}
\answer When reading and the pipe is empty but not when the pipe is full
\answer When writing and the pipe is full but not when the pipe is empty
\correctanswer When writing and all listeners (readers) are already closed
\answer When all writers are closed and a read is attempted
\answer When a reader or writer would block
\end{answers}
\begin{solution}
\end{solution}


\variant
A pipe is an example of
\begin{answers}
\answer APC
\answer PAC
\correctanswer IPC
\answer TLB
\answer MMU
\end{answers}
\begin{solution}
\end{solution}


\variant
In CS241, IPC stands for 
\begin{answers}
\answer Interrupted program counter
\answer Interprocess cancelation
\correctanswer Interprocess communication
\answer Inert pre-emptive Coffman 
\answer Infinite pre-emptive Condition
\end{answers}
\begin{solution}
\end{solution}


\variant
Which one of the following is NOT TRUE for a hardware implementation of Virtual Memory?
\begin{answers}
\answer The page table may store how recently a particular page was used
\answer The page table does not use the lowest bits of the virtual address
\correctanswer The page table converts frame numbers into page numbers
\answer The page table is stored in RAM
\answer Pages can be missing i.e. they may not have any corresponding physical memory associated with them
\end{answers}
\begin{solution}
\end{solution}


\variant
Which one of the following is TRUE for a typical 32 bit hardware implementation of Virtual Memory? Assume the machine has 128MB of ram
\begin{answers}
\answer The highest 12 bits of the virtual address are used as an offset
\answer A typical page size on a 32 bit linux machine is 32MB 
\correctanswer A single-level page table is sufficient to fit into main memory
\answer The page table converts page numbers into offset numbers
\answer The page table converts frame numbers into offset numbers
\end{answers}
\begin{solution}
\end{solution}



\variant
Solve my riddle! I speed up the conversion of a virtual address to a physical address by caching recent results. I am useless if your memory requests are random (you'll need the page tables for that case) but usually your reads and writes are to recently used pages. My short-term memory is tiny but I am extremely fast! What am I called?
\begin{answers}
\answer Physical Address Cache
\answer Memory Management Unit
\correctanswer Translation Lookaside Buffer
\answer Dynamic Ram Translation
\answer Address Conversation Cache
\end{answers}
\begin{solution}
\end{solution}

\variant
Solve my riddle! I can tell if you the frame is the same as an old copy on disk (``Secondary storage"). You'll find me in the page table. What am I called?
\begin{answers}
\answer The frame bit
\answer The frame-disk bit
\correctanswer The dirty bit
\answer The page-to-disk bit
\answer The copy bit
\end{answers}
\begin{solution}
\end{solution}



\variant
A 64 bit architecture with 16 GB of RAM uses 16 KB pages in a three-level page table. How many bits are used for the offset?
\begin{answers}
\answer $16$
\answer $10$
\correctanswer $14$
\answer $4$
\answer None of the other responses are correct
\end{answers}
\begin{solution}
\end{solution}


\variant
Choose the best response to fill in the blank. A computational process performs many writes over it's entire virtual memory space with no predictable pattern. In a machine with virtual memory support disabled the running time is 100 seconds. On an equivalent machine with virtual memory enabled that uses a single-level page table, the process would be expected to complete in approximately ______ seconds.
\begin{answers}
\answer 95 to 105
\answer 106 to 139
\correctanswer 40 to 60
\answer 140 or greater 
\answer 61 to 94
\end{answers}
\begin{solution}
\end{solution}


\variant
Which one of the following is NOT an advantage of virtual memory?
\begin{answers}
\answer Processes can share frames using the `mmap' system call.
\answer Virtual memory allows processes to share read-only frames  (e.g. C library, program code)
\correctanswer To prevent fragmentation, sequential frames are assigned sequentially to pages
\answer Stack memory can be set to be non-executable (i.e. only contain data)
\answer There can be valid virtual addresses that do not have a physical memory assigned
\end{answers}
\begin{solution}
\end{solution}


\variant
Which one of the following is NOT true for a multi-level page table?
\begin{answers}
\answer Useful for 64bit because it can be sparse; not all sub-tables need to exist
\answer Can identify pages that have been modified compared to the copy on disk
\correctanswer Is faster than a single-level page table for virtual address translation
\answer Like single-page tables, uses an offset for each frame to calculate the physical address
\answer For lookups into the same frame, the TLB will be faster at virtual address translation than a multi-level page table 
\end{answers}
\begin{solution}
\end{solution}



\variant
{\tt "fork(2)" "printf(3)"} is a short-hand to mean {\tt fork} is documented in the system-call section (section \#2) of the man pages, while {\tt printf} is documented in the C library (section \#3) of the man pages. Where would you expect to find {\tt strcmp} and {\tt pipe}?
\begin{answers}
\answer {\tt strcmp(3) pipe(3)}
\answer {\tt strcmp(2) pipe(3)}
\correctanswer {\tt strcmp(3) pipe(2)}
\answer {\tt strcmp(2) pipe(2)}
\answer None of the other responses are correct
\end{answers}
\begin{solution}
\end{solution}
%%



\variant
Analyze the following cryptic code that claims to solve the Reader Writer solution using a simple while loop. Note mutex function names have been shortened.

\begin{tabular}{ | p{0.45\textwidth} | p{0.45\textwidth} | }
\hline \begin{verbatim}void X() {
 lock(&m);
 while(y>0) { /* Try again! */} 
 x++;
 unlock(&m);
 // Do X stuff
 lock(&m);
 x--;
 unlock(&m);
} \end{verbatim} & \begin{verbatim}
double Y() { 
 lock(&m);
 while(y>0 || x>0) { /* Try again! */} 
 y++;
 unlock(&m);
 // Do Y stuff
 lock(&m);
 y--;
 unlock(&m);
}\end{verbatim} \\ \hline
\end{tabular}

Which response best describes the above code?
\begin{answers}
\answer Reader Writer `naive solution' (suffers from writer starvation); X is write Y is read
\answer Reader Writer `writers-preference solution' (no writer starvation); X is write Y is read
\correctanswer Can livelock because mutex is locked during the while loop
\answer Reader Writer `naive solution' (suffers from writer starvation); Y is write X is read
\answer Reader Writer `writers-preference solution'  (no writer starvation); Y is write X is read
\end{answers}
\begin{solution}
Notice that Y waits for X and Y, whereas X only waits for Y. Therefore Y is a writer.

For both X and Y code paths: When busy waiting in the while loop, the thread, unlike the cond_wait version, will not release the lock. This has the following affect:
If a writer or reader is waiting for a writer to finish then all incoming reader and writer threads will be blocked by the currently locked mutex.
However when an active reader or writer has finished they will need to acquire the mutex lock. This is impossible (the lock is being held by a busy-waiting thread). Therefore the two threads will not be able to proceed. This is deadlock not livelock because one thread will continually check the wait condition in the while loop but will never exit the while loop.

A side note: It is also inefficient to wait on a mutex (mutex is designed to be help only for a very brief period and may unnecessarily tie up a CPU).
\end{solution}

%%%%%%%%%%%%%%%%%% Revenge of quiz 7 %%%%%%%%%%%%%%%%%%

%%Q35
\question{3}
\variant
My IPv6 server program listens for TCP connections on port 2000 but fails when I try use port 1000 instead. Which of the following is the most likely explanation?
\begin{answers}
\correctanswer Ports numbers below 1024 can only be used by processes with root (admin) privileges
\answer Port numbers below 1024 are reserved for system tasks
\answer Port numbers below 1024 are reserved for IPv4 connections
\answer Port numbers below 1024 cannot be used for incoming connections on IPv6
\answer Port numbers below 1024 can only be used for internal socket connections on the same host
\end{answers}
\begin{solution}
\end{solution}

%% 
\variant
Which is NOT true for sockets?
\begin{answers}
\correctanswer Must be super-user (root) to create a socket
\answer Can be used for IPv4 streaming connections
\answer Can be used for IPv6 streaming connections
\answer Can be used for packet-based networking
\answer Can be used for stream-based networking
\end{answers}
\begin{solution}
\end{solution}

%% 
\variant
I want to store the client's port number stored in a socket C structure in a text file where I will log (keep a note of) all of the incoming connections. Which C function should I use to correctly read the port data from the struct?
\begin{answers}
\correctanswer  {\tt ntohs}
\answer {\tt port2n}
\answer {\tt htons}
\answer {\tt htonl}
\answer {\tt portin}
\end{answers}
\begin{solution}
\end{solution}

%% 
\variant
Solve my riddle! I am an modern Internet addressing scheme. My addresses are 128 bits -  so I'm perfect for everyone's Internet-connected wearables. There's no place like {\tt ::1}
\begin{answers}
\correctanswer  IPv6
\answer IPv5
\answer IPv4
\answer  UDP
\answer TCP
\end{answers}
\begin{solution}
\end{solution}

\variant
Solve my riddle! You'll find me in most Internet packets today. My addresses are 32 bits as 4 billion addresses should be enough for everyone! There's no place like {\tt 127.0.0.1}
\begin{answers}
\correctanswer IPv4
\answer IPv6
\answer TCP
\answer UDP
\answer IPv5
\end{answers}
\begin{solution}
\end{solution}

%% 
\variant
Solve my riddle! I am a packet-based method of communication. Send the packet and forget! (I behave more like a letter than a phone call). Sometimes I get lost along the way but I don't care - that's your problem!
\begin{answers}
\correctanswer UDP
\answer TCP
\answer ODP
\answer ADP
\answer TDP
\end{answers}
\begin{solution}
\end{solution}

\variant
Solve my riddle! I am a stream-based method of networking. Before you can send any bytes I will negotiate a reliable channel between you and another host. If my packets get lost I'll resend them automatically - you won't even know!
\begin{answers}
\correctanswer TCP
\answer UDP
\answer ODP
\answer ADP
\answer TDP
\end{answers}
\begin{solution}
\end{solution}

%% 
\variant
Which one of the following is NOT a feature of TCP?
\begin{answers}
\correctanswer Encryption
\answer Packet re-ordering
\answer Flow control
\answer Packet re-tranmission
\answer Simple error detection
\end{answers}
\begin{solution}
\end{solution}

%% 
\variant
Which one of the following correctly describes the minimum network calls required to build a client to connect to a web server?
\begin{answers}
\correctanswer getaddrinfo, socket, connect
\answer getaddrinfo connect
\answer getaddrinfo, socket, listen, connect
\answer getaddrinfo, listen
\answer getaddrinfo, socket
\end{answers}
\begin{solution}
\end{solution}

%% 
\variant
Riddle me this! I am a distributed service that can look up hosts for you. Give me a host name and I'll tell you their IP address(es)!
\begin{answers}
\correctanswer DNS
\answer DMS
\answer HHS
\answer HSS
\answer DDS
\end{answers}
\begin{solution}
\end{solution}


%% 
\variant
What is the correct order of the ``big 4" networking calls to initialize a server?
\begin{answers}
\correctanswer socket, bind, listen, accept
\answer socket, listen, bind, accept
\answer socket, listen, accept, bind
\answer listen, socket, accept, bind
\answer accept, socket, bind, listen
\end{answers}
\begin{solution}
\end{solution}

%% 
\variant
Solve my riddle! I am used to allow a backlog of connections. Call me to specify how many unaccepted new connections should be allowed
\begin{answers}
\correctanswer listen
\answer bind
\answer accept
\answer backlog
\answer sockqueue
\end{answers}
\begin{solution}
\end{solution}

\variant
Solve my riddle. I may block if there's no new connections to your server; but don't fear, I will return as soon as someone connects!
\begin{answers}
\correctanswer accept
\answer bind
\answer listen
\answer socket
\answer getaddrinfo
\end{answers}
\begin{solution}
\end{solution}

%% 
\variant
Solve my riddle. Use me to attach a socket to a particular port on the host.
\begin{answers}
\correctanswer bind
\answer accept
\answer listen
\answer socket
\answer attach
\end{answers}
\begin{solution}
\end{solution}


\variant
Which of the following is NOT a reason for a process (or thread) to be moved to the ready queue?
\begin{answers}
\correctanswer The currently executing process calls {\tt exit(0)}
\answer The currently executing process calls {\tt fork}
\answer A new TCP connection is fully initialized and {\tt accept} can now return
\answer A thread waiting on a condition variable is signaled
\answer A synchronization primitive (e.g. counting semaphore) is unlocked / released
\end{answers}
\begin{solution}
\end{solution}


%% 
\variant
Pick the best response to complete the following, ``Passive sockets are used ..."
\begin{answers}
\correctanswer For listening server connections only
\answer For client connections only
\answer For both client and server connections
\answer For system services
\answer For UDP clients
\end{answers}
\begin{solution}
\end{solution}

%% 
\variant
A student claims the following code fails to connect to a remote web server. 
Which response best describes the major bug in this code that causes this problem?
\begin{verbatim}
int setup_server() {
    struct addrinfo hints, *result;
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM; 
    int sock_fd = socket(hints.ai_family, hints.ai_socktype, 0);
    if( getaddrinfo("www.illinois.edu", "80", &hints, &result) ) 
        return 0;
    if( connect(sock_fd, result->ai_addr, result->ai_addrlen) )
      return 0;
    return sock_fd;
    }
\end{verbatim}
\begin{answers}
\correctanswer The {\tt hints} struct is not properly initialized 
\answer The {\tt getaddrinfo} call is only used for TCP servers
\answer The {\tt connect} call is only used for TCP servers
\answer The {\tt hints.ai_socktype} should be set to SOCK_DGRAM
\answer The port number is incorrect
\end{answers}
\begin{solution}
\end{solution}

%% 
\variant
You are writing a linux-specific high-performance uiuc-coin-chitchat-wearables-database-caching-search-ai-web server that is designed to concurrently handle 10,000 long-lived connections. For the best performance you recommend ....
\begin{answers}
\correctanswer {\tt epoll}
\answer {\tt select}
\answer {\tt poll}
\answer 10,000 threads (one per connection)
\answer 10,000 processes (one per connection)
\end{answers}
\begin{solution}
\end{solution}


%% 
\variant
A good reason to use {\tt select} to handle many open connections is 
\begin{answers}
\correctanswer It's cross-platform and supported on all POSIX platforms (including embedded devices and Mac OSX)
\answer It has better performance than {\tt epoll} when there are 1000s of connections
\answer It can be used with multiple processes but {\tt epoll} cannot
\answer It can be used with multiple threads but {\tt epoll} cannot
\answer {\tt epoll} requires an O(N) scan {\tt select} does not
\end{answers}
\begin{solution}
\end{solution}


\variant
Using Round robin scheduling, with a time quanta of 4 ms, determine the average wait time of the following processes. 

\begin{tabular}{ | l | r | r  |}
\hline
Process & Arrival time (ms) & Execution time (ms)  \\ \hline
P1 & 0 & 8 \\ \hline
P2 & 4 & 8 \\ \hline
P3 & 4 & 4 \\ \hline
P4 & 8 & 4 \\ \hline
\end{tabular}
\\
Hint: Wait time = total time a process remains in the ready queue\\
Thus, Wait time for each process = $(Endtime - Arrivaltime - Executiontime)$
\begin{answers}
\answer  None of the other responses are correct
\answer 3.00 - 3.49 ms
\answer 3.50 - 3.99 ms
\answer 4.00 - 4.49 ms
\correctanswer 4.50 ms or higher
\end{answers}
\begin{solution}
8ms.
\\
\begin{tabular}{ | l | l | l | l | l | l |}
\hline
0.4  &  4.8 &  8.12 & 12.16 & 16.20 & 20.24 \\ \hline
P1   &  P2  &   P3  &   P4  &    P1  &    P2 \\ \hline
\end{tabular}
\\
{\tt Total Wait = (20-8) + (24-8-4) + (12-4-4) + (16-8-4) = 12+12+4+4=32 ms}
\end{solution}

%% 
\variant
Three processes repeatably read a block of data, use the CPU to perform a calculation and then write to disk. While waiting for disk I/O the CPU is re-assigned to another waiting (ready) process. The first two processes require a short amount of CPU processing for each block. The third process requires a large amount of CPU time for each block. Which scheduling algorithm(s) exhibits poor parallelism in this circumstance (i.e. poor use of disk resources) ? Select the best response.
\begin{answers}
\correctanswer First come first served (FCFS) but not round robin (RR)
\answer First come first served (FCFS) and round robin (RR)
\answer Round robin (RR) but not First come first served (FCFS)
\answer Neither! Both Round robin and First come first served exhibit optimal disk I/O
\answer What do you mean? An African or a European swallow?
\end{answers}
\begin{solution}
\end{solution}

%% 
\variant
Which scheduler(s) would cause a system to become completely unresponsive (`appear to deadlock/crash') if a background batch process entered an infinite loop?\\
Hint: FCFS = First come first served; RR = Round robin.
\begin{answers}
\answer FCFS and RR
\correctanswer FCFS but not RR
\answer RR but not FCFS
\answer Neither RR nor FCFS 
\answer ``I refuse to answer that question on the grounds that I don't know the answer" 
\end{answers}
\begin{solution}
\end{solution}

%% 
\variant
It takes $20$ms for a packet to travel from client {\tt X} to the server {\tt yikyak.com} (and the same amount of time for a packet to be sent back to the client). How quickly can the client fully initialize a new TCP connection? i.e. How many milliseconds are required (starting from the moment the client sends the first packet) until the server is ready to receive the first {\tt data} packet?

\begin{answers}
\correctanswer Minimum 60 ms (3-way-handshake)
\answer Minimum 40 ms (2-way-handshake)
\answer Minimum 30 ms (Dual-duplex-handshake)
\answer Minimum 20 ms (1-way-handshake)
\answer Minimum 50 ms (2.5-way-shake)
\end{answers}
\begin{solution}
\end{solution}

%% 
\variant
Which one of the following is NOT part of the TCP header?
\begin{answers}
\correctanswer IP source address
\answer source port
\answer SYN bit
\answer ACK bit
\answer Sequence number
\end{answers}
\begin{solution}
The IP source (and destination) address is part of the IP header, not the TCP header. \\
The SYN and ACK bits are used to initiate and acknowledge sequence numbers.\\
\end{solution}

%% 
\variant
Four processes of equal priority, {\tt P1 P2 P3 P4}, enter the ready state at the same time. Process 1 requires 1 second of CPU, Process 2 requires 2 seconds of CPU, 3s of CPU for P3 and 4s of CPU for P4. Process 1 takes approximately 4 (wall-clock) seconds to finish. Which response describes the most likely scheduler? Assume there are no other significant workloads.
\begin{answers}
\correctanswer RR
\answer SJF
\answer FCFS
\answer pre-emptive SJF
\answer pre-emptive priority FCFS
\end{answers}
\begin{solution}
\end{solution}


%%%%%%%%%%%%%%%% Revenge of Quiz 8 %%%%%%%%%%%%%%%%%%

%%Q36
\question{3}

\variant
Which one of the following is true for the shell command {\tt touch abc} ?
\begin{answers}
\correctanswer Creates an empty file if {\tt abc} does not exist. Updates the last modified time to the current time
\answer Truncates the file {\tt abc} to zero bytes and removes any hard links to the original file
\answer Updates the user and group information of the file {\tt abc} to be the same as the shell process
\answer Creates a hard link to the file {\tt abc} in the same directory
\answer Converts a symbolic link of the file {\tt abc} to a physical file by coping the contents of the file
\end{answers}
\begin{solution}
\end{solution}

\variant
Solve my riddle! I am a virtual file in a virtual filesystem. I'll can generate unpredictable secure random byte values by collecting entropy (noise) from the rest of the system. I'm a useful source of random bytes to seed secure strongly-encrypted connections. Reading bytes from me may block until there is sufficient entropy to provide unpredictable values.
\begin{answers}
\correctanswer /dev/random
\answer /dev/block
\answer /random/entropy
\answer /random/noise
\answer /dev/entropy
\end{answers}
\begin{solution}
\end{solution}

\variant
Solve my riddle! I am a virtual file in a virtual filesystem. I provide a source of random values also based on entropy of the system however I never block and will always return pseudo-random values even when there is little entropy in the system.
\begin{answers}
\correctanswer  /dev/urandom
\answer /dev/noise
\answer /random/noise
\answer  /dev/source
\answer /dev/rnd
\end{answers}
\begin{solution}
\end{solution}

\variant
Which one of the following shell commands has the ``setuid bit" set?
\begin{answers}
\correctanswer sudo
\answer touch
\answer mkdir
\answer dd
\answer rm
\end{answers}
\begin{solution}
\end{solution}



\variant
Which one of the following is NOT true when mounting filesystems using Linux's {\tt mount} shell command?
\begin{answers}
\correctanswer Only read-only filesystems can be mounted
\answer File access permissions and ownership can be configured as part of the mounting process
\answer {\tt mount} requires admin (root) privileges to mount an arbitrary filesystem in an arbitrary directory
\answer {\tt mount} can be used to mount virtual and real filesystems
\answer {\tt mount} can mount loop-ed filesystems stored as a single file on an existing filesystem
\end{answers}
\begin{solution}
\end{solution}

\variant
Which of the following is NOT stored as part of the inode in a standard ext2 linux filesystem?
\begin{answers}
\correctanswer filename
\answer created time
\answer pointers to direct blocks, indirect blocks, double indirect block and triple indirect block
\answer reference count
\answer file length
\end{answers}
\begin{solution}
\end{solution}

\variant
I execute {\tt rm abc} to successfully delete my regular file. The file contents however are still accessible under a different filename in a different directory! What is the best explanation?
\begin{answers}
\correctanswer A hard link to the file must have been created before it was deleted
\answer A symbolic link to the file must have been created before it was deleted
\answer The file must have had its sticky bit set
\answer The file must have had its setuid bit set
\answer The file must have been created in the {\tt /etc /var} or {\tt /tmp} directory
\end{answers}
\begin{solution}
\end{solution}


\variant
I want to create a link in my home directory to my favorite python installation directory, what kind of link(s) is/are most reasonable for a non-root user?
\begin{answers}
\correctanswer A symbolic link is a good choice but a hard link is not
\answer A hard link is a good choice but a symbolic link is not a good choice
\answer Both a symbolic link and hard link are good choices for this task
\answer Neither symbolic nor hard links are good choices for this task
\answer There is no spoon (nor points for choosing this response)
\end{answers}
\begin{solution}
\end{solution}

\variant
I create a directory with permissions 500. Which response is a reasonable output of the {\tt ls} command below?
\begin{verbatim}
mkdir -m 500 stuff
ls -ldi stuff
\end{verbatim}
\begin{answers}
\correctanswer {\tt 12435 dr-x------. 2 angrave angrave 4096 Nov 16 20:51 stuff }
\answer {\tt 12435 d------r-x. 2 angrave angrave 4096 Nov 16 20:51 stuff }
\answer {\tt 12435 dr-sr-sr-s. 2 angrave angrave 4096 Nov 16 20:51 stuff }
\answer {\tt 12435 dr-xr-xr-x. 2 angrave angrave 4096 Nov 16 20:51 stuff }
\answer {\tt 12435 dr--r-----. 2 angrave angrave 4096 Nov 16 20:51 stuff }
\end{answers}
\begin{solution}
\end{solution}

\variant
Choose the best fitting description to complete the following: A directory consists of an inode and data blocks. The directory's data blocks contain ...
\begin{answers}
\correctanswer Filenames and inode numbers of the directory entries
\answer Only inode numbers of the directory entries
\answer Only filenames of the directory entries
\answer Only filenames and permissions of the directory entries
\answer Only filenames and hard-link entries
\end{answers}
\begin{solution}
\end{solution}


\variant
Complete the following code to return 1 if the given path corresponds to a valid directory
\begin{verbatim}
int isdir(char* path) {
  struct stat s;
  return  ________;
}
\end{verbatim}
\begin{answers}
\correctanswer  {\tt 0==stat(path, {\&}s )  {\&}{\&}  0 != S_ISDIR(s.st_mode) }
\answer  {\tt 0==fstat(path, {\&}s )  {\&}{\&}  0 != S_ISDIR(s)  }
\answer {\tt E_ISDIR==open(path,"d")  }
\answer {\tt S_ISDIR( lstat({\&}path, *s) ) }
\answer {\tt dstat({\&}path, *s) ==1 }
\end{answers}
\begin{solution}
Note {\tt stat} returns 0 if successful
\end{solution}

\variant
What is the role of {\tt __LINE __ } ?
\begin{answers}
\correctanswer The line number of the source code currently being compiled
\answer The line number of the input file currently being read
\answer The line number of the last kernel call
\answer The number of output lines printed by the process to standard out
\answer The total number of output lines printed by the process to stdout and stderr
\end{answers}
\begin{solution}
\end{solution}

%% EDK - I don't know about the lectures, but we didn't talk about the
%% sticky bit in labs or MPs
%% \variant
%% Solve my riddle. I'm a settable bit you can set on directories. If you set me then users can see each other's sub-directories but they cannot delete or directly overwrite them. I'm typically set on world-writable directories (such as {\tt /tmp})
%% \begin{answers}
%% \correctanswer The sticky bit!
%% \answer The temp bit!
%% \answer The setuid bit!
%% \answer The www bit!
%% \answer The shared bit!
%% \end{answers}
%% \begin{solution}
%% \end{solution}


\variant
Before modifying an existing file, the umask is changed to 777. What affect, if any, will this have on the existing file? A reminder that {\tt >} redirects standard output to a file and {\tt >>} appends standard output to a file.
\begin{verbatim}
echo "Hello" > story.txt
umask 777
echo "Again" >> story.txt
\end{verbatim}
\begin{answers}
\answer The story.txt contents cannot be modified or read by other users
\answer The story.txt contents can be read and modified by other users
\answer The story.txt contents is not readable by the user who created it
\answer The story.txt contents is not modifiable by the user who created it
\correctanswer Existing files and directories are unaffected by the umask value
\end{answers}
\begin{solution}
\end{solution}

\variant
My old harddisk has a seek time of 10ms and transfer rate of 50 MB/s. I perform the following benchmark on my system which takes 20 seconds to complete
\begin{verbatim}
dd if=/dev/zero of=/dev/null bs=1M count=123456
\end{verbatim}
I now replace my hard disk with a solid state drive (SSD) that can execute 50,000 I/O 4KB block requests per second and a transfer rate of 250 MB/s. What is the expected completion time now for the above benchmark?
\begin{answers}
\correctanswer 10-30 seconds
\answer 1-9.9 seconds
\answer  100-999 ms
\answer 10-99 ms
\answer  Less than 9ms
\end{answers}
\begin{solution}
The benchmark should run in approximately the same amount of time:
The above dd command is reading bytes from a virtual file {\tt /dev/zero } and writing to a virtual file {\tt /dev/null } from the virtual {\tt /dev } file system - there are no bytes being read or written to a physical disk during the approx. 12GB transfer!
\end{solution}

\variant
Solve my riddle - What am I? I increase the chances of keeping your data safe from drive failure by storing redundant information - a parity bit for every set of bits written to the other disks.  For performance, and to reduce stress on any one single drive, the parity bit is distributed across the disk array. You can replace any single failed drive with a new drive and recalculate the drive's contents. However if two drives fail (e.g. another drive fails during the rebuild process) - well... I hope you had recent backup using alternative storage!
\begin{answers}
\correctanswer RAID 5
\answer RAID 1
\answer RAID 0
\answer Reed-solomon coding
\answer Mirror
\end{answers}
\begin{solution}
\end{solution}

\variant
Which of the following describes how Google manages its distributed file system ``Colossus"?
\begin{verbatim}
1 Multiple copies in different geographic regions
2 Reed-solomon encoded data-blocks to recover from single bit and multiple-bit errors
3 Resilient to sudden failure of individual disks, servers, racks of servers, and entire data-centers
4 Pro-active warning when free space is under 1 petabyte
\end{verbatim}
\begin{answers}
\correctanswer (1) (2) (3) (4)
\answer (1) + (2) only 
\answer (3) + (4) only
\answer None of the other responses are correct
\answer (4) only
\end{answers}
\begin{solution}
\end{solution}


\variant
How many lines will be printed by this program and what is the content of each line? Assume all system calls complete successfully.
\begin{verbatim}
int main(int argc, char**argv) {
  mkdir("dir1",0755);
  mkdir("dir1/dir2",0755);
  symlink("dir1/dir2","dir1/sym");
  struct dirent* dp;
  DIR* dirp = opendir("dir1");
  while ((dp = readdir(dirp)) != NULL) {
      puts(dp->d_name);
  }
  closedir(dirp);
  return 0;
}
\end{verbatim}
\begin{answers}
\correctanswer 4 lines are printed:  {\tt "."  ".."  "dir2" } and  {\tt "sym" } 
\answer 2 lines are printed:  {\tt  "dir2" } and  {\tt "sym" }
\answer 3 lines are printed:  {\tt ".."  "dir2" } and  {\tt "sym" }
\answer 3 lines are printed:  {\tt "."  "dir2" } and  {\tt "sym" }
\answer 3 lines are printed:  {\tt "." ".." } and  {\tt "dir2" }
\end{answers}
\begin{solution}
\end{solution}

%%%%%%%%%%%%%%%%%% Revenge Quiz 9 %%%%%%%%%%%%%%%%%%

%%Q37
\question{3}

\variant
Which response best describes when the program below will terminate?
\begin{verbatim}
10  int main() {
11     sigset_t m, old;
12     sigfillset(&m);
13     sigprocmask(SIG_SETMASK,&m, &old);
14     raise(SIGINT);
15     sigprocmask(SIG_SETMASK,&old, &m);
16     raise(SIGINT);
17     exit(0);
18     return 0;
19  }
\end{verbatim}
\begin{answers}
\answer The program will terminate when line 16 is executed
\correctanswer The program will terminate when line 15 is executed
\answer The program will terminate when line 14 is executed
\answer The program will terminate when line 17 is executed
\answer None of the other responses are correct
\end{answers}
\begin{solution}
\end{solution}


\variant
Which response best describes how many of the following implements about {\tt sigaction()} compared to {\tt signal()} are correct? \\
``{\tt  signal} requires less code than {\tt sigaction} to set a signal handler" \\
``In a multi-threaded program {\tt sigaction} is preferable to {\tt signal}" \\
``With {\tt sigaction}, additional signals can be blocked for the duration of the signal handler" \\
``{\tt sigaction()} must be used to set a handler for {\tt SIGKILL}" \\
\begin{answers}
\correctanswer  Three (3) statements are correct
\answer  Four (4) statements are correct
\answer Two (2) statements are correct
\answer One statement is correct
\answer None of the statements are correct
\end{answers}
\begin{solution}
The last statement is incorrect. All other statements are correct. Neither {\tt sigaction} or {\tt action} can be used to catch {\tt SIGKILL}.
\end{solution}

\question{3}
\variant
Four students write similar programs but with different code at line 14 (shown below). Decide if any or all of the variations shown below terminate the program.
\begin{verbatim}
10 int main() {
11  pthread_t tid1, tid2;
12  tid1 = pthread_self();
13  pthread_create(&tid2, NULL, func, NULL);
14  _______
      
Student A:  pthread_kill( tid2, SIGKILL );
Student B:  kill( getpid(), SIGKILL );
Student C:  raise( SIGKILL );
Student D:  pthread_kill( tid1, SIGKILL );

\end{verbatim}
\begin{answers}
\correctanswer All four programs responses will terminate the program
\answer Student A's version will not terminate the program
\answer Student B's version will not terminate the program
\answer Student C's version will not terminate the program
\answer Student D's version will not terminate the program
\end{answers}
\begin{solution}
\end{solution}

\question{3}
\variant
How long will it take to completely download and display a small web page with 3 tiny images from the same web server under the following assumptions?\\
The round-trip time is 10ms. The multi-threaded web server supports only HTTP1.0 spec (i.e. no persistent connections). The client is multi-threaded and supports up to 4 simultaneous connections. The DNS lookup (IP address of the server) is already cached by the client. Each item can be sent as a small, single network packet. Client and server processing time is minimal.
\begin{answers}
\correctanswer 40 ms
\answer 80 ms
\answer 20 ms
\answer 50 ms
\answer 60 ms
\end{answers}
\begin{solution}
\end{solution}

\question{3}
\variant
Which of the following is NOT shared between threads in the same process ?
\begin{answers}
\answer pending signals
\answer signal disposition
\correctanswer signal mask
\answer Open file descriptors 
\answer Memory mapped files
\end{answers}
\begin{solution}
\end{solution}

\question{3}
\variant
Complete the following to create shared memory between a parent and child process that is NOT backed by a file. The shared memory must be large enough to hold one integer and be usable for IPC (Interprocess communication)
\begin{verbatim}
int* addr = __________;
*addr=42;
pid_t child = fork();
\end{verbatim}
\begin{answers}
\correctanswer {\tt mmap (0, sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON, -1, 0) }
\answer {\tt mmap (0, sizeof(int), PROT_READ , MAP_SHARED , -1, 0) }
\answer {\tt mmap (0, 1, 0, MAP_SHARED , -1, 0) }
\answer {\tt smem(1, S_CHILD) }
\answer {\tt openmem(sizeof(int), S_PARENT|S_CHILD, -1) }
\end{answers}
\begin{solution}
\end{solution}

\question{3}
\variant
Choose the best response. In an ext-based inode filesystem, a directory entry contains .... 
\begin{answers}
\correctanswer filename and corresponding inode numer
\answer filename, file size in bytes and modification time
\answer filename, number of disk blocks, owner and access information
\answer just an inode number (the filename is stored as part of the inode entry)
\end{answers}
\begin{solution}
\end{solution}

\question{3}
\variant
Select the best response. After a context switch to another process it is likely that ...
\begin{answers}
\correctanswer Physical address calculations will need a full page table lookup
\answer Physical address calculation will be satisfied by the TLB
\answer Shared memory must be reloaded (``paged-in") from disk
\answer Cached disk Inode information must be reloaded (``paged-in") from disk
\answer None of the other responses are correct
\end{answers}
\begin{solution}
\end{solution}

\question{3}
\variant
Our software buys stocks based on analyzing real-time short tweet messages. You modify the software to query the remote server for the most recent tweet using a UDP connection. I use the original software which requires a new TCP connection for each query. The round-trip time is 10ms for all types of packets. Assuming there are no packets lost, who will have an advantage? Select the best response. Assume the remote server does not push information; you must send a request first.
\begin{answers}
\correctanswer Your UDP implementation will get tweet information 10ms earlier than my TCP solution
\answer My TCP implementation will get tweet information 10ms earlier than my UDP solution
\answer Your UDP implementation will get tweet information 15ms earlier than my TCP solution
\answer Your UDP implementation will get tweet information 20ms earlier than my TCP solution
\answer None of the other responses are correct
\end{answers}
\begin{solution}
\end{solution}


\question{3}
\variant
Identify the missing code at positions X,Y, and Z to create an unnamed pipe and write one byte into the pipe. 
\begin{verbatim}
int fd[ _X_ ];
___Y___(fd);
// later...
write( fd[ _Z_ ] , "!",1);
\end{verbatim}

\begin{answers}
\correctanswer {\tt X:2 Y:pipe Z:1}
\answer {\tt X:2 Y:pipe Z:0}
\answer {\tt X:2 Y:mkfifo Z:1}
\answer {\tt X:1 Y:open Z:0}
\answer None of the other responses are correct
\end{answers}
\begin{solution}
\end{solution}

\zone

\cleardoublepage
\bigskip
\noindent
\textbf
\Large
End of Exam Checklist: \\
1. Did you correctly bubble in your i) {\underline 6 letter exam key}  ii)  netid   iii) uin ? \\
2. Did you correctly write on the front page i) Your full name  ii)  netid   iii) uin ? \\
3. Did you write your solutions to $1$-$5$ on the Free-Response sheet?\\
4. Did you bubble in all $46$ multiple choice responses on your Scantron? \\
5. Hand in your Scantron with the answer-side on top, and this printed booklet underneath with your name on top.
%% Spare page
\zone
\cleardoublepage
An incomplete, non-exhaustive list of useful library and system calls covered in CS241.
For brevity, const and restrict keywords not shown. 
In written answers you may safely shorten pthread calls and macros, 
provided it is unambiguous to the grader. 
e.g. You may write {\tt p_m_t lock = P_M_I} instead of {\tt pthread_mutex_t lock = PTHREAD_MUTEX_INITALIZER}
\small
\begin{verbatim}
void *memcpy(void *dest, void *src, size_t n)
void *memset(void *b, int c, size_t len)
char *strcpy(char *dest, char *src)
char *strcat(char *dest,char*src)
char *strncpy(char *dest,char*src, size_t n)
char *strncat(char *dest,char*src, size_t n)
int strcmp(char *s1, char *s2)
int strncmp(char *s1, char *s2, size_t n)
void *calloc(size_t nmemb, size_t size)
void *malloc(size_t size)
void free(void *ptr)
void *realloc(void *ptr, size_t size)
pid_t fork()
char * getenv(char *name)
int execve(char *path, char *argv[], char *envp[])
int execl(char *path, char *arg0, ... ) /* arg0 will be process name. Last arg must be (char*)0 */
pid_t getpid()
pid_t getppid()
int kill(pid_t pid, int sig) /* SIGINT, SIGKILL,SIGALRM ... */
pid_t wait(int *stat_loc)
pid_t waitpid(pid_t pid, int *stat_loc, int options) WIFEXITED ,WIFSIGNALED,WEXITSTATUS. options=WNOHANG
WIFEXITED(status) returns True if the process terminated normally by a call to _exit(2) or exit(3).
WIFSIGNALED(status) returns True if the process terminated due to receipt of a signal.
WEXITSTATUS(status) If WIFEXITED(status) is true, evaluates to the low-order 8 bits of the process's exit value.
int pthread_join(pthread_t thread, void **value_ptr)
int pthread_create(pthread_t * thread,  pthread_attr_t * attr, void *(*start_routine)(void *), void * arg)
int pthread_kill(pthread_t thread, int sig)
void pthread_exit(void *value_ptr)
pthread_mutex_t /* PTHREAD_MUTEX_INITIALIZER */
int pthread_mutex_lock(pthread_mutex_t *mutex)
int pthread_mutex_trylock(pthread_mutex_t *mutex)
int pthread_mutex_unlock(pthread_mutex_t *mutex)
int pthread_mutex_destroy(pthread_mutex_t *mutex)
pthread_cond_t /* PTHREAD_COND_INITIALIZER */
int pthread_cond_init(pthread_cond_t * cond, pthread_condattr_t * attr)
int pthread_cond_wait(pthread_cond_t * cond, pthread_mutex_t * mutex)
int pthread_cond_signal(pthread_cond_t *cond)
int pthread_cond_broadcast(pthread_cond_t *cond)
int pthread_cond_destroy(pthread_cond_t *cond)
int sem_init(sem_t *sem, int pshared, unsigned int value)
int sem_wait(sem_t *sem)
int sem_trywait(sem_t *sem)
int sem_post(sem_t *sem)
int sem_destroy(sem_t *sem)
int stat(char *path, struct stat *buf)  /* S_ISREG(mode), S_ISDIR(mode), S_ISLNK(mode) */
int lstat(char *path, struct stat *buf)
struct stat {
   dev_t     st_dev;     /* ID of device containing file */
   ino_t     st_ino;     /* inode number */
   mode_t    st_mode;    /* protection */
   nlink_t   st_nlink;   /* number of hard links */
   uid_t     st_uid;     /* user ID of owner */
   gid_t     st_gid;     /* group ID of owner */
   off_t     st_size;    /* total size, in bytes */
   ... };  
int open(char *pathname, int flags) /*flags = O_RDONLY,O_WRONLY,O_RDWR,O_CREAT */
int open(char *pathname, int flags, mode_t mode) /*mode=octal or S_IWUSR,S_IXGRP,S_IROTH...*/
int pipe(int fds[2]) /* Write to fds[1], read from fds[0]*/
ssize_t read(int fildes, void *buf, size_t nbyte)
ssize_t write(int fildes,  void *buf, size_t nbyte)
int close(int fd)
int dup2(int oldfd, int newfd) /* An existing fd with value newfd will be closed first */
int accept(int socket, struct sockaddr * address, socklen_t * address_len) /* address,address_len can be null */
int listen(int socket, int backlog)
int socket(int domain, int type, int protocol)
int connect(int socket, const struct sockaddr *address, socklen_t address_len)
int bind(int socket,  struct sockaddr *address, socklen_t address_len)
ssize_t recv(int socket, void *buffer, size_t length, int flags)
ssize_t recvfrom(int socket, void *buffer, size_t length, int flags, struct sockaddr * address, socklen_t * address_len)
ssize_t send(int socket, const void *buffer, size_t length, int flags)
ssize_t sendto(int socket, const void *buffer, size_t length, int flags, struct sockaddr *dest_addr, socklen_t dest_len)
int getaddrinfo( char *hostname,  char *servname, struct addrinfo *hints, struct addrinfo **res)
void freeaddrinfo(struct addrinfo *ai)
struct addrinfo {/* When used as a hint, unused entries should be zero/null */
   int ai_flags;           /* eg. AI_PASSIVE, AI_NUMERICSERV,AI_NUMERICHOST  */
   int ai_family;          /* eg. AF_INET, AF_INET6,PF_UNSPEC... */
   int ai_socktype;        /* eg. SOCK_DGRAM, SOCK_STREAM, SOCK_RAW */
   int ai_protocol;        /* eg. IPPROTO_UDP or IPPROTO_TCP */
   socklen_t ai_addrlen;   /* length of socket-address */
   struct sockaddr *ai_addr; /* socket-address for socket */
   char *ai_canonname;     /* canonical name for service location */
   struct addrinfo *ai_next; /* pointer to next in list */
} 
typedef void (*sighandler_t)(int)
sighandler_t signal(int signum, sighandler_t handler)
int sigaction(int signum,    struct sigaction *act, struct sigaction *oldact)
struct sigaction {
  void     (*sa_handler)(int);
  void     (*sa_sigaction)(int, siginfo_t *, void *);
  sigset_t   sa_mask;
  int        sa_flags;}
int sigprocmask(int how, sigset_t *set, sigset_t *oldset) /*how=SIG_BLOCK,SIG_UNBLOCKSIG_SETMASK*/
int pthread_sigmask(int how, sigset_t *set, sigset_t *oldset)
int sigemptyset(sigset_t *set)
int sigfillset(sigset_t *set)
int sigaddset(sigset_t *set, int signo)
FILE *fopen(char *path,char *mode) /*mode=a,a+,w,w+,r,...*/
int feof(FILE *stream) /* e.g. stdin,stdout,stderr */
int ferror(FILE *stream) int fflush(FILE *stream) int fclose(FILE*stream)
size_t fread(void * ptr, size_t size, size_t nitems, FILE * stream)
int fseek(FILE *stream, long offset, int whence) /*whence=SEEK_SET, SEEK_CUR, or SEEK_END*/
int lseek(int fd, off_t offset, int whence) /*whence=SEEK_SET, SEEK_CUR, or SEEK_END*/
long ftell(FILE *stream)
int fgetpos(FILE *stream, fpos_t *pos) int fsetpos(FILE *stream, fpos_t *pos) void rewind(FILE *stream)
int fclose(FILE *fp)
ssize_t getline(char **  linep, size_t *  linecapp, FILE *  stream)
char *fgets(char *s, int size, FILE *stream)
DIR *opendir(char *name)
int closedir(DIR *dirp)
struct dirent *readdir(DIR *dirp);
int readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result)
struct dirent {
  ino_t          d_ino;       /* inode number */
  char           d_name[256]; /* filename */  /* Other entries not shown */
}
void * mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset)
prot= PROT_READ | PROT_WRITE |PROT_EXEC,  flags= MAP_ANON|MAP_PRIVATE|MAP_SHARED 
int munmap(void *addr, size_t len)
\end{verbatim}\clearpage
\begin{verbatim}
STRPBRK(3)                 Linux Programmer's Manual                STRPBRK(3)

NAME
       strpbrk - search a string for any of a set of bytes

SYNOPSIS
       #include <string.h>

       char *strpbrk(const char *s, const char *accept);

DESCRIPTION
       The  strpbrk() function locates the first occurrence in the string s of
       any of the bytes in the string accept.

RETURN VALUE
       The strpbrk() function returns a pointer to the byte in s that  matches
       one of the bytes in accept, or NULL if no such byte is found.


\end{verbatim}
% Unused (to save space so it fits nicely on 2 pages)
%FILE *fdopen(int fd,char *mode)




\end{document} 
