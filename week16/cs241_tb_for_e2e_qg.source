this section is a short review of system architecture topics that you’ll need for system programming.
hyperthreading is a new technology and is in no way shape or form multithreading.
valgrind is a suite of tools designed to provide debugging and profiling tools to make your programs more correct and detect some runtime issues [4].
valgrind is a effective tool to check for errors at runtime.
threadsanitizer is a tool from google, built into clang and gcc, to help you detect race conditions in your code [5].
gdb is a program that helps you track down errors by interactively debugging them [6].
setting breakpoints programmatically a breakpoint is a line of code where you want the execution to stop and give control back to the debugger.
a shell is a programming language that is running inside your terminal.
the undefined behavior sanitizer is a wonderful tool provided by the llvm project.
preprocessing is a copy and paste operation that the compiler performs before actually compiling the program.
if the left operand is a pointer and the right operand is an integer type, then only plus or minus may be used and the rules for pointer arithmetic are invoked.
a system call is an operation that the kernel carries out.
the first parameter is a format string that includes placeholders for the data to be printed.
the buffering semantics of printf is a little complicated.
a c-string is a series of bytes delimited by a nul character which is equal to the byte 0x00.
in low-level terms, a struct is a piece of contiguous memory, nothing more.
a void pointer is a pointer without a type.
the following is a rapid fire section.
an operating system is a program that provides an interface between hardware and user software as well as providing a set of tools that the software can use.
a process is an instance of a computer program that may be running.
the heap is a contiguous, expanding region of memory.
process forking is a powerful and dangerous tool.
the following is a snippet of how to use system.
this also means that system is a blocking call.
however, this detail is an unwanted complexity.
the survey makes sure to note that memory allocation is a moving target.
our heap memory is a list of blocks where each block is either allocated or unallocated.
allocating memory is a worst-case linear time operation – search linked lists for a sufficiently large free block.
the slub allocator is a slab allocator that serves different needs for the linux kernel slub.
the slub allocator is a segregated list allocator with minimal splitting and coalescing.
almost weirdly, a thread is a process, meaning that creating a thread is similar to fork, except there is no copying meaning no copy on write.
calling pthread_exit in the main thread is a common way for simple programs to ensure that all threads finish.
but when compiled with -o2, assembly output is a single instruction.
a critical section is a section of code that can only be executed by one thread at a time if the program is to function correctly.
if the memory location is only accessible by one thread, for example the automatic variable i below, then there is no possibility of a race condition and no critical section associated with i. however, the sum variable is a global variable and accessed by two threads.
a mutex is a simple data structure.
atomic compare and exchange is an instruction supported by most modern architectures (on x86 it’s lock cmpxchg).
a mutex is a semaphore that always waits before it posts.
while push (and pop) is executing, the data structure is an inconsistent state, for example the count may not have been written to, so it may still contain the original value.
the other is the loop is a busy loop.
a ring buffer is a simple, usually fixed-sized, storage mechanism where contiguous memory is treated as if it is circular, and two index counters keep track of the current beginning and end of the queue.
the following code is an incorrect implementation.
the following code is an incorrect implementation.
the dining philosophers problem is a classic synchronization problem.
a page is a block of virtual memory.
a page table is a map from a number to a particular frame.
each table is a list of pointers that point to the next level of tables, som sub-tables may be omitted.
mmap is an interesting call because instead of tying each virtual address to a physical frame, it ties it to something else.
mmap is a trick of virtual memory of instead of mapping a page to a frame, that frame can be backed by a file on disk, or the frame can be shared among processes.
one of the big optimizations is a file may be lazily allocated to memory.
sharing anonymous memory is an efficient form of inter-process communication because there is no copying, system call, or disk-access overhead - the two processes share the same physical frame of main memory.
for files less than the size of a long, using fseek and ftell is a simple way to accomplish this.
hadoop is a great example where processes will write to append-only tables and then other processes will read from those tables.
one advantage of fcfs is that scheduling algorithm is simple the ready queue is a fifo (first in first out) queue.
a kilobyte is one thousand bytes, a megabyte is a thousand kilobytes and so on.
as for another definition, a protocol is a set of specifications put forward by the internet engineering task force that govern how implementers of a protocol have their program or circuit behave under specific circumstances.
tcp or transport control protocol is a connection-based protocol that is built on top of ipv4 and ipv6 and therefore can be described as “tcp/ip” or “tcp over ip”.
sockets are created with a domain af_inet for ipv4 or af_inet6 for ipv6, socket_type is whether to use udp, tcp, or other some other socket type, the protocol is an optional choice of protocol configuration for our examples this we can leave this as 0 for default.
void send_request(host_info *info) { int sock_fd = socket(af_inet, sock_stream, 0); // re-use address is a little overkill here because we are making a // listen only server and we don’t expect spoofed requests.
google protocol buffers is an open-source efficient binary protocol that places a strong emphasis on high throughput with low cpu overhead and minimal memory copying.
the last piece of background is an important one.
a filesystem is an implementation of the file interface.
a single indirect block is a block that stores pointers to more data blocks.
forgetting to release resources is a common c programming bug because there is no support in the c language to ensure resources are always released with all code paths.
the integrity of the file system assumes the directory structure is an acyclic tree that is reachable from the root directory.
the iso9660 filesystem is a read-only filesystem originally designed for optical storage media (i.e. cdroms).
a signal disposition is a per-process attribute that determines how a signal is handled after it is delivered.
for example, the following is a program that slowly prints a dot every second, up to 59 dots.
the mask is a temporary signal mask used during the signal handler execution.
spectre is a bug where instructions that otherwise wouldn’t be executed are speculatively executed due to out-of-order instruction execution.
the following snippet is a high-level proof of concept.
openbsd is an arguably better system for security.
a container is a lightweight environment that shares resources and a kernel with a host machine, while isolating itself from other containers or processes on the host.
a terminal is an application that displays the output from the shell.
the other type is a dynamic library.
the sentence that sets the expectation is the following the result of function calls involving any one handle (the "active handle") is defined elsewhere in this volume of posix.1-2008, but if two or more handles are used, and any one of them is a stream, the application shall ensure that their actions are coordinated as described below.
openmp is a standard that is an alternative to pthreads.
storemi is a hardware microcontroller that analyzes how the operating system accesses files and moves files/blocks around to speed up the load time.
although it may seem that the header is a constant size, you can include optional parameters to augment the path that is taken or other instructions.
kqueue is a system call that is exclusive the bsds and macos.
each arena is a large region of memory that is internally allocated by the system (using brk(2) or mmap(2)), and managed with its own mutexes.
someone who knows sleepsort is a bad idea but still dreams of an excuse to use it.
privacy concerns aside, and believe me there are a lot of them, the big problem was that this rootkit is a backdoor for everyone’s systems if programmed incorrectly.
a rootkit is a piece of code usually installed kernel-side that keeps track of almost anything that a user does.
