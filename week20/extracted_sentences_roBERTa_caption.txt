sentence
"this is our little hate please need to interrupt the program and by default of course that stops the process however we can make programs where it doesn't start the process and we can actually make it do other things as well then we've seen cr segfault where by default again it stopped process and that signal is generated by the kernel when we tried to read or write invalid memory and the last one ok so kill so the surprising thing about said kill is that are part of the process cannot avoid it they cannot run away from this event it cannot change this behavior no sick kill is when we want to stop all processes and they don't have a choice about this so you is nothing you can do about sigkill you will not get any prior notification is like an asteroid arriving at the speed of light that there's no prior warning no particulates going to simply stop your process ""and you won't be able to prevent that so that's sigkill it's when you want to terminate the process and you want no other options so if you've got a runaway chrome browser refuses to stop sigkill is going to be the answer ok so i think it's time we did a demo of this ok so for this demo i'm going to need some kind of little program to send signals to so here it is it's a little dot right but it writes a single period once the second here so you can see that i'm calling right and what am i going to write i'm sending out to standard out"
so that's that's a little challenge here how can we how can we write this very very simple program ok so here's if i wanted to write this in like a minute he's work is kind of warm way that i could do this do i have little arrow i do using this function called a two i which takes an ascii value and returns an integer it's not that great in sense if you give it garbage it's going to return the value zero so there's no easy way to detect the difference between zero and knowledge to value but for simple purposes here this is more than sufficient ok so we will take the signal we want the process id and the last thing
the solution we actually describing all the way is called like the base and bound where there's a mapping simple mapping from your virtual memory addresses we add some kind of offset offset that will be the base to get to the actual physical address or inside my ram and then we also put some kind of bound to make sure that addresses inside your process contract pieces of memory that don't don't don't that not your concern not sort of your process alright so this is not a great it's only advantages that was simple describe and also simple to implement in silicon and gives us a little bit of protection between each processor your process can't overwrite my memory well maybe we can do better than that ok so one thing to notice is that actually in my address space over here i've got tons of addresses loads of address numbers which i just don't care about they are not being used right now they're not part of the stack not part of the heap are never need to refer to them and in fact we could even go further and say look this part of my program code like the initialization code that i
and what about the lowest twelve bits that we just been ignoring to this point this is called the page offset
ok let's have a look at the different example so what do you think about the following i've got little variable called result what is it it points to characters so it's a pointer it holds memory dresses and then we say stroke copy another words copy the following and we're going to pass in
or maybe it's some data structure but whatever it is we have this idea that only one process or thread at a time can access it now i'm going to use the word process that's kind of historical reference in the sense that we thought about these things even with four threads exist but you could imagine how we could set up identical situations to multiple threads running inside just one process so it's the concept is the theory which is the most important idea here ok so what do i got in question one i've got my first process p one requests and obtains resource a and then resource be ok so let's set up process one here ok process one
right before that signal aggregates delivered to a process we can say that the signal is pending in other words it's hanging over process wanting to send it to to process so why is it not yet been delivered the answer is because actually processes come lock signals
has to kind of implement code like this or similar code like this it actually will have a special cpu primitives are instructions to say things like ok at this point there should be a memory fence to ensure that anything i've changed in memory or anything i want to read from memory is available to other cpu cores on my machine right so that's enough about peterson solution marvel its simplicity model of the fact that it took about a decade for for this to be discovered after we had deca solution and if you like this kind of stuff then this solution
esperat returns negative one when cast it as a void pointer if it fails if it refused to give us any more memory case so in that case we should return null because that's part of the malloc specification wait just a reminder what does void pointer mean it means i'm a pointer but i'm not going to declare or i don't care i want to keep secret exactly what i'm going to store at that location and void pointers can be cast to other kinds of pointers implicitly so you don't need to explicitly say cast that to another type ok so yeah we don't care about what this pointer is just simply or what was going to be stored there just simply that if i want to compare it to get negative one i should cast out first void pointer ok right so now i'm before i'm returning i'm doing some logging here printf say hey great now you have some memory at that location so let's print out this variable as a pointer i'm not using percent s i'm not attempting to read any memory at that location i'm simply saying take this value and display it as a hexadecimal value
and as you know they are necessary and sufficient we need all fall to be true and exactly or for them to be true and then we know that we've met the conditions for deadlock so what are they let's actually look at some definitions here so here's the first wanna process is currently holding at least one resource and requesting additional resources which are being held by other processes ok so it is holding and waiting so that's a hold and wait condition
ok where we used a shared memory using the virtual memory mechanisms some more that we're going to look at in the future again it be pipes where we can treat pipes a bit like files or at least streams where i can stream in some bites and then another process constrain them out in the same order and then we're going to talk about networking as well so the idea that i can create tcp and udp sockets so that i can pass messages between my processes right the other thing i want to finish with is amdahl's law so great we've learned a lot about threads and processes and concurrency let's actually kind of take a different tack and say just how much speed up could we actually get so on those law yes there was a formula but you never need to memorize that that formula instead it's very easy to workout from first principles what kind of speed up you can actually get so let's take a look at this as a kind of worked example
and secondly don't bother to expect a big massive speed up your running on two cpus are going to need at least three or four cpus before you start to see a significant improvement and even then you won't get the full fold difference so if i run for cpus i still don't expect to see a four fold improvement in runtime right so you can read more about lawndale slow but it's not necessary to memorize a formula you could always calculate it yourself just simply by sketching out a timeline of thinking about ok this is the code that i'm i'm running in the code that i'm going to improve an last comment is what's the difference between concurrency whoops and parallelization so concurrency is the idea of doing two things potentially do different things at the same time so for example you might make a phone call while baking cookies so you're able to do these two tasks at the same time but you're not going to leave the kitchen until both are done and then this parallelization
at the same time by input both in into the oven at the same time so parallelization is about taking the same task and running it twice or thousands of times in parallel just for example like a gpu can run the same piece of code not just kind of once but say three hundred times in parallel which is great if you want to run say the same shading algorithm on three hundred different pixels as part of your screen at the same time so that we have a fundamental idea about how gpu 's work and the idea is that we've seen in this course in terms of concurrency in parallel vitalization and synchronization primitives
tcp will automatically assemble any packets will wait for lost packets to be re sent so we just have a nice stream a data stream ok so how do we set one up right so if we're setting up a client all i need to do is first of all i'm going to be lazy and call get address info this does a lot of heavy lifting for me to actually figure out the correct parameters i'm going to send into my next two calls so technically this is not formally required but it does make my life a lot easier the two things which are definitely required is of course i need a socket then a socket is there abstract object owned by the kernel which allows my code to talk to the outside world and to be able to talk to other sockets maybe on this machine but maybe not ok so once i've made a socket and for a client all i need to do is ask it to connect so let's
ok and finally the head stuck in the ground yes it's called the ostrich algorithm which is that uh if it's look scary quick stick your head in the sand and don't look so the looks of windows strategy for deadlock avoidance is called let's just hope for the best which the ostrich algorithm is basically it's let's pretend it's not our problem their system is going to let you write code that can cause deadlock it's up to you the system programmer to make sure that deadlock cannot
so we can drown out this poor server we can run it out with these fake connection attempts making it harder for real connections to actually get a chance to talk to the talk to the server so this is called sin flooding and it was a very kind of early examples of a tcp level type attack on a server today there are mechanisms for a server can implement to prevent this and one of them is in the bag not is not to actually commit any significant resources when the syn packet first arrives so you say how can we actually remember the synchronization number well the trick that a server can play is to actually embed the synchronize your synchronization number client synchronization number inside its own acknowledgement synchronization number
so let's do some error checking remember that if getaddrinfo fails it will use its own little helper function to print an error but i'm also going to check the return values of all of my other network code as well and if something goes wrong with one if these calls returns negative one i'm going to just quit so my quit function is very simple it just prints out the errno message together with my little message of what happened and they just exits so that's that's quick very simple program there simple simple function right so what do we do ok right so let's call socket
ok it's sir let's talk a little bit about http so http is the mechanism today that how you actually get a web page and http actually grew out of an existing protocol and this very first version of h d two p the first of official version one point oh and also one point one is a text protocol so why do you think that is why choose a text protocol because this of
and this will tell me when it returns what signal has just been delivered and so signal weight is a way to standard the drawbridge munching signals one at a time as they come over but we want to make sure that the signals that we care about only delivered to this particular thread so we better pull up any of the other drawbridges ok so that's what we're going to do here inside my main thread i don't want my main thread to ever have to worry about getting a signal hey i don't want any signals being delivered to it so the first thing i'm going to do inside my main method here my main function so is to set a cig mask to say hey block all these signals in fact block sigterm blocks eginton if i wish i could walk a whole other brothers right so this this mask here is then used to say right ok on the main thread it pulled up this drawbridge so we cannot deliver these signals to the main thread
hi, so a big idea is that most file system devices are what note is known as block based devices meaning that at the hardware level we don't ask for a single bite from a disk instead we have a convention and we say you know i'd like give me the first block of bytes please will give me the second block of bytes or i'd like to update this block of bytes with some new values so for performance reasons we don't make requests down to just very small units we much prefer to say to a disk system an external system gave me a whole bunch of bikes and useful ideas to make the same disk blocks the same size as our memory blocks in fact what we're going to see is all over our system examples where the blocks are based around four kilobyte chunks
could have many human meaningful ways to be able to get a list things inside a directory ok so we're getting down to this next part here that right so what is an ai node this is the definition of how we store a file on disk and it has certain meta information it tells us about the size that file it tells us about who owns it and things like when it was last modified
with an i node and the i node itself directly holds the meta information but also then points to provides a way for us to actually get the contents of the file but without the inode you have no file so so i want you to forget now about filenames that's just an icing on the cake for us to use it's actually the i node number which tells us whether we're looking at a particular file or a different file alright i'll see you in the next video bye
ok so between you and me as big is not actually used anymore instead we're going to use some virtual memory tricks of all the slide this did modern c library uses some virtual memory tricks that we haven't learned yet so s breakers are simply mechanism but we will use it for cs two forty one to implement a simple memory allocator ok so remember how i said that the bottom of the memory i've got the text segment which is the program code and string literals and any other constants we've put in here and
a file or file system dedicated to supporting my virtual memory so now what's happened now every nanosecond every little memory right is going to result in a disk access as we page in an page out ok so unfortunately our paging mechanisms are about a million times slower than direct access to main memory so congratulations we've now just made a machine which is suddenly a million times slower than normal and this this effect is called thrashing that we're constantly swapping in and out pages in order to make the smallest amount of progress and so it appears from the users perspective that the whole machine is slowed to a crawl unfortunately what do we tend to do when our machines do this invariably what we do is to say i'm too impatient to wait for this website to load or for this compiler to finish i know what i'll do i will give my machine something else to do instead like i'll open up a different web browser or i'll try to compile something else and so i just made the problem even worse that now i've actually increase the load on my poor system and so there's even fewer pages left or are you available to actually going to make any progress so thrashing is a problem we want to avoid it happens in systems which are overloaded and it's
it looks like no ones needed for the longest possible time or less choose a page of ram that actually we know we already have a copy of that on the disk for example perhaps it corresponds to some of the code of a program and we already have that program stored on the disk somewhere right so that's kind of demand paging and in the next video let's address the following little brain teaser let's suppose you actually did a benchmark on catalog versus malloc ann you were surprised to discover that these two calls take the same amount of time how could that possibly be because kellogg is defined to return memory that has been
hi welcome to lecture twenty four we're going to start with a quick code review let's see look at this attempted waiting a fixed sized ring buffer and we'll see if we can figure out how it might go wrong ok so some of the things that we want to ask are is deadlock possible in other words could get stuck so that's never able to continue is underflow possible in other words could it be that we attempt to write so attempt to read some data that's not actually inside the ring buffer so will just be reading back some garbage information or perhaps overflow as possible which means that we're able to put more data into my buffer then it can actually hold so presumably we were going to corrupt something possibly value that we have not yet written out so what do we got here we have
then we've got fun stuff will see at the end of this course, which is sockets. and sockets is the way that we can set up our service. so this is how we can create say, a new database or new web or this is kind of a fundamental part of our internet is how we can get two machines to kind of talk to each other. so behind that all is just a simple idea of my process has these little file descriptors that is when i want to talk about a particular kernel object that want to read or write to. so anytime you see read or write you know that you're working with a little file descriptor. but above that, we can now talk about what does the c library give us? and the c library is going to make our world a little bit easier when we want to work with formatted information
and then i've got other things in here which is the sum of the standard libraries that we've dynamically loaded when this program started today the addresses which we map the virtual addresses that we use randomized somewhat to make it harder for attackers to guess where pieces of code are actually going to be found inside the virtual address of the system so that's called address randomization and it's kind of another piece of the security arsenal of the kernel for how we try to prevent attackers from taking over our machines right with that i'll stop and see you in a future lecture ok bye
hi so let's talk about processes processes are a fundamental unit of computation when it comes to the kernel and how it thinks about things it needs to do for users logged into the system so a process is a kind of based container for users when they want to do anything
and then later check to see if that value is still there and if it's not that's my canary to say oh someone overwrote some memory that they shouldn't have written and i probably exit at this point or perhaps i would print out some useful message or perhaps drop into the debugger ok so that's the idea of canaries you could you too can implement inside your my lock code write an one quick idea is yes you probably heard a buffer overflow we've also got buffer underflow which is where we go before the start of of the buffer so again we could put a canary there and check that that was not overwritten
hi welcome to lecture 38, so let's get started right today we're going to do some review ideas and also go into some operating system ideas as well. so let's start with going all the way back to threads and ask why is the following code threadsafe ok so let's have a look at it what's it doing. right so i've got a function. it takes a pointer to some memory, sleeps for second and then it assumes that there's a string of that memory. so will cast that
open but you'd like to know that the other side is actually still listening to you so why don't you send a little heartbeat request to say hey server how you're doing and you would expect the server to say hey i'm great and in fact all it does is just echo back what you said so that's the purpose it rip it litter is very very simple you'll notice here that we've got these calls called secure read that simply because we want to wrap up our normal read and write so that the bites actually sent are encrypted using some cryptographic
"ok so let's talk a little bit about http so http is the mechanism today that how you actually get a web page and http actually grew out of an existing protocol and this very first version of http the first official version one point oh and also one 1.1 is a text protocol so why do you think that ""is why choose a text protocol because there are"
and my i node is the file i can't create a file in this i've actually gotten inode entry and i'm going to have will say ten entries inside my inode directly to the first ten disk blocks used by my file so in otherwise i could hold forty kb there and then i also have inside the i node that this block which holds a table with a thousand twenty four entries and then another entry side the i node for my double interact an another entry for the really large files which is actually going to be a triple indirect in those for the triple indirect i need to follow the money three times i have to load three blocks before actually can find out where the data is stored but even for very large files the beginning of the file is always stored in these direct blocks so that we have nice fast access to those
now here's a useful little command get cwd noticed that's right it tells us the process is current working directory which is going to be useful if we want to work with relative directories and in fact paths in your system of defined to have a maximum length so you can be confident that the string that you can request can never be larger than this constant here path max and we add one just to ensure that there's enough space for the c string zero bite at the end ok so if you want to know how where you currently on file system here is one way to do it right
so first of all the actual spinning surface the physical part is called a platter and we may use both sides of it or just a single side of it so i think if it's just like a like a pizza platter except it's circular and it spins around ok now on that platter you could trace out an imaginary circle so i don't want to know i want
ok so latency you've heard this term before we fewer gamer this is the kind of delay this off introduced by a system over network or some kind of information flow and that we can measure the latency of an entire system the entire delay of a system and so typically that will be the latency due to over the response time so a delayed response time we can say oh it's because of the latency of the system
and a mutex is actually go back there right actually a shortening of do i have i want to be able to type we try some letters here ok there we go right ashley short for
right and let's talk about static variables and where do they live so do static variables live on the heap course the answer is no well do they live on the stack no ok so static variables are special you can think of them as basically global variables they live for the lifetime of the program so they where you declare them changes the scope meaning whether you can actually use their name or not so let's have a quick play with this let's let's go and modify our matrix code here suppose k i want to go back to ok there we go so suppose we made a variable static here so let's make the
the character see a static variable so between you and me i can tell you that static means that this only going to exist once that were going when our program is loaded and becomes a process some memory will be set aside for that variable now i've declared it inside the function but actually that would be just as equivalent to declaring it outside the function with one exception so if i
the beginning of the first video stream go to this file offset or if you want to find the first frame go to this other offset so there's lots of examples where i need a random access to a file so if my files on a disk or network disk then great i can start jumping around my file so that's what i'm going to be able to do with this fseek and ftell so ftell tells me my current position so that's useful if you want to kind of come back to where you were an f seek allows me to seek to a new position
like stamps instead it out instead of there it's not going to work those are not seekable but it will work with this regular files so we pass an offset and that offset is going to be offset to something that we specify in here and we've got three options either be an absolute offset in meaning that it's with respect to the beginning of the file or it can be offset to our current position or it can be an offset relative to the end of the file and notice this offset can be positive or negative so we can let's pick a nice bright color
,uh... perhaps you're going to write it in c, perhaps you're going to write it in some other language. it doesn't matter. it doesn't matter. the idea is all the same. ok so here's the goal. we're going to try to modify this code to be what's called 'thread safe' in other words i can actually use it with multiple threads so along the way we're going to fix some errors as well. ok so what do we got. we've got a pointer that corresponds to the start of my linked list. uhm, in more complicated examples this might be in a separate data structure but this is good enough for a little example here. ok, and then i've got two methods to
"another link that's being created at the same time so for example, i want to i don't want to first set head to be equal to a new one and then another thread immediately say, """"""aww, don't look at that one"" ""look at me instead."""" and we skip over one of those created"" links. ok so that's the piece of code that is a critical section in this first part of the code, that absolutely we can't have two threads running these two lines at the same time. we would like those two lines to be 'atomic' meaning that they should behave as if they happen in just one go and they can't be interrupted and no other thread can actually run those two lines at the same time. ok so how do we do that ok easy let's use mutex locks. so just before doing that we call pthread"
look up within the same page great we already have that information so that special locality the idea that neighboring address is going to be used in the near future and then there's temporal locality as well which is just that if you access one location you're likely to access the same location again in the future
wait did you notice something here that alarm clock still went off so even though we managed to ssh into the nsa server we didn't have a chance to download any files because in four seconds time that colonel sent the alarm clock to the very same process remember we had when you call exec you do not actually create a new process you give your existing processor head transplant and ask it to load in all of the new code and start with a new he put a fresh stack and all that good stuff
hi welcome to like twenty four we're going to start with a quick code review let's see look at this attempted waiting a fixed sized ring buffer and we'll see if we can figure out how it might go wrong ok so some of the things that we want to ask are is deadlock possible in other words could get stuck so that's never able to continue is underflow possible in other words could it be that we attempt to write so attempt to read some data that's not actually inside the ring buffer so will just be reading back some garbage information or perhaps overflow as possible which means that we're able to put more data into my buffer then it can actually hold so presumably we were going to corrupt something possibly value that we have not yet written out so what do we got here we have
but anyways so we have a little processor inside there and this job is to use this flash memory not only efficiently but given that it wears out we want to make sure that we push our rights in their different the physical areas of the flash memory overtime so this is called wear leveling so that whole device degrades overtime as opposed to say one particular area suddenly stops working ok inside our device we also need some ram because we're going to receive piece of information to write and yet our flash may not be ready to store that so we need a temporary some temporary buffer space similar we may choose if we can detect the pattern of read requests we may choose to read ahead so that we have the next block of data ready to go when the host asked for it so again we need some some storage space and buffer space and finally we may decide to reorganize how we're storing data on our flash so again i need some some more ram for my processor ok the other thing we have here is the host interface logic so too common interfaces today are saturn
overtime we might discover parts of our storage are no longer function correctly for example we are no longer able to write to a particular block so rather than simply declared the whole device as dead we can use what's called bad block mapping or sometimes bad block remapping where we delivery section off parts of the physical storage and so that they don't appear inside are kind of abstracted version of what the story actually looks like circle secondly we may use error correcting code
device as possible and typically the device read write patterns fall into either a synchronous read so imagine you're pulling all the bytes for a video file i just want to get in say four gigabytes of data as quickly as possible or for example you're starting up the operating system or you are loading an application you just want to move in as many bytes as possible one after another or random so you have random read write access patterns where now you want to jump to jump around a file or jump between many different files and now the amount of data you want per request is relatively small but now you have thousands of requests per second
so not only do we want to measure the actual number of bits that we can shovel through for more storage we also want to measure iops which is input or output operation per second
ok notice that we have kind of what's called write amplification happening here which is the the user program just set one bit but we had to actually write more than four thousand ninety six bytes or however big the blocksize happened to be on the device which is much larger than one bit but anyway so if i have the single bit purcell then empirically i can do about a hundred thousand lights for sale before that sell doesn't accept anymore writes ok today however in the quest to make of memory cheaper more bytes per per dollar we actually don't write a single bit per cell on a typical especially commodity devices you'll see that instead there's what's called multi level cells where now we can store two bits or even triple level cells and as of two thousand and nineteen there's now quad level cells as well ok where we store four bits
it allowed to actually enter the building until we've finished changing it ok so well swim changing the maze around or maze runners have to wait ok so there's stuck outside i'm going to let them out once this particular writer finishes so if you want to do ok there we go right only when this righteous come out when we let anybody else into the data structure ok and simply if another right appears on the scene they would have to wait until no one else is updating it so once that is once it is available they get to go in ok so that's the sketch of the logic that we need notice that there's several kind of moments that we might need to block things so here's our first block we need to block readers if there's any writers around right we want to stop the hoard if we don't stop the horde then we run into a problem called vita starvation where because there's always a new reader going to be arriving there's never a good time to actually update the data structure there's always at least one read it in there
and the way we're going to do this is to keep track of several things here we're going to have the number of actual readers that would like to read so here they are is all my reader threads that are either waiting to read or currently reading and then a subset of those are actually in the data structure right now and so we will call this the number of active readers
you hate bittorrent so what is bittorrent you might ask it's a communication protocol that allows you to share bites between two clients and it was often used to share pirated movies but it also has some bona fide reasons as well for example you can often share open source software such as an entire linux distribution using bit torrent as well so let's go back to our problem in hand how can you as internet provider actually prevent this this traffic from occuring right so let me give you some ideas and one thing i want you to notice as i do this is to realize that they work at different levels so first of all you want to be able to say identify
ok so this this deep packet inspection idea where we actually look at the actual data being sent from one machine to another and say oh yeah that definitely looks like the bit torrent protocol or all that daffney looks like say http protocol for that definitely looks like vpn packet vpn time information is means that we're actually looking at the raw data the unencrypted
reducer is the reference count of my entry by one and if that gets down to zero then we know that i node is not useful anymore and so the disk blocks that i required
hi welcome to lecture twenty four we're going to start with a quick code review let's see look at this attempted waiting a fixed sized ring buffer and we'll see if we can figure out how it might go wrong ok so some of the things that we want to ask are is deadlock possible in other words could it get stuck so that's never able to continue is underflow possible in other words could it be that we attempt to write so attempt to read some data that's not actually inside the ring buffer so will just be reading back some garbage information or perhaps overflow as possible which means that we're able to put more data into my buffer then it can actually hold so presumably we were going to corrupt something possibly a value that we have not yet written out so what do we got here we have
what i'll do today then is a little bit different from what we saw with the clients here's the first big change that i want to make what's called a passive socket so passive socket is as it sounds it just sits there it waits for clients to come to it ok so it doesn't go out and reach out and try to talk to her remote server no it's completely safin passive it just sits on a particular port waiting for those packets to arrive so this is the first big change as to how we specify that we like
ok so so far none of these calls will block but we have now set up a valid server if i've got this far then calling netcat on this connection or calling telnet or calling using firefox or chrome etc will make a valid connection and then i'll start to want to it's not to send back to us so we better actually start processing our clients ok so how do we do that and the answer is with accept ok so accept means please block untill there's a customer for me to serve ok and of course we pass in our source server socket now the big important idea here is that now is that that server socket is the front door to your shop but it's not actually going to be the way that you talk to your clients instead when accept returns you get a new file descriptor one for each customer which is the private communication channel between you and that client so with this new file descriptor that's how we're going to be calling read and write
examples and problems from the second lecture here the cc crash ok so let's have a look at our first little first little problem here we've got here is ok so we want to know about the pre the pre processor let me pull it in here ok so what kind of three examples of common examples first of all what is the c preprocessor is that it is a text replacement tool that runs before we actually compile this c code and we can think of is very simple and fairly dump tool that only stands a few understand a few limited commands so one thing i can do is that it can we can include additional files so for example if i say ok my utility functions then that moment inside our compilation file we're going to replace that line with the contents of another file in this case my little file called my utils dot h and that better be somewhere inside our project perhaps i want to include some system files for example standard i o dot h because i want to use things like printf and
ok so maybe you know about threats so great you are able to chunk up the work into different jobs so that each thread is responsible for the output of the total result and so you need each thread to work independently great you say i remember those two forty one p right to the rescue that now i can tell my first thread to explicitly write its results into the first part of the file meanwhile the second thread over here is starting to generate results as well and so it can start writing bits of data over here and we can explicitly say where in the file we want that to go so yep there's pwrite and there's also pread which does a similar thing that you can read from a certain part of the file and directly specify an offset into the file so they are very useful when you want to to do random access and random reads into file but also later inside cs two forty one we're going to learn how to memory mapped files directly into memory where we no longer even need to call read and write but we can actually look at the file as if it is actually part of our address space so that's coming up later inside cs two forty one and it's the most one of the most far and most powerful features of posix and system programming that you'll see in this course so the will do what's a named pipe ok how do i make a named pipe for this you can actually make pipes on your file system you can just say make vivo because they behave as a little first in first out queue so let's call it say my queue kate and
is any surprise then the rpc can be at least a thousand times slower than local courts and in fact it can often be ten thousand or even up to one hundred thousand times times slower so there can be a great cost to using rpc however why do we then still use it answer because sometimes it's really useful to be able to run code remotely for example perhaps you have a what's called a thin client meaning that your compute power close to the user can be very small because most of the actual work happens on the remote end so for example you might want to automatically modify video files audio files on a remote heavy due to server that has thousands of cores and lots gpu resources and now you can do all of that heavy computational work directly from your much lighter weight local front end
right the second thing that we'd like to change is this if inside here so in practice this can bite you in two different ways first of all maybe in other applications you have multiple threads calling this and we really just want to ensure their x really is positive before we continue and other things may change value x the second problem with this code is the actual deep condition wait is occasionally may suffer from what's called a spurious wake up it never truly went to sleep ok right so why does that occur well let's let's go back and talk about the implications for how conditioned weight is actually implemented right so we've just seen this problem of change in value of x and then signaling too early before they thread is actually blocking and waiting for that signal to arrive so in practice what does this mean it means that unlocking the mutex
ok so between you and me as big is not actually used anymore instead we're going to use some virtual memory tricks of all the slide this did modern c library uses some virtual memory tricks that we haven't learned yet so s breakers are simply mechanism but we will use it for cs two forty one to implement a simple memory allocator ok so remember how i said that the bottom of the memory i've got the text segment which is the program code and string literals and any other constants we've put in here and
x cpu instruction called exchange and here's what it's defined to do it's going to swap two values at two addresses as an atomic operation music sell uranium powered or thorium powered know what do we mean by atomic is it's an indivisible uninterruptible operation
call this exchange assembly instruction there all these people pretend that this is ok and we will say here's the address of q here's the
ok right sir i remember the next question is going to talk about and it's the following it's actually a typical kind of interview question where we look at something a power is simple and then say ok what actually happens what all the steps so let's take a look at the kind of typical question suppose you opened up a terminal and you ran the following so call http illinois dot edu and press return what happens next right so this is an opportunity to show off all of your operating system knowledge and system programming knowledge ok so first of all what is curl right so we better talk about that for a moment ok so curl actually is a bit like cat but rather than saying ok tammy cat about a file curl will connect to a website it understand several protocols including http and https and it will make a connection to a web server so great and then we can see we've connected to this and we've got back the kind of basic html document ok the actual body of the response we can probably ask it for more information maybe if we do kind of both it will tell us about how it's trying to connect what is trying to connect to and you'll see that uh this is what it's sent ok it's sent the following we actually can tell curl to send additional information as well if we wish and then here's the actual response headers we get back which is a standard http key by the way your web browser will can also kind of tell you some basic cool stuff as well
ok great so let's start talking about mandelbrot sets so here's a great wonderful idea i wanted to choose something which was it was called embarrassingly parallel meaning that we can just set all cpus off calculating something and then we don't need to think about any communication between those cpus we don't need to think about them trying to update the same piece of memory at the same time so this is a very easy problem for us to parallelize into play with do understand how to use p threads before we move on to more complicated examples ok so we're going to put together a lot of ideas first of all let's talk about a little bit of math so here's the plan i want you to think of a number right now i'd like you to square that number
so when that happens mmu the part that is reading this page table causes a page fault and a page fault is a hardware interrupt to tell the cpu that i'm sorry i cannot satisfy this
great so now we fixed it up we can release process and let it continue and it would be a non the wiser we might notice that our program took a little bit longer to run at that moment but as far as it's concerned those bytes will always available there was never a moment when those bites were not acting in memory so that's kind of pretty cool trick so we've seen two kinds of page faults of page for when we access invalid memory and the page fault where we had lied to the process and we had to go and grab those bites from the disk so this process is called demand paging we pull things in on demand and in fact there's two parts to this there's a page in process this is the part we just described where we go back to disk to actually read those bytes in but let's think about this for a moment what this bikes were pulled probably being used for something
let's see all chill at the moment ok so we're going to get out of there were going to take this check this after you run through this code once i know notice it is frayed i apologize the logic as given incorrect let's have a look see what it does first of all philosopher waist to pick up the fork on the left ok so that's only going to proceed once you get exclusive access to that particular fork alright and then it's going to change this local variable failed to based on on what happens when it tries to pick up the the fork on the right so notice that initial value of tries left is too so actually it's going to call this function called trilok which we haven't seen before trilok never blocks instead rather than blocking if it's unable to acquire this mutex
"you can test for that condition and then act accordingly ""one thing you wouldn't do after that point of course is call more reads because there isn't anything else coming down now here's the second type type of thing about read which is perhaps surprising is that it can block so it's default behavior is to wait until there's some bites ready to give you in other words this call to read might wait forever was this waiting for it's not gonna use any other any cpu time we can give the cpu to other processes and other kernel tasks that need to run so realize that this read is what's called a blocking call that it doesn't return immediately when it returns you know that something is happening is time to process it"
"ok we going live ok great wait let's talk about the program arguments so let's suppose you wanted to write a compiler right do you say well you know what i need to pass in some arguments like one dot c and minus d for something ok how are we going to get these things which people add after the program name and where do they go right so to that we need to understand argv and argc so every time we start our program this ""two important variables here called argc and argv. argc is the count of number of labels and argv actually tells us their values so look at this looks pretty scary a pointer to a pointer ok so before we panic here's what we start the first thing we see is just that working backwards like oh i have a pointer in other words all argv is is just holds a memory address and that's we could stop there and say ok points just something"
reducer is the reference count of my entry by one and if that gets down to zero then we know that i node is not useful anymore and so the disk blocks that i required
hi so a big idea is that most file system devices are what is known as block based devices meaning that at the hardware level we don't ask for a single byte from a disk instead we have a convention and we say you know i'd like give me the first block of bytes please will give me the second block of bytes or i'd like to update this block of bytes with some new values so for performance reasons we don't make requests down to just very small units we much prefer to say to a disk system an external system gave me a whole bunch of bytes and useful ideas to make the same disk blocks the same size as our memory blocks in fact what we're going to see is all over our system examples where the blocks are based around four kilobyte chunks
human meaningful ways to be able to get a list things inside a directory ok so we're getting down to this next part here that right so what is an inode this is the definition of how we store a file on disk and it has certain meta information it tells us about the size that file it tells us about who owns it and things like when it was last modified
with an inode and the i node itself directly holds the meta information but also then points to provides a way for us to actually get the contents of the file but without the inode you have no file so so i want you to forget now about filenames that's just an icing on the cake for us to use it's actually the inode number which tells us whether we're looking at a particular file or a different file alright i'll see you in the next video bye
let's see all chill at the moment ok so we're going to get out of there were going to take this check this after you run through this code once i know notice it is frayed i apologize the logic as given incorrect let's have a look see what it does first of all philosopher waist to pick up the fork on the left ok so that's only going to proceed once you get exclusive access to that particular fork alright and then it's going to change this local variable failed to based on on what happens when it tries to pick up the the fork on the right so notice that initial value of tries left is too so actually it's going to call this function called trilok which we haven't seen before trilok never blocks instead rather than blocking if it's unable to acquire this mutex
hi. so, ok, we've talked about a scanf() which would read from default from the standard input but guess what we can do a lot more using the same ideas so we call it the scanf family just like printf has a family we can say instead you know what i don't want to just read from standard in i want to specify which file to read from which filestream so this f scanner for that or you might say actually guess what i've got some bytes in memory that i did as a c string and i want to pass the output from that so in which case i can use snf and all i need to do is pass in the address of my c string right so
ok sir how could it be the celcom malik take the same amount of time well the answer is it depends it depends upon actually which operating system we're talking about and also actually just now talking about implementation choices based on implementation toys choices you'll find inside bsd and linux so let me give you kind of two two explanations how this could possibly be true and first of all let's do the the bsd one here's what bsd says bsd says you know we want to be very security conscious and that in fact is going to be our guiding principle that we want to make it secure operating system as possible so if a process has finished with a page of memory here then there could be important secrets inside that memory for example maybe there's a public private key information inside there maybe there's a password that you typed in maybe some sense of information that you just loaded from a file but whatever it is it's currently inside the ram so it would be unfortunate if that data got copied or access at some point in the future by a malicious process or malicious actor so what vsd does is to say we will have a background process to scrub all old pieces of memory so we're basically going to zero it all out so everyone is happy so that now i've got we put that as a little zero here a piece of memory that has been cleaned prewashed ready to go so if you called the kernel and say hey i need you to map please map some some pages of memory for me how many were let's say
no preemption is the idea that a garden is not going to voluntarily give up a resource while waiting so instead so how can we break this rule
ok welcome to lecture 22 so we're going to make a new kernel object today it's called a pipe and a pipe is a stream and we can use it to communicate between two processes. now we're going to start with what's called 'unnamed pipes' where the only way we can talk about them is just using file descriptors,
to make sure i update that heat map in the right spot queso bites read i can use post increment after i finished writing into that little application i want bites read to be incremented i want and let's store the character that i've just read for my input stream and each time around the loop then efficacy is going to give me the next character from the input stream if i haven't typed anything there an f gets see or block it will wait until a new character is given to this process
in practice you'll say see people talk about tcp ip protocols because they're using ip say version four for their addressing and tcp in order to implement a pipe in order to be able to use read and write on the outside of this ok so just to kind of couple more points before we close this lecture today first of all can you program is listening on any port ok the answer is new so the ports less than a thousand and twenty four are called privileged ports so zero two thousand and twenty three thousand twenty three of what's called privileged ports and you need to have administrative access spell this correctly privileged ports
right the second thing that we'd like to change is this if inside here so in practice this can bite you in two different ways first of all maybe in other applications you have multiple threads calling this and we really just want to ensure their x really is positive before we continue and other things may change value x the second problem with this code is the actual deep condition wait is occasionally may suffer from what's called a spurious wake up it never truly went to sleep ok
so join is the idea that hey i've been running along let me do it let me do this where time goes to the right so my main functions been started and then i call pay through it creates so at the same time now and you function starts and it's running along doing a calculation but at some point it finishes ok so now we want to make sure that in our main thread we don't continue until we're sure that other functions finished so we would call p thread joint here
ok so we've we've talked about e x t two and how we can represent a small and\large files efficiently so what does x t three nxd four givers so i've already mentioned one thing which is that they were expanded to allow much larger files but ext3 gavers are journaling which is the ability to make sure that our file system is always in a good state so a file system of course has to keep track of unused disk blocks so we want to make sure that even if there's a power failure we don't accidentally start relying on bad information that if our idea of which disk blocks were available was incorrect that oh we might start overwriting valid files so ext3 implement this idea called journaling which is that i can consider in time all of my writes to disk to be modifications to my disk so i can have checkpoints where i can have an idea that ok a certain time my disk is in a well known state whatever is actually physically stored on the disk surface is in a consistent well
like stamps instead it out instead of there it's not going to work those are not seekable but it will work with this regular files so we pass an offset and that offset is going to be offset to something that we specify in here and we've got three options either be an absolute offset in meaning that it's with respect to the beginning of the file or it can be offset to our current position or it can be an offset relative to the end of the file and notice this offset can be positive or negative so we can let's pick a nice bright color
about is the idea that we have a stack that can actually track what we're doing because when i make a function call i need to remember what i was doing before and i also need to pass parameters into a function may need some extra space for its local variables and then eventually to return and go back to what i was doing before so let's look at this function and think how we might implement it so i'm going to need a stack
and blocks forever because that mutex has already been acquired now you and i know that that mutex ashley held by thread one but we haven't set we haven't created any special kind of meetings log we haven't enable debugging we haven't enabled recursion so in this case thread one is going to go to sleep and will stay asleep until the day that the holder of the lock releases it by calling unlock unfortunately you and i know that that is thread one ok so we've reached called deadlock where both red one and thread to have become stuck and will stay stuck forever right and notice how olympic effects as well if i got something that was waiting for thread two to say finish result right to file print something out then that is going to be waiting forever as well and so is quite often to see an entire system kind of grind to a whole as critical pieces never complete ok so that's what we think is going to happen right do you agree with me because i'm going to run it now and see what really happens are you ready let's go
ok so between you and me as big is not actually used anymore instead we're going to use some virtual memory tricks of all the slide this did modern c library uses some virtual memory tricks that we haven't learned yet so s breakers are simply mechanism but we will use it for cs two forty one to implement a simple memory allocator ok so remember how i said that the bottom of the memory i've got the text segment which is the program code and string literals and any other constants we've put in here and
are we done no well ok you just typed a character but how is that character represented we're so used to thinking about the fact that we're writing in say ascii or utf eight that doesn't actually have to be the only way that we can represent our data so for example perhaps you want to store and send pictures using a jpeg format or perhaps you want to send a text using this ebcdic format which is a different way to represent characters or perhaps you want to use png so perhaps you want to do movies etc ok are we done no at the top most level is the idea of the application so at the application level, we get to define our own apis we get to define how we want to access remote files and resources and describe things like directory services as well so this top most level this is where we start talking about ok i want to be able to access web resources using http which itself is a protocol that grew out of a simple file transfer protocol and another well known protocol here is smtp which is a way for us to send emails simple mail transfer protocol so smtp allows you to send very simple messages or to send emails with attachments for example ok so these different levels of abstraction allow us to work independently so for example tomorrow i might decide that as you want to access a web page not over tcp but over udp of course if i do that then my web client better be able to actually handle udp connections and also my web server needs to be able to handle udp connections does it happen today yes surprising it does so if you
ok so we can look at what effort is supposed to do is supposed to be put s which means send all of these bytes plus a newline and rather than just send it to standard out we want to send it to this particular file so once we've got this working it will be easy for us to implement puts() because we can just implement that in terms of calling fputs() but will tell it to use standard up first file
approximately random satisfies some basic statistic properties that we expect a random numbers to satisfy and we're just going to seed it based on the current time ok so let's run this it's called and i kind of broken
what i'll do today then is a little bit different from what we saw with the clients here's the first big change that i want to make what's called a passive socket so passive socket is as it sounds it just sits there it waits for clients to come to it ok so it doesn't go out and reach out and try to talk toa remote server no it's completely passive it just sits on a particular port waiting for those packets to arrive so this is the first big change as to how we specify that we like
ok so so far none of these calls will block but we have now set up a valid server if i've got this far then calling netcat on this connection or calling telnet or calling using firefox or chrome etc will make a valid connection and then i'll start to want to send back to us so we better actually start processing our clients ok so how do we do that and the answer is with accept ok so accept means please block and till there's a customer for me to serve ok and of course we pass in our server socket now the big important idea here is that now is that that server socket is the front door to your shop but it's not actually going to be the way that you talk to your clients instead when accept returns you get a new file descriptor one for each customer which is the private communication channel between you and that client so with this new file descriptor that's how we're going to be calling read and write
and as you know they are necessary and sufficient we need all fall to be true and exactly or for them to be true and then we know that we've met the conditions for deadlock so what are they let's actually look at some definitions here so here's the first wanna process is currently holding at least one resource and requesting additional resources which are being held by other processes ok so it is holding and waiting so that's a hold and wait condition
ok great sir let's start talking about manafort says so here's a great wonderful idea i wanted to choose something which was it was called embarrassingly parallel meaning that we can just set all cpus off calculating something and then we don't need to think about any communication between those cpus we don't need to think about them trying to update the same piece of memory at the same time so this is a very easy problem for us to parallelize into play with do understand how to use pizza is before we move on to more complicated examples ok so we're going to put together a lot of ideas first of all let's talk about a little bit of math so here's the plan i want you to think of a number right now i'd like you to square that number
item that's being passed on paskin will actually continue to exist later when when pop is called if that's not true if you actually wanted to make a duplicate of this string then there's a nice little function in c called string duplication so strdup so it stands for those duplicate string so you pass in one string
there is an option however to say he actually i want to know a lot more about the signal that actually happened so when you work with real time signals and other signals you can actually get a lot more information from the kernel about why this signal was created and what was going on at the time then door so there's a void pointer you can use yourself as well ok so this more complicated function is called a cig action
hi ok so let's make it a little bit more complicated now let's have a whole load of data structures ok so in this case i'm actually going to have eight different data structures here we go right and so for each one of these i'm going to use a condition variable to block when things are not ready and i'm going to need eight different locks now i probably could implement this code with just a single lock but then i might have unnecessary lock contention so lock contention is when one thread would like to continue but it can't because another thread is currently holding the lock and so of course that effects performance sometimes we actually need that behavior when another field is kind of into the same critical section but we could probably in this problem get by with a fewer number of locks sorry a few more locks in order to reduce lock contention so so in this case we have we've got eight condition variables and eight locks plus here's my data structure is actually is going to be of eight integers but i want you to imagine that this actually could be a lot more complicated ok right so i've got some initialization to initialize all my condition variables and locks as you can see all i'm doing is using the array name
and as you know they are necessary and sufficient we need all fall to be true and exactly or for them to be true and then we know that we've met the conditions for deadlock so what are they let's actually look at some definitions here so here's the first wanna process is currently holding at least one resource and requesting additional resources which are being held by other processes ok so it is holding and waiting so that's a hold and wait condition
and my trick for making certain memory will just simply be if i fall off the end here then start at the beginning so it's perfect for all the people that believe in flat earth etc so right i've had i do that well i could use modulo with matich but i'm going to use bitmasking ok so if i've got a little index here let's call it in a little integer here then as i incremented i asked you only want the lowest bits so if my ring buffer it says of size sixteen then i need to just take the lowest for bits and how can i do that i can say bitmask please with fifteen or if i want to write that in text decimal of x f so that will just ensure that each time i use this my end pointer in here will keep going around here and when i fall off the end i will start at the beginning now we need to make sure that the ring buffer never gets never allows me to push things in if it's already full and never allows me to pull things from it if it's already empty otherwise i will start to either off see a buffer overflow issues or buffer underflow issues so underflow is when you try to read something from a memory structure and there's nothing actually there ok so in these situations we actually want to block
ok alright so it looks like it's kind of working but not as well as we hoped we certainly got different thread ideas appearing and they do look like addresses i'll give you that but look at this we've got very strange values over here and even the last value is ten and if i run it again i get different values again if i run it again i get different values again ok so i get in all sorts of values here what is going on clearly we've got a program which is not deterministic we don't know what it's going to print out ok so why did that happen well hopefully you can see that we passed in the address of i and so actually what we have here is called a race condition it depends upon the exact interleaving in time of the instructions that are going to be executed i've got one thread that immediately after calling pizza it could create is going to increment the value by and then test to see if i is less than ten i have not go around again so we've got one threat doing that as fast as fast as i can and i got another thread that as soon as it starts will gas that pointer to an end pointer and then try to read it so it's a value that it sees depends upon the relative timing of these operations and that can change from one run to the next you might be surprised we even saw the value of ten even though our loop says is i less than ten yes so that's why our threads can start at some point in the future maybe few microseconds but maybe a millisecond maybe much longer ok and
ok so we've we've talked about e x t two and how we can represent a smaller large files efficiently so what does x t three nxd four givers so i've already mentioned one thing which is that they were expanded to allow much larger files but e x t through gavers are journaling which is the ability to make sure that our file system is always in a good state so a file system of course has to keep track of unused disk blocks so we want to make sure that even if there's a power failure we don't accidentally start relying on bad information that if our idea of which disk blocks were available was incorrect that oh we might start overwriting valid files so xt through xt three implement this idea called journaling which is that i can consider in time all of my rights to disk to be modifications to my disk so i can have checkpoints where i can have an idea that ok a certain time my disk is in a well known state whatever is actually physically stored on the disk surface is in a consistent well
but you're saying hold on a moment this pointer you're starting with this user pointer it's avoid type that means that we're not declaring anything about what's actually at that memory location and if you read the c standard you're not allowed to do pointer arithmetic on that type because we don't know what's there would be absolutely correct however or modern compilers gcc clang and others do support this is the following extension which is you can add and subtract avoid pointers and if you do that then they behave like character pointers and in particular you are adding subtracting bytes off this memory location so we're walking back exactly the right number of bytes in this case because of this type ok so now i've got that now i can immediately say things like alright point p i know you're looking at my meta data entry so now let me declare that this entry is now free and then i would write my code to the block coalesce sing by checking my neighbors left and right to see if either of those are free and if so then i would assume they exist and if so i would collect them into one alright so that's one way of doing it but you and i also know about pointer arithmetic so here's a different way of doing it so
and i can also even look at how many allocation is performed inside the kernel as well and the kernel uses something called a slab allocator which builds upon a memory pool
right the second thing that we'd like to change is this if inside here so in practice this can bite you in two different ways first of all maybe in other applications you have multiple threads calling this and we really just want to ensure their x really is positive before we continue and other things may change value x the second problem with this code is the actual deep condition wait is occasionally may suffer from what's called a spurious wake up it never truly went to sleep ok right so why does that occur well let's let's go back and talk about the implications for how conditioned weight is actually implemented right so we've just seen this problem of change in value of x and then signaling too early before they thread is actually blocking and waiting for that signal to arrive so in practice what does this mean it means that unlocking the mutex
later or control them when we talked about memory mapped files they give us an advantage of being able to share things and they give us some security is not a hundred percent if you are interested then go and read up on return oriented programming which is an extremely kind of clever way of misusing the stack when all you can control is the return addresses that are actually present on the stack
entries that i can store inside of this block so this diagram is very very incomplete there's actually many many many many more of these so there's a thousand and twenty four so called indirect blocks and they are called indirect blocks because i had to load this indirect table i had a performance hit whilst i
or find me things which have the name or a case insensitive name say that has the word ok let's try say anything with python ok so find is a kind of swiss army knife of abilities to kinda find matching files and it searches recursively so let's think about how we might kind of write that ok so this is my first attempt but maybe there's some problems with it and that's where you come in we're trying to figure out where we can how we can fix this ok why is this not gonna work ok you'll see that i'm using sprintf waste sprintf works is bit like printf except that rather than printing something else it's going to write the result into this memory location so hey let's get some memory and we'll print into that so what do you think of all this code it's obviously some mistakes in it
hey welcome to lecture thirty six so in this lecture we get that start talking about protocols and handshaking so the protocols we're going to look at are going to be tcp protocols and a little bit beyond will look at http as well right so remember tcp is transmission control portable it allows us to hide the fact that we are sending packets and so to the application it just looks like a stream a pipe that we can push bites into anas bites will appear out the other side right so let's have a look at some of the protocol magic with actually supports that first of all we know that when we start making a tcp connection we first initiate one the handshaking needs to occur meaning that we're going to send a few packets backwards and forwards just to initialize that connection and in fact this is often known as the since in ach ag pattern right so there's three packets we've got to talk about where first of all the client sends a
ok so let's talk a little bit about http so http is the mechanism today that how you actually get a web page and http actually grew out of an existing protocol and this very first version of h d two p the first of official version one point oh and also one point one is a text protocol so why do you think that is why choose a text protocol because this of
"so a datagram is just a fancy word for a packet you can think of it like a telegram so user ground data critical "" the key characteristics of this protocol is that it is connectionless just like a telegram you can say oh i want to send it to this ip address and on this port and you can fire it off and off it goes so let's create our little message and send it and let it fly away right so we're not going to track it we don't get a notification when it gets there there's no there's no protocol to set up in terms of say bring them up first and the querying that we're going to send this message now we simply fire off this packet"
a great it present yeah ok so let's review just how else is working again we've got no int and this is changing the process mask before we call exec so we've pulled up the drawbridge for sigint in this case and then my little program was are there it is allows us to synchronously check to see if a signal is checked so we're not actually delivering the signal instead we're just picking outside to see if there's any hordes outside our castle we're trying to get in we're not letting them in we're not letting that signal being delivered we're just checking to see if they are there we just having a little peek ok so that is siggers member it's a way to synchronously check for pending signals and the next video we'll talk about pending signals and the process mask see you then bye
just a quick comment if you want to set environment variables this one version which takes a set where you pass in a name and a value add another version called put em where you pass in name equals character and then the values so that they are equivalent alright so that's quick introduction to environment variables to a very handy if you want to do things like store configuration file of your application inside the users home directory
right, ok. welcome to the next lecture i want us to think about how we might actually write the c library. ok so maybe you don't like the license of glibc maybe you want to write a library that is a lot smaller or simpler so how can we actually wrap the low level posix interface that the kernel gives us an actually implement the c-level objects like the file so let's i would go at this right now you know about fopen where i can pass in a filename k blah blah blah but there's also function called fdopen where i can just pass in an existing file descriptor so if we write f d open it would be pretty easy to then also implement f open which just calls open and then we can delegate the rest of the work to this ft open call right so here's what we need to do then we're going to be given a file descriptor and we want to create one of these file objects now normally these are opaque structures normally as programmers we don't need to peek inside to see how they're working but that's not true today because we are actually trying to write the c library so let's have a go at writing the kind of simplest version that we might want and that's what i've done up here ok so this is what i want to put inside my file struct i need to store several things first of all yeah i definitely need to know about the low level file descriptor that i'm going to need when actually call read and write secondly i want to have some kind of buffer and the purpose of my buffer is to actually reduce the number of times
so let's have a think about this we know that ippo control is how we actually manipulate the set of file descriptors that we want people to care about so we're saying hey i'm going to give you a file descriptor that i don't
that other thread has managed to get the colored paper and is now looking at me waiting for the queens and because we're holding onto our resources were not going to share them now we've got that look so the holden weight is the idea that you get exclusive access to the resource and daniel prepare to wait for other things you're not going to put it the app once you grabbed it you've got it ok so this is our threads and processes acting like toddlers or three year olds in a day care and the last one is the there is no daycare teacher in the room to actually
ok so we don't if we don't have that if there's no possibility preemption then then and all those other conditions occur then then we can have the possibility of deadlock ok so let's kind of try to differentiate between some of these because the press possibly last two sound kind of similar so holding weight is the idea that a process is holding onto one thing but so little or mount nested ok holding on to that but they want to have but there waiting for something else ok so
character rv right suppose i wanted to check that something is true so perhaps i want to assert i want to assume that from this great point going forward that my program actually has least one argument specified normally i would write an actual explicit test but because we want to demonstrate asserts today let's use it within a certain so we could say
so we have to make sure we've done the listen before hand but listen is a passive call it just simply sets up the server for new prepares the server for incoming connections it's the connect that's the moment that we start generating packets ok and of course once we do that we'll get back the syn ack automatically as well right so now with that in mind let's have a look at our little problem here lunar base so the moon is one point three light seconds difference by the way i wasn't very good sleep was a baby and moon as the first word i have a spoke apparently so one point three seconds difference takes an otherwise it takes light just over a second to reach the moon the tcp client is on the earth and there's a lunar console running some kind of tcp server on the lunar base so
ok right so remember signal blocking means that we've pulled up the drawbridge any zombies we have outside they they're not dead yet they held that there are there zombies but they haven't gone away so if there is a signal that's waiting to be delivered all we're doing is trying to delay the inevitable we're trying to stop that signal from being sent to us ok how do we do that we use sig prop mask and here's how it works it's a little bit like seek set in the sense that you can say exactly how you want to use it and so the first integer here is actually a choice of one of these three constants you can say i want to add to the existing mask so that's block here so any signals that i'm going to give you i want you to all them with existing mask or i want you to take the single set that i'm giving you here and use the bit set inside that signal set to unblock signals ok and then finally there's the i don't care about the existing mask i just want to replace the process mask with their one that i'm giving you ok so this how controls what the meaning is of the signal set here ok you also notice that actually we've got the three parameters here there's old here so if we wish we can ask cig pop mask details the old signal mask so that is sometimes useful because you might call mask twice you might initially calling to say hayes process here's my new signal mask and by the way i want to remember what the old process mask looks like and then later when i finish doing what i need to
ok i want to mention just a curious little bit of linux here which is called the directory sticky bit so here's the problem we need to solve let's suppose we have a disk which is nice and large and i'm going to let everybody write into this disk because we need lots of space but people only need this big space for a temporary amount of time so we'll have a part of our file systems say called slash temp where both you and i and others can unpack things maybe compile things etc so this directory itself needs to be world writable so the permissions on this directory are going to be quite unusual because the directory on the temp directory will be seven seven seven meaning hey we can all read
ok let's talk about counting salmon falls so kind semaphores are cool so here's what they can do so let me let me compare them a little bit with mutex locks mutex locks they're designed for very fast locking and unlocking right and the key thing about mutex lock is that the lock and the unlock occur in pairs and they have to be performed by the same threat right so you cannot create
why don't i have there we go ok so let's have a bit of a back story here which is that raid was born in the time where moore 's law showed that we could fit more and more transistors onto a square better silicon and this is a log rhythmic scale here so you can just see the kind of every decade or so decades of time we have this proximate kind of straight line here where machines are getting faster and faster
cape then you'll see that we get a figure of about kind of twelve days or so ok so enough back over the envelope calculations so given that given that we expect to be replacing disks quite quite often we need away a scheme to ensure that any information last on a particular list can be regenerated by the remaining disks so the simplest form of this with raid is just called a raid one where we literally right the disk the data twice so i can mirror let's come back like a mirror the data is a present on both so there's a little bit of a speed advantage here because if i need access to a particular piece of data say a certain part of the file actually i can use either of these sources
now here's a useful little command get cwd noticed that's right it tells us the process is current working directory which is going to be useful if we want to work with relative directories and in fact paths in your system of defined to have a maximum length so you can be confident that the string that you can request can never be larger than this constant here path max and we add one just to ensure that there's enough space for the c string zero bite at the end ok so if you want to know how where you currently on file system here is one way to do it right
but that's the big idea that's all the directory is of course most of the time we don't actually print the i node numbers but you could if you really wanted to so let's have a look to see how we can do this in c in fact these see libra gives a list of level of abstraction here and it's very easy to use we call opened are that internally is going to open file with a using a file descriptor so for example let's open the current directory and then we can keep calling reader to read the next entry
and as you know they are necessary and sufficient we need all fall to be true and exactly or for them to be true and then we know that we've met the conditions for deadlock so what are they let's actually look at some definitions here so here's the first wanna process is currently holding at least one resource and requesting additional resources which are being held by other processes ok so it is holding and waiting so that's a hold and wait condition
so, by the way, this kind of bug where we've freed something twice is called a double free error, and yes, the example i gave below is obvious because we've written it twice, but sometimes it can occur by accident, where the free is part of an indirect operation but buried inside some other code.
hi welcome to like twenty four we're going to start with a quick code review let's see look at this attempted waiting a fixed sized ring buffer and we'll see if we can figure out how it might go wrong ok so some of the things that we want to ask are is deadlock possible in other words could get stuck so that's never able to continue is underflow possible in other words could it be that we attempt to write so attempt to read some data that's not actually inside the ring buffer so will just be reading back some garbage information or perhaps overflow as possible which means that we're able to put more data into my buffer then it can actually hold so presumably we were going to corrupt something possibly value that we have not yet written out so what do we got here we have
on the receiver we need to bind it to a particular port number on particular ethernet card so we're going to call bind
so we can actually kind of write down a formula then based on a couple of basic ideas one is the arrival time so this is when the process is is created when it first arrives on the scene it's ok i'd like to use a cpu time and also we know how much time it's going to require to actually execute so that's a duration that's not a wall clock time and then the completion time so this is the actual wall clock time when it finishes ok so if we think kind of if we were to sketch out our time periods right so if this is when it arrives
other servers my server might send an xml message in order to confirm that booking or in order to find out if an airplane has some some seats between two destinations that are at a certain price point for example ok so xml is very kind of popular as interchange format for kind of finance and booking applications now quick comment is that you don't need to write your own json parser your xml pauses today of course there's plenty of library code out there that will do this for you some of them will give you events based on each time they see a new tag others will read the whole thing into memory and creates what's called a dom document object model module which is great for a kind of small message is not so great if your dom is huge and then you can iterate through that by asking a dom to say find a particular child of a certain type one last thing is you'll notice that each element we have here we can actually have water cord attributes case so we've talked about elements which are the items we actually find insight memory each element may have kind of attributes the difference between an element and a tag is the tag is the actual piece of string that we've written here the actor going to bite sequence that we needed to actually describe the elements ok so the tag is the actual thing with the open and close
is the idea that hey some jobs only need or some process is only need a tiny better cpu time so let's give them the cpu first that way will get lots of things done over the next minute or two because we've maximized a number of processes that can actually complete because each i'm going to give priority to the process which only needs a small amount of cpu time right now there is another version of this which
is called the preemptive shortest job first and so with preemption you are allowed to kick someone off the fairground right ok so let's imagine right now that process five because they only need one second of cpu time is on the ferris wheel right for some reason a new process is created let's call it process ten and process ten only needs point five of a second so what do we do right so we'll take process five kick them off the first real process ten now has priority because
ok hi right so let me tell you about this amazing currency it's going to be huge i'm calling it angrave coin is the latest in crypto technology and it's based on bitcoin but it's a lot better because so few people know about it alright so here we go here's the plan
i think we can call her called real path where we can actually ask for the absolute canonical path and this is going to be very useful when we want to build things like file servers and web servers for security to make sure that we are only serving files out of the correct directory we don't want requests to come in with a malicious user is requesting files like
"ok, so maybe you know about threats so great you are able to chunk up the work into different jobs so that each thread is responsible for the output of the total result and so you need each thread to work independently. """"""great!"""" you say. """"i remember those from cs241"" ""to the rescue."""" that now i can tell my first thread to"" explicitly write its results into the first part of the file meanwhile the second thread over here is starting to generate results as well and so it can start writing bits of data over here, and we can explicitly say where in the file we want that to go. so yep, there's pee right and there's also period which does a similar thing that you can read from a certain part of the file and directly specify an offset into the file. ok, so they are very useful when you want to do random access and random reads into file but also later inside cs241 we're going to learn how to 'memory map' files directly into memory where we no longer even need to call read and write but we can actually look at the file as if it is actually part of our address space. so that's coming up later inside cs241 and it's the most one of the most far and most powerful features of posix and system programming that you'll see in this course. ok, so the will do what's ""a named pipe?"""" ok, how do i make a named pipe? for this you"" can actually make pipes on your file system. you can just say make vivo because they behave as a little 'first in first out' queue. so ""let's call it say ok, and now if you look on the current directory you"
thing we can call here called real path where we can actually ask for the absolute canonical path and this is going to be very useful when we want to build things like file servers and web servers for security to make sure that we are only serving files out of the correct directory we don't want requests to come in with a malicious user is requesting files like
to realize that one thing that process has gives us is a security model we can say that a particular process runs as an effective user id and has access all not to certain system resources so we know for example if i was writing a web server that the web server has to run as root in order to access support that is privileged like a port less than a thousand and twenty four ok so should all my code however run as administrator vernors route maybe not maybe some of it should for example if you're going to work with
you might decide to say send the number of integers followed by their values or if you had a graph you'd have to find a way to turn that graph into some information to send down the wire so all of that idea of marshalling all the information you want is called is called marshaling it may include also some additional information like some session information because you've already authenticated with the other side right so all that happens inside the clients stub code
on the other side at the on the server we also we need to write some sub some stub code so for every function that we want to implement for example this get name function we need to receive the information from the other side and turn that back into the kind of necessary parameters to actually kind of implement it so this task is called une marshaling
ok right so let's talk about our iso images again so remember that if i gave you an iso image perhaps you've downloaded off the internet because you want to install linuxsomewhere you could actually look inside it so the iso image itself is a single file and it adheres to the following standard the so called nine six six oh standard which was a digital format to allow us to use cd roms which of course we designed for audio information but to be able to store digital information on that so so so today of course we barely see any cd roms around but we still use that format because it's sufficiently efficient to be able to distribute complete file systems for example to install some new game or earning complete new operating system right so we used mount in order to mount an ics file using a loop back file system we did that before how can you download things from the command line might have mentioned this before curl is pretty useful cold behaves like cat except rather than specifying file right cull expects http address so you might say ok http something rather right and just like cat it will by default spew all of its contents onto standard output so how can we fix that where you can either redirect it to a file or you can use this minus oh just to say hey figure out a reasonable filename based on the url that we give it here so curl is kind of tremendously useful tool you can even with your web browser
a way to actually take my iso and say here you go machine boot up using this now i'm not going to try to boot boot up my mac laptop right here using that instead i'm going to boot it up using a virtual machine so a virtual machine the idea is that let's virtualize every single piece of real machine in other words maybe there is a cd rom ok so here it is and a cd rom with an actual cd inside it ok so when it boots up it will actually see the contents of the thing we just the downloaded and in fact the ice image we're going to play with is called damn small linux and it's a fifty megabyte iso file which is a complete little lennox district ok so what else do we need to emulate well we need to emulate more than just a cd rom we need to emulate a complete cpus so for this i'm going to use a fantastic piece of open source code kemu is an emulator an it can emulate entire systems and there's different formats of it for example we could ask it to emulate an amd based cpu system or another kind of cpu but the system that we're going to emulate today is going to be based on a sixty four bit intel architecture so the x eighty six is the kind of original intel format for the cpu and the commands and we are looking at sixty four bit variant so
ok let's talk about some malicious attacks against tcp first of all port hijacking so whatever now other malicious user could take over a port so you think you're connecting to our web server but in fact you're connecting to a malicious process listing on the other end pretending to be a web server but in fact just stealing your password etc right so how can we try to prevent this so there's two kind of common mechanisms first of all the idea of privileged ports so as to spell privileged correctly if something like this privileged ports so you know that you need to have root or administrator privileges in order to be able to listen on a port number less than a thousand twenty four ok so you have to have administrative privileges which means that no mere mortal processes can pretend to listen on those ports they already have to be blessed by the administrator of that machine so that's kind of one trust boundary the second is that after you've after a service finishes listening on a port that pause is not immediately available for reuse in fact there's a time out of about two minutes where the you cannot simply start a new server listening on the same port ok so that's the default behavior for tcp under linux and other operating systems we can actually change their behavior so that
well hopefully you can see that we passed in the address of i and so actually what we have here is called a race condition it depends upon the exact interleaving in time of the instructions that are going to be executed i've got one thread that immediately after calling pete said quit going to create is going to increment the value of i and then test to see if i is less than ten i have not go around again so we've got one thread doing that as fast as it as fast as it can and i got another thread that as soon as it starts will gas that pointer to an end pointer and then try to read it so the value that it sees depends upon the relative timing of these operations and that can change from one run to the next you might be surprised we even saw the value of ten even though our loop says is i lesson ten yes so that's why our threads can start at some point in the future maybe few microseconds but maybe a millisecond maybe much longer and some point we're going to escape how did this this for loop so at that point the value of i will be equal to ten because that was our exit condition
ok and the answer to this riddle is because we gave it a head transplant is because we call it exec an exact threw away all of the existing memory of our process and inside that memory is
ok so between you and me as big is not actually used anymore instead we're going to use some virtual memory tricks of all the slide this did modern c library uses some virtual memory tricks that we haven't learned yet so s breakers are simply mechanism but we will use it for cs two forty one to implement a simple memory allocator ok so remember how i said that the bottom of the memory i've got the text segment which is the program code and string literals and any other constants we've put in here and
ok alright so it looks like it's kind of working but not as well as we hoped we certainly got different thread ideas appearing and they do look like addresses i'll give you that but look at this we've got very strange values over here and even the last value is ten and if i run it again i get different values again if i run it again i get different values again ok so i get in all sorts of values here what is going on clearly we've got a program which is not deterministic we don't know what it's going to print out ok so why did that happen well hopefully you can see that we passed in the address of i and so actually what we have here is called a race condition it depends upon the exact interleaving in time of the instructions that are going to be executed i've got one thread that immediately after calling pizza it could create is going to increment the value by and then test to see if i is less than ten i have not go around again so we've got one threat doing that as fast as fast as i can and i got another thread that as soon as it starts will gas that pointer to an end pointer and then try to read it so it's a value that it sees depends upon the relative timing of these operations and that can change from one run to the next you might be surprised we even saw the value of ten even though our loop says is i lesson ten yes so that's why our threads can start at some point in the future maybe few microseconds but maybe a millisecond maybe much longer ok and some
let's see all chill at the moment ok so we're going to get out of there were going to take this check this after you run through this code once i know notice it is frayed i apologize the logic as given incorrect let's have a look see what it does first of all philosopher waist to pick up the fork on the left ok so that's only going to proceed once you get exclusive access to that particular fork alright and then it's going to change this local variable failed to based on on what happens when it tries to pick up the the fork on the right so notice that initial value of tries left is too so actually it's going to call this function called trilok which we haven't seen before trilok never blocks instead rather than blocking if it's unable to acquire this mutex
what is really really useful to know is scanf tells you about the number of items that is successfully managed to parse
all bets are off now i can have complete access all of the memory of the real machine so it's not perfect it's not perfect security right stalker i'm sure that you will come across it in your kind of future future working it's kind of very popular tool today one last other thing i'm not going to mention but just point out and see if i can find doctor up here here it is you might also hear about something called communities in kubernetes is is a way to define how to create many many many working virtual machines or docker images and containers and run many of them at the same time so for example if i wanted to make my website work with say five different five instances of node js and i wanted to scale it up to have say ten back end databases then i would use kubernetes to be able to define how to scale up and use all of those different containers alright so cute like i said is also kind of great powerful tool if you get into this stuff it's very very easy to play with this stuff and docker has made it very easy lots of great examples so after cs two forty one final exams after you finished saying hi to your friends and your parents and etc and putting away the semester why don't you have a play with this i'm sure it would be kind of useful skills to learn ok so let's stop there and next video will go back to cs two forty want content which we do ask about on exam ok bye for now
or maybe it's some data structure but whatever it is we have this idea that only one process or thread at a time can access it now i'm going to use the word process that's kind of historical reference in the sense that we thought about these things even with four threads exist but you could imagine how we could set up identical situations to multiple threads running inside just one process so it's the concept is the theory which is the most important idea here ok so what do i got in question one i've got my first process p one requests and obtains resource a and then resource be ok so let's set up process one here ok process one
ok and finally it had stuck in the ground yes it's called the ostrich algorithm which is that uh if it's look scary quick stick your head in the sand and don't look so the lyrics of windows strategy for deadlock avoidance is called let's just hope for the best which the ostriches algorithm is basically let's pretend it's not our problem their system is going to let you write code that can cause deadlock it's up to you the system programmer to make sure that deadlock cannot occur so the system does not prevent you from causing deadlock so good luck you're on your own on this one and that's why it's important to make sure that we don't enter possible deadlock which brings us to our final little point which is how can we possibly do this ok so here's the secret source here's the most important part of this lecture because now i've shown you that we can simulate deadlock we could see it occur inside the resource allocation graph but we actually want to prevent it here's the secret
hi welcome to like twenty four we're going to start with a quick code review let's see look at this attempted waiting a fixed sized ring buffer and we'll see if we can figure out how it might go wrong ok so some of the things that we want to ask are is deadlock possible in other words could get stuck so that's never able to continue is underflow possible in other words could it be that we attempt to write so attempt to read some data that's not actually inside the ring buffer so will just be reading back some garbage information or perhaps overflow as possible which means that we're able to put more data into my buffer then it can actually hold so presumably we were going to corrupt something possibly value that we have not yet written out so what do we got here we have
ok so we are going to choose a color here we are going to model i simulate some different schedulers and we've got the same process model that we're going to run for each one you'll see i've got four process is here and this is the wall clock time that that process is is ready to start ok so would like to run initially we got three processes which are available they would all like a cpu unfortunately in this model we've only got one cpu then we've got their burst time in other words the amount of cpu time they actually need to complete here and we've got
ask a waiter for a particular resource and off they go and they bring that back and then you ask for another resource and off they go and bring that back this is quite inefficient it would be great if we could just ask for multiple resource and then they just arrive as soon as they are ready so the first idea then is hey we can have pipelining which means that if i can spell it that i can make multiple requests and not have to wait for the response it's like yes i want the web page so give me the give give me the html as soon as i start getting bites back from that i know that say i want a cat picture i've got a whole lot of javascript libraries to load i've got some css s to load i can make all these requests and not have to wait for any of them to finish so i can efficiently start these requests as soon as possible ok then next thing we talked about is that each request is quite heavy it has a lot of headers in inside the request so let's have header compression let's find ways to actually reduce that the number of the byte overhead ok so we can you header compression and in fact we are going to support binary
right the second thing that we'd like to change is this if inside here so in practice this can bite you in two different ways first of all maybe in other applications you have multiple threads calling this and we really just want to ensure their x really is positive before we continue and other things may change value x the second problem with this code is the actual deep condition wait is occasionally may suffer from what's called a spurious wake up it never truly went to sleep ok right so why does that occur well let's let's go back and talk about the implications for how conditioned weight is actually implemented right so we've just seen this problem of change in value of x and then signaling too early before they thread is actually blocking and waiting for that signal to arrive so in practice what does this mean it means that unlocking the mutex
to look at the next byte in both cases. ok, our code is looking a lot better. right. except we've got a couple of problems here. first of all, we were supposed to be implementing strcat. the idea of strcat is to advance beyond the end of the existing string
ok right so signal disposition is per process it describes what we should do with the signal do we want to just ignore it do we want to terminate the process or do we want to run special some special signal handler that we that we have installed ok so that's kind of basically our options or some kind of handler
before we kind of jump in there with this kind of mentioned one last thing kind of pending signals remember these are the signals which have not yet been delivered ok so let's say about when you exec so first of all when you child which is initially created by fork does not get a copy of the pending signal set so a child always
ok so first of all to send a signal his several calls that you maybe you seen already so first of all here's one you've probably seen kill where we could specify a process possibly ourselves by calling get pid and the signal number and then we have raised right what does raise do that calls kill on ourselves so so raise is equivalent to calling kill but with get pid so it's just a shorthand to say hey send a signal to myself to the current process
let's see all chill at the moment ok so we're going to get out of there were going to take this check this after you run through this code once i know notice it is frayed i apologize the logic as given incorrect let's have a look see what it does first of all philosopher waist to pick up the fork on the left ok so that's only going to proceed once you get exclusive access to that particular fork alright and then it's going to change this local variable failed to based on on what happens when it tries to pick up the the fork on the right so notice that initial value of tries left is too so actually it's going to call this function called trilok which we haven't seen before trilok never blocks instead rather than blocking if it's unable to acquire this mutex
sorry simple http server and in both these cases you can specify a port number so if we wanted to comment that one up if we wanted to specify a port then i could specify a different part number here so let's choose for example if i try to do a low port number like poor eighty it won't be very happy we got permission denied because i'm not root right now on this system and so port numbers less than a thousand and twenty four restricted they're privileged ports so you have to be an administrative built to listen on those ports so let's not connect on let's not listen on port eighty let's list on say port eighty eighty ok great and off it goes again so now again i can make a connection using my favorite web browser and off we go and see the contents again wait and you'll see this particular
tcp will automatically assemble any packets will wait for lost packets to be re sent so we just have a nice stream a data stream ok so how do we set one up right so if we're setting up a client all i need to do is first of all i'm going to be lazy and call get address info this does a lot of heavy lifting for me to actually figure out the correct parameters i'm going to send into my next two calls so technically this is not formally required but it does make my life a lot easier the two things which are definitely required is of course ideas a socket then a socket is there abstract object owned by the kernel which allows my code to talk to the outside world to be able to talk to other sockets maybe on this machine but maybe not ok so once i've made a socket and for a client all i need to do is ask it to connect so let's
so great i can be inside the critical section after i finished i'm going to change this term based variable to point to you meaning that if there is a tie breaker then you get to go forward an i get to wait so do you see how we've satisfied mutual exclusion meaning that only one of us can actually be inside the critical section to the time we've got bounded weight meaning that i don't have to wait for you a fixed number of times
it's kind of see this here it is right so here's my kind of main method today instead of using with mmap to say hey here's my file descriptor please map this into memory we're going to say actually i want anonymous mapping meaning that it doesn't actually map to any file at all so why might i do this because i can create some shared memory between a child process an apparent process gets so for example let's have four thousand ninety six bytes case that this is going to be the number of bytes we want let's decide how we want to use these bites so we don't need to execute any code here but we do want to be able to read and write to this page of memory and lastly because we're going to fork we do care about changes that i make inside this file to be seen by my child process as well so
