sentence	source	start
ok right so we want to make a barrier out of the following and we're only going to make a single use barrier right so let's get started well each time thread calls barrier we definitely want to reduce our count by one ok so let's let's do that now in order to make sure that it behaves as an atomic operation we will first lock a mutex lock and so some point after that we will be unlocking it as well now we want most of all threads to wait we want most of them to to call sam wait another word to go to sleep ok so that's the only way that we can actually stop our threads right now so before this we will need to initialize that variable and will initialize it to zero in other words do you know pizza slices ok so we've done that previous to calling the barrier	the following	45
ok right so we want to make a barrier out of the following and we're only going to make a single use barrier right so let's get started well each time thread calls barrier we definitely want to reduce our count by one ok so let's let's do that now in order to make sure that it behaves as an atomic operation we will first lock a mutex lock and so some point after that we will be unlocking it as well now we want most of all threads to wait we want most of them to to call sam wait another word to go to sleep ok so that's the only way that we can actually stop our threads right now so before this we will need to initialize that variable and will initialize it to zero in other words do you know pizza slices ok so we've done that previous to calling the barrier	a mutex	328
ok right so we want to make a barrier out of the following and we're only going to make a single use barrier right so let's get started well each time thread calls barrier we definitely want to reduce our count by one ok so let's let's do that now in order to make sure that it behaves as an atomic operation we will first lock a mutex lock and so some point after that we will be unlocking it as well now we want most of all threads to wait we want most of them to to call sam wait another word to go to sleep ok so that's the only way that we can actually stop our threads right now so before this we will need to initialize that variable and will initialize it to zero in other words do you know pizza slices ok so we've done that previous to calling the barrier	thread	151
right so was left well we've got this if we made an post right so here's the plan that most threads we want to immediately call sam wait and get blocked but what about the last final thread ok so the last last thread we don't want to block so here's our plan that that for most threads where remain is non zero we will get into call some weight and they will go to sleep	block	145
right so was left well we've got this if we made an post right so here's the plan that most threads we want to immediately call sam wait and get blocked but what about the last final thread ok so the last last thread we don't want to block so here's our plan that that for most threads where remain is non zero we will get into call some weight and they will go to sleep	thread	92
but the fifth thread will do what ok so here's actually we're going to see is a chain of domino's here releasing one thread after another so the kind of sketch this out right so the five threads will call there still they'll each one at a time reduced reduced remain and the first four will go into same weight and then get blocked because there's no pizza slices there but the fifth one has remained value of zero so where when it comes through it will not go into that if statement and instead will call sam post so great	block	324
but the fifth thread will do what ok so here's actually we're going to see is a chain of domino's here releasing one thread after another so the kind of sketch this out right so the five threads will call there still they'll each one at a time reduced reduced remain and the first four will go into same weight and then get blocked because there's no pizza slices there but the fifth one has remained value of zero so where when it comes through it will not go into that if statement and instead will call sam post so great	thread	14
what is the fifth thread do it puts pizza slice back into the counting semaphore right so we've got we've called sam post right so the effect of that is that one of these hungry threads inside here gets to continue gets to steal that slice of pizza and so it can a scape at asem weight and continue ok what does it do equals sam post in other words it adds pizza slice back into the counting semaphore	thread	18
ok so now another thread is allowed to escape so it reduces the count back down to zero and out it comes what does it do it also puts a slice of pizza back into the counting centreport ok so now another one can escape and so on and so on so one after another each escaping prisoner opens the door further next prisoner to escape so we've managed implemented barrier just using a simple	thread	18
counterexample for and its value will only ever be between zero and one right so there is a possibility of some interesting way conditions here where if two threads at the very end the fourth and fifth read for example both came here and saw a value of zero so in this case what would happen would be those two threads would both call sam post but that's ok we just ended up with a barrier where again all the threads will get stuck	thread	157
until the very last thread have changed that value of remain down to zero ok so here's a kind of q example of implementing a single single use thread using accounting said before but if today i wanted to implement a value i of course would use condition variables	thread	20
ok right so in the next video we want to think about the following is the following does not have any kind of potential race conditions ok so i'm going to have some kind of global variable here called please stop and when i set that i also then call peter condition broadcast but in my other threads i do the following ok so if the variable please stop is not set then i want to wait so would that work as implementation detail for making sure that my thread escapes once i've changed please stop right let's talk about that in the next video	the following	53
ok right so in the next video we want to think about the following is the following does not have any kind of potential race conditions ok so i'm going to have some kind of global variable here called please stop and when i set that i also then call peter condition broadcast but in my other threads i do the following ok so if the variable please stop is not set then i want to wait so would that work as implementation detail for making sure that my thread escapes once i've changed please stop right let's talk about that in the next video	thread	292
ok hi so i've got a couple of questions for you first of all why does this implementation suffer from false fragmentation when should we split blocks and are we using explicit or implicit linked list implementation here so let's go for the first one what do we mean by false fragmentation	block	143
ok so this backtrack for moment and realize that we're talking about our heat which is just one large piece of memory but on top of that we've layered a accounting system are using linked lists to say where you can have this chunk or this chunk or this chunk this block is free that blogosphere that blocks not free etc so we've put that as a perspective review on top of this really just a single large piece of memory so here's our problem is that	memory	111
ok so this backtrack for moment and realize that we're talking about our heat which is just one large piece of memory but on top of that we've layered a accounting system are using linked lists to say where you can have this chunk or this chunk or this chunk this block is free that blogosphere that blocks not free etc so we've put that as a perspective review on top of this really just a single large piece of memory so here's our problem is that	block	264
ok so this backtrack for moment and realize that we're talking about our heat which is just one large piece of memory but on top of that we've layered a accounting system are using linked lists to say where you can have this chunk or this chunk or this chunk this block is free that blogosphere that blocks not free etc so we've put that as a perspective review on top of this really just a single large piece of memory so here's our problem is that	system	164
we can end up with situations where my linked list says yes does amuse memory here that's available and some using memory right next door that is available	memory	71
but what we don't do is consider these conceptually as a single large area that could be allocated so if each of these say was ten kilobytes and request for twenty kb came in we wouldn't realize that we could have actually used these two blocks if they were both free	block	238
now fixing this week was a little bit of thought and we've got to be very careful the pointers because remember that actually what we have is come back have a different color is some	pointer	86
areas of memory that we have decided we're going to use to hold that metadata structure for little link	memory	9
areas of memory that we have decided we're going to use to hold that metadata structure for little link	a struct	76
list data so we've got one there an one there and if we got more might have one just here as well etc and inside that yes we had a little pointer that points to the beginning of the user data came and simply for that one etc so if we're going to coalesce these two blocks what we need to end up doing is first of all identified the two blocks next door to each other which are free ok so this book is free this one is free right and combine them together ok so what do we want to end up with we want to end up with the next pointer on here	block	265
list data so we've got one there an one there and if we got more might have one just here as well etc and inside that yes we had a little pointer that points to the beginning of the user data came and simply for that one etc so if we're going to coalesce these two blocks what we need to end up doing is first of all identified the two blocks next door to each other which are free ok so this book is free this one is free right and combine them together ok so what do we want to end up with we want to end up with the next pointer on here	pointer	138
pointing all the way over to this block here and the size of this new block that there could be allocated	block	34
is more than just temper ten because actually there's a bit of extra memory inside here that we no longer need so what about this metadata that we're going to free up that we don't care about anymore do we need to call free on that well no there trick here is to realize that we just walk away from those bits and bytes those numbers inside them they happen to correspond to pointers and integers but we're the ones that are actually doing the allocation here and so if we don't have any pointers that point to this piece of data in the middle here then that's fine and no one else cares	memory	69
is more than just temper ten because actually there's a bit of extra memory inside here that we no longer need so what about this metadata that we're going to free up that we don't care about anymore do we need to call free on that well no there trick here is to realize that we just walk away from those bits and bytes those numbers inside them they happen to correspond to pointers and integers but we're the ones that are actually doing the allocation here and so if we don't have any pointers that point to this piece of data in the middle here then that's fine and no one else cares	pointer	375
metadata block still pointing at the beginning of this one but conceptually we're going to update the size information inside here so that let's say it's	block	9
as the available slicer this ok so that's block coalesce sing and when's the best time to do it answer inside free that's a great place to do it because you know that you are freeing one block and in practice here's a couple of quick hints first of all it might be that you want to coalesce with a free block right next to you that is available or you might want to coalesce with the block behind the current ones so we	block	42
when you're implementing this there's two ways to get yourself into trouble the first is to walk off the end of the world so we keep going past the end link list and you try to follow a null pointer so remember that your link list does actually stop the other similar way of falling off the end of the world	pointer	191
lots of small spaces in our apartment block but actually that is just where we put the partition the false partitions in really we got tons of contiguous space	block	38
ok so that was blocked splitting we can also do the opposite which is cur lessing blocks so let's go back in for a moment and have a look at our code here where we worked remember through are linked list finding a viable entry here and if we did we decided to mark that particular entry as unavailable and we return a pointer to that entry ok so i want you to imagine the following suppose	the following	368
ok so that was blocked splitting we can also do the opposite which is cur lessing blocks so let's go back in for a moment and have a look at our code here where we worked remember through are linked list finding a viable entry here and if we did we decided to mark that particular entry as unavailable and we return a pointer to that entry ok so i want you to imagine the following suppose	block	15
ok so that was blocked splitting we can also do the opposite which is cur lessing blocks so let's go back in for a moment and have a look at our code here where we worked remember through are linked list finding a viable entry here and if we did we decided to mark that particular entry as unavailable and we return a pointer to that entry ok so i want you to imagine the following suppose	code	145
ok so that was blocked splitting we can also do the opposite which is cur lessing blocks so let's go back in for a moment and have a look at our code here where we worked remember through are linked list finding a viable entry here and if we did we decided to mark that particular entry as unavailable and we return a pointer to that entry ok so i want you to imagine the following suppose	pointer	318
so what's happened right so in that very first call to malloc there was are linked list was empty so we went to the system we called ass break and we got ourselves plenty of space enough space to hold the metadata and then immediately after that one hundred kilobytes then we called free what do we do at this point well we didn't call espec again we just simply updated our metadata to say that hey the memory i'm pointing to is now available for free and then my lock was called again with asking for one kilobyte so what do we do we simply change the free point to here to be	memory	404
so what's happened right so in that very first call to malloc there was are linked list was empty so we went to the system we called ass break and we got ourselves plenty of space enough space to hold the metadata and then immediately after that one hundred kilobytes then we called free what do we do at this point well we didn't call espec again we just simply updated our metadata to say that hey the memory i'm pointing to is now available for free and then my lock was called again with asking for one kilobyte so what do we do we simply change the free point to here to be	system	116
zero what does that done to our memory well the caller has only actually requested to use one kilobyte of	memory	32
this block and so all of this remaining space remaining ninety nine kb here going to be unused and we could have done a better job here we could have actually put a link entry into our linked list to say actually not only how do i have this	block	5
piece is in use i've got a new entry of available apartment blocks here and there's another metadata entry that i could write in there and it's pointer is going to point to the space that future caller of malloc actually actually use if they want ninety nine kb or less ok so are there any gotchas in here yeah ok so here's the first gotcha that when you decide to do this block splitting realize that the metadata entry they're going to use is actually going to take up a tiny 's portion of that space let's say thirty two bites we could always use size off to actually determine exactly how much so if the remainder space the remaining space is pretty small if for example that the new malloc call had been for ninety nine point nine kb then we have to start to wonder what point do we not bother to actually split this an conceptually record a new available space there going to be so small for example if the remaining space was only sixteen bytes that might not even be enough to be able to store the metadata so we have to choose some kind of threshold for when to actually make another block and that is actually part of the mp that's been one of the things that you can tweak with your own code is to decide when you should make another block of the remaining of the remaining unused space and when you're just going to ignore it and say oh well that's the overhead of life ok so that's log splitting and the time to do that is when you decide to reuse a block and that there's sufficient space so in other words we're going to write things like ok we've god chose and let's have a look at the chosen size and	block	60
piece is in use i've got a new entry of available apartment blocks here and there's another metadata entry that i could write in there and it's pointer is going to point to the space that future caller of malloc actually actually use if they want ninety nine kb or less ok so are there any gotchas in here yeah ok so here's the first gotcha that when you decide to do this block splitting realize that the metadata entry they're going to use is actually going to take up a tiny 's portion of that space let's say thirty two bites we could always use size off to actually determine exactly how much so if the remainder space the remaining space is pretty small if for example that the new malloc call had been for ninety nine point nine kb then we have to start to wonder what point do we not bother to actually split this an conceptually record a new available space there going to be so small for example if the remaining space was only sixteen bytes that might not even be enough to be able to store the metadata so we have to choose some kind of threshold for when to actually make another block and that is actually part of the mp that's been one of the things that you can tweak with your own code is to decide when you should make another block of the remaining of the remaining unused space and when you're just going to ignore it and say oh well that's the overhead of life ok so that's log splitting and the time to do that is when you decide to reuse a block and that there's sufficient space so in other words we're going to write things like ok we've god chose and let's have a look at the chosen size and	code	1198
piece is in use i've got a new entry of available apartment blocks here and there's another metadata entry that i could write in there and it's pointer is going to point to the space that future caller of malloc actually actually use if they want ninety nine kb or less ok so are there any gotchas in here yeah ok so here's the first gotcha that when you decide to do this block splitting realize that the metadata entry they're going to use is actually going to take up a tiny 's portion of that space let's say thirty two bites we could always use size off to actually determine exactly how much so if the remainder space the remaining space is pretty small if for example that the new malloc call had been for ninety nine point nine kb then we have to start to wonder what point do we not bother to actually split this an conceptually record a new available space there going to be so small for example if the remaining space was only sixteen bytes that might not even be enough to be able to store the metadata so we have to choose some kind of threshold for when to actually make another block and that is actually part of the mp that's been one of the things that you can tweak with your own code is to decide when you should make another block of the remaining of the remaining unused space and when you're just going to ignore it and say oh well that's the overhead of life ok so that's log splitting and the time to do that is when you decide to reuse a block and that there's sufficient space so in other words we're going to write things like ok we've god chose and let's have a look at the chosen size and	pointer	144
so will have some kind of tweaking there to decide some parameter in there to decide what point what's our threshold going to be that we want to create a new block ok right so let's go back and see if we have these questions alright so we talked about block splitting and false presentation and the last question for this little video is our is our implementation using an explicit or implicit link list so this implementation uses an explicit link list meaning that we are throwing pointers around were writing a lot of code that uses memory addresses explicitly we can talk about the memory address of p we cannot talk about members of chosen we could talk about the memory addressing turn to my lock so	memory	536
so will have some kind of tweaking there to decide some parameter in there to decide what point what's our threshold going to be that we want to create a new block ok right so let's go back and see if we have these questions alright so we talked about block splitting and false presentation and the last question for this little video is our is our implementation using an explicit or implicit link list so this implementation uses an explicit link list meaning that we are throwing pointers around were writing a lot of code that uses memory addresses explicitly we can talk about the memory address of p we cannot talk about members of chosen we could talk about the memory addressing turn to my lock so	block	158
so will have some kind of tweaking there to decide some parameter in there to decide what point what's our threshold going to be that we want to create a new block ok right so let's go back and see if we have these questions alright so we talked about block splitting and false presentation and the last question for this little video is our is our implementation using an explicit or implicit link list so this implementation uses an explicit link list meaning that we are throwing pointers around were writing a lot of code that uses memory addresses explicitly we can talk about the memory address of p we cannot talk about members of chosen we could talk about the memory addressing turn to my lock so	parameter	56
so will have some kind of tweaking there to decide some parameter in there to decide what point what's our threshold going to be that we want to create a new block ok right so let's go back and see if we have these questions alright so we talked about block splitting and false presentation and the last question for this little video is our is our implementation using an explicit or implicit link list so this implementation uses an explicit link list meaning that we are throwing pointers around were writing a lot of code that uses memory addresses explicitly we can talk about the memory address of p we cannot talk about members of chosen we could talk about the memory addressing turn to my lock so	code	521
so will have some kind of tweaking there to decide some parameter in there to decide what point what's our threshold going to be that we want to create a new block ok right so let's go back and see if we have these questions alright so we talked about block splitting and false presentation and the last question for this little video is our is our implementation using an explicit or implicit link list so this implementation uses an explicit link list meaning that we are throwing pointers around were writing a lot of code that uses memory addresses explicitly we can talk about the memory address of p we cannot talk about members of chosen we could talk about the memory addressing turn to my lock so	address	543
so will have some kind of tweaking there to decide some parameter in there to decide what point what's our threshold going to be that we want to create a new block ok right so let's go back and see if we have these questions alright so we talked about block splitting and false presentation and the last question for this little video is our is our implementation using an explicit or implicit link list so this implementation uses an explicit link list meaning that we are throwing pointers around were writing a lot of code that uses memory addresses explicitly we can talk about the memory address of p we cannot talk about members of chosen we could talk about the memory addressing turn to my lock so	pointer	483
we have lots of memory dresses and in particular link list when we want to jump from one entry to another we look at the entry code next and that is an explicit address it's got a memory location	memory	16
we have lots of memory dresses and in particular link list when we want to jump from one entry to another we look at the entry code next and that is an explicit address it's got a memory location	code	127
we have lots of memory dresses and in particular link list when we want to jump from one entry to another we look at the entry code next and that is an explicit address it's got a memory location	address	161
and with an implicit linked list we start talking about the sizes of things and we can then use those using pointer arithmetic to calculate a new address so for example if i had an integer pointer	address	146
and with an implicit linked list we start talking about the sizes of things and we can then use those using pointer arithmetic to calculate a new address so for example if i had an integer pointer	pointer	108
so in the next video i'm going to ask you a little challenge which is we saw how we implemented best fit so how would you know right or complete this code so that malloc is a first fit placement allocation ok so how are we going to change that code so it implements first fit i'll see you next video bye	code	150
right so we'll see those a lot with port numbers and there's also the equivalent for four byte numbers as well so each two and for a long were always four bytes and they integers varied between two bytes and four bytes so this was used for when we need to convert ip four addresses as well ok so right next review is what are the four calls we need to set up a server right so hopefully you didn't say get address info no that's just icing on the cake what we do need however is a socket ok and of course we're going to make a passive socket because that's how we make server sockets right what do we want to do next we want to bind it to a local port and in fact we're going to	address	272
so this is what we call accept and except will block if there's no new clients otherwise it returns a new file descriptor force an unused file descriptor number which is which is connected to one particular client one particular connection	block	47
struct won't have been changed at all but in fact this result thing is not just destructive practice appointed to a strict and in fact remember it's a linked list so you could write the code to go through that link list following the next point two and calling free etc or guess what there already is a function to do that for you so if you want an easy life just use this to free up the memory that get address info has reserved on the heat for you	memory	388
struct won't have been changed at all but in fact this result thing is not just destructive practice appointed to a strict and in fact remember it's a linked list so you could write the code to go through that link list following the next point two and calling free etc or guess what there already is a function to do that for you so if you want an easy life just use this to free up the memory that get address info has reserved on the heat for you	code	186
struct won't have been changed at all but in fact this result thing is not just destructive practice appointed to a strict and in fact remember it's a linked list so you could write the code to go through that link list following the next point two and calling free etc or guess what there already is a function to do that for you so if you want an easy life just use this to free up the memory that get address info has reserved on the heat for you	address	404
hi so we've always been a lot of jealous of the hardware people that are able to handle interrupts and changing events from the outside world what can we do with the software well in the software world we actually have something very similar and they called signals or posix signals to be precise the kind of events that we're going to be looking at here and the great thing about positive signals is that they can actually interrupt our code so perhaps we've got deeply piece of nested recursive code perhaps we've got whole lot of nested for loops it's going to take another hour to complete process i've got a while loop that runs forever it doesn't matter with a posix signal i can interrupt it and ask my function or my process to run another piece of code right now so basically	code	438
and this will happen typically as result of some hardware event so for example the cpu notices that your process is attempting to write into some invalid memory and the actual cpu catches that to attempt to read or write to an incorrect memory address and that causes an interrupt we stopped reading your stop reading your process code the kernel code runs instead which ultimately generates segfault which by default kills you process of course but we	memory	154
and this will happen typically as result of some hardware event so for example the cpu notices that your process is attempting to write into some invalid memory and the actual cpu catches that to attempt to read or write to an incorrect memory address and that causes an interrupt we stopped reading your stop reading your process code the kernel code runs instead which ultimately generates segfault which by default kills you process of course but we	code	331
and this will happen typically as result of some hardware event so for example the cpu notices that your process is attempting to write into some invalid memory and the actual cpu catches that to attempt to read or write to an incorrect memory address and that causes an interrupt we stopped reading your stop reading your process code the kernel code runs instead which ultimately generates segfault which by default kills you process of course but we	address	244
this is our little hate please need to interrupt the program and by default of course that stops the process however we can make programs where it doesn't start the process and we can actually make it do other things as well then we've seen cr segfault where by default again it stopped process and that signal is generated by the kernel when we tried to read or write invalid memory and the last one ok so kill so the surprising thing about said kill is that are part of the process cannot avoid it they cannot run away from this event it cannot change this behavior no sick kill is when we want to stop all processes and they don't have a choice about this so you is nothing you can do about sigkill you will not get any prior notification is like an asteroid arriving at the speed of light that there's no prior warning no particulates going to simply stop your process "and you won't be able to prevent that so that's sigkill it's when you want to terminate the process and you want no other options so if you've got a runaway chrome browser refuses to stop sigkill is going to be the answer ok so i think it's time we did a demo of this ok so for this demo i'm going to need some kind of little program to send signals to so here it is it's a little dot right but it writes a single period once the second here so you can see that i'm calling right and what am i going to write i'm sending out to standard out	memory	377
here's the address i'm giving their dress with string literal and i'm asking right to say ok i'm giving you an address another address i want you to take one bike to please and because we're using the low level posit calls rather than the c library that that bite is immediately going to be written out to standard out so we'll see it straight away it won't be any buffering and then we say ok please sleep with one second now this is not some expensive for loop that burns up the cpu and keeps our house is warm at night no instead the cpu at that point is going to be	string	47
here's the address i'm giving their dress with string literal and i'm asking right to say ok i'm giving you an address another address i want you to take one bike to please and because we're using the low level posit calls rather than the c library that that bite is immediately going to be written out to standard out so we'll see it straight away it won't be any buffering and then we say ok please sleep with one second now this is not some expensive for loop that burns up the cpu and keeps our house is warm at night no instead the cpu at that point is going to be	address	11
ok let's put my code here and clean that out so i have my little dot writer where are you	code	16
ok make it a little bit bigger right so what do they do that because i want to do two things at the same time i want two windows over here ok so great let's do that let's do my little dot right over here so if you go a little bit later ok right so now let's have some fun with my little light of course i could just press ctrl c and it stops nothing new there but how about we want to start sending out signals so from the command line we can type kill and then we can say which signal so i could might say alright send second and i'm going to send it to process number four seven oh eight three ok and it stopped right so just like pressing ctrl c ok will	type	443
and it can it detect that it's child was killed by a signal it says killed night here's why because every systems programmer knows that signal nine is actually sigkill and so sometimes you'll see on forums that you know that we really need to kind of minus nine that so let's just do that again this time with a number of the case so will send it with minus nine four seven oh it would help if i type correctly	type	396
and it can it detect that it's child was killed by a signal it says killed night here's why because every systems programmer knows that signal nine is actually sigkill and so sometimes you'll see on forums that you know that we really need to kind of minus nine that so let's just do that again this time with a number of the case so will send it with minus nine four seven oh it would help if i type correctly	system	106
sir let's go have a look at that right so if i type man kill i get the wrong thing i get the thing that i can type on the command line so as you can see in the top left and right hand corner that i'm actually in section one of the manual so that's great if you're trying to do something from your shell not so great if it won't actually program c code ok so let's get out of that	type	47
sir let's go have a look at that right so if i type man kill i get the wrong thing i get the thing that i can type on the command line so as you can see in the top left and right hand corner that i'm actually in section one of the manual so that's great if you're trying to do something from your shell not so great if it won't actually program c code ok so let's get out of that	code	347
sir let's go have a look at that right so if i type man kill i get the wrong thing i get the thing that i can type on the command line so as you can see in the top left and right hand corner that i'm actually in section one of the manual so that's great if you're trying to do something from your shell not so great if it won't actually program c code ok so let's get out of that	section	212
ok let's have a look at section two ok this is more like it so now you can see we need to process id and the signal that would lead to set ok and there's more stuff we can do with it alright so i will need hash include signature h so let's go back to my editor and look at that i happen to have some useful types already included up here so let's see where we're going to kill this and we wanted to send the process id so let's get pid and which signal today so we wanted to send equivalent of pressing ctrl c ok so let's do that and run this so i need my little dot lighter again off you off you go	type	307
ok let's have a look at section two ok this is more like it so now you can see we need to process id and the signal that would lead to set ok and there's more stuff we can do with it alright so i will need hash include signature h so let's go back to my editor and look at that i happen to have some useful types already included up here so let's see where we're going to kill this and we wanted to send the process id so let's get pid and which signal today so we wanted to send equivalent of pressing ctrl c ok so let's do that and run this so i need my little dot lighter again off you off you go	section	24
and it will take a number the signal number that happened ok and we need to do something at this point so let's have a little message let's say don't do that and will print it out directly so we use right i'll send it to say standard out and i want to send it message how many characters will have stroller and characters to send ok i can't use size often the way that i've written this code because messages just a pointer and let's have a little newline ok wait so i somehow i need a way to say call this code when control c is pressed here's how we're going to do it there's a little thing called signal i'm going to show you better ways to do this later on in the course and you can read online about sick action but this is the simplest way to get started	code	387
and it will take a number the signal number that happened ok and we need to do something at this point so let's have a little message let's say don't do that and will print it out directly so we use right i'll send it to say standard out and i want to send it message how many characters will have stroller and characters to send ok i can't use size often the way that i've written this code because messages just a pointer and let's have a little newline ok wait so i somehow i need a way to say call this code when control c is pressed here's how we're going to do it there's a little thing called signal i'm going to show you better ways to do this later on in the course and you can read online about sick action but this is the simplest way to get started	pointer	416
and for cigna action so it's for signal all we need is the function name and the signal that we want to connect it to i discover which we wanted to use this so i guess what i want to use the manpages right so if i do signal discover something that looks disgusting but that way that's just a function pointer today we're just going to concentrate on disk that says oh look i just need a signal and the function after it so let's do that ok so i need the signal i want to say if a second happens don't do the default behavior which is to kill my process but instead here's the address of a function how do i get the address of the function you could either put an ampersand in front of the fund function name or if you just use the function then their function named end ceases oh you must be talking about where this is in memory what you should not do is put parentheses after it because now you're saying at this moment call this function that's not what we need we just want the actual function that we're going to call	memory	823
and for cigna action so it's for signal all we need is the function name and the signal that we want to connect it to i discover which we wanted to use this so i guess what i want to use the manpages right so if i do signal discover something that looks disgusting but that way that's just a function pointer today we're just going to concentrate on disk that says oh look i just need a signal and the function after it so let's do that ok so i need the signal i want to say if a second happens don't do the default behavior which is to kill my process but instead here's the address of a function how do i get the address of the function you could either put an ampersand in front of the fund function name or if you just use the function then their function named end ceases oh you must be talking about where this is in memory what you should not do is put parentheses after it because now you're saying at this moment call this function that's not what we need we just want the actual function that we're going to call	address	576
and for cigna action so it's for signal all we need is the function name and the signal that we want to connect it to i discover which we wanted to use this so i guess what i want to use the manpages right so if i do signal discover something that looks disgusting but that way that's just a function pointer today we're just going to concentrate on disk that says oh look i just need a signal and the function after it so let's do that ok so i need the signal i want to say if a second happens don't do the default behavior which is to kill my process but instead here's the address of a function how do i get the address of the function you could either put an ampersand in front of the fund function name or if you just use the function then their function named end ceases oh you must be talking about where this is in memory what you should not do is put parentheses after it because now you're saying at this moment call this function that's not what we need we just want the actual function that we're going to call	pointer	301
and i made sure that is the right type and so now let's run this ok wait and	type	34
compile and we better get stroller and string on each ok	string	39
that you can send signals from the terminal but just by typing kill and then either a number like minus nine or something like sigint well how would you implement this kill command and i wanted to impress upon you that all these commands you type like kill like ls like gcc there just little programs often their written in c in fact if you do something like cat dot c you can probably find the source code of capital see if you type that into google anyway so we want to write a little program that's called kill dot c which can take a process id and	type	242
that you can send signals from the terminal but just by typing kill and then either a number like minus nine or something like sigint well how would you implement this kill command and i wanted to impress upon you that all these commands you type like kill like ls like gcc there just little programs often their written in c in fact if you do something like cat dot c you can probably find the source code of capital see if you type that into google anyway so we want to write a little program that's called kill dot c which can take a process id and	code	402
that you can send signals from the terminal but just by typing kill and then either a number like minus nine or something like sigint well how would you implement this kill command and i wanted to impress upon you that all these commands you type like kill like ls like gcc there just little programs often their written in c in fact if you do something like cat dot c you can probably find the source code of capital see if you type that into google anyway so we want to write a little program that's called kill dot c which can take a process id and	a process	535
if they look both valid what would we put in here ok so now i need to write some code and see if i've got	code	81
and for that we really don't need to understand how to work with errors and how to print out errors and how to discover when things don't work so networking is tricky because with things don't work where you actually want to understand what your problem with the client or the server was there a problem in setting up the connection and so dealing with errors becomes quite important areas can be because of code areas we've made but it also can be say because the client has finished the connection before the server had finished saying everything he wanted to say unvoice versa ok so let's start talking about errors that right so	code	408
you want to put out some errors ok so here's first way you've probably seen things like ok i can use p error to print an error to standard error and i can include piece of text here which gets included along with some standard string ok there's also if you prefer a way to get just a simple string and this is it you can say store error and i can ask for a	string	227
the string associated with a particular error number like one two three four five etc etc etc ok but perhaps you want to know what is actually just gone wrong with your program and so if you want to find out the air associated with a recent system call guess what there is something called ever know urdu there we go so i could say please tell me	string	4
the string associated with a particular error number like one two three four five etc etc etc ok but perhaps you want to know what is actually just gone wrong with your program and so if you want to find out the air associated with a recent system call guess what there is something called ever know urdu there we go so i could say please tell me	system	241
the these string associated with the most recent system ever ok so in fact we could re implement pm so if we needed to write kind of piero ourselves we might do something like the following we might say ok so peer error i just want to print out to standard error	the following	176
the these string associated with the most recent system ever ok so in fact we could re implement pm so if we needed to write kind of piero ourselves we might do something like the following we might say ok so peer error i just want to print out to standard error	string	10
the these string associated with the most recent system ever ok so in fact we could re implement pm so if we needed to write kind of piero ourselves we might do something like the following we might say ok so peer error i just want to print out to standard error	system	49
format string to say whatever the user said ok cologne another	string	7
ok and then another string	string	20
right so there's a one big surprising gotcher however with string ever and if the following if we actually read the manpage we discover that let's come back	the following	78
right so there's a one big surprising gotcher however with string ever and if the following if we actually read the manpage we discover that let's come back	string	59
a different color that it is not thread safe	thread	33
video surprise right here we are using this low function inside here and we thought we could do everything we wanted inside our threads it's not thread safe key and if we instead we actually want to write code that is two s dave then	code	205
video surprise right here we are using this low function inside here and we thought we could do everything we wanted inside our threads it's not thread safe key and if we instead we actually want to write code that is two s dave then	thread	128
so the reason for that is that string air itself might return just a hardcoded string literal safer error number one two three four five six etc but if you pass an arbitrary large number it actually constructs	code	73
so the reason for that is that string air itself might return just a hardcoded string literal safer error number one two three four five six etc but if you pass an arbitrary large number it actually constructs	string	31
the string itself and how it might do that well it could call malloc except that stuart air itself doesn't ask you to return anything instead it just returns a pointer so instead internally has some static	string	4
the string itself and how it might do that well it could call malloc except that stuart air itself doesn't ask you to return anything instead it just returns a pointer so instead internally has some static	pointer	160
static memory that it reuses from one call to the next ok so that's our problem that if i'm going to use this in multiple threads i could have one call to store arribe be entered by another call to stuart error	memory	7
static memory that it reuses from one call to the next ok so that's our problem that if i'm going to use this in multiple threads i could have one call to store arribe be entered by another call to stuart error	thread	122
on a different thread an oh dear both of them are now trying to use the same piece of static memory so one hour is going to override the other one right so this kind of common with some of the earlier calls inside posix that they weren't built with with threads in mind and so threat support the ability to work with multiple threads has kind of been reverse engineered back into some of these api calls so stroit error itself with this underscore r will discover actually	memory	93
on a different thread an oh dear both of them are now trying to use the same piece of static memory so one hour is going to override the other one right so this kind of common with some of the earlier calls inside posix that they weren't built with with threads in mind and so threat support the ability to work with multiple threads has kind of been reverse engineered back into some of these api calls so stroit error itself with this underscore r will discover actually	thread	15
doesn't have doesn't take just a simple integer for the integer or no instead you also pass in a pointer to your memory that you would like it to use so here's some memory and typically as well you impasse in how much many as well so we could pull up a terminal window to see the exact order of these things but what i want you to learn yeah there's quite a few of these kind of underscore are variations or variants of existing course and they were added later to posix	memory	113
doesn't have doesn't take just a simple integer for the integer or no instead you also pass in a pointer to your memory that you would like it to use so here's some memory and typically as well you impasse in how much many as well so we could pull up a terminal window to see the exact order of these things but what i want you to learn yeah there's quite a few of these kind of underscore are variations or variants of existing course and they were added later to posix	a terminal	251
doesn't have doesn't take just a simple integer for the integer or no instead you also pass in a pointer to your memory that you would like it to use so here's some memory and typically as well you impasse in how much many as well so we could pull up a terminal window to see the exact order of these things but what i want you to learn yeah there's quite a few of these kind of underscore are variations or variants of existing course and they were added later to posix	pointer	97
in order to make it more thread safe now the last thing you might have been thinking about when i was talking about this is hold on a moment what about earner what is this other thing and wins it set ok so oh no is set by most system calls that can fail so for example read or write set errno to tell you what went wrong so if you call right and it doesn't work	thread	25
in order to make it more thread safe now the last thing you might have been thinking about when i was talking about this is hold on a moment what about earner what is this other thing and wins it set ok so oh no is set by most system calls that can fail so for example read or write set errno to tell you what went wrong so if you call right and it doesn't work	system	227
oh dear it will return negative one but you want to find out more about what went wrong so that information is encoded inside this global variable but wait a moment if i've got a multithreaded program surely it's going to be really hard to figure out which particular thread on which system call caused evernote change	code	113
oh dear it will return negative one but you want to find out more about what went wrong so that information is encoded inside this global variable but wait a moment if i've got a multithreaded program surely it's going to be really hard to figure out which particular thread on which system call caused evernote change	thread	184
oh dear it will return negative one but you want to find out more about what went wrong so that information is encoded inside this global variable but wait a moment if i've got a multithreaded program surely it's going to be really hard to figure out which particular thread on which system call caused evernote change	system	284
yes you are correct and now i'm forced to tell you that actually ok that ever know actually for multithreaded programs	thread	101
is a very special variably behaves like a global variable but actually it's three uses thread local storage which means that each thread gets his own copy thread local storage each thread gets its own copy of error	thread	87
it still behaves like a global variable but the value that each thread reads is actually specific to that thread so now you can confidently say oh yes that most recent call to read	thread	64
or write or say creating a pipe that if it failed then i can read my own value of errno to find out why it fell ok wait so in the next video we're going to talk about what happens when system calls get interrupted i'll see you then bye	system	185
ok so we've kind of talked a little bit about this idea before so it could i implement p thread mutex lock just by disabling interrupts on on the cpu so the idea here is that if my code is running on the cpu if i disable interrupts then i cannot be stopped become agent smith out of the matrix that now i own the cpu so no one else can can take it for me so one of the limitations of this first of all that yes we can ensure that we're the only ones going into the critical section if one there is only one cpu	code	181
ok so we've kind of talked a little bit about this idea before so it could i implement p thread mutex lock just by disabling interrupts on on the cpu so the idea here is that if my code is running on the cpu if i disable interrupts then i cannot be stopped become agent smith out of the matrix that now i own the cpu so no one else can can take it for me so one of the limitations of this first of all that yes we can ensure that we're the only ones going into the critical section if one there is only one cpu	section	474
ok so we've kind of talked a little bit about this idea before so it could i implement p thread mutex lock just by disabling interrupts on on the cpu so the idea here is that if my code is running on the cpu if i disable interrupts then i cannot be stopped become agent smith out of the matrix that now i own the cpu so no one else can can take it for me so one of the limitations of this first of all that yes we can ensure that we're the only ones going into the critical section if one there is only one cpu	thread	89
ok so if i control the one and only cpu and i cannot be interrupted then i get to do everything inside the critical section until i give up the cpu ok so providing i don't make any system calls providing i'm just updating my data structure no one can stop me because i disabled into apps	a struct	228
ok so if i control the one and only cpu and i cannot be interrupted then i get to do everything inside the critical section until i give up the cpu ok so providing i don't make any system calls providing i'm just updating my data structure no one can stop me because i disabled into apps	section	116
ok so if i control the one and only cpu and i cannot be interrupted then i get to do everything inside the critical section until i give up the cpu ok so providing i don't make any system calls providing i'm just updating my data structure no one can stop me because i disabled into apps	system	181
ok the second is that i require an here's a big problem here is that actually require sufficient privileges to disable the interrupts and because this is such a powerful operation by default that is disabled for normal user programs we need interrupts in order to make a cpu stop running one thread and start running another in order to handle hardware interrupt you too do to devices iot devices being ready to either take data from the system or give data from the system for example the network card might report that her new packages arrived and here's some data or a disk or solid state disk might report hey i've now finally got the data you can now read this into memory or gpu might ask for more memory more data so there's lots	memory	671
ok the second is that i require an here's a big problem here is that actually require sufficient privileges to disable the interrupts and because this is such a powerful operation by default that is disabled for normal user programs we need interrupts in order to make a cpu stop running one thread and start running another in order to handle hardware interrupt you too do to devices iot devices being ready to either take data from the system or give data from the system for example the network card might report that her new packages arrived and here's some data or a disk or solid state disk might report hey i've now finally got the data you can now read this into memory or gpu might ask for more memory more data so there's lots	thread	292
ok the second is that i require an here's a big problem here is that actually require sufficient privileges to disable the interrupts and because this is such a powerful operation by default that is disabled for normal user programs we need interrupts in order to make a cpu stop running one thread and start running another in order to handle hardware interrupt you too do to devices iot devices being ready to either take data from the system or give data from the system for example the network card might report that her new packages arrived and here's some data or a disk or solid state disk might report hey i've now finally got the data you can now read this into memory or gpu might ask for more memory more data so there's lots	system	438
of reasons why we in over a normal complex system we cannot just disable disable interrupts ok so this	system	43
is one solution to the critical section but like i said it's not a generally useful solution to the critical section we need to find a way to be able to kind of implement these correctly and will talk about some algorithmic concerns about that in the future instead now is what i've got a real challenge for you which is i want to implement a barrier in fact i'm going to give you all the code that you need here it is i just want to implement a barrier that will wait until five threads call this method called this function and i've got to keep track of how many there we go and all i'm going to give you is the following code which uses a counting semaphore so you get to choose how what you would like to implement what you'd like to to initialize is counting semaphore with and all you have to do is rearrange these lines enter the correct order so that's my challenge to you pause this video and see if you can work it out i'll give you the solution next video but before you do that make some brain new brain cell connections and actually think about how you're going to rearrange this code to the actually works by	the following	610
is one solution to the critical section but like i said it's not a generally useful solution to the critical section we need to find a way to be able to kind of implement these correctly and will talk about some algorithmic concerns about that in the future instead now is what i've got a real challenge for you which is i want to implement a barrier in fact i'm going to give you all the code that you need here it is i just want to implement a barrier that will wait until five threads call this method called this function and i've got to keep track of how many there we go and all i'm going to give you is the following code which uses a counting semaphore so you get to choose how what you would like to implement what you'd like to to initialize is counting semaphore with and all you have to do is rearrange these lines enter the correct order so that's my challenge to you pause this video and see if you can work it out i'll give you the solution next video but before you do that make some brain new brain cell connections and actually think about how you're going to rearrange this code to the actually works by	code	389
is one solution to the critical section but like i said it's not a generally useful solution to the critical section we need to find a way to be able to kind of implement these correctly and will talk about some algorithmic concerns about that in the future instead now is what i've got a real challenge for you which is i want to implement a barrier in fact i'm going to give you all the code that you need here it is i just want to implement a barrier that will wait until five threads call this method called this function and i've got to keep track of how many there we go and all i'm going to give you is the following code which uses a counting semaphore so you get to choose how what you would like to implement what you'd like to to initialize is counting semaphore with and all you have to do is rearrange these lines enter the correct order so that's my challenge to you pause this video and see if you can work it out i'll give you the solution next video but before you do that make some brain new brain cell connections and actually think about how you're going to rearrange this code to the actually works by	section	32
is one solution to the critical section but like i said it's not a generally useful solution to the critical section we need to find a way to be able to kind of implement these correctly and will talk about some algorithmic concerns about that in the future instead now is what i've got a real challenge for you which is i want to implement a barrier in fact i'm going to give you all the code that you need here it is i just want to implement a barrier that will wait until five threads call this method called this function and i've got to keep track of how many there we go and all i'm going to give you is the following code which uses a counting semaphore so you get to choose how what you would like to implement what you'd like to to initialize is counting semaphore with and all you have to do is rearrange these lines enter the correct order so that's my challenge to you pause this video and see if you can work it out i'll give you the solution next video but before you do that make some brain new brain cell connections and actually think about how you're going to rearrange this code to the actually works by	thread	480
ok so let's play with race conditions and then fixing with blocks right so what do you think the following code is going to print here we have a counter variable which is global as you can see anybody can reach into it and read it or write it and in fact like a little function here that is going to loop looks like a million times and each time around the loop we're going to implement that counter now the value of eyes a stack variable which means i can create a whole load of threads and each one is going to get his own value of i but they are all picking at this global variable this countered so they're going to share access to that that variable right and then i've got some code on here peter create peter create and then two p thread joins so out of the two p thread joins we print out the value of counter right so what do you think about this code what's it going to print let's give it ago so i need to compile it ok i've compiled it off we go right it did not print out of course two million it we run it it just happy prints out different values each and every time so why do you think that is a key so actually there's two reasons the first one is because it the value that we get depends upon the actual interleaving of my two threads to how they do this increment so even though we plus plus hear	the following	93
ok so let's play with race conditions and then fixing with blocks right so what do you think the following code is going to print here we have a counter variable which is global as you can see anybody can reach into it and read it or write it and in fact like a little function here that is going to loop looks like a million times and each time around the loop we're going to implement that counter now the value of eyes a stack variable which means i can create a whole load of threads and each one is going to get his own value of i but they are all picking at this global variable this countered so they're going to share access to that that variable right and then i've got some code on here peter create peter create and then two p thread joins so out of the two p thread joins we print out the value of counter right so what do you think about this code what's it going to print let's give it ago so i need to compile it ok i've compiled it off we go right it did not print out of course two million it we run it it just happy prints out different values each and every time so why do you think that is a key so actually there's two reasons the first one is because it the value that we get depends upon the actual interleaving of my two threads to how they do this increment so even though we plus plus hear	the loop	353
ok so let's play with race conditions and then fixing with blocks right so what do you think the following code is going to print here we have a counter variable which is global as you can see anybody can reach into it and read it or write it and in fact like a little function here that is going to loop looks like a million times and each time around the loop we're going to implement that counter now the value of eyes a stack variable which means i can create a whole load of threads and each one is going to get his own value of i but they are all picking at this global variable this countered so they're going to share access to that that variable right and then i've got some code on here peter create peter create and then two p thread joins so out of the two p thread joins we print out the value of counter right so what do you think about this code what's it going to print let's give it ago so i need to compile it ok i've compiled it off we go right it did not print out of course two million it we run it it just happy prints out different values each and every time so why do you think that is a key so actually there's two reasons the first one is because it the value that we get depends upon the actual interleaving of my two threads to how they do this increment so even though we plus plus hear	block	59
ok so let's play with race conditions and then fixing with blocks right so what do you think the following code is going to print here we have a counter variable which is global as you can see anybody can reach into it and read it or write it and in fact like a little function here that is going to loop looks like a million times and each time around the loop we're going to implement that counter now the value of eyes a stack variable which means i can create a whole load of threads and each one is going to get his own value of i but they are all picking at this global variable this countered so they're going to share access to that that variable right and then i've got some code on here peter create peter create and then two p thread joins so out of the two p thread joins we print out the value of counter right so what do you think about this code what's it going to print let's give it ago so i need to compile it ok i've compiled it off we go right it did not print out of course two million it we run it it just happy prints out different values each and every time so why do you think that is a key so actually there's two reasons the first one is because it the value that we get depends upon the actual interleaving of my two threads to how they do this increment so even though we plus plus hear	code	107
ok so let's play with race conditions and then fixing with blocks right so what do you think the following code is going to print here we have a counter variable which is global as you can see anybody can reach into it and read it or write it and in fact like a little function here that is going to loop looks like a million times and each time around the loop we're going to implement that counter now the value of eyes a stack variable which means i can create a whole load of threads and each one is going to get his own value of i but they are all picking at this global variable this countered so they're going to share access to that that variable right and then i've got some code on here peter create peter create and then two p thread joins so out of the two p thread joins we print out the value of counter right so what do you think about this code what's it going to print let's give it ago so i need to compile it ok i've compiled it off we go right it did not print out of course two million it we run it it just happy prints out different values each and every time so why do you think that is a key so actually there's two reasons the first one is because it the value that we get depends upon the actual interleaving of my two threads to how they do this increment so even though we plus plus hear	thread	480
the big news flash is that this is not an atomic operation so what we mean by atomic well you enough uranium together no we don't mean that what we mean by atomic here is it is that an atomic operation it behaves as if it completes as one complete operation but that's not true not for plus plus here so instead what is going on we're saying ok read the value of counter add one to it and then right back into memory so there's three distinct stages here	memory	410
we go over to main memory you will see he may maybe i need to read the following four bytes please ok we pull that into a cpu register then we invoke the arithmetic logic unit to add one to our register ok so we've recalculated new value and then we take that bit pattern and we throw it back towards memory here you go memory have a new value the adding one is extremely fast writing to main memory is extremely slow compared to what the cpu can do so of course practice we have levels of cash operating but let's	the following	67
we go over to main memory you will see he may maybe i need to read the following four bytes please ok we pull that into a cpu register then we invoke the arithmetic logic unit to add one to our register ok so we've recalculated new value and then we take that bit pattern and we throw it back towards memory here you go memory have a new value the adding one is extremely fast writing to main memory is extremely slow compared to what the cpu can do so of course practice we have levels of cash operating but let's	memory	19
alright so that's the kind of first idea is that i've got two chefs two threads running as fast as possible really from memory adding on writing it back	memory	120
alright so that's the kind of first idea is that i've got two chefs two threads running as fast as possible really from memory adding on writing it back	thread	72
life would be fine if they did this carefully synchronized but instead you could imagine that our two threads go over and read the same value and then they add one at about the same time and then they write back their new values so instead of increasing the value by two we've only increased it by one you can imagine more extreme variations where one thread is running a bit slow perhaps my cpu keeps on being interrupted because it's being asked to transcode some videos as as i as i'm talking to you and so now the other thread is able to run forward a bit so imagine the following one thread reaches in grabs the number	the following	571
life would be fine if they did this carefully synchronized but instead you could imagine that our two threads go over and read the same value and then they add one at about the same time and then they write back their new values so instead of increasing the value by two we've only increased it by one you can imagine more extreme variations where one thread is running a bit slow perhaps my cpu keeps on being interrupted because it's being asked to transcode some videos as as i as i'm talking to you and so now the other thread is able to run forward a bit so imagine the following one thread reaches in grabs the number	code	456
life would be fine if they did this carefully synchronized but instead you could imagine that our two threads go over and read the same value and then they add one at about the same time and then they write back their new values so instead of increasing the value by two we've only increased it by one you can imagine more extreme variations where one thread is running a bit slow perhaps my cpu keeps on being interrupted because it's being asked to transcode some videos as as i as i'm talking to you and so now the other thread is able to run forward a bit so imagine the following one thread reaches in grabs the number	thread	102
i know it's doing the calculation or at least it's going to get to the calculations soon meanwhile the other thread reaches in grabs the number add one send it back breaches in addison number as well and send it back which anson does like like a million times then our first red wakes up again a few i got cpu again fantastic what was i doing oh yes i was adding one at one right it back so it's just managed to write over all of those results taking years back to a really low number so that is kind of the problem of just letting our threads run without any kind of proper synchronization so i mentioned there were two bugs the other one actually is just an insidious copy paste bug did you spot it ok so we call pthread create here	thread	109
or with the same id address here which means that our second thread id here is actually was never initialized	thread	61
or with the same id address here which means that our second thread id here is actually was never initialized	address	20
so we never actually truly going to wait for that second thread to actually complete case so so we should fix that let's make sure that we are writing into two different two different variables	thread	57
right so i promise we start using p thread mutex locks so here we go let's figure out how we can fix this program alright so xm ideas we can try here first of all let's get our self lock will make it a global so all my programs can see it if i didn't use globals i'd have to pass it around or least pass a pointer around to it right so p three edit musics type i'm going to call it a duck i want to imagine little duck quack quack that's very important little lock and today i'll use the the magic value piece red mutex initializer	type	356
right so i promise we start using p thread mutex locks so here we go let's figure out how we can fix this program alright so xm ideas we can try here first of all let's get our self lock will make it a global so all my programs can see it if i didn't use globals i'd have to pass it around or least pass a pointer around to it right so p three edit musics type i'm going to call it a duck i want to imagine little duck quack quack that's very important little lock and today i'll use the the magic value piece red mutex initializer	thread	36
right so i promise we start using p thread mutex locks so here we go let's figure out how we can fix this program alright so xm ideas we can try here first of all let's get our self lock will make it a global so all my programs can see it if i didn't use globals i'd have to pass it around or least pass a pointer around to it right so p three edit musics type i'm going to call it a duck i want to imagine little duck quack quack that's very important little lock and today i'll use the the magic value piece red mutex initializer	pointer	306
ok how do you feel about this so before doing any work in my data structure i'm going to grab the duck here so how do i do that as a pthread mutex lock and here's the address of my variable	a struct	64
ok how do you feel about this so before doing any work in my data structure i'm going to grab the duck here so how do i do that as a pthread mutex lock and here's the address of my variable	thread	134
ok how do you feel about this so before doing any work in my data structure i'm going to grab the duck here so how do i do that as a pthread mutex lock and here's the address of my variable	address	167
but we never let it go so when the second thread starts and calls preferred mutex locked it's going to be waiting for a very long time an infinite amount of time it never gets that duck that duck has been stolen by the first red and never returned so as a result the second thread will never finish so as a result rp so join in maine will never complete so as a result will never put the counter ok i think we better fix that let's put in their pthread mutex unlock there you go after i finished in my surgery on the data structure i'm going to give the duck back at which point is this anybody else waiting for the duck they too can grab the duck and then carry on	the data structure	513
but we never let it go so when the second thread starts and calls preferred mutex locked it's going to be waiting for a very long time an infinite amount of time it never gets that duck that duck has been stolen by the first red and never returned so as a result the second thread will never finish so as a result rp so join in maine will never complete so as a result will never put the counter ok i think we better fix that let's put in their pthread mutex unlock there you go after i finished in my surgery on the data structure i'm going to give the duck back at which point is this anybody else waiting for the duck they too can grab the duck and then carry on	a struct	520
but we never let it go so when the second thread starts and calls preferred mutex locked it's going to be waiting for a very long time an infinite amount of time it never gets that duck that duck has been stolen by the first red and never returned so as a result the second thread will never finish so as a result rp so join in maine will never complete so as a result will never put the counter ok i think we better fix that let's put in their pthread mutex unlock there you go after i finished in my surgery on the data structure i'm going to give the duck back at which point is this anybody else waiting for the duck they too can grab the duck and then carry on	thread	42
ok and ha who've are yes guess gratulation 's we've managed to make another finished lee complicated program to add up to two million by using now kind of three for threads the main thread which doesn't do much it just delegates like a manager doesn't actually do any work and then two threads which are independently adding up a million but you did notice that actually we don't actually do any of the work in parallel first a thread probably the probably thread one but who knows actual add a million and then when it's finished it releases the duck and so the other thread gets to continue it requires a duck carries on adds a million to it and then unlock the duck ok so	a thread	426
ok and ha who've are yes guess gratulation 's we've managed to make another finished lee complicated program to add up to two million by using now kind of three for threads the main thread which doesn't do much it just delegates like a manager doesn't actually do any work and then two threads which are independently adding up a million but you did notice that actually we don't actually do any of the work in parallel first a thread probably the probably thread one but who knows actual add a million and then when it's finished it releases the duck and so the other thread gets to continue it requires a duck carries on adds a million to it and then unlock the duck ok so	thread	165
maybe we should allow our threads to work in smaller units so what we think we could try here is let's make a version three right well now i'm going to only acquire my doc for a very short period of time case so now i'm going to rap each call to before i change the counter	thread	26
k von function three so for a million times we acquire the lock we had wanted to counter and then we unlock the duck ok so let's compile this run it ok it gave us a correct answer and will always give us a correct answer but is now actually a little bit slower do you know why well in this contrived example adding one to a variable is an extremely fast operation compared to a typical program where we've got thousand instructions to do and in a typical program we only want to access this data structure this shared data structure occasionally so we've just managed to modify our original program	a struct	494
which would just increment the counter to now accessing the mutex changing the counter unlocking the mutex so we've actually added a lot more complexity in terms of number of structures that have to be executed for each iteration vanderloop ok so that wasn't didn't make a program any faster and in fact it slowed it down a bit just because we're using their lock in such a fine grained manner but it didn't sure that are two threads could actually carry carry on now and finish it about the same time so now we've got an interleaving of our two threads but we've ensured that the actual change of the data structure only happens in one thread or the other thread at a time	the data structure	598
which would just increment the counter to now accessing the mutex changing the counter unlocking the mutex so we've actually added a lot more complexity in terms of number of structures that have to be executed for each iteration vanderloop ok so that wasn't didn't make a program any faster and in fact it slowed it down a bit just because we're using their lock in such a fine grained manner but it didn't sure that are two threads could actually carry carry on now and finish it about the same time so now we've got an interleaving of our two threads but we've ensured that the actual change of the data structure only happens in one thread or the other thread at a time	a struct	605
which would just increment the counter to now accessing the mutex changing the counter unlocking the mutex so we've actually added a lot more complexity in terms of number of structures that have to be executed for each iteration vanderloop ok so that wasn't didn't make a program any faster and in fact it slowed it down a bit just because we're using their lock in such a fine grained manner but it didn't sure that are two threads could actually carry carry on now and finish it about the same time so now we've got an interleaving of our two threads but we've ensured that the actual change of the data structure only happens in one thread or the other thread at a time	thread	426
my i've got two threads two cpus actually trying to read a right to the same piece piece of memory what if that value was cached or the good news actually is depleted mutex lock takes care of that as well for us that if this cpu supports some caching mechanisms peter mutex lock will ensure that that values are flushed out to main memory if any other cpu wants to read these	memory	92
my i've got two threads two cpus actually trying to read a right to the same piece piece of memory what if that value was cached or the good news actually is depleted mutex lock takes care of that as well for us that if this cpu supports some caching mechanisms peter mutex lock will ensure that that values are flushed out to main memory if any other cpu wants to read these	thread	16
magnets so technically it's called memory fence what memory barrier	memory	35
we're not going to write code that does not explicitly instead we're just kind of allowing the factor period mutex lock makes our world saying again makes our programs be equal to all the process is i've actually	code	25
running at least that's what it appears to be like that the values in memory other values that we expect to see in memory ok with some of course slight slight loss in performance when we do that ok so that's our first example of of contrived example of using petered mutex lock	memory	70
colon and then the port number so if we get and what what do we see we actually see that this little module by by python gives me a directory listing and then i can click on a link here ok and actually see the code that we just wrote today which is kind of fun	code	210
ok and if i wanted i could have a little website here as well so now let's do let's do our web client in c so here we go one of the same thing now from rc code	code	155
we'll see that my python servers been happily reporting all the things that fire fox has been requesting so let me break out of that now an run it in the background ok so alf it goes because now i want to start compiling my code right so compile the client and run it and we see the beginnings of this yes it connects we see a status message of two hundred which means the server liked our request and it tells me the content length is four hundred nineteen bytes but for some reason we don't see the content our problem right now is that we just called read once and so we got back the head up but that wasn't enough to see the rest of the information so time to wrap this inside a loop ok so let's keep on reading read until we don't want to case so let's think about first of all we want to escape this if if reed returned a zero or negative value so zero remember for read means that there's no more bites so zero would mean the end it's the end of the line no more bites for you negative one would be failure so in either case will will stop so	code	224
we'll see that my python servers been happily reporting all the things that fire fox has been requesting so let me break out of that now an run it in the background ok so alf it goes because now i want to start compiling my code right so compile the client and run it and we see the beginnings of this yes it connects we see a status message of two hundred which means the server liked our request and it tells me the content length is four hundred nineteen bytes but for some reason we don't see the content our problem right now is that we just called read once and so we got back the head up but that wasn't enough to see the rest of the information so time to wrap this inside a loop ok so let's keep on reading read until we don't want to case so let's think about first of all we want to escape this if if reed returned a zero or negative value so zero remember for read means that there's no more bites so zero would mean the end it's the end of the line no more bites for you negative one would be failure so in either case will will stop so	background	154
compile run it again and now we see our web server is actually giving back there very code that was used to request it which i think is kind of cool alright that's enough for this lecture i will see you on friday ok bye	code	86
that allows us to put a block on other threads so how's it going to work ok so here it is i will do it over here	block	24
that allows us to put a block on other threads so how's it going to work ok so here it is i will do it over here	thread	39
right so you seen so already the idea i could make these type thread things which represent a running thread of execution now what else does posix give us when i say posix this is posix standard part of unix is the	type	57
right so you seen so already the idea i could make these type thread things which represent a running thread of execution now what else does posix give us when i say posix this is posix standard part of unix is the	thread	62
standard which writing all the code ok so we're going to make one of these mutex objects let's call it say lock	code	31
and what can i do with them ok so a lot doesn't support that many operations we can lock it and unlock it so let's have a look at that code and big important idea is before we're out allowed to lock and unlock the mutex i have to initialize it so there's a couple of ways you can do that guess what you can say pthread mutex iniciat and pass in a lock and one of the great things about pizza it's implementation of mutex locks is that we can actually pass in a few attributes like we can set it up to debug we can actually create recursive locks but i'm going to anyway we're going to stick with this vanilla logs today again this is kind of one of the example where where the posix implementation the positive definition of mutex logs goes a little bit further than what the new c standards do ok so i want to initialize my lock and i'm not going to pass in any special attributes today right so that's one way of doing it	code	135
and what can i do with them ok so a lot doesn't support that many operations we can lock it and unlock it so let's have a look at that code and big important idea is before we're out allowed to lock and unlock the mutex i have to initialize it so there's a couple of ways you can do that guess what you can say pthread mutex iniciat and pass in a lock and one of the great things about pizza it's implementation of mutex locks is that we can actually pass in a few attributes like we can set it up to debug we can actually create recursive locks but i'm going to anyway we're going to stick with this vanilla logs today again this is kind of one of the example where where the posix implementation the positive definition of mutex logs goes a little bit further than what the new c standards do ok so i want to initialize my lock and i'm not going to pass in any special attributes today right so that's one way of doing it	thread	312
so that in the future when i call the loc method on my mutex it will automatically initialize at that point so you can choose one of these but don't choose both particular mutex right so how can i find out more about these mutex locks well guess what the i've got a lot of information inside my manual for example i could all this stuff about the p threads and what i can do in a detached state which i kind of skipped over	thread	349
but we care about which is the p thread mutex lock here we go and you'll see it doesn't take that many parameters this was really easy we just take the address or mutex object ok so the definition here is if the mutex is already locked the calling third will block until the mutex becomes available ok so let's write this out as an example so i've got my pthread mutex lock here and i pass in the address of my little object here called lock right	block	259
but we care about which is the p thread mutex lock here we go and you'll see it doesn't take that many parameters this was really easy we just take the address or mutex object ok so the definition here is if the mutex is already locked the calling third will block until the mutex becomes available ok so let's write this out as an example so i've got my pthread mutex lock here and i pass in the address of my little object here called lock right	parameter	103
but we care about which is the p thread mutex lock here we go and you'll see it doesn't take that many parameters this was really easy we just take the address or mutex object ok so the definition here is if the mutex is already locked the calling third will block until the mutex becomes available ok so let's write this out as an example so i've got my pthread mutex lock here and i pass in the address of my little object here called lock right	thread	33
but we care about which is the p thread mutex lock here we go and you'll see it doesn't take that many parameters this was really easy we just take the address or mutex object ok so the definition here is if the mutex is already locked the calling third will block until the mutex becomes available ok so let's write this out as an example so i've got my pthread mutex lock here and i pass in the address of my little object here called lock right	address	152
and then i go off and do my critical section stuff so do critical section stuff here do critical section stuff like eg update the data structure or read from the data structure	the data structure	126
and then i go off and do my critical section stuff so do critical section stuff here do critical section stuff like eg update the data structure or read from the data structure	a struct	133
and then i go off and do my critical section stuff so do critical section stuff here do critical section stuff like eg update the data structure or read from the data structure	section	37
but i can be sure that if all of my code follows this pattern so after this i call p thread mutex unlock right and then here's the address of my mutex i can be clear that that that only one thread at a time can be accessed in the data structure so that sounds like a big overhead and in theory it might be if that's the only thing you're doing but remember in practice in real programs ninety nine percent of the time your thread is working on something else it's only when it's actually got a result or once more data that would actually go to this shared data structure	the data structure	226
but i can be sure that if all of my code follows this pattern so after this i call p thread mutex unlock right and then here's the address of my mutex i can be clear that that that only one thread at a time can be accessed in the data structure so that sounds like a big overhead and in theory it might be if that's the only thing you're doing but remember in practice in real programs ninety nine percent of the time your thread is working on something else it's only when it's actually got a result or once more data that would actually go to this shared data structure	a struct	233
but i can be sure that if all of my code follows this pattern so after this i call p thread mutex unlock right and then here's the address of my mutex i can be clear that that that only one thread at a time can be accessed in the data structure so that sounds like a big overhead and in theory it might be if that's the only thing you're doing but remember in practice in real programs ninety nine percent of the time your thread is working on something else it's only when it's actually got a result or once more data that would actually go to this shared data structure	code	36
but i can be sure that if all of my code follows this pattern so after this i call p thread mutex unlock right and then here's the address of my mutex i can be clear that that that only one thread at a time can be accessed in the data structure so that sounds like a big overhead and in theory it might be if that's the only thing you're doing but remember in practice in real programs ninety nine percent of the time your thread is working on something else it's only when it's actually got a result or once more data that would actually go to this shared data structure	thread	85
but i can be sure that if all of my code follows this pattern so after this i call p thread mutex unlock right and then here's the address of my mutex i can be clear that that that only one thread at a time can be accessed in the data structure so that sounds like a big overhead and in theory it might be if that's the only thing you're doing but remember in practice in real programs ninety nine percent of the time your thread is working on something else it's only when it's actually got a result or once more data that would actually go to this shared data structure	address	131
ok so that's all basic pattern this is how we bring order to our madness all the examples we've seen so far would have helped if we had this ability to pause or threats to implement synchronization now is a couple of limitations with rp thread mutex is which	thread	237
we will be able to relax when we look at other synchronization primitives but here's the big one we have to write these things in pairs we have to put the lock and unlock together on the same thread	thread	192
when we finished we should clean up so we will call p thread mutex destroy right and here's the address of my lock	thread	54
when we finished we should clean up so we will call p thread mutex destroy right and here's the address of my lock	address	96
this is not actual father spain stored on disk it's just the variable and it's the same idea with this this mutex lock its represents a mutex but it's not the attribute x itself ok see what else do you want to say right so you call peter mutex lock and we get to continue great what happens if another thread now calls peter mutex lock on the same object on the same mutex	a mutex	134
this is not actual father spain stored on disk it's just the variable and it's the same idea with this this mutex lock its represents a mutex but it's not the attribute x itself ok see what else do you want to say right so you call peter mutex lock and we get to continue great what happens if another thread now calls peter mutex lock on the same object on the same mutex	thread	302
right so we can imagine that we've got this global variable here it calls peter mutex lock guess what it has to wait it's called preferred mutex lock is blocked so right so we know for sure that this coal here either continues if no one else has the log right now and if it continues then you have acquired that look you get to play ball right the rock is yours	block	153
it may block meaning your poor cpu is not allowed to pass go and not allowed to execute a single more instruction of your code it's stuck inside here waiting	block	7
it may block meaning your poor cpu is not allowed to pass go and not allowed to execute a single more instruction of your code it's stuck inside here waiting	code	122
so great now what happens if i've got ten threads or piling together all calling petered mutex log at exactly the same nanosecond what this mutex log guarantees is is that one of them will win	thread	42
that's that one thread will acquire the lock and will continue the other nine or however many it is day or block they have to wait	block	107
that's that one thread will acquire the lock and will continue the other nine or however many it is day or block they have to wait	thread	16
at some point in the future you release the lock you it's no longer yours and out of those nine threads that are called mutex look one of them	thread	96
is going to win the others will remain blocked ok so it guarantees you that there's only one thread at a time that can acquire the lock so only zero threads are one third of the time now the piece that mutex lock doesn't do anything special other than that it doesn't bless your code in the middle it doesn't declare to the compiler that something wonderful is about to happen no it's basic mechanism is very simple it either blocks or allows you to continue if no one else has acquired that look and only one thread at a time even if two threads at exactly the same clock cycle call preferred mutex locked even if even in that extreme case only one of them is guaranteed to win of course this arbitrary as to which one wins but	block	39
is going to win the others will remain blocked ok so it guarantees you that there's only one thread at a time that can acquire the lock so only zero threads are one third of the time now the piece that mutex lock doesn't do anything special other than that it doesn't bless your code in the middle it doesn't declare to the compiler that something wonderful is about to happen no it's basic mechanism is very simple it either blocks or allows you to continue if no one else has acquired that look and only one thread at a time even if two threads at exactly the same clock cycle call preferred mutex locked even if even in that extreme case only one of them is guaranteed to win of course this arbitrary as to which one wins but	code	279
is going to win the others will remain blocked ok so it guarantees you that there's only one thread at a time that can acquire the lock so only zero threads are one third of the time now the piece that mutex lock doesn't do anything special other than that it doesn't bless your code in the middle it doesn't declare to the compiler that something wonderful is about to happen no it's basic mechanism is very simple it either blocks or allows you to continue if no one else has acquired that look and only one thread at a time even if two threads at exactly the same clock cycle call preferred mutex locked even if even in that extreme case only one of them is guaranteed to win of course this arbitrary as to which one wins but	thread	93
ensures that we have now the ability to control are critical sections and right start to write threadsafe code so that's that big idea right so we've talked about how we can create it either used to magic initialize the constant or copy said dark addition iniciat we told how do you lock and unlock and i had mentioned how you destroyed me text by just calling peter mutex destroy ok and that's just like kind of closing a file to say ok kernal done with this resource alright see you in the next video bye	code	106
ensures that we have now the ability to control are critical sections and right start to write threadsafe code so that's that big idea right so we've talked about how we can create it either used to magic initialize the constant or copy said dark addition iniciat we told how do you lock and unlock and i had mentioned how you destroyed me text by just calling peter mutex destroy ok and that's just like kind of closing a file to say ok kernal done with this resource alright see you in the next video bye	section	61
ensures that we have now the ability to control are critical sections and right start to write threadsafe code so that's that big idea right so we've talked about how we can create it either used to magic initialize the constant or copy said dark addition iniciat we told how do you lock and unlock and i had mentioned how you destroyed me text by just calling peter mutex destroy ok and that's just like kind of closing a file to say ok kernal done with this resource alright see you in the next video bye	thread	95
ok right so let's talk about what what is a mutex mutex is the key thing that we need in order to implement critical sections if you think about our code from moment where our critics sections are basically	code	149
ok right so let's talk about what what is a mutex mutex is the key thing that we need in order to implement critical sections if you think about our code from moment where our critics sections are basically	a mutex	42
ok right so let's talk about what what is a mutex mutex is the key thing that we need in order to implement critical sections if you think about our code from moment where our critics sections are basically	section	117
where we want to do surgery on a data structure that moment we only want one surgeon in the room most of the time my thread can be busy say working on the sound another one could be working on the ui another one	a struct	36
where we want to do surgery on a data structure that moment we only want one surgeon in the room most of the time my thread can be busy say working on the sound another one could be working on the ui another one	thread	117
but at some point they need to come together and say send messages over data bus or some other kind of event structure so when they manipulate that structure only one of them should be changing at a time ok so that we've identified a critical section and now we need to make sure that if one thread is currently doing that then other threads get temporarily blocked put on pause if you like whilst we are in that critical piece of code and the key to doing that then is this	block	358
but at some point they need to come together and say send messages over data bus or some other kind of event structure so when they manipulate that structure only one of them should be changing at a time ok so that we've identified a critical section and now we need to make sure that if one thread is currently doing that then other threads get temporarily blocked put on pause if you like whilst we are in that critical piece of code and the key to doing that then is this	code	431
but at some point they need to come together and say send messages over data bus or some other kind of event structure so when they manipulate that structure only one of them should be changing at a time ok so that we've identified a critical section and now we need to make sure that if one thread is currently doing that then other threads get temporarily blocked put on pause if you like whilst we are in that critical piece of code and the key to doing that then is this	section	243
but at some point they need to come together and say send messages over data bus or some other kind of event structure so when they manipulate that structure only one of them should be changing at a time ok so that we've identified a critical section and now we need to make sure that if one thread is currently doing that then other threads get temporarily blocked put on pause if you like whilst we are in that critical piece of code and the key to doing that then is this	thread	292
add a mutex is actually go back there right actually a shortening of do i have i want to be able to type we try some letters here ok there we go right ashley short for	type	100
add a mutex is actually go back there right actually a shortening of do i have i want to be able to type we try some letters here ok there we go right ashley short for	a mutex	4
so the pieces sort of peaceful so we've got we've seen p thread so far now that if you look at what posix gives us for mutexes ok i'll see you in the next video	thread	57
hi great so let's welcome to virtual memory ok so the story so far we've been designing process is and each process has its own address space as we had this idea of virtual memory ok and so the address numbers that you and i talk about inside our code only make sense inside one particular process meanwhile we've	memory	37
hi great so let's welcome to virtual memory ok so the story so far we've been designing process is and each process has its own address space as we had this idea of virtual memory ok and so the address numbers that you and i talk about inside our code only make sense inside one particular process meanwhile we've	code	247
hi great so let's welcome to virtual memory ok so the story so far we've been designing process is and each process has its own address space as we had this idea of virtual memory ok and so the address numbers that you and i talk about inside our code only make sense inside one particular process meanwhile we've	address	128
it's the limiting factor for when we want to run multiple virtual machines on a host we can never seem to get enough of it it's nice and fast compared to other storage mechanisms so we want to use it efficiently ok so here's one idea we could say well let's assign your process to use the following chunk of memory ok so this can be you you can say process one or let's say process eleven at meanwhile i'm running as well so here's	the following	285
it's the limiting factor for when we want to run multiple virtual machines on a host we can never seem to get enough of it it's nice and fast compared to other storage mechanisms so we want to use it efficiently ok so here's one idea we could say well let's assign your process to use the following chunk of memory ok so this can be you you can say process one or let's say process eleven at meanwhile i'm running as well so here's	memory	308
memory down here that would be for me ok so that'll be safer my process might be processed twelve ok so some problems with this first of all you could imagine that overtime when i stop processes and end process is my memories going to look very fragmented and it's going to look exactly like problems we faced with our heap that are actual physical memory ok will have bits of memory that are in use their over here ok but the free space free places in memory are are separated	memory	0
ok so what can we do to fix that well we could start copying bites down but these processes are pretty big ass a lot of bytes to copy so that's going to be pretty inefficient and slow and take up a lot of time using the memory bus to do that copy so this doesn't seem like a great solution	memory	220
the solution we actually describing all the way is called like the base and bound where there's a mapping simple mapping from your virtual memory addresses we add some kind of offset offset that will be the base to get to the actual physical address or inside my ram and then we also put some kind of bound to make sure that addresses inside your process contract pieces of memory that don't don't don't that not your concern not sort of your process alright so this is not a great it's only advantages that was simple describe and also simple to implement in silicon and gives us a little bit of protection between each processor your process can't overwrite my memory well maybe we can do better than that ok so one thing to notice is that actually in my address space over here i've got tons of addresses loads of address numbers which i just don't care about they are not being used right now they're not part of the stack not part of the heap are never need to refer to them and in fact we could even go further and say look this part of my program code like the initialization code that i	memory	139
the solution we actually describing all the way is called like the base and bound where there's a mapping simple mapping from your virtual memory addresses we add some kind of offset offset that will be the base to get to the actual physical address or inside my ram and then we also put some kind of bound to make sure that addresses inside your process contract pieces of memory that don't don't don't that not your concern not sort of your process alright so this is not a great it's only advantages that was simple describe and also simple to implement in silicon and gives us a little bit of protection between each processor your process can't overwrite my memory well maybe we can do better than that ok so one thing to notice is that actually in my address space over here i've got tons of addresses loads of address numbers which i just don't care about they are not being used right now they're not part of the stack not part of the heap are never need to refer to them and in fact we could even go further and say look this part of my program code like the initialization code that i	the heap	939
the solution we actually describing all the way is called like the base and bound where there's a mapping simple mapping from your virtual memory addresses we add some kind of offset offset that will be the base to get to the actual physical address or inside my ram and then we also put some kind of bound to make sure that addresses inside your process contract pieces of memory that don't don't don't that not your concern not sort of your process alright so this is not a great it's only advantages that was simple describe and also simple to implement in silicon and gives us a little bit of protection between each processor your process can't overwrite my memory well maybe we can do better than that ok so one thing to notice is that actually in my address space over here i've got tons of addresses loads of address numbers which i just don't care about they are not being used right now they're not part of the stack not part of the heap are never need to refer to them and in fact we could even go further and say look this part of my program code like the initialization code that i	code	1054
the solution we actually describing all the way is called like the base and bound where there's a mapping simple mapping from your virtual memory addresses we add some kind of offset offset that will be the base to get to the actual physical address or inside my ram and then we also put some kind of bound to make sure that addresses inside your process contract pieces of memory that don't don't don't that not your concern not sort of your process alright so this is not a great it's only advantages that was simple describe and also simple to implement in silicon and gives us a little bit of protection between each processor your process can't overwrite my memory well maybe we can do better than that ok so one thing to notice is that actually in my address space over here i've got tons of addresses loads of address numbers which i just don't care about they are not being used right now they're not part of the stack not part of the heap are never need to refer to them and in fact we could even go further and say look this part of my program code like the initialization code that i	address	146
really don't even need in memory right now or passing my heap i haven't touched since yesterday ok so maybe we should think about a better way to organize our memory and also deal with this fragmentation problem so right let's scrap that and come up with a new design so here's my idea i i idea every time that your process actually wants to read or write something for memory so imagine we're going to really character safe on the heap we need to map that to an actual piece of silicon somewhere inside my ram ok so i'll have a magic piece of machinery their memory management unit here which is actually part of the cpu and it's going to magically map that to an arbitrary piece of memory ok so any bite can be mapped to any other bite ok so here's the following bite over here that can go to somewhere else alright so now we've solved the fragmentation cost alright so this is obvious strawman argument let's tear it down and show why it's not a very good idea ok so let's make this kind of concrete well they imagine we're running today on a	the following	751
really don't even need in memory right now or passing my heap i haven't touched since yesterday ok so maybe we should think about a better way to organize our memory and also deal with this fragmentation problem so right let's scrap that and come up with a new design so here's my idea i i idea every time that your process actually wants to read or write something for memory so imagine we're going to really character safe on the heap we need to map that to an actual piece of silicon somewhere inside my ram ok so i'll have a magic piece of machinery their memory management unit here which is actually part of the cpu and it's going to magically map that to an arbitrary piece of memory ok so any bite can be mapped to any other bite ok so here's the following bite over here that can go to somewhere else alright so now we've solved the fragmentation cost alright so this is obvious strawman argument let's tear it down and show why it's not a very good idea ok so let's make this kind of concrete well they imagine we're running today on a	memory	26
really don't even need in memory right now or passing my heap i haven't touched since yesterday ok so maybe we should think about a better way to organize our memory and also deal with this fragmentation problem so right let's scrap that and come up with a new design so here's my idea i i idea every time that your process actually wants to read or write something for memory so imagine we're going to really character safe on the heap we need to map that to an actual piece of silicon somewhere inside my ram ok so i'll have a magic piece of machinery their memory management unit here which is actually part of the cpu and it's going to magically map that to an arbitrary piece of memory ok so any bite can be mapped to any other bite ok so here's the following bite over here that can go to somewhere else alright so now we've solved the fragmentation cost alright so this is obvious strawman argument let's tear it down and show why it's not a very good idea ok so let's make this kind of concrete well they imagine we're running today on a	the heap	428
two bit machine ok so i've got that means that my address space is thirty two bits meaning that is actually	address	50
the total number of addresses is two to the thirty two also meaning that if i actually want to write down an address i need for the debits or in the words four bytes so we're going to work between these three ideas continuously either the idea that we've got thirty bits and their physical bits separate and you know physical wires or this is the total number or this is the number of bytes needed to hold that number ok right so we just started with the idea that any address here inside your virtual machine can be mapped to any physical piece of my rab	address	20
so in other words for each and every bite inside here i need to store number i need to store what i need to store four bytes so if your address space over here for your process is habig thirty two bits in other words i've got say two to the thirty two entries	address	136
right but each entry now it's going to take some storage somewhere i'm going to store for each one of those four byte number to say where inside my physical memory ok so how big is this how how many bytes we actually need to store this giant look up table case so first of all let's just work this out this is of course two to the thirty four bytes right now that doesn't mean much to me thirty thirty four but i know how to work it out quickly right and the computer scientist knows it too to the is two fifty six but it's more useful to know that two to the ten is about a thousand in fact of course is a thousand twenty four so two to the twenty is about a million ok so this is your standard kind of mb right and then two to the thirty is going to be a gigabyte ok so what about my two to the thirty four this means i've just come up with an addressing scheme that takes drum wall sixteen gigabytes to store	memory	157
right but each entry now it's going to take some storage somewhere i'm going to store for each one of those four byte number to say where inside my physical memory ok so how big is this how how many bytes we actually need to store this giant look up table case so first of all let's just work this out this is of course two to the thirty four bytes right now that doesn't mean much to me thirty thirty four but i know how to work it out quickly right and the computer scientist knows it too to the is two fifty six but it's more useful to know that two to the ten is about a thousand in fact of course is a thousand twenty four so two to the twenty is about a million ok so this is your standard kind of mb right and then two to the thirty is going to be a gigabyte ok so what about my two to the thirty four this means i've just come up with an addressing scheme that takes drum wall sixteen gigabytes to store	address	846
ok so i just need to go out and buy sixteen gigabytes of memory just to store this look up table right hold on a moment how much memory going to actually buy and put into this machine well we had thirty two bit addressing space so in other words my memory is limited to two to the thirty two bites ok so i've got a total of four gigabytes of memory i could actually put into my machine ok so this was not a great idea this is definitely kind of fail see metry to think of a better way to do this because we've just wasted our time memory building a giant look up table we better do better than that	memory	57
ok so i just need to go out and buy sixteen gigabytes of memory just to store this look up table right hold on a moment how much memory going to actually buy and put into this machine well we had thirty two bit addressing space so in other words my memory is limited to two to the thirty two bites ok so i've got a total of four gigabytes of memory i could actually put into my machine ok so this was not a great idea this is definitely kind of fail see metry to think of a better way to do this because we've just wasted our time memory building a giant look up table we better do better than that	address	211
divide on memory conceptually up into not just an arbitrary number between zero to thirty two minus one but instead let's think about all of our dresses chunked are chunked up each chunk i would arbitrarily pick four thousand ninety six so this will be zero to four thousand ninety five and then it's four thousand	memory	10
ninety six to eight thousand one hundred and ninety one etc right so i'm taking my address based now and i'm saying i've got this blocks of memory and in fact i'm going to call these blocks of memory page	memory	140
ninety six to eight thousand one hundred and ninety one etc right so i'm taking my address based now and i'm saying i've got this blocks of memory and in fact i'm going to call these blocks of memory page	block	130
ninety six to eight thousand one hundred and ninety one etc right so i'm taking my address based now and i'm saying i've got this blocks of memory and in fact i'm going to call these blocks of memory page	address	83
ok so i gotta pay zero page one and page two and so on and so on and so on and when i talk about that all i mean is just i'm taking the address and dividing up into a block of four thousand and ninety six ok so why four thousand ninety six well remember how i said that two to the ted is a very useful thing to note well it turns out the four thousand and ninety six is this times four so this actually is equal to two to the twelve what does that mean in terms of the wires ok so think about when you actually want to talk about a specific address i've got in my little machine thirty two wires do do do do do do do do do here they all go right do a few more ok well imagine that thirty two it means that the lowest twelve bits so the lowest first twelve wires so it's that one two three four five six seven eight nine ten eleven twelve ok these twelve wires right here	block	167
ok so i gotta pay zero page one and page two and so on and so on and so on and when i talk about that all i mean is just i'm taking the address and dividing up into a block of four thousand and ninety six ok so why four thousand ninety six well remember how i said that two to the ted is a very useful thing to note well it turns out the four thousand and ninety six is this times four so this actually is equal to two to the twelve what does that mean in terms of the wires ok so think about when you actually want to talk about a specific address i've got in my little machine thirty two wires do do do do do do do do do here they all go right do a few more ok well imagine that thirty two it means that the lowest twelve bits so the lowest first twelve wires so it's that one two three four five six seven eight nine ten eleven twelve ok these twelve wires right here	address	136
right so so far we've been talking about the virtual address space we can divide up our physical memory the stuff we physically gone out and brought and put inside our machine into these same blocks into these same frames again these same pages except that if we want to be accurate but we talk about it in terms of physical memory we talk about it in terms of physical frame	memory	97
right so so far we've been talking about the virtual address space we can divide up our physical memory the stuff we physically gone out and brought and put inside our machine into these same blocks into these same frames again these same pages except that if we want to be accurate but we talk about it in terms of physical memory we talk about it in terms of physical frame	block	192
right so so far we've been talking about the virtual address space we can divide up our physical memory the stuff we physically gone out and brought and put inside our machine into these same blocks into these same frames again these same pages except that if we want to be accurate but we talk about it in terms of physical memory we talk about it in terms of physical frame	address	53
so we got to change our first stroman idea to now a mapping between a page	a page	68
which is something which is meaningful inside a process and it's part of the virtual memory address going to map that somehow we want to do it quickly to a particular place inside my actual memory my actual ram in other words are particular physical frame and ask for the	memory	85
which is something which is meaningful inside a process and it's part of the virtual memory address going to map that somehow we want to do it quickly to a particular place inside my actual memory my actual ram in other words are particular physical frame and ask for the	a process	46
which is something which is meaningful inside a process and it's part of the virtual memory address going to map that somehow we want to do it quickly to a particular place inside my actual memory my actual ram in other words are particular physical frame and ask for the	address	92
fragmentation is less of an issue because as my process is start and stop or take up more memory or release memory if i can do an arbitrary mapping from any one of these spare spaces like say that this guy is currently completely free then i could map that to say that this stack is getting deep larger here this mapping could be completely arbitrary it does matter the ordering and where the spaces inside my physical memory	memory	90
and we will store that where in memory we're going to actually use our ram for this so our process will never see it so here's my cs two twenty five student over here all happy right in their code scratching their head wondering what bug is right what they don't know is that behind the scenes anytime they create a c plus plus object or anytime cs one twenty five student is looking at their java object in reading or writing to it ok	memory	32
and we will store that where in memory we're going to actually use our ram for this so our process will never see it so here's my cs two twenty five student over here all happy right in their code scratching their head wondering what bug is right what they don't know is that behind the scenes anytime they create a c plus plus object or anytime cs one twenty five student is looking at their java object in reading or writing to it ok	code	192
some magic is happening for each and every time we are talk to memory we need to do this conversion we need to convert the address that they are sleeping and thinking about internally bug into an actual physical piece of memory so we need to map it say to this particular frame here right so how do we do that that's the subject of my next video ok bye	memory	63
some magic is happening for each and every time we are talk to memory we need to do this conversion we need to convert the address that they are sleeping and thinking about internally bug into an actual physical piece of memory so we need to map it say to this particular frame here right so how do we do that that's the subject of my next video ok bye	address	123
hi ok so let's use a condition variable to implement a cookie eater and here's the idea so i've got a data structure is actually just an integer but you could imagine it could be a linked list it could be some other more interesting data structure and we're going to add things to this and remove things from this and i want to make sure that i don't try to remove things if there's nothing there for example ok so here's my logic then i've got some code here that you can see i'm going to	a struct	105
hi ok so let's use a condition variable to implement a cookie eater and here's the idea so i've got a data structure is actually just an integer but you could imagine it could be a linked list it could be some other more interesting data structure and we're going to add things to this and remove things from this and i want to make sure that i don't try to remove things if there's nothing there for example ok so here's my logic then i've got some code here that you can see i'm going to	code	450
use pthread condition soapy threads to run and i'm going to pull out a name from this	thread	5
and inside my little loop here was my game is running a lot the mutex and then i want to check to see if there's actually anything inside my data structures so if my data structure is empty then let's go for a nap this block this comment thread so we'll see that because will print out a little message with the name and will say ok going for a nap there we go then	block	219
and inside my little loop here was my game is running a lot the mutex and then i want to check to see if there's actually anything inside my data structures so if my data structure is empty then let's go for a nap this block this comment thread so we'll see that because will print out a little message with the name and will say ok going for a nap there we go then	a struct	144
and inside my little loop here was my game is running a lot the mutex and then i want to check to see if there's actually anything inside my data structures so if my data structure is empty then let's go for a nap this block this comment thread so we'll see that because will print out a little message with the name and will say ok going for a nap there we go then	thread	238
we will if we escape that loop we then we know the condition must be true that there is something in my data structure and because i'm holding the mutex lock we're going to make sure that no one else can actually modify it so between testing it and using it we know that's value cannot be changed because i'm holding the mutex lock	a struct	107
and so what do we do we take something out of the data structure and then will print this thread managed to eat this and in fact this code is going to be run by multiple threats ok we're going to have two threads trying to eat cookies at the same time ok but will protect our data structure by the use of this peter mutex lock ok we need to weigh to add things to a data structure and so here is my little add cookie notice that i've got i protected my change the data structure using using the lock and after modifying the data structure i'm also going to broadcast so anybody any thread that happens to be sleeping inside the condition available will be working up	the data structure	46
and so what do we do we take something out of the data structure and then will print this thread managed to eat this and in fact this code is going to be run by multiple threats ok we're going to have two threads trying to eat cookies at the same time ok but will protect our data structure by the use of this peter mutex lock ok we need to weigh to add things to a data structure and so here is my little add cookie notice that i've got i protected my change the data structure using using the lock and after modifying the data structure i'm also going to broadcast so anybody any thread that happens to be sleeping inside the condition available will be working up	a struct	53
and so what do we do we take something out of the data structure and then will print this thread managed to eat this and in fact this code is going to be run by multiple threats ok we're going to have two threads trying to eat cookies at the same time ok but will protect our data structure by the use of this peter mutex lock ok we need to weigh to add things to a data structure and so here is my little add cookie notice that i've got i protected my change the data structure using using the lock and after modifying the data structure i'm also going to broadcast so anybody any thread that happens to be sleeping inside the condition available will be working up	code	134
and so what do we do we take something out of the data structure and then will print this thread managed to eat this and in fact this code is going to be run by multiple threats ok we're going to have two threads trying to eat cookies at the same time ok but will protect our data structure by the use of this peter mutex lock ok we need to weigh to add things to a data structure and so here is my little add cookie notice that i've got i protected my change the data structure using using the lock and after modifying the data structure i'm also going to broadcast so anybody any thread that happens to be sleeping inside the condition available will be working up	thread	90
wait i promised you that we have multiple multiple threads so here it is i've got two threads which are going to be cookie eaters and one could be all angry even one could be agent smith ok and then we'll just use scan f to see how many cookies should be added to the jar so each time that i successfully read one integer	thread	51
so scan app please read into my interview here then i'll add a cookie so if you type nine or control d then we're going to stop ok how should we stop what do you think about the following so we will first of all call peter mutex lock	the following	174
so scan app please read into my interview here then i'll add a cookie so if you type nine or control d then we're going to stop ok how should we stop what do you think about the following so we will first of all call peter mutex lock	type	80
and we do that to ensure that actually there's something special about peter text lock which is not only does it acquiring musics it ensures that if i've got some variables which are in memory that the cash values on the cpu actually represent what should be in memory so it behaves as if there's no cash meaning if i got two threads running on two different pieces of silicon they will see the correct value	memory	186
and we do that to ensure that actually there's something special about peter text lock which is not only does it acquiring musics it ensures that if i've got some variables which are in memory that the cash values on the cpu actually represent what should be in memory so it behaves as if there's no cash meaning if i got two threads running on two different pieces of silicon they will see the correct value	thread	326
running inside the sword inside main memory ok so we've set game_running to zero and let's wake up or threats ok so now will just wait until they both exited and then will print finished ok so let's try this and see how well it works ok so we're clear that which code is this cookie solution ok so let's compile that and run it ok so you'll see that i main thread is waiting for some input meanwhile the angry even agent smith are going for a nap so they call pizza condition wait ok so let's add a few cookies right so all that five alright we've called broadcast so angry work up and he eats so now there's four cookies left and then agent smith is also working up so smith it's another cookie and then they can have both go round as fast as possible trying to acquire that mutex lock so in this case they both managed to it eat some cookies but now they notice one at a time that	memory	37
running inside the sword inside main memory ok so we've set game_running to zero and let's wake up or threats ok so now will just wait until they both exited and then will print finished ok so let's try this and see how well it works ok so we're clear that which code is this cookie solution ok so let's compile that and run it ok so you'll see that i main thread is waiting for some input meanwhile the angry even agent smith are going for a nap so they call pizza condition wait ok so let's add a few cookies right so all that five alright we've called broadcast so angry work up and he eats so now there's four cookies left and then agent smith is also working up so smith it's another cookie and then they can have both go round as fast as possible trying to acquire that mutex lock so in this case they both managed to it eat some cookies but now they notice one at a time that	code	263
running inside the sword inside main memory ok so we've set game_running to zero and let's wake up or threats ok so now will just wait until they both exited and then will print finished ok so let's try this and see how well it works ok so we're clear that which code is this cookie solution ok so let's compile that and run it ok so you'll see that i main thread is waiting for some input meanwhile the angry even agent smith are going for a nap so they call pizza condition wait ok so let's add a few cookies right so all that five alright we've called broadcast so angry work up and he eats so now there's four cookies left and then agent smith is also working up so smith it's another cookie and then they can have both go round as fast as possible trying to acquire that mutex lock so in this case they both managed to it eat some cookies but now they notice one at a time that	thread	357
that there's no cookies left so they call pizza hut condition condition wait they released a mutex lock and so the other thread acquires mutex lock and also notice is it so let's just add some more cookies here	a mutex	91
that there's no cookies left so they call pizza hut condition condition wait they released a mutex lock and so the other thread acquires mutex lock and also notice is it so let's just add some more cookies here	thread	121
ok oh yes right so we put the number of cookies that we remain we just read the value of jaw out outside of any pthread mutex lock so the value of this jaw could be changed between us decrement in it and as printing something out i think in this case that's exactly what happened so in this case angry have managed to eat a cookie	thread	113
let's now let's try and quit my program here so ok so i'm going to try to exit ok but we never exit what is the problem here as you can see that my two two threads still sleeping ok so what was the problem here we did actually wake them up look they work up after we told it to finish but they didn't escape why not the problem here is that yes we call broadcast but then each thread notice that the java store zero so we exited each thread exited pizza condition wait but then when around the while loop and said oh look jar is zero what should i do i'll go back into my water loop and wait again ok so what's the fix here are fix is	thread	156
and compile ok so now when i exit great it finishes and p thread join is able to exit as well but look at this we managed to get negative two cookies ok so the lesson here is that after exiting this loop we actually carried on we actually code on pulling things from our data structure and so better code here would actually also break out of this so if the game is not running do not collect two hundred dollars do not pass go but instead break out of this loop as well because we want to quit the game right	a struct	274
and compile ok so now when i exit great it finishes and p thread join is able to exit as well but look at this we managed to get negative two cookies ok so the lesson here is that after exiting this loop we actually carried on we actually code on pulling things from our data structure and so better code here would actually also break out of this so if the game is not running do not collect two hundred dollars do not pass go but instead break out of this loop as well because we want to quit the game right	code	239
and compile ok so now when i exit great it finishes and p thread join is able to exit as well but look at this we managed to get negative two cookies ok so the lesson here is that after exiting this loop we actually carried on we actually code on pulling things from our data structure and so better code here would actually also break out of this so if the game is not running do not collect two hundred dollars do not pass go but instead break out of this loop as well because we want to quit the game right	thread	58
we call preacher condition broadcast on both threads but we never finished why not ok so good question oh yes so now what do we do we broke out of this loop but we never actually release the mutex log ok so now let's	thread	45
well at least the mutex lock soapy thread mutex	thread	35
now will ensure that before finishing we've let god in meters lock and so this is kind of a fun example because we managed to get one to finish but because angry never finished our maine med main thread never finished because it was still waiting for both of them to complete ok so that's kind of fun with threads here so finally let's have a working solution came right so we'll add some cookies will see that it's working eat some cookies and now let's finish ok and finally angry wakes up releases the mutex lock so smith can now finish and finally everybody finishes happily in the next video will talk about producer consumer by	thread	196
hi so the last still a videos one this one is going to be how can i write a fast memory pool and the last will be tips for the malloc mp so here we go how can i write a really fast malloc memory pool so let's imagine we want to do the following so i'm going to write a very quick version of malloc and the idea here is that with the memory pool all the objects that i'm going to allocate inside this memory pool going to be freed at the same time so let's kind of sketch this out i've got a buffer some memory here i'm going to use some static make this larger there we go right	the following	231
hi so the last still a videos one this one is going to be how can i write a fast memory pool and the last will be tips for the malloc mp so here we go how can i write a really fast malloc memory pool so let's imagine we want to do the following so i'm going to write a very quick version of malloc and the idea here is that with the memory pool all the objects that i'm going to allocate inside this memory pool going to be freed at the same time so let's kind of sketch this out i've got a buffer some memory here i'm going to use some static make this larger there we go right	memory	81
i've got ten thousand bytes and that will be my memory pool for today i'm going to keep track of how much i've used so i can do the following wait so you want so many so many bytes ok i can give you that right so will make make a note of that will have this device i'm going to return to you will be at buffer plus how many used	the following	128
i've got ten thousand bytes and that will be my memory pool for today i'm going to keep track of how much i've used so i can do the following wait so you want so many so many bytes ok i can give you that right so will make make a note of that will have this device i'm going to return to you will be at buffer plus how many used	memory	48
ok and then i'll just make a note that you've used some ok so let's implement my used here by bites so each request gets a brand new piece of memory there's no attempt as you see to reuse memory the our bookkeeping is very simple with its in many ways it's very similar to the ecb rate version we saw the very beginning right and then one day when we finish using all of these objects we just want to say ok i'm done with them how can i freedom all alright well easy you can just reset our use flag back to zero perhaps if there was a security concern	memory	142
or you're trying to debug code you could call memset and wipe out all the values in that array but if you just care about performance there's nothing else to do future calls to malloc will start again at the beginning of the memory pool so we see this in things like say games where huge you know that you just want to create objects and they're only going to disappear when the user dies or which is the end of the level you see this in high performance web servers where say or your string manipulation whereas you tried to take the request and extract the head of information and exactly what they want or that string stuff we could call new and delete or malloc and free but why don't we just put it into a pool because we know that it has a very temporary lifespan and once we satisfy this request once we've decoded it we can throw all those away in just one go so that's memory pools for you very simple concept here's a very simple implementation no error checking no bounds checking we could write more complicated once but i think you get the idea all right i'll see you in the next video bye	memory	225
or you're trying to debug code you could call memset and wipe out all the values in that array but if you just care about performance there's nothing else to do future calls to malloc will start again at the beginning of the memory pool so we see this in things like say games where huge you know that you just want to create objects and they're only going to disappear when the user dies or which is the end of the level you see this in high performance web servers where say or your string manipulation whereas you tried to take the request and extract the head of information and exactly what they want or that string stuff we could call new and delete or malloc and free but why don't we just put it into a pool because we know that it has a very temporary lifespan and once we satisfy this request once we've decoded it we can throw all those away in just one go so that's memory pools for you very simple concept here's a very simple implementation no error checking no bounds checking we could write more complicated once but i think you get the idea all right i'll see you in the next video bye	code	26
or you're trying to debug code you could call memset and wipe out all the values in that array but if you just care about performance there's nothing else to do future calls to malloc will start again at the beginning of the memory pool so we see this in things like say games where huge you know that you just want to create objects and they're only going to disappear when the user dies or which is the end of the level you see this in high performance web servers where say or your string manipulation whereas you tried to take the request and extract the head of information and exactly what they want or that string stuff we could call new and delete or malloc and free but why don't we just put it into a pool because we know that it has a very temporary lifespan and once we satisfy this request once we've decoded it we can throw all those away in just one go so that's memory pools for you very simple concept here's a very simple implementation no error checking no bounds checking we could write more complicated once but i think you get the idea all right i'll see you in the next video bye	string	485
right ok so great we've put thread to sleep by calling p thread condition wait and now is happily dozing inside that condition variable right at some point in the future on a different thread we now know that it's time to wake up that thread so for example perhaps you finished downloading something perhaps the sound sample is ready to play or perhaps you know that the users quit and it's time to run that clean up thread which is going to we move the files and everything else for us ok so how do we wake up a threat it's easy you just need to call	thread	28
kate and that will wake up a thread inside one of our our rooms that it sleeping in so we better pass the condition variable that our thread is sleeping in ok and there's one other option which is p thread conditioned broadcast	a thread	27
kate and that will wake up a thread inside one of our our rooms that it sleeping in so we better pass the condition variable that our thread is sleeping in ok and there's one other option which is p thread conditioned broadcast	thread	29
so the difference is that sometimes i actually send a whole load of threads to sleep inside my condition variable and if i call condition broadcast i'm going to wake them all up if i just call signal then i'm asking the system to wake up just one of them and i don't get to say which one i just simply asking to say find me one and wake wake it up for me ok right so quick comment on these if it turns out that right now no one is sleeping inside my condition variable then these two calls have no effect so just as an analogy you could imagine p three conditions signal is running up to i hotel and randomly knocking on a door where one person it is sleeping versus broadcast your waving their sort of pulling the fire alarm on waking everybody up right so so that's our basic idea as you can see sounds pretty simple right said the threat to sleep later when you know conditions have changed you've added money to the wallet you found that favorite sweater now we can wake up that other thread so we can continue alright so let's actually have a look that using this	thread	68
so the difference is that sometimes i actually send a whole load of threads to sleep inside my condition variable and if i call condition broadcast i'm going to wake them all up if i just call signal then i'm asking the system to wake up just one of them and i don't get to say which one i just simply asking to say find me one and wake wake it up for me ok right so quick comment on these if it turns out that right now no one is sleeping inside my condition variable then these two calls have no effect so just as an analogy you could imagine p three conditions signal is running up to i hotel and randomly knocking on a door where one person it is sleeping versus broadcast your waving their sort of pulling the fire alarm on waking everybody up right so so that's our basic idea as you can see sounds pretty simple right said the threat to sleep later when you know conditions have changed you've added money to the wallet you found that favorite sweater now we can wake up that other thread so we can continue alright so let's actually have a look that using this	system	220
and for this we're going to have some multithreaded code that implements some cake ok so let's have some cake that's my resource here or my data structure	a struct	143
and for this we're going to have some multithreaded code that implements some cake ok so let's have some cake that's my resource here or my data structure	code	52
and for this we're going to have some multithreaded code that implements some cake ok so let's have some cake that's my resource here or my data structure	thread	43
and as you can see initially i don't have any cake ok but soon we're going to be creating cake and we're going to use this because i want to talk about creating resources and then consuming those resources ok it's kind of very standard problem that we're going to have when we start writing larger pieces of code that now i've got bits of code processes and threads which are putting things into my data structure or or finishing images or finishing processing of videos etc and then i've got other threads say great as soon as you have these things i wanted now consume these and act upon them right so what do i have in order to implement this well you can see just like i could have p thread threads i can have a mutex thing here it is and here is a condition variable and just like a p thread mutex initializer lips will fix that actually must be an underscore	a struct	402
and as you can see initially i don't have any cake ok but soon we're going to be creating cake and we're going to use this because i want to talk about creating resources and then consuming those resources ok it's kind of very standard problem that we're going to have when we start writing larger pieces of code that now i've got bits of code processes and threads which are putting things into my data structure or or finishing images or finishing processing of videos etc and then i've got other threads say great as soon as you have these things i wanted now consume these and act upon them right so what do i have in order to implement this well you can see just like i could have p thread threads i can have a mutex thing here it is and here is a condition variable and just like a p thread mutex initializer lips will fix that actually must be an underscore	code	308
and as you can see initially i don't have any cake ok but soon we're going to be creating cake and we're going to use this because i want to talk about creating resources and then consuming those resources ok it's kind of very standard problem that we're going to have when we start writing larger pieces of code that now i've got bits of code processes and threads which are putting things into my data structure or or finishing images or finishing processing of videos etc and then i've got other threads say great as soon as you have these things i wanted now consume these and act upon them right so what do i have in order to implement this well you can see just like i could have p thread threads i can have a mutex thing here it is and here is a condition variable and just like a p thread mutex initializer lips will fix that actually must be an underscore	a mutex	714
and as you can see initially i don't have any cake ok but soon we're going to be creating cake and we're going to use this because i want to talk about creating resources and then consuming those resources ok it's kind of very standard problem that we're going to have when we start writing larger pieces of code that now i've got bits of code processes and threads which are putting things into my data structure or or finishing images or finishing processing of videos etc and then i've got other threads say great as soon as you have these things i wanted now consume these and act upon them right so what do i have in order to implement this well you can see just like i could have p thread threads i can have a mutex thing here it is and here is a condition variable and just like a p thread mutex initializer lips will fix that actually must be an underscore	thread	358
and as you can see initially i don't have any cake ok but soon we're going to be creating cake and we're going to use this because i want to talk about creating resources and then consuming those resources ok it's kind of very standard problem that we're going to have when we start writing larger pieces of code that now i've got bits of code processes and threads which are putting things into my data structure or or finishing images or finishing processing of videos etc and then i've got other threads say great as soon as you have these things i wanted now consume these and act upon them right so what do i have in order to implement this well you can see just like i could have p thread threads i can have a mutex thing here it is and here is a condition variable and just like a p thread mutex initializer lips will fix that actually must be an underscore	resources	161
have a look at the code what have we got right i've got two little methods here and i want to make them thread safe and i want to make sure that my cake never goes negative ok so if you call my decrement function i wanted to block and that is where our condition variable is going to be useful in other words you can only remove cake if if there's at least and a positive value amount of cake again so right so adding things to my cake is easy all i need to do is just come back come back come back there we go add one to my cake and i'm going to ignore overflow issues today ok so right let's think about how we can do this well first of all i need to make my code threads safer so on my increment i want to make sure that only one thread at a time can change the value of cakes so let me call lock in there and then after i finished let me call unlock	block	225
have a look at the code what have we got right i've got two little methods here and i want to make them thread safe and i want to make sure that my cake never goes negative ok so if you call my decrement function i wanted to block and that is where our condition variable is going to be useful in other words you can only remove cake if if there's at least and a positive value amount of cake again so right so adding things to my cake is easy all i need to do is just come back come back come back there we go add one to my cake and i'm going to ignore overflow issues today ok so right let's think about how we can do this well first of all i need to make my code threads safer so on my increment i want to make sure that only one thread at a time can change the value of cakes so let me call lock in there and then after i finished let me call unlock	code	19
have a look at the code what have we got right i've got two little methods here and i want to make them thread safe and i want to make sure that my cake never goes negative ok so if you call my decrement function i wanted to block and that is where our condition variable is going to be useful in other words you can only remove cake if if there's at least and a positive value amount of cake again so right so adding things to my cake is easy all i need to do is just come back come back come back there we go add one to my cake and i'm going to ignore overflow issues today ok so right let's think about how we can do this well first of all i need to make my code threads safer so on my increment i want to make sure that only one thread at a time can change the value of cakes so let me call lock in there and then after i finished let me call unlock	thread	104
ok right so will put that in a little bit and now if two threads calling current at the same time one of them gets stuck waiting for that mutex so they'll call p thread mutex lock on my mute x variable and the first one to do that continues 'cause that no ones holding the duck great raptor duck releases it when they call unlock if whilst we're doing that in another thread calls peter mutex log they can't access that duck 'cause i'm holding it right now so they have to wait they get blocked inside the local right so we've got over there before should be obvious now let's go back to thinking about what we're going to do for this this decrement bettered right so here's the plan ok	block	487
ok right so will put that in a little bit and now if two threads calling current at the same time one of them gets stuck waiting for that mutex so they'll call p thread mutex lock on my mute x variable and the first one to do that continues 'cause that no ones holding the duck great raptor duck releases it when they call unlock if whilst we're doing that in another thread calls peter mutex log they can't access that duck 'cause i'm holding it right now so they have to wait they get blocked inside the local right so we've got over there before should be obvious now let's go back to thinking about what we're going to do for this this decrement bettered right so here's the plan ok	thread	57
we would like to call just cake decrement value but let's imagine we haven't taken cs two forty one so how would we make it so that we can only consume this resource we can only take one away from the cake when there is a piece of cake present well if we didn't do any better we write a loop so here is my really naive little lupe look whilst there's no cake just sleep for a second and try again ok so this is the non cs two forty one version of this code we don't understand synchronization primitives so just do under loop and every second we were polled the result ok so as a stepping stone to using condition variables this is actually really useful way to think because what we've done is we've defined a condition	code	452
let's use our condition variables so instead let's call p thread condition wait there we go	thread	58
we know that does the same thing but others posted just sleeping for a second my thread is gonna sleep like sleeping beauty here ok so	thread	81
right is that the full story no because we have to think about thread safety so	thread	63
here's the here's what we'll have to think about first of all yeah we can't just call minus minus here that's not a thread safe operation so we are also going to need to put in some unlock and locking course so we would like to put in say p thread lock here on the mutex and p thread unlock here also on the mutex	a thread	114
here's the here's what we'll have to think about first of all yeah we can't just call minus minus here that's not a thread safe operation so we are also going to need to put in some unlock and locking course so we would like to put in say p thread lock here on the mutex and p thread unlock here also on the mutex	thread	116
right but that's not quite the whole story ok we have some problems here that the time that we test the value of cake if it is versus the time that we use it we don't want another thread to quickly run in front of us and eat up a piece of cake because then that would mean that we've erroneously managed to make the value of cake go negative and as we said the beginning we're not going to allow that so somehow we need to make sure that i'm between when we check the value of cake here's part of our while	thread	180
not lock there we actually want to lock before we test its value so let's put our mutex lock here p thread mutex lock as the very first thing we're going to do so pthread mutex lock ok grab that duck	thread	100
and here's a big idea with mutex locks is that if we use them correctly you actually only hold on to them for just microseconds at a time just while we say test data structure and then maybe using so ok that looks pretty good we've got rp thread mutex and peter mutex on lock on mutex	a struct	164
and here's a big idea with mutex locks is that if we use them correctly you actually only hold on to them for just microseconds at a time just while we say test data structure and then maybe using so ok that looks pretty good we've got rp thread mutex and peter mutex on lock on mutex	thread	239
our asked what we doing inside a little loop here ok so we're sleeping will not peace it condition wait but it's no problem here if i ask my thread to go to sleep it went to sleep holding the duck no one will be able to continue ok so at this point we can say i told you a little like while i here here's my little lie that i	thread	141
i ok i want my scissors that i put a parentheses there let's drop you off there we go so it actually that is not the whole story for pizza at condition variables when you go to sleep you actually pass in the address or a mutex so	a mutex	219
i ok i want my scissors that i put a parentheses there let's drop you off there we go so it actually that is not the whole story for pizza at condition variables when you go to sleep you actually pass in the address or a mutex so	address	208
before it returns outta peter condition wait it calls p thread mutex lock	thread	56
ok so that means when it finally continues when it finally goes around in this code it has to meet ex again ok so what does this mean this means all the code we write in here we can definitively say that we are holding that mutex that we've acquired it that no one can change the value of cake while square inside this code because we have the mutex and that was a condition in all of the code that we're writing the first you must call pizza admin takes log and if that lock is currently taken sorry you're going to have to wait	code	79
millisecond or so until it's released until whoever is modify or reading the data structure has finished	the data structure	73
millisecond or so until it's released until whoever is modify or reading the data structure has finished	a struct	80
so that's ever critical critical idea alright so will stressed out again in a moment but now we've sketched out how we want our decrement method to work first of all we always have a mutex lock and never we work	a mutex	181
and we have our condition application condition that the cake value must not be zero and here's the big idea peter condition wait we call it a condition variable but there's no condition part that the kernel or the system actually cares about it's up to us to write this while loop and the correct way to use condition variables is always to write them inside a while loop do not using this statement always use a while loop and i'll tell you more about that in a future video ok bye for now	system	215
ok so let's have a look at this example one more time but actually the text editor and then we'll talk specifically about how pthread condition wait actually works	thread	127
so here we go remember the story so far is we want to modify some data structure which will just be a little integer here and in particular we've got a certain condition where we have to wait so for example we don't want the amount of cake to go negative because that doesn't make sense right so rather than star than making cake and negative will just blocked until more cake arrives ok so he was our plan we said	block	353
so here we go remember the story so far is we want to modify some data structure which will just be a little integer here and in particular we've got a certain condition where we have to wait so for example we don't want the amount of cake to go negative because that doesn't make sense right so rather than star than making cake and negative will just blocked until more cake arrives ok so he was our plan we said	a struct	69
hundred seconds but you get the idea right so that's all stepping stone to using a condition variable we do need a loop i'll tell you one big reason why in a moment and what do we need to do we replaced the sleep where their pee thread condition weights and here's a condition variable we're going to ask a threat to sleep in and we also going to release a mutex so it's we discovered it is always necessary to use a mutex because we're going to write code in here where we want to test some condition and then later use that the assumption that condition is now true so we need a mutex lock to ensure that we are the only person get there can be modified data structure so we end up biting p thread mutex lock cave right so there's the log and then later we unlock it	a struct	659
hundred seconds but you get the idea right so that's all stepping stone to using a condition variable we do need a loop i'll tell you one big reason why in a moment and what do we need to do we replaced the sleep where their pee thread condition weights and here's a condition variable we're going to ask a threat to sleep in and we also going to release a mutex so it's we discovered it is always necessary to use a mutex because we're going to write code in here where we want to test some condition and then later use that the assumption that condition is now true so we need a mutex lock to ensure that we are the only person get there can be modified data structure so we end up biting p thread mutex lock cave right so there's the log and then later we unlock it	code	452
hundred seconds but you get the idea right so that's all stepping stone to using a condition variable we do need a loop i'll tell you one big reason why in a moment and what do we need to do we replaced the sleep where their pee thread condition weights and here's a condition variable we're going to ask a threat to sleep in and we also going to release a mutex so it's we discovered it is always necessary to use a mutex because we're going to write code in here where we want to test some condition and then later use that the assumption that condition is now true so we need a mutex lock to ensure that we are the only person get there can be modified data structure so we end up biting p thread mutex lock cave right so there's the log and then later we unlock it	a mutex	355
hundred seconds but you get the idea right so that's all stepping stone to using a condition variable we do need a loop i'll tell you one big reason why in a moment and what do we need to do we replaced the sleep where their pee thread condition weights and here's a condition variable we're going to ask a threat to sleep in and we also going to release a mutex so it's we discovered it is always necessary to use a mutex because we're going to write code in here where we want to test some condition and then later use that the assumption that condition is now true so we need a mutex lock to ensure that we are the only person get there can be modified data structure so we end up biting p thread mutex lock cave right so there's the log and then later we unlock it	thread	229
right so the point then is to actually a threat can block and two places it might be blocked temporarily at the very beginning here just wait get the mutex lock and a good rule of good conceptual idea is that you only holds mutex lock for a few nanoseconds we're modifying something for example ok so reminder this code actually does three things first of all it unlocks the mutex and then it sleeps literally we ask the cpu to go and work on a different thread right so we're not going to execute anymore code but later when we work it up before returning it will re lock which mutex so it will reacquire the mutex so if there happens to be another thread that was temporarily holding that mutex say was also being also college document or those will see in a moment also calling equipment then this thread has to wait so there's lots of places where thread is blocked ports has to wait till it can continue ok right so what about our increment method we saw that before we change the data structure we want to lock the mutex so that we are the only surgeon operating on it and then afterwards we unlock the mutex ok right so what do we forget we forgot to wake up any sleeping threads in here so we've modified the value of cakes so we could wake up all threats so for example we could say p thread condition forecast if we wanted to wake up all threats that might be sleeping inside the thread condition wait or we could call p thread conditions signal if we wanted to just wake up one of them and which one gets working up this arbitrary ok right what else can i say about this well it could be that there's no thread waiting inside the condition variable so in which case our signal or broadcast called here is a no op is not worth calling so if i truly cared about maximum performance i could actually reason about when i actually need to do this i remember that because of the mutex lock only one third of the time can be operating so at this moment we could say look if i've just changed my value of cake from zero to one then that's the only time that there might be sleeping through its otherwise if there's pieces of kate lying about no one 's going to be sleeping when they call decrement so let me test that if cake is now on let me call peter conditions signal now some of you might ask is it best to call peter conditions signal or broadcast before or after you are not the mutex surely it's better to call it afterwards but the surprising thing is	block	52
right so the point then is to actually a threat can block and two places it might be blocked temporarily at the very beginning here just wait get the mutex lock and a good rule of good conceptual idea is that you only holds mutex lock for a few nanoseconds we're modifying something for example ok so reminder this code actually does three things first of all it unlocks the mutex and then it sleeps literally we ask the cpu to go and work on a different thread right so we're not going to execute anymore code but later when we work it up before returning it will re lock which mutex so it will reacquire the mutex so if there happens to be another thread that was temporarily holding that mutex say was also being also college document or those will see in a moment also calling equipment then this thread has to wait so there's lots of places where thread is blocked ports has to wait till it can continue ok right so what about our increment method we saw that before we change the data structure we want to lock the mutex so that we are the only surgeon operating on it and then afterwards we unlock the mutex ok right so what do we forget we forgot to wake up any sleeping threads in here so we've modified the value of cakes so we could wake up all threats so for example we could say p thread condition forecast if we wanted to wake up all threats that might be sleeping inside the thread condition wait or we could call p thread conditions signal if we wanted to just wake up one of them and which one gets working up this arbitrary ok right what else can i say about this well it could be that there's no thread waiting inside the condition variable so in which case our signal or broadcast called here is a no op is not worth calling so if i truly cared about maximum performance i could actually reason about when i actually need to do this i remember that because of the mutex lock only one third of the time can be operating so at this moment we could say look if i've just changed my value of cake from zero to one then that's the only time that there might be sleeping through its otherwise if there's pieces of kate lying about no one 's going to be sleeping when they call decrement so let me test that if cake is now on let me call peter conditions signal now some of you might ask is it best to call peter conditions signal or broadcast before or after you are not the mutex surely it's better to call it afterwards but the surprising thing is	the data structure	982
right so the point then is to actually a threat can block and two places it might be blocked temporarily at the very beginning here just wait get the mutex lock and a good rule of good conceptual idea is that you only holds mutex lock for a few nanoseconds we're modifying something for example ok so reminder this code actually does three things first of all it unlocks the mutex and then it sleeps literally we ask the cpu to go and work on a different thread right so we're not going to execute anymore code but later when we work it up before returning it will re lock which mutex so it will reacquire the mutex so if there happens to be another thread that was temporarily holding that mutex say was also being also college document or those will see in a moment also calling equipment then this thread has to wait so there's lots of places where thread is blocked ports has to wait till it can continue ok right so what about our increment method we saw that before we change the data structure we want to lock the mutex so that we are the only surgeon operating on it and then afterwards we unlock the mutex ok right so what do we forget we forgot to wake up any sleeping threads in here so we've modified the value of cakes so we could wake up all threats so for example we could say p thread condition forecast if we wanted to wake up all threats that might be sleeping inside the thread condition wait or we could call p thread conditions signal if we wanted to just wake up one of them and which one gets working up this arbitrary ok right what else can i say about this well it could be that there's no thread waiting inside the condition variable so in which case our signal or broadcast called here is a no op is not worth calling so if i truly cared about maximum performance i could actually reason about when i actually need to do this i remember that because of the mutex lock only one third of the time can be operating so at this moment we could say look if i've just changed my value of cake from zero to one then that's the only time that there might be sleeping through its otherwise if there's pieces of kate lying about no one 's going to be sleeping when they call decrement so let me test that if cake is now on let me call peter conditions signal now some of you might ask is it best to call peter conditions signal or broadcast before or after you are not the mutex surely it's better to call it afterwards but the surprising thing is	a struct	989
right so the point then is to actually a threat can block and two places it might be blocked temporarily at the very beginning here just wait get the mutex lock and a good rule of good conceptual idea is that you only holds mutex lock for a few nanoseconds we're modifying something for example ok so reminder this code actually does three things first of all it unlocks the mutex and then it sleeps literally we ask the cpu to go and work on a different thread right so we're not going to execute anymore code but later when we work it up before returning it will re lock which mutex so it will reacquire the mutex so if there happens to be another thread that was temporarily holding that mutex say was also being also college document or those will see in a moment also calling equipment then this thread has to wait so there's lots of places where thread is blocked ports has to wait till it can continue ok right so what about our increment method we saw that before we change the data structure we want to lock the mutex so that we are the only surgeon operating on it and then afterwards we unlock the mutex ok right so what do we forget we forgot to wake up any sleeping threads in here so we've modified the value of cakes so we could wake up all threats so for example we could say p thread condition forecast if we wanted to wake up all threats that might be sleeping inside the thread condition wait or we could call p thread conditions signal if we wanted to just wake up one of them and which one gets working up this arbitrary ok right what else can i say about this well it could be that there's no thread waiting inside the condition variable so in which case our signal or broadcast called here is a no op is not worth calling so if i truly cared about maximum performance i could actually reason about when i actually need to do this i remember that because of the mutex lock only one third of the time can be operating so at this moment we could say look if i've just changed my value of cake from zero to one then that's the only time that there might be sleeping through its otherwise if there's pieces of kate lying about no one 's going to be sleeping when they call decrement so let me test that if cake is now on let me call peter conditions signal now some of you might ask is it best to call peter conditions signal or broadcast before or after you are not the mutex surely it's better to call it afterwards but the surprising thing is	code	315
right so the point then is to actually a threat can block and two places it might be blocked temporarily at the very beginning here just wait get the mutex lock and a good rule of good conceptual idea is that you only holds mutex lock for a few nanoseconds we're modifying something for example ok so reminder this code actually does three things first of all it unlocks the mutex and then it sleeps literally we ask the cpu to go and work on a different thread right so we're not going to execute anymore code but later when we work it up before returning it will re lock which mutex so it will reacquire the mutex so if there happens to be another thread that was temporarily holding that mutex say was also being also college document or those will see in a moment also calling equipment then this thread has to wait so there's lots of places where thread is blocked ports has to wait till it can continue ok right so what about our increment method we saw that before we change the data structure we want to lock the mutex so that we are the only surgeon operating on it and then afterwards we unlock the mutex ok right so what do we forget we forgot to wake up any sleeping threads in here so we've modified the value of cakes so we could wake up all threats so for example we could say p thread condition forecast if we wanted to wake up all threats that might be sleeping inside the thread condition wait or we could call p thread conditions signal if we wanted to just wake up one of them and which one gets working up this arbitrary ok right what else can i say about this well it could be that there's no thread waiting inside the condition variable so in which case our signal or broadcast called here is a no op is not worth calling so if i truly cared about maximum performance i could actually reason about when i actually need to do this i remember that because of the mutex lock only one third of the time can be operating so at this moment we could say look if i've just changed my value of cake from zero to one then that's the only time that there might be sleeping through its otherwise if there's pieces of kate lying about no one 's going to be sleeping when they call decrement so let me test that if cake is now on let me call peter conditions signal now some of you might ask is it best to call peter conditions signal or broadcast before or after you are not the mutex surely it's better to call it afterwards but the surprising thing is	thread	455
that actually best practices are to call signal podcast before here is just a annoying reason why and you can follow the rabbit hole start off on stack overflow and the long discussion about this but the headline is that if you have threads with different priorities then this ensures that the thread with the highest priority will be woken up by this signal so that's a minor detail anas as you'll see all kind of code that follows best practices will do it in that order ok so are we done here let's have a look i've got some code i prepared earlier here it is it looks markedly similar but actually i've done better than that i've got some code i made earlier that actually kind of print some things out and does it wood colour as well so	code	415
that actually best practices are to call signal podcast before here is just a annoying reason why and you can follow the rabbit hole start off on stack overflow and the long discussion about this but the headline is that if you have threads with different priorities then this ensures that the thread with the highest priority will be woken up by this signal so that's a minor detail anas as you'll see all kind of code that follows best practices will do it in that order ok so are we done here let's have a look i've got some code i prepared earlier here it is it looks markedly similar but actually i've done better than that i've got some code i made earlier that actually kind of print some things out and does it wood colour as well so	thread	233
first of all my cake eater is called decrement but it's blocked but it's got blocked on p three condition wait and then after a few seconds we think we call implement a few times so you could see that we've called broadcast now we're going to wake up the document method so peter conditioned weight returns and is able to eat cake right so in fact we can follow this pattern for a few few times the producer makes more cake each time we increment we change the data structure but calling beats condition broadcast and then the decrement method is able to continue and you can see it's it's consuming cakes so this is great we've got basically like a cue based structural or the idea of a producer can 's beginnings of a producer in a consumer and the consumer can block until resources are available and we've implemented this with just a single test like is the value of cake 0 or not but now you could realize that you can write any application condition	block	56
first of all my cake eater is called decrement but it's blocked but it's got blocked on p three condition wait and then after a few seconds we think we call implement a few times so you could see that we've called broadcast now we're going to wake up the document method so peter conditioned weight returns and is able to eat cake right so in fact we can follow this pattern for a few few times the producer makes more cake each time we increment we change the data structure but calling beats condition broadcast and then the decrement method is able to continue and you can see it's it's consuming cakes so this is great we've got basically like a cue based structural or the idea of a producer can 's beginnings of a producer in a consumer and the consumer can block until resources are available and we've implemented this with just a single test like is the value of cake 0 or not but now you could realize that you can write any application condition	the data structure	457
first of all my cake eater is called decrement but it's blocked but it's got blocked on p three condition wait and then after a few seconds we think we call implement a few times so you could see that we've called broadcast now we're going to wake up the document method so peter conditioned weight returns and is able to eat cake right so in fact we can follow this pattern for a few few times the producer makes more cake each time we increment we change the data structure but calling beats condition broadcast and then the decrement method is able to continue and you can see it's it's consuming cakes so this is great we've got basically like a cue based structural or the idea of a producer can 's beginnings of a producer in a consumer and the consumer can block until resources are available and we've implemented this with just a single test like is the value of cake 0 or not but now you could realize that you can write any application condition	a struct	464
first of all my cake eater is called decrement but it's blocked but it's got blocked on p three condition wait and then after a few seconds we think we call implement a few times so you could see that we've called broadcast now we're going to wake up the document method so peter conditioned weight returns and is able to eat cake right so in fact we can follow this pattern for a few few times the producer makes more cake each time we increment we change the data structure but calling beats condition broadcast and then the decrement method is able to continue and you can see it's it's consuming cakes so this is great we've got basically like a cue based structural or the idea of a producer can 's beginnings of a producer in a consumer and the consumer can block until resources are available and we've implemented this with just a single test like is the value of cake 0 or not but now you could realize that you can write any application condition	resources	776
like only start the countdown thread if they walk it has fuel and the astronauts are in the rocket ok	thread	30
so quick comments about this is that how do we ensure that the compiler doesn't optimize this away so for example the compiler might say oh look at this nothing is this code changes please stop maybe i should just turn that into an infinite loop	code	169
simply that this variable don't trust it don't make assumptions about its state always go back to main memory to actually read it just because you're not changing the code doesn't mean that someone else might so it's it's a hint to the optimizer right the last thing we want to say about peter condition wait is it has two important ideas first of all the unlocking the mutex and sleeping actually occurs as if it's an atomic operation so there's no opportunity between unlocking boot x and going to sleep where another threat might call peace road conditions signal we don't want accidentally to allow another thread to continue call peter condition broadcast or signal	memory	103
simply that this variable don't trust it don't make assumptions about its state always go back to main memory to actually read it just because you're not changing the code doesn't mean that someone else might so it's it's a hint to the optimizer right the last thing we want to say about peter condition wait is it has two important ideas first of all the unlocking the mutex and sleeping actually occurs as if it's an atomic operation so there's no opportunity between unlocking boot x and going to sleep where another threat might call peace road conditions signal we don't want accidentally to allow another thread to continue call peter condition broadcast or signal	code	167
simply that this variable don't trust it don't make assumptions about its state always go back to main memory to actually read it just because you're not changing the code doesn't mean that someone else might so it's it's a hint to the optimizer right the last thing we want to say about peter condition wait is it has two important ideas first of all the unlocking the mutex and sleeping actually occurs as if it's an atomic operation so there's no opportunity between unlocking boot x and going to sleep where another threat might call peace road conditions signal we don't want accidentally to allow another thread to continue call peter condition broadcast or signal	thread	611
blocked	block	0
hi so let's review some ideas from c code first of all what do you think the size of char is at this point you say oh now i know this ones easy the size of chart is defined to be one yes the character in c is actually a fundamental way of how we talk about addressable memory and so that's kind of the fundamental unit of one item that we can read or write so that is defined to be one in c code and have a look at their supposing one someone said the following i've got x what is x it's a pointer to in it and we've initialized it to hold the following value now we chose today to write that as a hexadecimal value but we could have also just used integer just a regular decimal integer as well and then someone says ok so what do you think the value of x plus one is at this point you need to say oh ok hold on a moment i know about pointer arithmetic	the following	449
hi so let's review some ideas from c code first of all what do you think the size of char is at this point you say oh now i know this ones easy the size of chart is defined to be one yes the character in c is actually a fundamental way of how we talk about addressable memory and so that's kind of the fundamental unit of one item that we can read or write so that is defined to be one in c code and have a look at their supposing one someone said the following i've got x what is x it's a pointer to in it and we've initialized it to hold the following value now we chose today to write that as a hexadecimal value but we could have also just used integer just a regular decimal integer as well and then someone says ok so what do you think the value of x plus one is at this point you need to say oh ok hold on a moment i know about pointer arithmetic	memory	270
hi so let's review some ideas from c code first of all what do you think the size of char is at this point you say oh now i know this ones easy the size of chart is defined to be one yes the character in c is actually a fundamental way of how we talk about addressable memory and so that's kind of the fundamental unit of one item that we can read or write so that is defined to be one in c code and have a look at their supposing one someone said the following i've got x what is x it's a pointer to in it and we've initialized it to hold the following value now we chose today to write that as a hexadecimal value but we could have also just used integer just a regular decimal integer as well and then someone says ok so what do you think the value of x plus one is at this point you need to say oh ok hold on a moment i know about pointer arithmetic	code	37
hi so let's review some ideas from c code first of all what do you think the size of char is at this point you say oh now i know this ones easy the size of chart is defined to be one yes the character in c is actually a fundamental way of how we talk about addressable memory and so that's kind of the fundamental unit of one item that we can read or write so that is defined to be one in c code and have a look at their supposing one someone said the following i've got x what is x it's a pointer to in it and we've initialized it to hold the following value now we chose today to write that as a hexadecimal value but we could have also just used integer just a regular decimal integer as well and then someone says ok so what do you think the value of x plus one is at this point you need to say oh ok hold on a moment i know about pointer arithmetic	address	258
hi so let's review some ideas from c code first of all what do you think the size of char is at this point you say oh now i know this ones easy the size of chart is defined to be one yes the character in c is actually a fundamental way of how we talk about addressable memory and so that's kind of the fundamental unit of one item that we can read or write so that is defined to be one in c code and have a look at their supposing one someone said the following i've got x what is x it's a pointer to in it and we've initialized it to hold the following value now we chose today to write that as a hexadecimal value but we could have also just used integer just a regular decimal integer as well and then someone says ok so what do you think the value of x plus one is at this point you need to say oh ok hold on a moment i know about pointer arithmetic	pointer	491
and x is a pointer so when i try to move left to right by using point arithmetic it actually depends upon the size of the type that x is pointing to which is an int	type	122
and x is a pointer so when i try to move left to right by using point arithmetic it actually depends upon the size of the type that x is pointing to which is an int	pointer	11
so what do i have i'm on a thirty two bit machine what can i say about the size of my integers well actually you don't know you cannot say for certain in this case because we're not talking about looking at pointers which we can make a particular diction about their size we actually talking about just a simple scalar simple value type here so how big is an int	type	332
so what do i have i'm on a thirty two bit machine what can i say about the size of my integers well actually you don't know you cannot say for certain in this case because we're not talking about looking at pointers which we can make a particular diction about their size we actually talking about just a simple scalar simple value type here so how big is an int	pointer	207
so let's see one or thirty two bit machine but that's not enough to narrow it down now we do know that the c specification gives us a minimum size for at into type and that's just two bites so it's probably going to be somewhere between two bites and four bytes now today if you were to run this on a thirty two bit machine that you can get your hands on maybe a small cell phone may be really old laptop	type	159
but like i said because we're dealing with vince and not pointers we can't say that for certain	pointer	57
all right now the last thing will talk about is the following code let's see if we can spot some errors in this code ok so anytime we use malloc we should slow down and check their actually getting the minor mattix	the following	48
all right now the last thing will talk about is the following code let's see if we can spot some errors in this code ok so anytime we use malloc we should slow down and check their actually getting the minor mattix	code	62
number right number of bytes so today we're trying to store inside this variable a what is a it's a pointer to a double so i need enough space to hold at least a double floating point number which will be eight bites what do we ask for we said hey malloc this is number why it's telling about the size of a double pointer	pointer	100
instead we asked for the size of a pointer now on a sixty four bit machine we're in luck that will be eight bytes which will be the amount of memory we wanted on a thirty two bit machine were not so lucky because our point is only need four bytes so an easy we have actually now requested an insufficient number of bytes or because of this sneaky aspects down here so don't fall for the kind of visual trap of making the type here the same as the type inside you the size of	memory	142
instead we asked for the size of a pointer now on a sixty four bit machine we're in luck that will be eight bytes which will be the amount of memory we wanted on a thirty two bit machine were not so lucky because our point is only need four bytes so an easy we have actually now requested an insufficient number of bytes or because of this sneaky aspects down here so don't fall for the kind of visual trap of making the type here the same as the type inside you the size of	type	421
instead we asked for the size of a pointer now on a sixty four bit machine we're in luck that will be eight bytes which will be the amount of memory we wanted on a thirty two bit machine were not so lucky because our point is only need four bytes so an easy we have actually now requested an insufficient number of bytes or because of this sneaky aspects down here so don't fall for the kind of visual trap of making the type here the same as the type inside you the size of	pointer	35
so that's kind of a big gotcha right then what do we do we say ok let's have another variable called be it's going to be appointed to do a double as well and so we've assigned it away in other words at this point i've got a and b both holding the address that was both looking at	address	247
they both got their own kind of little bit patterns somewhere inside memory	memory	69
full bites eight bytes and here's be and that is a number which is the address of my four bites on the heap well i've got my value ok so now we say freebie in other words used be to say hey heap i don't need this memory anymore	memory	213
full bites eight bytes and here's be and that is a number which is the address of my four bites on the heap well i've got my value ok so now we say freebie in other words used be to say hey heap i don't need this memory anymore	the heap	99
full bites eight bytes and here's be and that is a number which is the address of my four bites on the heap well i've got my value ok so now we say freebie in other words used be to say hey heap i don't need this memory anymore	address	71
and as a good citizen i've changed be now to look at nothing so hopefully if someone tries to use my b code in the future the program will crash immediately as opposed to overwriting some memory that i'm no longer using to hold a value but then i say oh use a follow a dereference a to hold the following double value and i'm passing in this file integer called bad food and there's like a sheep this unhappy with this grass so at this point if we're lucky our program will crash if we're unlucky it will crash in an exciting and mysterious mysterious ways later if we really lucky it will not crash and instead give erroneous results and do arbitrary behaviors	the following	291
and as a good citizen i've changed be now to look at nothing so hopefully if someone tries to use my b code in the future the program will crash immediately as opposed to overwriting some memory that i'm no longer using to hold a value but then i say oh use a follow a dereference a to hold the following double value and i'm passing in this file integer called bad food and there's like a sheep this unhappy with this grass so at this point if we're lucky our program will crash if we're unlucky it will crash in an exciting and mysterious mysterious ways later if we really lucky it will not crash and instead give erroneous results and do arbitrary behaviors	memory	188
and as a good citizen i've changed be now to look at nothing so hopefully if someone tries to use my b code in the future the program will crash immediately as opposed to overwriting some memory that i'm no longer using to hold a value but then i say oh use a follow a dereference a to hold the following double value and i'm passing in this file integer called bad food and there's like a sheep this unhappy with this grass so at this point if we're lucky our program will crash if we're unlucky it will crash in an exciting and mysterious mysterious ways later if we really lucky it will not crash and instead give erroneous results and do arbitrary behaviors	code	103
so the we're not happy with this because just in line three but we actually deallocated that memory we freed up	memory	93
ok let's have a look at the different example so what do you think about the following i've got little variable called result what is it it points to characters so it's a pointer it holds memory dresses and then we say stroke copy another words copy the following and we're going to pass in	the following	73
ok let's have a look at the different example so what do you think about the following i've got little variable called result what is it it points to characters so it's a pointer it holds memory dresses and then we say stroke copy another words copy the following and we're going to pass in	memory	188
ok let's have a look at the different example so what do you think about the following i've got little variable called result what is it it points to characters so it's a pointer it holds memory dresses and then we say stroke copy another words copy the following and we're going to pass in	pointer	171
to store copy the address of crash maybe and also passing in the address held by result and what is that and the answer is it could be anything results looks like it's just a piece of code here so it's going to be just a stack variable so result is going to hold some arbitrary bit pattern in other words lines five and six are going to copy a whole sequence of bytes into some arbitrary piece of memory that result is pointing to so again if we're lucky instantly if we are not so lucky it will crash later if we really unlucky now we just made a program do arbitrary an undefined behavior in the future ok and what about this last one this is meant to be an append function	memory	397
to store copy the address of crash maybe and also passing in the address held by result and what is that and the answer is it could be anything results looks like it's just a piece of code here so it's going to be just a stack variable so result is going to hold some arbitrary bit pattern in other words lines five and six are going to copy a whole sequence of bytes into some arbitrary piece of memory that result is pointing to so again if we're lucky instantly if we are not so lucky it will crash later if we really unlucky now we just made a program do arbitrary an undefined behavior in the future ok and what about this last one this is meant to be an append function	code	184
to store copy the address of crash maybe and also passing in the address held by result and what is that and the answer is it could be anything results looks like it's just a piece of code here so it's going to be just a stack variable so result is going to hold some arbitrary bit pattern in other words lines five and six are going to copy a whole sequence of bytes into some arbitrary piece of memory that result is pointing to so again if we're lucky instantly if we are not so lucky it will crash later if we really unlucky now we just made a program do arbitrary an undefined behavior in the future ok and what about this last one this is meant to be an append function	address	18
which takes a available ptr and what's meant to be it's meant to be a pointer	pointer	70
to a character pointer	pointer	15
and also another variable called parameter called message which is a pointer to a cosmic set of characters in other words we promised not to change what messages pointing to so let's just remind ourselves what this actually means it means that we're ptr is going to hold a value which itself is a pointer so it's looking over here	parameter	33
and also another variable called parameter called message which is a pointer to a cosmic set of characters in other words we promised not to change what messages pointing to so let's just remind ourselves what this actually means it means that we're ptr is going to hold a value which itself is a pointer so it's looking over here	pointer	69
but you won't actually find any characters there instead it's a pointer itself so it also is going to be four bytes or eight bytes holding a memory address and if we follow that that is where we will find the beginning of some string ok so this function is meant to append things but it has several errors so to fix it i'm actually going to take their code and will will edit it in place in a text editor ok so little bit larger alright so it's	memory	141
but you won't actually find any characters there instead it's a pointer itself so it also is going to be four bytes or eight bytes holding a memory address and if we follow that that is where we will find the beginning of some string ok so this function is meant to append things but it has several errors so to fix it i'm actually going to take their code and will will edit it in place in a text editor ok so little bit larger alright so it's	code	352
but you won't actually find any characters there instead it's a pointer itself so it also is going to be four bytes or eight bytes holding a memory address and if we follow that that is where we will find the beginning of some string ok so this function is meant to append things but it has several errors so to fix it i'm actually going to take their code and will will edit it in place in a text editor ok so little bit larger alright so it's	string	227
but you won't actually find any characters there instead it's a pointer itself so it also is going to be four bytes or eight bytes holding a memory address and if we follow that that is where we will find the beginning of some string ok so this function is meant to append things but it has several errors so to fix it i'm actually going to take their code and will will edit it in place in a text editor ok so little bit larger alright so it's	address	148
but you won't actually find any characters there instead it's a pointer itself so it also is going to be four bytes or eight bytes holding a memory address and if we follow that that is where we will find the beginning of some string ok so this function is meant to append things but it has several errors so to fix it i'm actually going to take their code and will will edit it in place in a text editor ok so little bit larger alright so it's	pointer	64
so the first thing that jumps out to me is a pattern stroll end of of malaquais hold a moment that is not going to be the night right number of bytes to hold a string i would at least expect this to be ok take the string message and add add one to it ok so what does this code attempting to do here it says hey i've got a pointer to someone elses pointer so let's look at that let's look at that point and if it's not initialized to anything in other words it's just looking at null then our plan will be to change their pointer to look at some knew heat memory	memory	555
so the first thing that jumps out to me is a pattern stroll end of of malaquais hold a moment that is not going to be the night right number of bytes to hold a string i would at least expect this to be ok take the string message and add add one to it ok so what does this code attempting to do here it says hey i've got a pointer to someone elses pointer so let's look at that let's look at that point and if it's not initialized to anything in other words it's just looking at null then our plan will be to change their pointer to look at some knew heat memory	code	272
so the first thing that jumps out to me is a pattern stroll end of of malaquais hold a moment that is not going to be the night right number of bytes to hold a string i would at least expect this to be ok take the string message and add add one to it ok so what does this code attempting to do here it says hey i've got a pointer to someone elses pointer so let's look at that let's look at that point and if it's not initialized to anything in other words it's just looking at null then our plan will be to change their pointer to look at some knew heat memory	string	160
so the first thing that jumps out to me is a pattern stroll end of of malaquais hold a moment that is not going to be the night right number of bytes to hold a string i would at least expect this to be ok take the string message and add add one to it ok so what does this code attempting to do here it says hey i've got a pointer to someone elses pointer so let's look at that let's look at that point and if it's not initialized to anything in other words it's just looking at null then our plan will be to change their pointer to look at some knew heat memory	pointer	322
right so the idea is if there's nothing there hey let's at least get some some memory setup otherwise if they have given us a valid pointer then we'll assume that it's big enough to actually copy too so that's the purpose of this store cat line is hey again i'm looking at their pointer so i want to know its value and i'm	memory	79
right so the idea is if there's nothing there hey let's at least get some some memory setup otherwise if they have given us a valid pointer then we'll assume that it's big enough to actually copy too so that's the purpose of this store cat line is hey again i'm looking at their pointer so i want to know its value and i'm	pointer	132
ok so we could require that they give us sufficient memory but what about the case where we just called malac well what's going to be inside that heat memory	memory	52
well i could write code to now	code	19
let's see do malloc and then in the case of mark use store copy but instead let me show you another alternative which is let's let's deliberately set the very first bite of that heat memory to zero so in other words right how do i do that i need to dereference twice my variable to finally get to that very first character of my heap so let me set that to zero and i can do that by typing the integer zero or i can type the ascii nul byte right so this is the ascii nul byte which is not the same is writing know with two l's anytime you see 2 l tells you know you're actually talking about a pointer value ok so now we do that when we get down to strcat, strcat is immediately going to find that nul byte and say ah-ha that's where i should start from the last thing i notice is that returns a type of void pointer avoid pointer isn't is not scary it just means i want to point to some memory but i'm not going to tell you what is there i just actually really only care about the address the actual piece of memory that i want to read or write to later right now i'm not going to declare a type ok so let's return something there and will return say this is the piece of heap memory that may be allocated or the memory that you gave us that is there so the code is written assumes that if we are given	heap memory	1172
let's see do malloc and then in the case of mark use store copy but instead let me show you another alternative which is let's let's deliberately set the very first bite of that heat memory to zero so in other words right how do i do that i need to dereference twice my variable to finally get to that very first character of my heap so let me set that to zero and i can do that by typing the integer zero or i can type the ascii nul byte right so this is the ascii nul byte which is not the same is writing know with two l's anytime you see 2 l tells you know you're actually talking about a pointer value ok so now we do that when we get down to strcat, strcat is immediately going to find that nul byte and say ah-ha that's where i should start from the last thing i notice is that returns a type of void pointer avoid pointer isn't is not scary it just means i want to point to some memory but i'm not going to tell you what is there i just actually really only care about the address the actual piece of memory that i want to read or write to later right now i'm not going to declare a type ok so let's return something there and will return say this is the piece of heap memory that may be allocated or the memory that you gave us that is there so the code is written assumes that if we are given	memory	183
let's see do malloc and then in the case of mark use store copy but instead let me show you another alternative which is let's let's deliberately set the very first bite of that heat memory to zero so in other words right how do i do that i need to dereference twice my variable to finally get to that very first character of my heap so let me set that to zero and i can do that by typing the integer zero or i can type the ascii nul byte right so this is the ascii nul byte which is not the same is writing know with two l's anytime you see 2 l tells you know you're actually talking about a pointer value ok so now we do that when we get down to strcat, strcat is immediately going to find that nul byte and say ah-ha that's where i should start from the last thing i notice is that returns a type of void pointer avoid pointer isn't is not scary it just means i want to point to some memory but i'm not going to tell you what is there i just actually really only care about the address the actual piece of memory that i want to read or write to later right now i'm not going to declare a type ok so let's return something there and will return say this is the piece of heap memory that may be allocated or the memory that you gave us that is there so the code is written assumes that if we are given	type	415
let's see do malloc and then in the case of mark use store copy but instead let me show you another alternative which is let's let's deliberately set the very first bite of that heat memory to zero so in other words right how do i do that i need to dereference twice my variable to finally get to that very first character of my heap so let me set that to zero and i can do that by typing the integer zero or i can type the ascii nul byte right so this is the ascii nul byte which is not the same is writing know with two l's anytime you see 2 l tells you know you're actually talking about a pointer value ok so now we do that when we get down to strcat, strcat is immediately going to find that nul byte and say ah-ha that's where i should start from the last thing i notice is that returns a type of void pointer avoid pointer isn't is not scary it just means i want to point to some memory but i'm not going to tell you what is there i just actually really only care about the address the actual piece of memory that i want to read or write to later right now i'm not going to declare a type ok so let's return something there and will return say this is the piece of heap memory that may be allocated or the memory that you gave us that is there so the code is written assumes that if we are given	code	1258
let's see do malloc and then in the case of mark use store copy but instead let me show you another alternative which is let's let's deliberately set the very first bite of that heat memory to zero so in other words right how do i do that i need to dereference twice my variable to finally get to that very first character of my heap so let me set that to zero and i can do that by typing the integer zero or i can type the ascii nul byte right so this is the ascii nul byte which is not the same is writing know with two l's anytime you see 2 l tells you know you're actually talking about a pointer value ok so now we do that when we get down to strcat, strcat is immediately going to find that nul byte and say ah-ha that's where i should start from the last thing i notice is that returns a type of void pointer avoid pointer isn't is not scary it just means i want to point to some memory but i'm not going to tell you what is there i just actually really only care about the address the actual piece of memory that i want to read or write to later right now i'm not going to declare a type ok so let's return something there and will return say this is the piece of heap memory that may be allocated or the memory that you gave us that is there so the code is written assumes that if we are given	address	981
let's see do malloc and then in the case of mark use store copy but instead let me show you another alternative which is let's let's deliberately set the very first bite of that heat memory to zero so in other words right how do i do that i need to dereference twice my variable to finally get to that very first character of my heap so let me set that to zero and i can do that by typing the integer zero or i can type the ascii nul byte right so this is the ascii nul byte which is not the same is writing know with two l's anytime you see 2 l tells you know you're actually talking about a pointer value ok so now we do that when we get down to strcat, strcat is immediately going to find that nul byte and say ah-ha that's where i should start from the last thing i notice is that returns a type of void pointer avoid pointer isn't is not scary it just means i want to point to some memory but i'm not going to tell you what is there i just actually really only care about the address the actual piece of memory that i want to read or write to later right now i'm not going to declare a type ok so let's return something there and will return say this is the piece of heap memory that may be allocated or the memory that you gave us that is there so the code is written assumes that if we are given	pointer	593
valid piece of memory that is large enough we could now modify this code to actually calculate the new length of of the old message there plus whatever pending and possibly create larger piece of memory for that but i think it's time to stop this video and if you wish how big are doing that and the other kind of piece of fun homework fun thing to think about is on his previous page which is try the following how about a forking program where the pen process creates end child processes or as an alternative picture can you create a chain of process in other words each process except the last one has its own child process so there are two very different structures of processes	the following	398
valid piece of memory that is large enough we could now modify this code to actually calculate the new length of of the old message there plus whatever pending and possibly create larger piece of memory for that but i think it's time to stop this video and if you wish how big are doing that and the other kind of piece of fun homework fun thing to think about is on his previous page which is try the following how about a forking program where the pen process creates end child processes or as an alternative picture can you create a chain of process in other words each process except the last one has its own child process so there are two very different structures of processes	memory	15
valid piece of memory that is large enough we could now modify this code to actually calculate the new length of of the old message there plus whatever pending and possibly create larger piece of memory for that but i think it's time to stop this video and if you wish how big are doing that and the other kind of piece of fun homework fun thing to think about is on his previous page which is try the following how about a forking program where the pen process creates end child processes or as an alternative picture can you create a chain of process in other words each process except the last one has its own child process so there are two very different structures of processes	code	68
ok right now it's time to start talking about some deep gnarly bits of system programming and in particular what happens when system calls get interrupted ok so many system calls a very fast for example if you want to find your pid that will return immediately but some things might be slow for example if you call write and it's to something which might block like a network socket or a pipe then it is possible that this write call might be interrupted before it completes so positive has the idea of fast and slow devices local disk is considered fast but for slow devices possible than not little bites maybe actually be written so it's important that we find out what actually happened ok so it's important that we actually get and store the result of our write call and then check to see what happens ok so let's just see what are man pages at least on my mac says about to the white call here it is and you'll see that k we've got our standard right we've got p right we talked about a little bit which allows us to include an offset there's even another version which allows us to assemble right using different bits of memories so rather than requiring all of your data to be in one contiguous area you can use this more complicated version to say ok take these bits over there and those bits over there	block	355
ok right now it's time to start talking about some deep gnarly bits of system programming and in particular what happens when system calls get interrupted ok so many system calls a very fast for example if you want to find your pid that will return immediately but some things might be slow for example if you call write and it's to something which might block like a network socket or a pipe then it is possible that this write call might be interrupted before it completes so positive has the idea of fast and slow devices local disk is considered fast but for slow devices possible than not little bites maybe actually be written so it's important that we find out what actually happened ok so it's important that we actually get and store the result of our write call and then check to see what happens ok so let's just see what are man pages at least on my mac says about to the white call here it is and you'll see that k we've got our standard right we've got p right we talked about a little bit which allows us to include an offset there's even another version which allows us to assemble right using different bits of memories so rather than requiring all of your data to be in one contiguous area you can use this more complicated version to say ok take these bits over there and those bits over there	system	71
then it will just return doesn't actually do any writing force ok what a lazy kernel that is so ok will keep scrolling down and you can see here there's more and more stuff there's other ones as well for when we start talking about asynchronous rights so you probably heard of node dot js which is kind of taking the server world by storm but we can make javascript on the server that uses asynchronous io and so it uses epoll to figure out which file descriptors ready and it uses things like these e again and he would block to figure out which file descriptors ready for more bites so as you can see there's plenty and plenty of errors that we might want to deal with at some point or gate right but we are just going to think about this what this idea about oh i was interrupted key so if we don't handle this then	block	521
exciting things might happen so perhaps you've written code that uses same weight right so same way is supposed to actually wait until there was a piece of pizza available in the pizza box for as to eat but it just got interrupted and just returned as it off so i can be bothered to wait anymore right and so then we let our code continue	code	55
oh idea so we've been oversimplifying things at this point we haven't been writing high quality code instead what we need to do is we need to check the return value of some weight and read and write and even sleep if we actually want to write production worthy code because some weight might be say oh i failed and it might fail simply because it got into up to do to a signal so we can check this and then we can just re run it again so typically you'll see the following kind of code that	the following	459
oh idea so we've been oversimplifying things at this point we haven't been writing high quality code instead what we need to do is we need to check the return value of some weight and read and write and even sleep if we actually want to write production worthy code because some weight might be say oh i failed and it might fail simply because it got into up to do to a signal so we can check this and then we can just re run it again so typically you'll see the following kind of code that	code	96
and we're going to call some way on a particular counting semaphore ok like ok here's a pointer to my structure there but it could be that that returns a negative one meaning it failed ok so we could store that inside a little variable here it is	pointer	88
k is equal to ok you just interrupted then go round the loop again so here's our trick that's all big expression for awhile and notice it as a side effect of evaluating this while we actually call sam wait ok so put all that inside there and dropped a t t inside and for the actual body of the while loop don't do anything	the loop	52
ok right so that would be more production quality code we might as well log any other errors as well so that if we get out of this loop and we see that we didn't get zero value here then maybe we actually want to	code	50
for example that would that would help us catch if the county center was not properly initialized ok so this is a lot of annoying code to write each time and actually makes it harder for us to generally read our code so also people tend to kind of put this code inside a little function calls so you might want something called say same way reentrant or my same weight which kind of does this error checking as well and does this	code	130
oh i must have right to thirty seven bytes but that's not enough so let's keep account of the true number of bites that we've actually sent so far and then go round the loop to try to send the remainder obviously we don't start from the beginning we want to start from whatever offset that we've counted up so far or maybe we've now got to the point where total bytes sent is everything which case we can finish and return say yeah we sent all the bytes ok we're done we're done with this return so we've actually got to write code that copes correctly with all four of these situations	the loop	165
oh i must have right to thirty seven bytes but that's not enough so let's keep account of the true number of bites that we've actually sent so far and then go round the loop to try to send the remainder obviously we don't start from the beginning we want to start from whatever offset that we've counted up so far or maybe we've now got to the point where total bytes sent is everything which case we can finish and return say yeah we sent all the bytes ok we're done we're done with this return so we've actually got to write code that copes correctly with all four of these situations	code	527
for read we also have the possibility that it would return zero which means ok that's it you've read anything and there's no more bites coming through this pipe is now closed for business i can tell you no one is going to read anymore or this stream safer the terminal is not getting any more bites or this file you've reached the end of it ok so again we have to write sophisticated code to think about these possible different states	code	384
right i finally was sleep so we sleep we say please sleep for so many seconds but it is possible to be interrupted so let's have a quick look at sleep this one is going to be a little bit easier so we see we probably want section two let's try that section three ten	section	222
k so will put that in there and will know that sleep return zero if the if it's actually manage to sleep number of seconds otherwise for sleep it will never return negative one so we don't have to worry about that for sleep so life is a bit simpler for sleep we just need to keep a running tally the total number of seconds slept so far so ok done plus equals are so that's a lot simpler in the right code again after right but gives you the same idea that we keep keep track of how much progress we've made towards completing our goal so if we now put this	code	401
into the earlier code where we played with process is you'd now notice that sleep now would works a lot better even when i have child processes that existing and causing c chart events which interrupt our sleep	code	17
ok right so let's run through some simulations of purposes obtaining some resources case so what do we have here right so first of all let's not confuse deadlock with dreadlocks ok both of those can get you into trouble on the high seas so but we are looking at c code today but just a simulation of process is requesting obtaining resources and releasing them ok so what do we got right	code	264
ok right so let's run through some simulations of purposes obtaining some resources case so what do we have here right so first of all let's not confuse deadlock with dreadlocks ok both of those can get you into trouble on the high seas so but we are looking at c code today but just a simulation of process is requesting obtaining resources and releasing them ok so what do we got right	resources	74
ok so here's the here's the game that assume processes require locks in the order specified and really sources resources only when finished ok so we're going to use what's called a resource allocation graph to determine if and when there is deadlock so we could sketch out the order in which processes or obtain these locks and there's a possible order maybe that will lead to deadlock ok so	resources	111
and then it will then it will continue ok so i went to process wait for resources will quite an exclusive lock called resource as soon as no other processes have text message block ok and will assume the locks affair so in the general case with the period mutex locks we could set oarlocks up to a give processes with the highest priority access to exclusive lock but in general the sequence of which the locks are assigned to up process is arbitrary	block	175
and then it will then it will continue ok so i went to process wait for resources will quite an exclusive lock called resource as soon as no other processes have text message block ok and will assume the locks affair so in the general case with the period mutex locks we could set oarlocks up to a give processes with the highest priority access to exclusive lock but in general the sequence of which the locks are assigned to up process is arbitrary	resources	72
ok right so how do we write these resource allocation graphs well first of all let's write down our resources of different types so	type	123
ok right so how do we write these resource allocation graphs well first of all let's write down our resources of different types so	resources	100
here we go right i've got different resources down here here's my resource of type a b and c ok so you might imagine for example these are pieces of hardware maybe it's exclusive access to the screen i want to go and put my computer into a kind of full screen mode so only i can actually kind of right to the screen or maybe it's a piece of hardware maybe i want exclusive access to the firmware or to storage device or maybe it's a database table and i now need to make sure that only i can access it	type	78
here we go right i've got different resources down here here's my resource of type a b and c ok so you might imagine for example these are pieces of hardware maybe it's exclusive access to the screen i want to go and put my computer into a kind of full screen mode so only i can actually kind of right to the screen or maybe it's a piece of hardware maybe i want exclusive access to the firmware or to storage device or maybe it's a database table and i now need to make sure that only i can access it	resources	36
or maybe it's some data structure but whatever it is we have this idea that only one process or thread at a time can access it now i'm going to use the word process that's kind of historical reference in the sense that we thought about these things even with four threads exist but you could imagine how we could set up identical situations to multiple threads running inside just one process so it's the concept is the theory which is the most important idea here ok so what do i got in question one i've got my first process p one requests and obtains resource a and then resource be ok so let's set up process one here ok process one	a struct	22
or maybe it's some data structure but whatever it is we have this idea that only one process or thread at a time can access it now i'm going to use the word process that's kind of historical reference in the sense that we thought about these things even with four threads exist but you could imagine how we could set up identical situations to multiple threads running inside just one process so it's the concept is the theory which is the most important idea here ok so what do i got in question one i've got my first process p one requests and obtains resource a and then resource be ok so let's set up process one here ok process one	thread	96
right we done no so the next thing and in our timeline here is process two requests see ok so let me choose a different color for a process to ok right so process two first requests see ok so it gets see fine it's holding on to that got screws have access to that resource but then it would like be unfortunately it can't right now be is currently being held by process one so it's going to look longingly is hand is outstretched	a process	130
wanting to touch be but no it's stuck on the outside looking at this box can i really want this but i'm being forced to wait because process one has exclusive access ok so that's the beginnings of a resource allocation graph or rag right and you can see the process to cannot continue right now it doesn't have everything it needs and we can actually say oh look it's stuck because it's waiting for resource be and the reason we can't get it is because process one is still running right so do we have deadlock well no we don't because we can see that process one isn't actually waiting for any resources yeah sure it's being a bit slow and finishing up but there's no reason for it to actually run forever so at some point it's going to finish and when it does so it can release these resources ok so delete that line and we delete that line so we can now see that process too and no longer needs to be waiting for the mystery source be and so we could raise the at and turn that back into a line that's looking at it and say ok great now process to has everything it needs it can continue so if we were writing code you can imagine our call to peter mutex lock has finally completed or access to the reader writer data structures finally given 's ability to read that so great we can continue right so eventually process too because it has all the resources it needs can continue as well we don't care how long it's going to take all we can say is for sure is that there is no deadlock ok so in this case no and no alright so that was an easy one join me in the next video when i look at a more complicated one alright see you then	a struct	1219
wanting to touch be but no it's stuck on the outside looking at this box can i really want this but i'm being forced to wait because process one has exclusive access ok so that's the beginnings of a resource allocation graph or rag right and you can see the process to cannot continue right now it doesn't have everything it needs and we can actually say oh look it's stuck because it's waiting for resource be and the reason we can't get it is because process one is still running right so do we have deadlock well no we don't because we can see that process one isn't actually waiting for any resources yeah sure it's being a bit slow and finishing up but there's no reason for it to actually run forever so at some point it's going to finish and when it does so it can release these resources ok so delete that line and we delete that line so we can now see that process too and no longer needs to be waiting for the mystery source be and so we could raise the at and turn that back into a line that's looking at it and say ok great now process to has everything it needs it can continue so if we were writing code you can imagine our call to peter mutex lock has finally completed or access to the reader writer data structures finally given 's ability to read that so great we can continue right so eventually process too because it has all the resources it needs can continue as well we don't care how long it's going to take all we can say is for sure is that there is no deadlock ok so in this case no and no alright so that was an easy one join me in the next video when i look at a more complicated one alright see you then	code	1113
wanting to touch be but no it's stuck on the outside looking at this box can i really want this but i'm being forced to wait because process one has exclusive access ok so that's the beginnings of a resource allocation graph or rag right and you can see the process to cannot continue right now it doesn't have everything it needs and we can actually say oh look it's stuck because it's waiting for resource be and the reason we can't get it is because process one is still running right so do we have deadlock well no we don't because we can see that process one isn't actually waiting for any resources yeah sure it's being a bit slow and finishing up but there's no reason for it to actually run forever so at some point it's going to finish and when it does so it can release these resources ok so delete that line and we delete that line so we can now see that process too and no longer needs to be waiting for the mystery source be and so we could raise the at and turn that back into a line that's looking at it and say ok great now process to has everything it needs it can continue so if we were writing code you can imagine our call to peter mutex lock has finally completed or access to the reader writer data structures finally given 's ability to read that so great we can continue right so eventually process too because it has all the resources it needs can continue as well we don't care how long it's going to take all we can say is for sure is that there is no deadlock ok so in this case no and no alright so that was an easy one join me in the next video when i look at a more complicated one alright see you then	resources	595
colon and then the port number so off we get and what what do we see we actually see that this little module by by python gives me a directory listing and then i can click on a link here ok and actually see the code that we just wrote today which is kind of fun	code	211
ok and if i wanted i could have a little website here as well so now let's do let's do our web client in c so here we go one of the same thing now from our c code	code	158
we'll see that my python servers been happily reporting all the things that fire fox has been requesting so let me break out of that now an run it in the background ok so off it goes because now i want to start compiling my code right so we'll compile the client and run it and we see the beginnings of this yes it connects we see a status message of two hundred which means the server liked our request and it tells me the content length is four hundred nineteen bytes but for some reason we don't see the content our problem right now is that we just called read once and so we got back the head up but that wasn't enough to see the rest of the information so time to wrap this inside a loop ok so let's keep on reading read until we don't want to case so let's think about first of all we want to escape this if if reed returned a zero or negative value so zero remember for read means that there's no more bites so zero would mean the end it's the end of the line no more bites for you negative one would be failure so in either case will will stop so	code	224
we'll see that my python servers been happily reporting all the things that fire fox has been requesting so let me break out of that now an run it in the background ok so off it goes because now i want to start compiling my code right so we'll compile the client and run it and we see the beginnings of this yes it connects we see a status message of two hundred which means the server liked our request and it tells me the content length is four hundred nineteen bytes but for some reason we don't see the content our problem right now is that we just called read once and so we got back the head up but that wasn't enough to see the rest of the information so time to wrap this inside a loop ok so let's keep on reading read until we don't want to case so let's think about first of all we want to escape this if if reed returned a zero or negative value so zero remember for read means that there's no more bites so zero would mean the end it's the end of the line no more bites for you negative one would be failure so in either case will will stop so	background	154
compile run it again and now we see our web server is actually giving back there very code that was used to request it which i think is kind of cool alright that's enough for this lecture i will see you on friday ok bye	code	86
ok hi welcome to lecture thirty five so let's get started we are going to be looking at signals and working with the machines from cool things we can do it but first alkaline kind of puzzle for you alright let's take a look at the following code and workout what will it print so we initialize are using this odd looking smiley ok we print out its value and looks like we should put another i in here because we're actually going into decimal value and a hexadecimal value so will fix that to have two eyes but then we calculate their following so one plus two y and then we use another one of these tilders here finally we print out the value of j ok so what will that actually print so let's go and turn to some code we've got let's see my bit puzzle here	the following	227
ok hi welcome to lecture thirty five so let's get started we are going to be looking at signals and working with the machines from cool things we can do it but first alkaline kind of puzzle for you alright let's take a look at the following code and workout what will it print so we initialize are using this odd looking smiley ok we print out its value and looks like we should put another i in here because we're actually going into decimal value and a hexadecimal value so will fix that to have two eyes but then we calculate their following so one plus two y and then we use another one of these tilders here finally we print out the value of j ok so what will that actually print so let's go and turn to some code we've got let's see my bit puzzle here	code	241
right so there it is with the fixed up two versions of right there right so what is this going to print right so take a moment to think about it while i run the code ok	code	161
ok so what about the following though what about this idea was saying ok i'm going to add up all these values and then do a bit wise and as just a single am percent but with the value of tilda two what is that doing ok so if you were to add up one plus two plus four plus eight you'd get to fifteen so why is it that we print out thirteen what is this code doing ok so what we're looking at here is a concrete example of masking and turning out turning off bits so in other words if you had some expression or some variable and all you wanted to do was to turn off a particular bit here's how you can do it you can use a bitwise and to say i only want to let a certain number of my bits survive and then i'm going to give an expression to say which bits i want to allow through the gate and which ones should be masked out so by saying tilde two were saying please generate the bit pattern in base two this would be one more one ala jolla ones about thirty of them and then a zero	the following	17
ok so what about the following though what about this idea was saying ok i'm going to add up all these values and then do a bit wise and as just a single am percent but with the value of tilda two what is that doing ok so if you were to add up one plus two plus four plus eight you'd get to fifteen so why is it that we print out thirteen what is this code doing ok so what we're looking at here is a concrete example of masking and turning out turning off bits so in other words if you had some expression or some variable and all you wanted to do was to turn off a particular bit here's how you can do it you can use a bitwise and to say i only want to let a certain number of my bits survive and then i'm going to give an expression to say which bits i want to allow through the gate and which ones should be masked out so by saying tilde two were saying please generate the bit pattern in base two this would be one more one ala jolla ones about thirty of them and then a zero	code	352
ok so in the next century let's talk about how we can block signals he ready let's go by	block	54
hi so the c library actually has quite a few functions to work with strings when is going to look at a few of them and realize that they're actually really really simple and is actually really really easy to write but the ones inside the c library are probably much better debug and more performant and run faster and quicker than anything we might write for example perhaps they use specialized assembly instructions	string	68
a destination address to; sorry; allows me to write from a source address to a destination address and it will keep going until it copies that zero byte str cat does a similar idea except it will concatenate	address	14
after the end of the string thats already at the destination in other words	string	21
it has to walk along the string until it finds that zero byte and that is where it's going to put the copy the contents of the new one str len, it's an order n operation to find out how long a string is in c we actually have to keep walking until we find that last one and then finally str cmp to compare two strings and that will return zero if the two strings are the same so it's not unusual to write things like	string	25
lets get rid of my lines; if not larger we ok right not unusual to see things like if str compare some string like s if that's the same as like yes then we actually need to check to see if that is zero to know that equal you will even see code that actually uses the not operator so realize that this not operator is actually flipping in the way that you want to so	code	239
lets get rid of my lines; if not larger we ok right not unusual to see things like if str compare some string like s if that's the same as like yes then we actually need to check to see if that is zero to know that equal you will even see code that actually uses the not operator so realize that this not operator is actually flipping in the way that you want to so	string	103
so because it returns zero if they're the same let's see if we just quickly can build version struck up like how can we find out more about how this works and so use demand pages so if we use man str cmp, for example we'll find out things like where is it and also what's its declaration so you'll see that it takes two pointers	pointer	320
to; character pointers there's a promise here that it won't modify the strings in memory and it returns an int so could we write a similar function let's have a go very quickly right so we want to compare one character at a time	memory	82
to; character pointers there's a promise here that it won't modify the strings in memory and it returns an int so could we write a similar function let's have a go very quickly right so we want to compare one character at a time	string	71
to; character pointers there's a promise here that it won't modify the strings in memory and it returns an int so could we write a similar function let's have a go very quickly right so we want to compare one character at a time	pointer	14
at both s1 and s2 ok so we could write the following right let's just keep going round in the loop and we'll figure out when to exit a little bit right but let's have a look so if the contents of s1 is not equal to "the contents of s2, ""oh, we've got a problem, time to quit""" so we need to return some non zero value. now the real version of str cmp actually returns the difference but our fake version jsut returns a non zero value so return say one	the following	39
at both s1 and s2 ok so we could write the following right let's just keep going round in the loop and we'll figure out when to exit a little bit right but let's have a look so if the contents of s1 is not equal to "the contents of s2, ""oh, we've got a problem, time to quit""" so we need to return some non zero value. now the real version of str cmp actually returns the difference but our fake version jsut returns a non zero value so return say one	the loop	90
to do fix me right now the next thing we should do is move on to the next character right so we should increment both pointers. ok, and pointer arithmetic but we're looking at characters so we're only going to move one byte at a time	pointer	118
we actually have to be careful here because if either string if we get to the end of either string then we know we should break out ok so let's check here that we're still looking at valid strings so while s1 is valid right so whilst that is not equal to zero and also while our other string the contents of that point it is also not equal to zero then we know that we're looking at characters the moment the either those conditions fails we should stop proceeding so we're going to keep going around and	string	54
either we will both get to the end of the strings together or we'll find a difference or will get to a point where one string has finished and the other one hasn't so if we escaped out of this loop we know that we've reached the end of one of those strings so if both strings have finished then great we know that actually they're equal right, so if	string	42
the first string has finished	string	10
and the second string is finished then we know we're in good shape now ok let's, let's, do we know thy're equal so we should be returning zero at this point if not we'll return one. now could we do better than this code yes absolutely we we could simplify this last part to first of all to be correct that actually it should	code	215
and the second string is finished then we know we're in good shape now ok let's, let's, do we know thy're equal so we should be returning zero at this point if not we'll return one. now could we do better than this code yes absolutely we we could simplify this last part to first of all to be correct that actually it should	string	15
hi ok so we're not going to do it is today's lecture will actually start this in the next lecture video but i wanted to give you a little challenge which is perhaps you actually can already workout how to write a reader writer implementation that doesn't suffer from starving writers yourself ok i mean i'm going to do this and next lecture by keeping track of the number of writers the number of writing the number of threads that want to read and the number of threads which are reading and so perhaps you can reason it out yourself so next time you laying in bed unable to sleep or on the bus or in your chemistry class whatever safe you can actually sketch out how you would implement this that's my little challenge to you i'll see you in the next letter by	thread	419
hi so welcome to a bit of a challenge here what is this madness what does this code possibly do so it's written in a very kind of bizarre way we want to see if c is greater than one and if it is then fork so how can we describe this possible code well remember every time we call fork the college process continues but we get a new one as well the only difference between them is at that point is that one of them	code	79
go around the loop again however if i am the other process where fork returns	the loop	10
ok so here's the original power to poopy doopy doopy doopy do and then we made the child process in the child process fork returns zero and otherwise it's true so we get to kyon round the loop so around we go and that child is going to have a value of four but that gets changed to three and the next it's going to make another child and we're going to keep making a child of a child and keep going to make any kind of a child etc until at some point of value of c is no longer greater than one	the loop	184
right so take a look at that string for specific process we expect to turn that string into a simple integer eight why is not particular bust will return zero if it doesn't like the look of the string that you pass in other words if we can't pass a simple integer and then we could sleep	string	29
it's sorting algorithm for system programmers it's it's incredibly awful it says hey process please sleep for this number of seconds so it first first glance great it looks like we've almost created ourselves in order and sleeping sources simple order end algorithm to do sorts but we're relying of course on the operating system to properly schedule our processes and did not return from sleep until that time is up to that time is expired so that's what we've got we create all of these processes we do that very quickly	system	27
ok so posix signals right there is quite a bit to this and so far we've glossed over a lot of details when we just simply said hey call signal and install your own signal handler now this surprisingly is actually one area where the linux man pages is actually quite useful and there's a lot of details so in section seven you can find a whole kind of little mini manual on on posix signals so i code you if you wish to go and have a look at that and to learn more about this ok so my intent here the learning objective here is that you should be able to kind of be comfortable with a standard kind of terminology of signal so it's kind of go over there right and also understand about kind of have some of the implementation of signals works so first of all here's a here's a surprising idea can signals be queued where you might have said yes but actually technically there is a reason here to say no	code	395
ok so posix signals right there is quite a bit to this and so far we've glossed over a lot of details when we just simply said hey call signal and install your own signal handler now this surprisingly is actually one area where the linux man pages is actually quite useful and there's a lot of details so in section seven you can find a whole kind of little mini manual on on posix signals so i code you if you wish to go and have a look at that and to learn more about this ok so my intent here the learning objective here is that you should be able to kind of be comfortable with a standard kind of terminology of signal so it's kind of go over there right and also understand about kind of have some of the implementation of signals works so first of all here's a here's a surprising idea can signals be queued where you might have said yes but actually technically there is a reason here to say no	section	308
then actually if multiple signals signals occur then your process itself may see only one single sick child event may see only one particular signal delivered ok so that is surprised and be careful about that biting you when you actually right signal handlers don't assume that there's a simple one to one correspondence for example suppose i press control c multiple times very very quickly it's quite possible that my process my only see one sigint event the way to imagine this is to imagine that there is a bit field of all the signals that we would like to deliver to a particular process and so once you do find that bit is being set then signals of the same type would fall underneath that same same category or that same signal type ok so in that sense they are not queued	type	665
and say here's a particular signal number that i want to be created or the kernel itself can generate signals for example we've already seen sick child which the kernel will generate when one of the children 's finished we've seen sigpipe we've also seen things like segfault as well with the kernel would generate if your program tries to read or write to an invalid memory location	memory	368
right before that signal aggregates delivered to a process we can say that the signal is pending in other words it's hanging over process wanting to send it to to process so why is it not yet been delivered the answer is because actually processes come lock signals	a process	49
so you can temporarily stop the signal from being delivered this is useful for example perhaps you want some critical code to complete before you allow the user to interrupt it or perhaps you want to set up some communication device before for example you want to deal with any sink pipes or other kind of signals that might have happened so if you one way to consider this is to imagine like a raise shields we will prevent any arrows from arriving right now	code	118
right when is signal is not blocked then we deliver it to a process here we go ok and we say that by being it to leverage that the process can catch or the signal is caught so we've seen that in terms of signal handlers	block	28
right when is signal is not blocked then we deliver it to a process here we go ok and we say that by being it to leverage that the process can catch or the signal is caught so we've seen that in terms of signal handlers	a process	58
and that describes what our process is going to do when the signal is delivered to do it when it's caught by the process and in fact he's a lovely word tell me what's your disposition this position to banana sandwiches what's your disposition to say orange sandwiches how about wasn't disposition to talking before coffee right you've got a view on this ok you've got an idea about	disposition	172
about how you feel about say banana sandwiches well we can also describe the disposition of our process or to a particular signal we could describe what what will happen when a particular signal like sigint	disposition	77
or sigpipe is delivered is it blocked is ignored or will we run some kind of signal handler right so my question to you is do you think this signal disposition is per thread so if i got a multithreaded program can i set different signal dispositions or is it per process our answer that in the next video bye	block	30
or sigpipe is delivered is it blocked is ignored or will we run some kind of signal handler right so my question to you is do you think this signal disposition is per thread so if i got a multithreaded program can i set different signal dispositions or is it per process our answer that in the next video bye	disposition	148
or sigpipe is delivered is it blocked is ignored or will we run some kind of signal handler right so my question to you is do you think this signal disposition is per thread so if i got a multithreaded program can i set different signal dispositions or is it per process our answer that in the next video bye	thread	167
ok so yeah we talked about race conditions what i meant to say is let's talk about a critical section	section	94
so here's here's an important idea that there's possible code that is necessary that only one thread at a time should be executing because in that moment inside part of that code is where we are updating some resource for example updating some data structure or updating a file in a critical way and it's important that no are the process or thread updates at resource at the same time so it's critical that we prevent other threads or processes from also being inside a critical section at the same time so lots of kind of examples and in the real world where there's there's moments in time where we only want kind of one person to be working on something at a time or save as a database you might implement a database so it's critical that only one process updates particular row at a time ok so you can imagine that if we were doing code review you might say hold on a moment there i've got a race condition here between say my implement incrementing i and when we actually reading the value of i in our previous code when we were taking the value of this pointer	a struct	247
so here's here's an important idea that there's possible code that is necessary that only one thread at a time should be executing because in that moment inside part of that code is where we are updating some resource for example updating some data structure or updating a file in a critical way and it's important that no are the process or thread updates at resource at the same time so it's critical that we prevent other threads or processes from also being inside a critical section at the same time so lots of kind of examples and in the real world where there's there's moments in time where we only want kind of one person to be working on something at a time or save as a database you might implement a database so it's critical that only one process updates particular row at a time ok so you can imagine that if we were doing code review you might say hold on a moment there i've got a race condition here between say my implement incrementing i and when we actually reading the value of i in our previous code when we were taking the value of this pointer	code	57
so here's here's an important idea that there's possible code that is necessary that only one thread at a time should be executing because in that moment inside part of that code is where we are updating some resource for example updating some data structure or updating a file in a critical way and it's important that no are the process or thread updates at resource at the same time so it's critical that we prevent other threads or processes from also being inside a critical section at the same time so lots of kind of examples and in the real world where there's there's moments in time where we only want kind of one person to be working on something at a time or save as a database you might implement a database so it's critical that only one process updates particular row at a time ok so you can imagine that if we were doing code review you might say hold on a moment there i've got a race condition here between say my implement incrementing i and when we actually reading the value of i in our previous code when we were taking the value of this pointer	section	480
so here's here's an important idea that there's possible code that is necessary that only one thread at a time should be executing because in that moment inside part of that code is where we are updating some resource for example updating some data structure or updating a file in a critical way and it's important that no are the process or thread updates at resource at the same time so it's critical that we prevent other threads or processes from also being inside a critical section at the same time so lots of kind of examples and in the real world where there's there's moments in time where we only want kind of one person to be working on something at a time or save as a database you might implement a database so it's critical that only one process updates particular row at a time ok so you can imagine that if we were doing code review you might say hold on a moment there i've got a race condition here between say my implement incrementing i and when we actually reading the value of i in our previous code when we were taking the value of this pointer	thread	94
so here's here's an important idea that there's possible code that is necessary that only one thread at a time should be executing because in that moment inside part of that code is where we are updating some resource for example updating some data structure or updating a file in a critical way and it's important that no are the process or thread updates at resource at the same time so it's critical that we prevent other threads or processes from also being inside a critical section at the same time so lots of kind of examples and in the real world where there's there's moments in time where we only want kind of one person to be working on something at a time or save as a database you might implement a database so it's critical that only one process updates particular row at a time ok so you can imagine that if we were doing code review you might say hold on a moment there i've got a race condition here between say my implement incrementing i and when we actually reading the value of i in our previous code when we were taking the value of this pointer	pointer	1060
so we have synchronization bug and it would have been solved if we identified a critical section and said ok we need to divide a moment in time so that define a moment in time so that the value can be read independently of the update	section	89
ok so we'll talk more about critical sections in the future but like i said the big idea is that only one thread at a time should be inside a critical section if our program is to behave correctly	section	37
ok so we'll talk more about critical sections in the future but like i said the big idea is that only one thread at a time should be inside a critical section if our program is to behave correctly	thread	106
so how can we identify what can we do to ensure this and one way to do that is to put locks around our critical section code for example suppose you had some code from cs two twenty five that is going to say insert a link right on a data structure and this price is going to work in the linked list price is going to work on a vector and inside that code you realize that there's a moment in time where you're going to say of mess with the pointers or you're going to copy the entire data structure from us one sized piece of resource to say a doubling of the resources some other piece of memory over there ok so that's a critical section what we need to do then is to block any other threads that want to do a similar operation we want to somehow say right i want to give you exclusive access to this right now so the only you this comment thread is executing in this code gets too	memory	590
so how can we identify what can we do to ensure this and one way to do that is to put locks around our critical section code for example suppose you had some code from cs two twenty five that is going to say insert a link right on a data structure and this price is going to work in the linked list price is going to work on a vector and inside that code you realize that there's a moment in time where you're going to say of mess with the pointers or you're going to copy the entire data structure from us one sized piece of resource to say a doubling of the resources some other piece of memory over there ok so that's a critical section what we need to do then is to block any other threads that want to do a similar operation we want to somehow say right i want to give you exclusive access to this right now so the only you this comment thread is executing in this code gets too	block	670
so how can we identify what can we do to ensure this and one way to do that is to put locks around our critical section code for example suppose you had some code from cs two twenty five that is going to say insert a link right on a data structure and this price is going to work in the linked list price is going to work on a vector and inside that code you realize that there's a moment in time where you're going to say of mess with the pointers or you're going to copy the entire data structure from us one sized piece of resource to say a doubling of the resources some other piece of memory over there ok so that's a critical section what we need to do then is to block any other threads that want to do a similar operation we want to somehow say right i want to give you exclusive access to this right now so the only you this comment thread is executing in this code gets too	a struct	236
so how can we identify what can we do to ensure this and one way to do that is to put locks around our critical section code for example suppose you had some code from cs two twenty five that is going to say insert a link right on a data structure and this price is going to work in the linked list price is going to work on a vector and inside that code you realize that there's a moment in time where you're going to say of mess with the pointers or you're going to copy the entire data structure from us one sized piece of resource to say a doubling of the resources some other piece of memory over there ok so that's a critical section what we need to do then is to block any other threads that want to do a similar operation we want to somehow say right i want to give you exclusive access to this right now so the only you this comment thread is executing in this code gets too	code	120
so how can we identify what can we do to ensure this and one way to do that is to put locks around our critical section code for example suppose you had some code from cs two twenty five that is going to say insert a link right on a data structure and this price is going to work in the linked list price is going to work on a vector and inside that code you realize that there's a moment in time where you're going to say of mess with the pointers or you're going to copy the entire data structure from us one sized piece of resource to say a doubling of the resources some other piece of memory over there ok so that's a critical section what we need to do then is to block any other threads that want to do a similar operation we want to somehow say right i want to give you exclusive access to this right now so the only you this comment thread is executing in this code gets too	section	112
so how can we identify what can we do to ensure this and one way to do that is to put locks around our critical section code for example suppose you had some code from cs two twenty five that is going to say insert a link right on a data structure and this price is going to work in the linked list price is going to work on a vector and inside that code you realize that there's a moment in time where you're going to say of mess with the pointers or you're going to copy the entire data structure from us one sized piece of resource to say a doubling of the resources some other piece of memory over there ok so that's a critical section what we need to do then is to block any other threads that want to do a similar operation we want to somehow say right i want to give you exclusive access to this right now so the only you this comment thread is executing in this code gets too	thread	686
so how can we identify what can we do to ensure this and one way to do that is to put locks around our critical section code for example suppose you had some code from cs two twenty five that is going to say insert a link right on a data structure and this price is going to work in the linked list price is going to work on a vector and inside that code you realize that there's a moment in time where you're going to say of mess with the pointers or you're going to copy the entire data structure from us one sized piece of resource to say a doubling of the resources some other piece of memory over there ok so that's a critical section what we need to do then is to block any other threads that want to do a similar operation we want to somehow say right i want to give you exclusive access to this right now so the only you this comment thread is executing in this code gets too	resources	560
so how can we identify what can we do to ensure this and one way to do that is to put locks around our critical section code for example suppose you had some code from cs two twenty five that is going to say insert a link right on a data structure and this price is going to work in the linked list price is going to work on a vector and inside that code you realize that there's a moment in time where you're going to say of mess with the pointers or you're going to copy the entire data structure from us one sized piece of resource to say a doubling of the resources some other piece of memory over there ok so that's a critical section what we need to do then is to block any other threads that want to do a similar operation we want to somehow say right i want to give you exclusive access to this right now so the only you this comment thread is executing in this code gets too	pointer	440
gets to modify this data structure anybody else that wants to insert something into my data structure or iterate over the linked list or get a value that just going to have to wait until i finished operating on my data structure ok so only one surgeon at a time is the mantra here and how we're going to do that well i'm going to introduce you to our first synchronization primitive in a moment and that is going to be called a mutex alright so i'll see you in the next video when we start talking about mutex in particular p three music clocks rp thread mutex	a struct	23
gets to modify this data structure anybody else that wants to insert something into my data structure or iterate over the linked list or get a value that just going to have to wait until i finished operating on my data structure ok so only one surgeon at a time is the mantra here and how we're going to do that well i'm going to introduce you to our first synchronization primitive in a moment and that is going to be called a mutex alright so i'll see you in the next video when we start talking about mutex in particular p three music clocks rp thread mutex	a mutex	426
gets to modify this data structure anybody else that wants to insert something into my data structure or iterate over the linked list or get a value that just going to have to wait until i finished operating on my data structure ok so only one surgeon at a time is the mantra here and how we're going to do that well i'm going to introduce you to our first synchronization primitive in a moment and that is going to be called a mutex alright so i'll see you in the next video when we start talking about mutex in particular p three music clocks rp thread mutex	thread	548
ok so i want to review the critical section problem	section	36
here is the idea that we don't just say oh i've got a piece that mutex lock that actually is the very problem i'm trying to solve is that i've got a critical section and i want to make sure that if i have say two threads or two processes that only one of them at a time can actually be inside the critical section if two of them are inside the critical section same time then we've probably destroyed the integrity of the data structure that we've got we're trying to modify so the critical section problem became really important in the nineteen sixties when we were trying to figure out how to write good operating systems because with operating systems there's lots of things going on concurrently i've got lots of processes to an update things i've got bits of hardware interrupting me trying to get their data structures fixed so i need to work out very carefully how to implement a good critical section so today we're not going to ask people to going to arrive this	the data structure	418
here is the idea that we don't just say oh i've got a piece that mutex lock that actually is the very problem i'm trying to solve is that i've got a critical section and i want to make sure that if i have say two threads or two processes that only one of them at a time can actually be inside the critical section if two of them are inside the critical section same time then we've probably destroyed the integrity of the data structure that we've got we're trying to modify so the critical section problem became really important in the nineteen sixties when we were trying to figure out how to write good operating systems because with operating systems there's lots of things going on concurrently i've got lots of processes to an update things i've got bits of hardware interrupting me trying to get their data structures fixed so i need to work out very carefully how to implement a good critical section so today we're not going to ask people to going to arrive this	a struct	425
here is the idea that we don't just say oh i've got a piece that mutex lock that actually is the very problem i'm trying to solve is that i've got a critical section and i want to make sure that if i have say two threads or two processes that only one of them at a time can actually be inside the critical section if two of them are inside the critical section same time then we've probably destroyed the integrity of the data structure that we've got we're trying to modify so the critical section problem became really important in the nineteen sixties when we were trying to figure out how to write good operating systems because with operating systems there's lots of things going on concurrently i've got lots of processes to an update things i've got bits of hardware interrupting me trying to get their data structures fixed so i need to work out very carefully how to implement a good critical section so today we're not going to ask people to going to arrive this	section	158
here is the idea that we don't just say oh i've got a piece that mutex lock that actually is the very problem i'm trying to solve is that i've got a critical section and i want to make sure that if i have say two threads or two processes that only one of them at a time can actually be inside the critical section if two of them are inside the critical section same time then we've probably destroyed the integrity of the data structure that we've got we're trying to modify so the critical section problem became really important in the nineteen sixties when we were trying to figure out how to write good operating systems because with operating systems there's lots of things going on concurrently i've got lots of processes to an update things i've got bits of hardware interrupting me trying to get their data structures fixed so i need to work out very carefully how to implement a good critical section so today we're not going to ask people to going to arrive this	thread	213
here is the idea that we don't just say oh i've got a piece that mutex lock that actually is the very problem i'm trying to solve is that i've got a critical section and i want to make sure that if i have say two threads or two processes that only one of them at a time can actually be inside the critical section if two of them are inside the critical section same time then we've probably destroyed the integrity of the data structure that we've got we're trying to modify so the critical section problem became really important in the nineteen sixties when we were trying to figure out how to write good operating systems because with operating systems there's lots of things going on concurrently i've got lots of processes to an update things i've got bits of hardware interrupting me trying to get their data structures fixed so i need to work out very carefully how to implement a good critical section so today we're not going to ask people to going to arrive this	system	617
instead there are two well known examples that computer scientist should recognize and their called petersons of solution and decker solution peterson solution is simpler but actually was about ten years after dec 's original solution so i want to have a look at both an understand why they solve the critical section problem so we've talked about this c s b a couple of times is this idea we only want one process will thread to be inside the critical section in fact we have	section	310
instead there are two well known examples that computer scientist should recognize and their called petersons of solution and decker solution peterson solution is simpler but actually was about ten years after dec 's original solution so i want to have a look at both an understand why they solve the critical section problem so we've talked about this c s b a couple of times is this idea we only want one process will thread to be inside the critical section in fact we have	thread	420
one of these is mutual exclusion right so this is the basic idea that if worn thread or process is inside the critical section the other one must wait ok the other one is progress so if i'm the process that wants to be inside the critical section then i shouldn't wait if nobody is in there so it's a bit like saying if there's a four way stop at a junction i shouldn't have to wait for another car to come in traverse the four way stop i should be able to just enter that four way stop area if no one else is around and the last one is kind of bounded weight that i should only have to wait a fixed number of times for another process in other words if there's a lot of kind of little tiny kids running in front of me i don't always kind of q jump and get in front of me eventually there should only be a fixed number of of other participants that can be in front of me at some point it has to be my turn i don't want to have to end up waiting forever ever so let's have a look at pizza and solution to see how peterson solve this so here's some code about earlier and hopefully have actually seen this or skim read this before inside the course book and i just want to go over it and see if we can kind of understand how it works so the first thing to realize is	code	1047
one of these is mutual exclusion right so this is the basic idea that if worn thread or process is inside the critical section the other one must wait ok the other one is progress so if i'm the process that wants to be inside the critical section then i shouldn't wait if nobody is in there so it's a bit like saying if there's a four way stop at a junction i shouldn't have to wait for another car to come in traverse the four way stop i should be able to just enter that four way stop area if no one else is around and the last one is kind of bounded weight that i should only have to wait a fixed number of times for another process in other words if there's a lot of kind of little tiny kids running in front of me i don't always kind of q jump and get in front of me eventually there should only be a fixed number of of other participants that can be in front of me at some point it has to be my turn i don't want to have to end up waiting forever ever so let's have a look at pizza and solution to see how peterson solve this so here's some code about earlier and hopefully have actually seen this or skim read this before inside the course book and i just want to go over it and see if we can kind of understand how it works so the first thing to realize is	section	119
one of these is mutual exclusion right so this is the basic idea that if worn thread or process is inside the critical section the other one must wait ok the other one is progress so if i'm the process that wants to be inside the critical section then i shouldn't wait if nobody is in there so it's a bit like saying if there's a four way stop at a junction i shouldn't have to wait for another car to come in traverse the four way stop i should be able to just enter that four way stop area if no one else is around and the last one is kind of bounded weight that i should only have to wait a fixed number of times for another process in other words if there's a lot of kind of little tiny kids running in front of me i don't always kind of q jump and get in front of me eventually there should only be a fixed number of of other participants that can be in front of me at some point it has to be my turn i don't want to have to end up waiting forever ever so let's have a look at pizza and solution to see how peterson solve this so here's some code about earlier and hopefully have actually seen this or skim read this before inside the course book and i just want to go over it and see if we can kind of understand how it works so the first thing to realize is	thread	78
with peterson solution is it is actually surprisingly simple and here's here's what is based on first of all we need a couple of variables in a very simple variables one of them this kind of turn based thing we're actually going to share between our two threads or two processes or whatever they are and that's we're going to use as a kind of a tiebreaker to ensure that we always have abounded wait	thread	254
and that if we both arrive at the same time then one of his gun is going to defer and the other words in person is going to continue and then the other thing we're going to need is each process is going to need a little binary flag a little boolean flag here to say whether you want to be inside the critical section or not so here it is notice that just before you go into the critical section are going to raise your flag so you and i are going to agree to do both of these things and if we do then we've solved the critical section problem let's see how it works in	section	309
ok so i want you to imagine right now that both of us have decided we want to update say the same data structure so let's see if this is going to work so you raise your flag always my flag right but we both share this turn based variable so if i call you one and i'm too then there's going to be a bit of a racist who ends up setting turn first and who's ends up setting it last but it doesn't matter let's find out what happens so maybe this be value of one maybe would be a value of two maybe it's indeterminate but but the idea is that ok somebody will be will be setting it last and so then right while your flag is up and turn is the other id then just keep going around this loop	a struct	101
ok so we can ensure that because we both raise the flags before we enter the critical section that we've guaranteed that medical exclusion is ok that that is not possible for both of us to be inside the inside the critical section the second thing is that we've got bounded bounded wait because i defer to you	section	86
only if i arrive arrive early but then after that it's my turn so at some point i will enter the critical section	section	106
ok so if i wife first i'm going to go straight into the critical section but what happens if you know arrive or where you're going to see my flag is already up so you will wait ok so again mutual exclusion is satisfied now realize that this is a verbal argument we're trying to think about all of the possible interleavings that might happen and we've only sketched out reason as devices correct this is not a formal proof in fact there were actual papers submitted and accepted for publication that claimed to solve the critical section problem which actually had errors they had race conditions so this stuff is hard to think about and	section	65
if you try to kind of work this out and also realize that that in modern processes you can't just simply write this code the main reason being is that a modern processor is a super scaler structure and the compiler as well cares about performance and so both the cpu and the compiler will do things like instruction reordering so they might change the ordering of these statements they might do lazy writing back to main memories so the other process may not see the flag has been changed immediately so we can't just naively write this code in c or rust or python or whatever language you want and just assume it's going to work instead all the performance characteristics of a modern system from the compiler to the cpu were working against you which is why the implementation of saint peter mutex lock not only	code	116
if you try to kind of work this out and also realize that that in modern processes you can't just simply write this code the main reason being is that a modern processor is a super scaler structure and the compiler as well cares about performance and so both the cpu and the compiler will do things like instruction reordering so they might change the ordering of these statements they might do lazy writing back to main memories so the other process may not see the flag has been changed immediately so we can't just naively write this code in c or rust or python or whatever language you want and just assume it's going to work instead all the performance characteristics of a modern system from the compiler to the cpu were working against you which is why the implementation of saint peter mutex lock not only	system	686
has to kind of implement code like this or similar code like this it actually will have a special cpu primitives are instructions to say things like ok at this point there should be a memory fence to ensure that anything i've changed in memory or anything i want to read from memory is available to other cpu cores on my machine right so that's enough about peterson solution marvel its simplicity model of the fact that it took about a decade for for this to be discovered after we had deca solution and if you like this kind of stuff then this solution	memory	184
has to kind of implement code like this or similar code like this it actually will have a special cpu primitives are instructions to say things like ok at this point there should be a memory fence to ensure that anything i've changed in memory or anything i want to read from memory is available to other cpu cores on my machine right so that's enough about peterson solution marvel its simplicity model of the fact that it took about a decade for for this to be discovered after we had deca solution and if you like this kind of stuff then this solution	code	25
like it was the seven eighty one is is just four two threats it's an interesting exercise is to figure out how to generalize this to more than two threads and we're not going to go there with two forty one instead of the next video let's have a look at the deck a solution	thread	147
ok so i wanted you to imagine that you actually writing these calls ok the ability to say initialize that that signal type to be to be an empty set how ok so we're going to make a design decision that the signal set here is really just a typedef to along and now we want to manipulate the bit patterns within that long hence the little puzzle at the beginning of this letter video ok so here's what we'll do then so if we just want to initialize my long to be equivalent to the empty set and you have given me a pointer to some memory wear long is to be found all i'm going to do is dereference your pointer and initialize it to zero ok right what about if i want to fill it i want to enable all signals ok so i need a way to actually say ok or the bit pattern that corresponds to all or signal set right so you've got some maybe a couple of ideas here maybe you've got two ideas ok here's two ideas and they'll say well they're not quite right first of all perhaps you know about two bit	memory	528
ok so i wanted you to imagine that you actually writing these calls ok the ability to say initialize that that signal type to be to be an empty set how ok so we're going to make a design decision that the signal set here is really just a typedef to along and now we want to manipulate the bit patterns within that long hence the little puzzle at the beginning of this letter video ok so here's what we'll do then so if we just want to initialize my long to be equivalent to the empty set and you have given me a pointer to some memory wear long is to be found all i'm going to do is dereference your pointer and initialize it to zero ok right what about if i want to fill it i want to enable all signals ok so i need a way to actually say ok or the bit pattern that corresponds to all or signal set right so you've got some maybe a couple of ideas here maybe you've got two ideas ok here's two ideas and they'll say well they're not quite right first of all perhaps you know about two bit	type	118
ok so i wanted you to imagine that you actually writing these calls ok the ability to say initialize that that signal type to be to be an empty set how ok so we're going to make a design decision that the signal set here is really just a typedef to along and now we want to manipulate the bit patterns within that long hence the little puzzle at the beginning of this letter video ok so here's what we'll do then so if we just want to initialize my long to be equivalent to the empty set and you have given me a pointer to some memory wear long is to be found all i'm going to do is dereference your pointer and initialize it to zero ok right what about if i want to fill it i want to enable all signals ok so i need a way to actually say ok or the bit pattern that corresponds to all or signal set right so you've got some maybe a couple of ideas here maybe you've got two ideas ok here's two ideas and they'll say well they're not quite right first of all perhaps you know about two bit	pointer	512
could say that but also you could say hey i just saw the first lecture and i remember that i can flip all the bits so let's do that let's use my expression now which is tilda zero in other words the opposite of zero let's find the bit pattern where all those bits have been changed ok and i say that's pretty good there's just one little short coming here which is the values that we're using are just regular in 's just to see it and they may not be as large as a long on some systems so better code would actually say	code	496
could say that but also you could say hey i just saw the first lecture and i remember that i can flip all the bits so let's do that let's use my expression now which is tilda zero in other words the opposite of zero let's find the bit pattern where all those bits have been changed ok and i say that's pretty good there's just one little short coming here which is the values that we're using are just regular in 's just to see it and they may not be as large as a long on some systems so better code would actually say	system	478
let's take a zero as a long value and then flip all the bits and so then this operator will not just work on the lowest bits but all of all of the bits and so if along was twice as large as as an int then it would actually modify give me back an expression where where all of those bits are set simile here we actually want to make sure that we tell the compiler that i really do care about longs ok right so that's kind of what we find code here you could argue that with the first expression that it might property the copper casting from the into to log but so i personally i find this code to get a lot more satisfying and concrete there are actually working in the same types as our pointer value expl it being very explicitly	type	675
let's take a zero as a long value and then flip all the bits and so then this operator will not just work on the lowest bits but all of all of the bits and so if along was twice as large as as an int then it would actually modify give me back an expression where where all of those bits are set simile here we actually want to make sure that we tell the compiler that i really do care about longs ok right so that's kind of what we find code here you could argue that with the first expression that it might property the copper casting from the into to log but so i personally i find this code to get a lot more satisfying and concrete there are actually working in the same types as our pointer value expl it being very explicitly	code	437
let's take a zero as a long value and then flip all the bits and so then this operator will not just work on the lowest bits but all of all of the bits and so if along was twice as large as as an int then it would actually modify give me back an expression where where all of those bits are set simile here we actually want to make sure that we tell the compiler that i really do care about longs ok right so that's kind of what we find code here you could argue that with the first expression that it might property the copper casting from the into to log but so i personally i find this code to get a lot more satisfying and concrete there are actually working in the same types as our pointer value expl it being very explicitly	pointer	688
not that besides we got a harder problem to think about here how do i set a particular bit inside now my long value ok so when someone calls cigarettes set they want to add a particular signal into into my set of bits which is being held by this long at some point are how we're going to do that ok well we started this code we've said well i want to modify the value app style pointer at the addressed appointed by the pointer	code	320
not that besides we got a harder problem to think about here how do i set a particular bit inside now my long value ok so when someone calls cigarettes set they want to add a particular signal into into my set of bits which is being held by this long at some point are how we're going to do that ok well we started this code we've said well i want to modify the value app style pointer at the addressed appointed by the pointer	address	393
not that besides we got a harder problem to think about here how do i set a particular bit inside now my long value ok so when someone calls cigarettes set they want to add a particular signal into into my set of bits which is being held by this long at some point are how we're going to do that ok well we started this code we've said well i want to modify the value app style pointer at the addressed appointed by the pointer	pointer	378
one bit set who it is and shift it left queso which way is left let's go that way right and how many places do we want to shift left will shift left by saying ok so now providing the value of seagulls not too large great we can end up with a two to the n value that's pretty good i would make one change here however i would actually explicitly tell the compiler that hey i'm working with long 's or whatever type is over here otherwise if i'm only working with say a thirty two bit value then if my signal number happens to be greater than thirty one but all i've shifted it off the end like a little lemming we've lost that bit information so we want to make sure that any shifting operations uses the full width the full width that we have here is a long	type	409
particular bit right so what we learned hopefully you've learned a little bit about twiddling bits as it's called and also this idea that these functions they really don't do much they just provide a level of abstraction or an abstraction layer so that you don't have to think about getting the correct types	type	303
and writing these bitwise expressions instead you can work at a conceptual level of saying i want to add a particular signal or remove a particular signal from a set of signals so that's all they do so they're very lightweight they don't actually system calls they're just going to modify this memory ok right so the next we're going to talk about is why we want to use sig action and how we can do that bye for now	memory	294
and writing these bitwise expressions instead you can work at a conceptual level of saying i want to add a particular signal or remove a particular signal from a set of signals so that's all they do so they're very lightweight they don't actually system calls they're just going to modify this memory ok right so the next we're going to talk about is why we want to use sig action and how we can do that bye for now	system	247
hi so let's build a very very simple in their memory allocator ok let's actually think about how we could actually write malloc if all we had was s break in five minutes ok so here's what we'll do	memory	46
ok right now i have a little pointer right so when you call s break it tells you the old water mock so here's a simple thing we could do with aspiration is to say hey tell me exactly where the current data segment ends so this will be my original top of the heap had moved it yet	the heap	254
ok right now i have a little pointer right so when you call s break it tells you the old water mock so here's a simple thing we could do with aspiration is to say hey tell me exactly where the current data segment ends so this will be my original top of the heap had moved it yet	pointer	29
ok and will print that out as a pointer ok let me come back to this question about whether it's safer not in a moment instead let's look at the rest of the curry so you called malac say hey man i need space for my nice double array or some other data structure and the number of contiguous bites that i need allocated	a struct	249
ok and will print that out as a pointer ok let me come back to this question about whether it's safer not in a moment instead let's look at the rest of the curry so you called malac say hey man i need space for my nice double array or some other data structure and the number of contiguous bites that i need allocated	pointer	32
so my plan for malloc is just simply to ask for some more memory from the system	memory	58
so my plan for malloc is just simply to ask for some more memory from the system	system	74
hey system i need to increase my data segment by that many bytes ok so we'll call it s break with say four thousand ninety six bytes over many you needed ok add will wait for that to return system calls can be slow so this may not be the fastest memory allocator but certainly is the simplest ok so will wait for that to return to give us some more valid memory locations and then when it returns like i said it returns the old address so great that means that if i've just increased my watermark here we go up to valid	memory	246
hey system i need to increase my data segment by that many bytes ok so we'll call it s break with say four thousand ninety six bytes over many you needed ok add will wait for that to return system calls can be slow so this may not be the fastest memory allocator but certainly is the simplest ok so will wait for that to return to give us some more valid memory locations and then when it returns like i said it returns the old address so great that means that if i've just increased my watermark here we go up to valid	address	428
hey system i need to increase my data segment by that many bytes ok so we'll call it s break with say four thousand ninety six bytes over many you needed ok add will wait for that to return system calls can be slow so this may not be the fastest memory allocator but certainly is the simplest ok so will wait for that to return to give us some more valid memory locations and then when it returns like i said it returns the old address so great that means that if i've just increased my watermark here we go up to valid	system	4
higher value that means that all of these previous addresses are now mind right into so and since there's break gives me the old value of data segment	address	51
esperat returns negative one when cast it as a void pointer if it fails if it refused to give us any more memory case so in that case we should return null because that's part of the malloc specification wait just a reminder what does void pointer mean it means i'm a pointer but i'm not going to declare or i don't care i want to keep secret exactly what i'm going to store at that location and void pointers can be cast to other kinds of pointers implicitly so you don't need to explicitly say cast that to another type ok so yeah we don't care about what this pointer is just simply or what was going to be stored there just simply that if i want to compare it to get negative one i should cast out first void pointer ok right so now i'm before i'm returning i'm doing some logging here printf say hey great now you have some memory at that location so let's print out this variable as a pointer i'm not using percent s i'm not attempting to read any memory at that location i'm simply saying take this value and display it as a hexadecimal value	memory	106
esperat returns negative one when cast it as a void pointer if it fails if it refused to give us any more memory case so in that case we should return null because that's part of the malloc specification wait just a reminder what does void pointer mean it means i'm a pointer but i'm not going to declare or i don't care i want to keep secret exactly what i'm going to store at that location and void pointers can be cast to other kinds of pointers implicitly so you don't need to explicitly say cast that to another type ok so yeah we don't care about what this pointer is just simply or what was going to be stored there just simply that if i want to compare it to get negative one i should cast out first void pointer ok right so now i'm before i'm returning i'm doing some logging here printf say hey great now you have some memory at that location so let's print out this variable as a pointer i'm not using percent s i'm not attempting to read any memory at that location i'm simply saying take this value and display it as a hexadecimal value	type	517
esperat returns negative one when cast it as a void pointer if it fails if it refused to give us any more memory case so in that case we should return null because that's part of the malloc specification wait just a reminder what does void pointer mean it means i'm a pointer but i'm not going to declare or i don't care i want to keep secret exactly what i'm going to store at that location and void pointers can be cast to other kinds of pointers implicitly so you don't need to explicitly say cast that to another type ok so yeah we don't care about what this pointer is just simply or what was going to be stored there just simply that if i want to compare it to get negative one i should cast out first void pointer ok right so now i'm before i'm returning i'm doing some logging here printf say hey great now you have some memory at that location so let's print out this variable as a pointer i'm not using percent s i'm not attempting to read any memory at that location i'm simply saying take this value and display it as a hexadecimal value	printf	790
esperat returns negative one when cast it as a void pointer if it fails if it refused to give us any more memory case so in that case we should return null because that's part of the malloc specification wait just a reminder what does void pointer mean it means i'm a pointer but i'm not going to declare or i don't care i want to keep secret exactly what i'm going to store at that location and void pointers can be cast to other kinds of pointers implicitly so you don't need to explicitly say cast that to another type ok so yeah we don't care about what this pointer is just simply or what was going to be stored there just simply that if i want to compare it to get negative one i should cast out first void pointer ok right so now i'm before i'm returning i'm doing some logging here printf say hey great now you have some memory at that location so let's print out this variable as a pointer i'm not using percent s i'm not attempting to read any memory at that location i'm simply saying take this value and display it as a hexadecimal value	pointer	52
ok so we were turning right now there's one last thing we should do with a little memory allocator which is remember programs are polite they should call free when they've finished with some heat memory	memory	82
and what are we going to do well we have the world 's fastest implementation of free just hear it does nothing you say hey i finished with this piece of memory you need ok great good for you	memory	153
kate so will our memory allocator work actually ironically it would work if we remove the debugging information let's go and see what the problem is so this is a pretty good alligator at least hey it works but we have a problem that it calls print air for part of this kind of debugging and why is that problem why do you think	memory	17
ok good good idea yes print f itself may call malloc so if it's running at it if it needs more memory when assembling a string is going to malloc oh dear so potentially we have in kind of infinite recursion and that might make our malloc rather slow so when writing your version of malloc don't use print f use things like right which is a lower level remember right talks directly to the kernel and wet your own little functions to print out hexadecimal values it's not hard you could probably find something on stackoverflow for that if you do use another code like that however please be sure to reference insight today with the original author it's however is a pretty easy function to figure out how to quite so we've got something working	memory	95
ok good good idea yes print f itself may call malloc so if it's running at it if it needs more memory when assembling a string is going to malloc oh dear so potentially we have in kind of infinite recursion and that might make our malloc rather slow so when writing your version of malloc don't use print f use things like right which is a lower level remember right talks directly to the kernel and wet your own little functions to print out hexadecimal values it's not hard you could probably find something on stackoverflow for that if you do use another code like that however please be sure to reference insight today with the original author it's however is a pretty easy function to figure out how to quite so we've got something working	code	558
ok good good idea yes print f itself may call malloc so if it's running at it if it needs more memory when assembling a string is going to malloc oh dear so potentially we have in kind of infinite recursion and that might make our malloc rather slow so when writing your version of malloc don't use print f use things like right which is a lower level remember right talks directly to the kernel and wet your own little functions to print out hexadecimal values it's not hard you could probably find something on stackoverflow for that if you do use another code like that however please be sure to reference insight today with the original author it's however is a pretty easy function to figure out how to quite so we've got something working	string	120
limitations are that it doesn't reuse any let's come back right ok so it doesn't re-use any memory	memory	92
so there's no re use of any memory that we are always asking for more memory and memory is actually one of the most precious resources you have on a system if you run a set of virtual machines on a real physical host actually it's the memory that you need to allocate to each virtual machine which is going to limit the number of vms that you can run the second thing is that we always calling aspect will always going back to the kernel so	memory	28
so there's no re use of any memory that we are always asking for more memory and memory is actually one of the most precious resources you have on a system if you run a set of virtual machines on a real physical host actually it's the memory that you need to allocate to each virtual machine which is going to limit the number of vms that you can run the second thing is that we always calling aspect will always going back to the kernel so	resources	125
so there's no re use of any memory that we are always asking for more memory and memory is actually one of the most precious resources you have on a system if you run a set of virtual machines on a real physical host actually it's the memory that you need to allocate to each virtual machine which is going to limit the number of vms that you can run the second thing is that we always calling aspect will always going back to the kernel so	system	149
actually were able to reuse memory pass we would need to go back to the kernel so many times	memory	28
perhaps we should have asked for say just another four thousand bytes or so so that all the features smaller requests don't need 's to keep keep calling aspect to keep asking the kernel for more memory also it's not particular performance because we are writing things out and we actually end up calling s break twice	memory	195
ok so i could probably make it fast if i just deleted my debugging information here right so that's pretty exciting we should think about how to develop this and writing a memory allocator gets hard and get challenging really quickly because we've got lots of pointers to think about so it would be useful if we could turn are debugging information on and off and for that why not use the preprocessor by putting are debugging information say inside a hash if and other tricks so that when we want our program to run at full speed we can turn or disable these additional lines of code but when we're fixing and chasing things	memory	172
ok so i could probably make it fast if i just deleted my debugging information here right so that's pretty exciting we should think about how to develop this and writing a memory allocator gets hard and get challenging really quickly because we've got lots of pointers to think about so it would be useful if we could turn are debugging information on and off and for that why not use the preprocessor by putting are debugging information say inside a hash if and other tricks so that when we want our program to run at full speed we can turn or disable these additional lines of code but when we're fixing and chasing things	code	580
ok so i could probably make it fast if i just deleted my debugging information here right so that's pretty exciting we should think about how to develop this and writing a memory allocator gets hard and get challenging really quickly because we've got lots of pointers to think about so it would be useful if we could turn are debugging information on and off and for that why not use the preprocessor by putting are debugging information say inside a hash if and other tricks so that when we want our program to run at full speed we can turn or disable these additional lines of code but when we're fixing and chasing things	pointer	260
maybe we want to turn the backup simply remember things like assert as well is a kind of good chance to check that beliefs about the code and how it operates are correct ok the other thing that we could do is improve the way that we just we just ignore any freed memory so perhaps we need some kind of data structure to keep track of memory that was allocated and then freed because now we've got blocks of memory which we could reuse in the future right so for that how should we store that well one approach is to have some kind of linked list of	memory	263
maybe we want to turn the backup simply remember things like assert as well is a kind of good chance to check that beliefs about the code and how it operates are correct ok the other thing that we could do is improve the way that we just we just ignore any freed memory so perhaps we need some kind of data structure to keep track of memory that was allocated and then freed because now we've got blocks of memory which we could reuse in the future right so for that how should we store that well one approach is to have some kind of linked list of	block	397
maybe we want to turn the backup simply remember things like assert as well is a kind of good chance to check that beliefs about the code and how it operates are correct ok the other thing that we could do is improve the way that we just we just ignore any freed memory so perhaps we need some kind of data structure to keep track of memory that was allocated and then freed because now we've got blocks of memory which we could reuse in the future right so for that how should we store that well one approach is to have some kind of linked list of	a struct	305
maybe we want to turn the backup simply remember things like assert as well is a kind of good chance to check that beliefs about the code and how it operates are correct ok the other thing that we could do is improve the way that we just we just ignore any freed memory so perhaps we need some kind of data structure to keep track of memory that was allocated and then freed because now we've got blocks of memory which we could reuse in the future right so for that how should we store that well one approach is to have some kind of linked list of	code	133
memories are peace areas of memory that we could be allocated in the future will think more about that in later lecture ok right so in the next lecture let's talk about a new call that perhaps you haven't seen before which is calloc see you in part five bye	memory	28
ok it's a dns so you've already had to play with dns i've leaving the lab possibly at least this semester i'm recording it and you know that dns is based on udp so that let's say that i type into my web browser hey i want to load say a page from bbc dot com we need to turn that into an ip address maybe like before ip six address	a page	234
ok it's a dns so you've already had to play with dns i've leaving the lab possibly at least this semester i'm recording it and you know that dns is based on udp so that let's say that i type into my web browser hey i want to load say a page from bbc dot com we need to turn that into an ip address maybe like before ip six address	type	186
ok it's a dns so you've already had to play with dns i've leaving the lab possibly at least this semester i'm recording it and you know that dns is based on udp so that let's say that i type into my web browser hey i want to load say a page from bbc dot com we need to turn that into an ip address maybe like before ip six address	address	290
and that's where domain the domain name system comes in we need an authorative way to say ok in order to actually talk to this server there is an ip address somewhere and that mapping is part of the domain name system	address	149
and that's where domain the domain name system comes in we need an authorative way to say ok in order to actually talk to this server there is an ip address somewhere and that mapping is part of the domain name system	system	40
so when you type that type that in the second thing that your machine does in order to actually convert this is to send out some udp packets and in fact dns is designed such that you can talk to up to three known domain name service to say hey i'm looking i'm doing a query do you have a for example and a record in other words in ip record associated with this host name like bbc dot com	type	12
in that sense that it could be that more than one server reacts to this and says yes i've got an ip address for you and the way that dns works is to say whoever gives me the fastest answer wins so if you were	address	100
malicious coffee shop of if you've had to work for government agency you can do some exciting things now you can say oh you want to bbc dot com i'm going to give you an answer to that here's an ip address largely bloody bloody blah there we go and you control then that ip address meaning that the server will now decide to go over to that ip address and display contents from that machine rather than the real bbc dot com	address	197
but i want to kind of come back to a couple of points about the actual dns system first of all i said ok we send out three udp packets to our neighboring servers where do they get their answer form and the answer is that dns is interesting because it's a completely distributed key value system	system	75
of any dns look up normally you don't talk to those machines directly instead you talk to this distributed system and if they don't know the answer they will ask their neighbor and if they don't know the answer they lost their neighbor etc etc and ultimately your request might end up at one of these root name servers	system	107
but i want to get back to something i said at the beginning which is this is the second thing that they do yes actually so there are times when you do a dns look up and no network traffic is generated we don't see any udp packets ok so one answer to that is as trivial answer which is simply that hey my process was already cashed in answer so if my web browser has already gone to the bbc dot com then it doesn't necessarily need to look up that answer again and in fact dns records have a timeout parameter to say how good a piece of information is available for though is considered to be correct but there's one other place that dns uses in order to look up ip ip 's and that is inside	parameter	499
to this host name in fact it's not going to be get is not going to get a valid ip address so this is kind of fun of perhaps you've got friend exams coming up and you decide you want to be more productive great let me show you how so we can do a case sue do let's edit vm etc hosts ok so i need my password	address	82
go wrong with look at a security problem so let's talk about remote procedure calls here's the idea i can actually split up my code into a local portion and remote portion and so it's a bit like saying look i've got a function here called say update scoreboard	code	127
why might we do this well perhaps we've got a distributed application with lots of people playing on the same game another reason is for security so i could have different process is having different security models so for example the update scoreboard might be the only portion of my code that's allowed to talk to a central database so that might have special privileges but there for that same code might also have lots of checks to make sure that the name is valid and the score is valid for example	code	285
ok so let's think about kind of a minimum implementation of what are this code might look like from the outside hey it just looks like a regular call but from the inside we actually need to construct a message so how could we do that well here's one way there's a call called ass print f which will get some heat memory for you automatically so it's a bit like sprint f meaning that it will write the output to some memory but in this case it will actually get some heat them before you the right amount and then tell you where that is so we just need to give it the address of a pointer and it will update that pointer force ok so we are going to send a little message to say hey this new score here's a name here's the score right and let's send that off and we better hope that the name does not contain a calmer because we're using commas to separate the fields here right so will call right in practice of course this would actually have to have some error checking in here here's a message and we want to send the entire message ok what do you think about this message plus one well that would mean ok start sending the message from the e so this is incorrect we actually want to send message but why why does this code say send everything plus one well if we're going to send messages we need a way to say hey at the message has finished and is typically two ways to do that either top of the message that started the message you say how long your messages or you have some kind of	memory	313
ok so let's think about kind of a minimum implementation of what are this code might look like from the outside hey it just looks like a regular call but from the inside we actually need to construct a message so how could we do that well here's one way there's a call called ass print f which will get some heat memory for you automatically so it's a bit like sprint f meaning that it will write the output to some memory but in this case it will actually get some heat them before you the right amount and then tell you where that is so we just need to give it the address of a pointer and it will update that pointer force ok so we are going to send a little message to say hey this new score here's a name here's the score right and let's send that off and we better hope that the name does not contain a calmer because we're using commas to separate the fields here right so will call right in practice of course this would actually have to have some error checking in here here's a message and we want to send the entire message ok what do you think about this message plus one well that would mean ok start sending the message from the e so this is incorrect we actually want to send message but why why does this code say send everything plus one well if we're going to send messages we need a way to say hey at the message has finished and is typically two ways to do that either top of the message that started the message you say how long your messages or you have some kind of	code	74
ok so let's think about kind of a minimum implementation of what are this code might look like from the outside hey it just looks like a regular call but from the inside we actually need to construct a message so how could we do that well here's one way there's a call called ass print f which will get some heat memory for you automatically so it's a bit like sprint f meaning that it will write the output to some memory but in this case it will actually get some heat them before you the right amount and then tell you where that is so we just need to give it the address of a pointer and it will update that pointer force ok so we are going to send a little message to say hey this new score here's a name here's the score right and let's send that off and we better hope that the name does not contain a calmer because we're using commas to separate the fields here right so will call right in practice of course this would actually have to have some error checking in here here's a message and we want to send the entire message ok what do you think about this message plus one well that would mean ok start sending the message from the e so this is incorrect we actually want to send message but why why does this code say send everything plus one well if we're going to send messages we need a way to say hey at the message has finished and is typically two ways to do that either top of the message that started the message you say how long your messages or you have some kind of	address	567
ok so let's think about kind of a minimum implementation of what are this code might look like from the outside hey it just looks like a regular call but from the inside we actually need to construct a message so how could we do that well here's one way there's a call called ass print f which will get some heat memory for you automatically so it's a bit like sprint f meaning that it will write the output to some memory but in this case it will actually get some heat them before you the right amount and then tell you where that is so we just need to give it the address of a pointer and it will update that pointer force ok so we are going to send a little message to say hey this new score here's a name here's the score right and let's send that off and we better hope that the name does not contain a calmer because we're using commas to separate the fields here right so will call right in practice of course this would actually have to have some error checking in here here's a message and we want to send the entire message ok what do you think about this message plus one well that would mean ok start sending the message from the e so this is incorrect we actually want to send message but why why does this code say send everything plus one well if we're going to send messages we need a way to say hey at the message has finished and is typically two ways to do that either top of the message that started the message you say how long your messages or you have some kind of	pointer	580
so this is kind of a one way one way to do it the couple of comments on this however is that we are converting the score into an integer representation so you know say four thousand and ninety six or something and that means that we are wasting a lot of potentially wasting a lot of network bandwidth we've got many bytes to send here i mean this value we can encode in just a few bites but now we using could have at least five bites here with decimal digits secondly actually going to take quite a bit of cpu time to turn this number back into an actual integer value so perhaps rather than using a text based protocol we could actually choose a binary based protocol if you do that then you better specify exactly how you represent strings and integers and booleans etc so	code	362
so this is kind of a one way one way to do it the couple of comments on this however is that we are converting the score into an integer representation so you know say four thousand and ninety six or something and that means that we are wasting a lot of potentially wasting a lot of network bandwidth we've got many bytes to send here i mean this value we can encode in just a few bites but now we using could have at least five bites here with decimal digits secondly actually going to take quite a bit of cpu time to turn this number back into an actual integer value so perhaps rather than using a text based protocol we could actually choose a binary based protocol if you do that then you better specify exactly how you represent strings and integers and booleans etc so	string	735
to realize that the code the server at the other end may not be on the same cpu so how can we how can we ensure we can write portable code ok so with that we can turn back to some of our favorite functions from the networking code which can be used to convert two bite or fullback values of host to network shorten hosted network long so for example	code	20
suppose i wanted to send messages and i wanted to say ok i'm going to include despite my message how long my messages we might do the following let's find out how long the message string is that gives me an integer but rather than just simply writing their integer and saying i have no idea where it is going to be a little endian or big indian let me deliberately convert it into a big endian format no matter what my cpu is my cpu happens to be big endian then this is a new operation	the following	130
suppose i wanted to send messages and i wanted to say ok i'm going to include despite my message how long my messages we might do the following let's find out how long the message string is that gives me an integer but rather than just simply writing their integer and saying i have no idea where it is going to be a little endian or big indian let me deliberately convert it into a big endian format no matter what my cpu is my cpu happens to be big endian then this is a new operation	string	180
and then we will we've got that we know that it's going to be a two byte or sixteen bit values so let's actually put it into a type that is specifically sixteen bits	type	127
will just move the stack pointer possibly put a few values on the stack maybe not if we can discuss further on registers and so we can do a normal call in the matter of ns just tens of clock cycles to change stack pointers and changed	pointer	25
program counter when we get back etc so normal procedure calls are very lightweight this is the opposite of lightweight in fact in our version we are we are getting stack memory and so inside here so heat memory so you know inside here there's going to be a call to malloc so now we're already talking micro hundreds of microseconds	memory	171
ok so this is actually a tricky tricky tricky problem to think about even though it's just four lines of code and the trickiness comes because we've got to think about all possible interleavings of code here and there's quite a few of them and the one that can bite us is in between when we check the value of please stop and then when we actually go to sleep so there's a moment in time let's call it just a few nanoseconds maybe a microsecond most between when our code has decided that the value of please stop is one	code	105
and then let's say one hundred nanoseconds later where inside pthread condition wait and we're actually blocking right so within that small window imagine the following happened imagine that between checking this and actually blocking that just with one hundred	the following	155
and then let's say one hundred nanoseconds later where inside pthread condition wait and we're actually blocking right so within that small window imagine the following happened imagine that between checking this and actually blocking that just with one hundred	block	104
and then let's say one hundred nanoseconds later where inside pthread condition wait and we're actually blocking right so within that small window imagine the following happened imagine that between checking this and actually blocking that just with one hundred	thread	63
nanosecond window we did both of these two things in a different thread so there are other thread changes the value of please stop and call broadcast but there's no one inside that condition	thread	65
we haven't yet actually finished running pizza condition wait inside our other thread ok so we've run the fire bell but there's no one there ok so now what happens in our right hand thread now we finish executing pta condition wait and so it blocks	block	242
we haven't yet actually finished running pizza condition wait inside our other thread ok so we've run the fire bell but there's no one there ok so now what happens in our right hand thread now we finish executing pta condition wait and so it blocks	thread	79
and it blocks forever because there are attempt to call broadcast has already gone by already happened	block	7
ok so how can we fix this our problem is there we like these actually behave as atomic operations we like to ensure that between checking for stopping and actually going to sleep behaves as one interruptible operation so how can we ensure that as true and the answer is to use a mutex lock on both sides of this because if we have a mutex lock set if we required the mutex log then only once bit of code can be running it at a time so there's no longer any opportunity to quick to say oh and then quick imagine these two lines execute between these two so so or fix is on this side is to make sure that we've actually called pthread mutex lock before we start changing these variables so lock on the same mutex lock and then afterwards	code	399
ok so how can we fix this our problem is there we like these actually behave as atomic operations we like to ensure that between checking for stopping and actually going to sleep behaves as one interruptible operation so how can we ensure that as true and the answer is to use a mutex lock on both sides of this because if we have a mutex lock set if we required the mutex log then only once bit of code can be running it at a time so there's no longer any opportunity to quick to say oh and then quick imagine these two lines execute between these two so so or fix is on this side is to make sure that we've actually called pthread mutex lock before we start changing these variables so lock on the same mutex lock and then afterwards	a mutex	277
ok so how can we fix this our problem is there we like these actually behave as atomic operations we like to ensure that between checking for stopping and actually going to sleep behaves as one interruptible operation so how can we ensure that as true and the answer is to use a mutex lock on both sides of this because if we have a mutex lock set if we required the mutex log then only once bit of code can be running it at a time so there's no longer any opportunity to quick to say oh and then quick imagine these two lines execute between these two so so or fix is on this side is to make sure that we've actually called pthread mutex lock before we start changing these variables so lock on the same mutex lock and then afterwards	thread	626
so now we've done that even if you wanted to quit you're not allowed to actually run these original two p two lines of code just in here because this first thread on the left hand side is going to get stuck waiting to acquire the lock first so that has to complete first and that will complete either we will complete here after the second thread ask has gone to sleep so there's no race condition we prevented the race condition ok so the big learning point here is that mutex locks are your friends they do lots of useful things for us and actually what they do is they bring order to our madness they prevent unwanted interleavings of instructions they synchronize our instructions they bring us back down to running one thread of the time but wait you said	code	119
so now we've done that even if you wanted to quit you're not allowed to actually run these original two p two lines of code just in here because this first thread on the left hand side is going to get stuck waiting to acquire the lock first so that has to complete first and that will complete either we will complete here after the second thread ask has gone to sleep so there's no race condition we prevented the race condition ok so the big learning point here is that mutex locks are your friends they do lots of useful things for us and actually what they do is they bring order to our madness they prevent unwanted interleavings of instructions they synchronize our instructions they bring us back down to running one thread of the time but wait you said	thread	156
i took this course in order to understand multithreading yes and multi thing is great however there are key points in our program where we don't want it where we want to make sure that we strictly control the ordering of of operations and that we want to strictly manage pieces of code as if they occur as one atomic unit as an inseparable unit so that i can reason correctly about the order of operations with my program alright fun stuff and remember pizza admits locks are your friend for this kind of stuff ok in the next video we are going to have my ok we are going to work out what is the largest value that this code is going to print our case so let's briefly introduce this and then you can pause the video and work it out i've got a fireworks variable you'll see that inside my main method i set fireworks equal to one and then here is my firework code ok so tell me based on what you can see what do you think that the highest value that we're going to see here when we actually run this code ok alright see you then bye	code	281
i took this course in order to understand multithreading yes and multi thing is great however there are key points in our program where we don't want it where we want to make sure that we strictly control the ordering of of operations and that we want to strictly manage pieces of code as if they occur as one atomic unit as an inseparable unit so that i can reason correctly about the order of operations with my program alright fun stuff and remember pizza admits locks are your friend for this kind of stuff ok in the next video we are going to have my ok we are going to work out what is the largest value that this code is going to print our case so let's briefly introduce this and then you can pause the video and work it out i've got a fireworks variable you'll see that inside my main method i set fireworks equal to one and then here is my firework code ok so tell me based on what you can see what do you think that the highest value that we're going to see here when we actually run this code ok alright see you then bye	thread	47
and as you know they are necessary and sufficient we need all fall to be true and exactly or for them to be true and then we know that we've met the conditions for deadlock so what are they let's actually look at some definitions here so here's the first wanna process is currently holding at least one resource and requesting additional resources which are being held by other processes ok so it is holding and waiting so that's a hold and wait condition	a process	259
and as you know they are necessary and sufficient we need all fall to be true and exactly or for them to be true and then we know that we've met the conditions for deadlock so what are they let's actually look at some definitions here so here's the first wanna process is currently holding at least one resource and requesting additional resources which are being held by other processes ok so it is holding and waiting so that's a hold and wait condition	resources	338
my process is all threads only needed to actually hold on to say just one mutex lock at a time that deadlock would be impossible	thread	18
and the process or thread wait for graph	thread	19
no pre emption right that we cannot force a task or thread to put down a lot or something that is acquired exclusively ok no pre are going to say pre emptive but let's change that to know preemption	thread	52
now first of all don't panic let's pull this apart and see how it works the exciting part it seems to take a pointer to a pointer to a character and a pointer to one of these variables causes a size under course t my goodness and the last thing is where should it read from so we're going to give it a c c library file handle which we've either got from calling f open or which could use standard in if we want to read just from the standard input	pointer	109
but you can think of it is just a mathematical integer but it has a potentially greater range of values than just normal c int type	type	127
right so how does get light work is actually going to put the data that it reads are into the heap memory and for performance reasons each time you call get line it will pull in a new line of data and store it and overwrite the original area in memory in heap memo	heap memory	94
right so how does get light work is actually going to put the data that it reads are into the heap memory and for performance reasons each time you call get line it will pull in a new line of data and store it and overwrite the original area in memory in heap memo	memory	99
right so how does get light work is actually going to put the data that it reads are into the heap memory and for performance reasons each time you call get line it will pull in a new line of data and store it and overwrite the original area in memory in heap memo	the heap	90
so we need to be able to get a process that line before we call get line again so we do this for for performance because we don't want to have each time go back to the heap and say hey heap i need some more memory for another line instead could be a lot more quicker to run if we can actually just overwrite the heap memory that we already requested	heap memory	312
so we need to be able to get a process that line before we call get line again so we do this for for performance because we don't want to have each time go back to the heap and say hey heap i need some more memory for another line instead could be a lot more quicker to run if we can actually just overwrite the heap memory that we already requested	memory	207
so we need to be able to get a process that line before we call get line again so we do this for for performance because we don't want to have each time go back to the heap and say hey heap i need some more memory for another line instead could be a lot more quicker to run if we can actually just overwrite the heap memory that we already requested	the heap	164
so we need to be able to get a process that line before we call get line again so we do this for for performance because we don't want to have each time go back to the heap and say hey heap i need some more memory for another line instead could be a lot more quicker to run if we can actually just overwrite the heap memory that we already requested	a process	29
fortunately get line will then free up the old memory allocate some new memory force and it does this all automatically the only thing it needs from us is to remember from one call to the next where its buffer is so that's the purpose of these two variables this line pointer and this size pointer the first one is going to be useful to remember where it's storing the current line inside the heap the second one is how big is that buffer so so if potentially exceed that size we can get a new one right but why is it the case that both of these are pointers here's the trick get lines actually going to change our variables from one call to the next so we actually again to give it the address of our variables so let's do this actually write some code here so it'll get line demo here	memory	47
fortunately get line will then free up the old memory allocate some new memory force and it does this all automatically the only thing it needs from us is to remember from one call to the next where its buffer is so that's the purpose of these two variables this line pointer and this size pointer the first one is going to be useful to remember where it's storing the current line inside the heap the second one is how big is that buffer so so if potentially exceed that size we can get a new one right but why is it the case that both of these are pointers here's the trick get lines actually going to change our variables from one call to the next so we actually again to give it the address of our variables so let's do this actually write some code here so it'll get line demo here	the heap	389
fortunately get line will then free up the old memory allocate some new memory force and it does this all automatically the only thing it needs from us is to remember from one call to the next where its buffer is so that's the purpose of these two variables this line pointer and this size pointer the first one is going to be useful to remember where it's storing the current line inside the heap the second one is how big is that buffer so so if potentially exceed that size we can get a new one right but why is it the case that both of these are pointers here's the trick get lines actually going to change our variables from one call to the next so we actually again to give it the address of our variables so let's do this actually write some code here so it'll get line demo here	code	749
fortunately get line will then free up the old memory allocate some new memory force and it does this all automatically the only thing it needs from us is to remember from one call to the next where its buffer is so that's the purpose of these two variables this line pointer and this size pointer the first one is going to be useful to remember where it's storing the current line inside the heap the second one is how big is that buffer so so if potentially exceed that size we can get a new one right but why is it the case that both of these are pointers here's the trick get lines actually going to change our variables from one call to the next so we actually again to give it the address of our variables so let's do this actually write some code here so it'll get line demo here	address	687
fortunately get line will then free up the old memory allocate some new memory force and it does this all automatically the only thing it needs from us is to remember from one call to the next where its buffer is so that's the purpose of these two variables this line pointer and this size pointer the first one is going to be useful to remember where it's storing the current line inside the heap the second one is how big is that buffer so so if potentially exceed that size we can get a new one right but why is it the case that both of these are pointers here's the trick get lines actually going to change our variables from one call to the next so we actually again to give it the address of our variables so let's do this actually write some code here so it'll get line demo here	pointer	268
and the variables i'm going to need then are going to be a pointer to a character but you and i know we don't care just that single character actually going to treat this as a c string so all the characters after that including the null byte so i'll call this a buffer and how big is that buffer once its capacity so i'll call it say buffer capacity	string	178
and the variables i'm going to need then are going to be a pointer to a character but you and i know we don't care just that single character actually going to treat this as a c string so all the characters after that including the null byte so i'll call this a buffer and how big is that buffer once its capacity so i'll call it say buffer capacity	pointer	59
now that's called get line getline is going to tell us it's result and like a good system a programmer it's important to check their result values so we need a signed type of s size t	type	167
now that's called get line getline is going to tell us it's result and like a good system a programmer it's important to check their result values so we need a signed type of s size t	system	83
and now this is the moment we say alright here's the address of my buffer and here's the address of my capacity available	address	53
and something called i want to kind of point out at this moment is take a look at the types of our variables i had	type	86
pointed a character and size two but we took the address of those things	address	49
now let's take a look at the declaration of get line and you saw we have a pointer to a pointer to a character and a pointer to a size t i hope that makes sense that in taking the address of these variables we've added basically just another pointer in front of what they already are in terms of their type	type	302
now let's take a look at the declaration of get line and you saw we have a pointer to a pointer to a character and a pointer to a size t i hope that makes sense that in taking the address of these variables we've added basically just another pointer in front of what they already are in terms of their type	address	180
now let's take a look at the declaration of get line and you saw we have a pointer to a pointer to a character and a pointer to a size t i hope that makes sense that in taking the address of these variables we've added basically just another pointer in front of what they already are in terms of their type	pointer	75
this call to get line is going to block until it gives us complete line or an error occurs and it can't continuous so we better now the first thing is to check that result let's see if result is negative one then it's time to get outside of my wire loop so let's break out of that there's no line to be protest	block	34
ok otherwise let's do a few things here let's for debugging purposes and demo purposes let's print out the where in memory it is so i can say right my	memory	116
buffer is at an i want to print something as a pointer so i'll do percent p and capacity is alright and i'll just use simple integers today and the result is something else ok right so for this i need the buffer	pointer	47
if i wanted to just directly use those those bites get line actually gives me a c string including the null byte so i could print it out i could say right kind of buffer contents and will say percent s k and we had a buffer at	string	82
alright so now will say go round the loop again key like when we get out of here we know it's because getline return negative one what we do here well	the loop	33
get line has allocated some memory on the heap is our responsibility to free that memory up so let's remember to do that if get line never successfully well then buffalo will still be pointing to null that's ok calling free of null is an o operation won't do anything if get line had to extend the buffer then it will automatically call free on the old buffer so there's only ever one buffer in existence so we've got free there let's	memory	28
get line has allocated some memory on the heap is our responsibility to free that memory up so let's remember to do that if get line never successfully well then buffalo will still be pointing to null that's ok calling free of null is an o operation won't do anything if get line had to extend the buffer then it will automatically call free on the old buffer so there's only ever one buffer in existence so we've got free there let's	the heap	38
we've run it and notice waiting get line is blocked because their deep inside the implement vegetation at some point rc library is calling read and read itself is blocked or process isn't doing anything right now it's stuck and it only gets to continue when read returns so let's give it some data let's say abcd	block	44
ok and now look are variables have changed the buffers now not pointing at null is pointing it's invalid memory it's been initialized to our capacity of eight and we got five bites back and what do we see abcd and something else in fact we get back in this case is abc d and the new line that's right get lines not stripping that new line forces automatically including it we did type it is part of our input or part of a file whatever where reading form so if we don't want that new line it's up to us to actually get rid of it but before we do that let's do some more entries let's do d e f ok seems to be working let's you'll notice it used the same buffer location i'll do one more do something small it keeps using that same buffer now let me start waiting	memory	105
ok and now look are variables have changed the buffers now not pointing at null is pointing it's invalid memory it's been initialized to our capacity of eight and we got five bites back and what do we see abcd and something else in fact we get back in this case is abc d and the new line that's right get lines not stripping that new line forces automatically including it we did type it is part of our input or part of a file whatever where reading form so if we don't want that new line it's up to us to actually get rid of it but before we do that let's do some more entries let's do d e f ok seems to be working let's you'll notice it used the same buffer location i'll do one more do something small it keeps using that same buffer now let me start waiting	type	380
go back to our code and fix up the fact that we're seeing in new line character so i have my get line demo	code	15
print buffer contents ok so we're pretty good out here i actually want to strip off that new line because look we were seeing a new line even though i didn't put slash n inside my print out here ok so how can we do that what do you think about the following i know that result tells me about the number of characters that is seen does it include the zero night zero at the end good question one way to answer that is to read the man pages so let's do that let's go and see exactly what man says we get line so on my mac system here will go scroll down till we	the following	244
print buffer contents ok so we're pretty good out here i actually want to strip off that new line because look we were seeing a new line even though i didn't put slash n inside my print out here ok so how can we do that what do you think about the following i know that result tells me about the number of characters that is seen does it include the zero night zero at the end good question one way to answer that is to read the man pages so let's do that let's go and see exactly what man says we get line so on my mac system here will go scroll down till we	system	520
so that's important information to know we can write correct code if we are accurate	code	61
all we had was a single newline then the value of result would be one so actually we have enough by one right now so we need result minus one ok so that will be our new line we want to kate the string at that point we want to chop off that that new line so i'm going to overwrite it with something if i overwrote it with an x great we would see the x will just do that as a quick demo their case so off we go will learn it and i'll have abc and now you'll see it prints out abc anna next we got rid of that new line and we're still on the same line so now if i type say bbc	type	561
all we had was a single newline then the value of result would be one so actually we have enough by one right now so we need result minus one ok so that will be our new line we want to kate the string at that point we want to chop off that that new line so i'm going to overwrite it with something if i overwrote it with an x great we would see the x will just do that as a quick demo their case so off we go will learn it and i'll have abc and now you'll see it prints out abc anna next we got rid of that new line and we're still on the same line so now if i type say bbc	string	194
notice we did actually print out any new lines anymore ok but i don't want to print out an ex actually want to stop the string there how can i do that should i make a new string no here's what we need to do to truncate the string let's just put in an extra zero at that point so i'm just going to put in a zero byte because we now know that if i pass in the address of buffer it's going to read all the bytes until exes the zero bite and what about the other zero by after the end of this who cares	string	120
notice we did actually print out any new lines anymore ok but i don't want to print out an ex actually want to stop the string there how can i do that should i make a new string no here's what we need to do to truncate the string let's just put in an extra zero at that point so i'm just going to put in a zero byte because we now know that if i pass in the address of buffer it's going to read all the bytes until exes the zero bite and what about the other zero by after the end of this who cares	address	358
will run it ok and i'll type something like one two three and you'll see that great we've actually script off the new line an only printing that so and we can now use it as a c string so abc and we have abc and we have a longer string and we change capacity and potentially the address of a buffer ok so what do we got little get line demo so that's if you get line lots of kind of moving past it is to think carefully about but it's actually a very powerful utility that gives us a great performance because we can reuse the same piece of memory if you truly wanted to read these different lines into different parts of memory then one tricks you could do would be to reset buffer and reset buffer capacity back to their zero values and get line when you call it again would never know about those those earlier memory allocations that would be a little bit strange but you could do that so have we got great code yes not bad but remember we can actually improve things a little bit	memory	540
will run it ok and i'll type something like one two three and you'll see that great we've actually script off the new line an only printing that so and we can now use it as a c string so abc and we have abc and we have a longer string and we change capacity and potentially the address of a buffer ok so what do we got little get line demo so that's if you get line lots of kind of moving past it is to think carefully about but it's actually a very powerful utility that gives us a great performance because we can reuse the same piece of memory if you truly wanted to read these different lines into different parts of memory then one tricks you could do would be to reset buffer and reset buffer capacity back to their zero values and get line when you call it again would never know about those those earlier memory allocations that would be a little bit strange but you could do that so have we got great code yes not bad but remember we can actually improve things a little bit	memory allocation	813
will run it ok and i'll type something like one two three and you'll see that great we've actually script off the new line an only printing that so and we can now use it as a c string so abc and we have abc and we have a longer string and we change capacity and potentially the address of a buffer ok so what do we got little get line demo so that's if you get line lots of kind of moving past it is to think carefully about but it's actually a very powerful utility that gives us a great performance because we can reuse the same piece of memory if you truly wanted to read these different lines into different parts of memory then one tricks you could do would be to reset buffer and reset buffer capacity back to their zero values and get line when you call it again would never know about those those earlier memory allocations that would be a little bit strange but you could do that so have we got great code yes not bad but remember we can actually improve things a little bit	type	24
will run it ok and i'll type something like one two three and you'll see that great we've actually script off the new line an only printing that so and we can now use it as a c string so abc and we have abc and we have a longer string and we change capacity and potentially the address of a buffer ok so what do we got little get line demo so that's if you get line lots of kind of moving past it is to think carefully about but it's actually a very powerful utility that gives us a great performance because we can reuse the same piece of memory if you truly wanted to read these different lines into different parts of memory then one tricks you could do would be to reset buffer and reset buffer capacity back to their zero values and get line when you call it again would never know about those those earlier memory allocations that would be a little bit strange but you could do that so have we got great code yes not bad but remember we can actually improve things a little bit	code	910
will run it ok and i'll type something like one two three and you'll see that great we've actually script off the new line an only printing that so and we can now use it as a c string so abc and we have abc and we have a longer string and we change capacity and potentially the address of a buffer ok so what do we got little get line demo so that's if you get line lots of kind of moving past it is to think carefully about but it's actually a very powerful utility that gives us a great performance because we can reuse the same piece of memory if you truly wanted to read these different lines into different parts of memory then one tricks you could do would be to reset buffer and reset buffer capacity back to their zero values and get line when you call it again would never know about those those earlier memory allocations that would be a little bit strange but you could do that so have we got great code yes not bad but remember we can actually improve things a little bit	string	177
will run it ok and i'll type something like one two three and you'll see that great we've actually script off the new line an only printing that so and we can now use it as a c string so abc and we have abc and we have a longer string and we change capacity and potentially the address of a buffer ok so what do we got little get line demo so that's if you get line lots of kind of moving past it is to think carefully about but it's actually a very powerful utility that gives us a great performance because we can reuse the same piece of memory if you truly wanted to read these different lines into different parts of memory then one tricks you could do would be to reset buffer and reset buffer capacity back to their zero values and get line when you call it again would never know about those those earlier memory allocations that would be a little bit strange but you could do that so have we got great code yes not bad but remember we can actually improve things a little bit	address	278
to to null so we call accidentally use them in the future is this necessary in this tiny demo no of course not because we're immediately exiting but it's good engineering practice secondly what would happen if we had never freed this would machine get really slow if i kept on running this little demo a hundred times well know the good news is that the kernel knows how to tear down a complete process so when your process finishes we're going to scrap all of the memory associated with the heap and the stack etc etc etc so technically	memory	465
to to null so we call accidentally use them in the future is this necessary in this tiny demo no of course not because we're immediately exiting but it's good engineering practice secondly what would happen if we had never freed this would machine get really slow if i kept on running this little demo a hundred times well know the good news is that the kernel knows how to tear down a complete process so when your process finishes we're going to scrap all of the memory associated with the heap and the stack etc etc etc so technically	the heap	488
we will be fine without the free but if you are in a course which actually checked whether you're have good memory management practices then it is important to put the right number of freezing so that you actually do deallocate all memory that you personally have allocated or utility 's have allocated on your behalf	memory	108
hi welcome to lecture eight we're going to spend it mostly fletcher talking about memory allocation but before we do that let's have a look at little puzzle ok so first question for you why is it that we put the heaps so far away from this stack why is it that we organize our memory this way so to try to answer this and let's think about how these structures can grow in time both the heap and the stack can dynamic dynamic in the sense that they can get significantly larger so heat gets larger when we call malloc for example and stack gets larger when we recurse so every time we make another function call i'm going to need to extend my my stack space so for for architectures that only have a limited address space so particularly true on say sixteen bit and thirty two bit architectures let's put these two structures as far away as possible so that the likelihood of them colliding is small	memory	82
hi welcome to lecture eight we're going to spend it mostly fletcher talking about memory allocation but before we do that let's have a look at little puzzle ok so first question for you why is it that we put the heaps so far away from this stack why is it that we organize our memory this way so to try to answer this and let's think about how these structures can grow in time both the heap and the stack can dynamic dynamic in the sense that they can get significantly larger so heat gets larger when we call malloc for example and stack gets larger when we recurse so every time we make another function call i'm going to need to extend my my stack space so for for architectures that only have a limited address space so particularly true on say sixteen bit and thirty two bit architectures let's put these two structures as far away as possible so that the likelihood of them colliding is small	memory allocation	82
hi welcome to lecture eight we're going to spend it mostly fletcher talking about memory allocation but before we do that let's have a look at little puzzle ok so first question for you why is it that we put the heaps so far away from this stack why is it that we organize our memory this way so to try to answer this and let's think about how these structures can grow in time both the heap and the stack can dynamic dynamic in the sense that they can get significantly larger so heat gets larger when we call malloc for example and stack gets larger when we recurse so every time we make another function call i'm going to need to extend my my stack space so for for architectures that only have a limited address space so particularly true on say sixteen bit and thirty two bit architectures let's put these two structures as far away as possible so that the likelihood of them colliding is small	the heap	208
hi welcome to lecture eight we're going to spend it mostly fletcher talking about memory allocation but before we do that let's have a look at little puzzle ok so first question for you why is it that we put the heaps so far away from this stack why is it that we organize our memory this way so to try to answer this and let's think about how these structures can grow in time both the heap and the stack can dynamic dynamic in the sense that they can get significantly larger so heat gets larger when we call malloc for example and stack gets larger when we recurse so every time we make another function call i'm going to need to extend my my stack space so for for architectures that only have a limited address space so particularly true on say sixteen bit and thirty two bit architectures let's put these two structures as far away as possible so that the likelihood of them colliding is small	address	708
right so we've got the idea then that my memory has some really text segment down here for my code and constants i've got little space for my global variables and then i've got the heap above that my question is	memory	41
right so we've got the idea then that my memory has some really text segment down here for my code and constants i've got little space for my global variables and then i've got the heap above that my question is	the heap	177
right so we've got the idea then that my memory has some really text segment down here for my code and constants i've got little space for my global variables and then i've got the heap above that my question is	code	94
above the heap and simply if at the very top of memory i've got things like argv argc values i've got environment variables and then i've got the stack here	memory	48
above the heap and simply if at the very top of memory i've got things like argv argc values i've got environment variables and then i've got the stack here	the heap	6
a little hv heap what's immediately above the heap here and what's immediately below the stack	the heap	42
ok so the answer surprisingly is nothing these areas of memory these pages of memory and not actually mapped to any memory if you try to write to an arbitrary address in here that doesn't correspond to any particular piece of ram and so the cpu memory subsystem will act the interrupt your program the kernel will evaluate that interrupt and eventually will generate a segfault	memory	56
ok so the answer surprisingly is nothing these areas of memory these pages of memory and not actually mapped to any memory if you try to write to an arbitrary address in here that doesn't correspond to any particular piece of ram and so the cpu memory subsystem will act the interrupt your program the kernel will evaluate that interrupt and eventually will generate a segfault	address	159
ok so the answer surprisingly is nothing these areas of memory these pages of memory and not actually mapped to any memory if you try to write to an arbitrary address in here that doesn't correspond to any particular piece of ram and so the cpu memory subsystem will act the interrupt your program the kernel will evaluate that interrupt and eventually will generate a segfault	system	255
ok this is the whole story now there's a few little lies inside this story ok so what are the lies first of all that when we load libraries like the c library or if we were doing open gl sound library we need to put those in memory as well so in practice they will actually live between these where we dynamically load libraries so we might put other stuff in the side there also the idea that the heap is actually just one contiguous block of memory later on will axe that model and if you say to malloc hey malloc i'd like four gigabytes of memory actually it's going on a modern machine going to find a different space for such a large allocation ok but more little other light is that in the future we'll talk about threats and each thread will need to own stack but less live in a cozy world right now where we just got a single stack a single heap area and as we make more complicated programs these are going to expand my heap expands as i keep calling malik and i never call free my stack expands downwards as eyes for example keep making lots of recursive calls right so you'll learn more about stack and how we represent things on the stack	memory	225
ok this is the whole story now there's a few little lies inside this story ok so what are the lies first of all that when we load libraries like the c library or if we were doing open gl sound library we need to put those in memory as well so in practice they will actually live between these where we dynamically load libraries so we might put other stuff in the side there also the idea that the heap is actually just one contiguous block of memory later on will axe that model and if you say to malloc hey malloc i'd like four gigabytes of memory actually it's going on a modern machine going to find a different space for such a large allocation ok but more little other light is that in the future we'll talk about threats and each thread will need to own stack but less live in a cozy world right now where we just got a single stack a single heap area and as we make more complicated programs these are going to expand my heap expands as i keep calling malik and i never call free my stack expands downwards as eyes for example keep making lots of recursive calls right so you'll learn more about stack and how we represent things on the stack	the heap	394
ok this is the whole story now there's a few little lies inside this story ok so what are the lies first of all that when we load libraries like the c library or if we were doing open gl sound library we need to put those in memory as well so in practice they will actually live between these where we dynamically load libraries so we might put other stuff in the side there also the idea that the heap is actually just one contiguous block of memory later on will axe that model and if you say to malloc hey malloc i'd like four gigabytes of memory actually it's going on a modern machine going to find a different space for such a large allocation ok but more little other light is that in the future we'll talk about threats and each thread will need to own stack but less live in a cozy world right now where we just got a single stack a single heap area and as we make more complicated programs these are going to expand my heap expands as i keep calling malik and i never call free my stack expands downwards as eyes for example keep making lots of recursive calls right so you'll learn more about stack and how we represent things on the stack	block	435
ok this is the whole story now there's a few little lies inside this story ok so what are the lies first of all that when we load libraries like the c library or if we were doing open gl sound library we need to put those in memory as well so in practice they will actually live between these where we dynamically load libraries so we might put other stuff in the side there also the idea that the heap is actually just one contiguous block of memory later on will axe that model and if you say to malloc hey malloc i'd like four gigabytes of memory actually it's going on a modern machine going to find a different space for such a large allocation ok but more little other light is that in the future we'll talk about threats and each thread will need to own stack but less live in a cozy world right now where we just got a single stack a single heap area and as we make more complicated programs these are going to expand my heap expands as i keep calling malik and i never call free my stack expands downwards as eyes for example keep making lots of recursive calls right so you'll learn more about stack and how we represent things on the stack	thread	737
ok so immediately above we have nothing in practice the the operating system may include what's called a canary value so if we could deliberately put a value into some memory so for example i can have a value a hexadecimal value like the following bad food	the following	234
ok so immediately above we have nothing in practice the the operating system may include what's called a canary value so if we could deliberately put a value into some memory so for example i can have a value a hexadecimal value like the following bad food	memory	168
ok so immediately above we have nothing in practice the the operating system may include what's called a canary value so if we could deliberately put a value into some memory so for example i can have a value a hexadecimal value like the following bad food	system	70
then later i could check to see if that value has been changed so we could write that to the few bites immediately above where are heap and stack finished to check for overruns but we're going to do that for the entire memory between the heap and stack	memory	219
then later i could check to see if that value has been changed so we could write that to the few bites immediately above where are heap and stack finished to check for overruns but we're going to do that for the entire memory between the heap and stack	the heap	234
ok so the next video i've got a little challenge for you let's start playing with fork and you'll see that i set a variable a here to ten that take the address of ten and then i call fork right and that as you know	address	152
that at that moment are single universe becomes two are single process now is two independent processes we've cloned it right with the second process returning from fork right none the wiser that really it's just been created that it has a fake history there's lots of science sci-fi movies that use that as a plot device ok so it thinks it knows where it came from but actually we've cloned a different process ok the only give away the only tell is that the return value from fork is actually zero for the child so have a look to see what the child is doing here is changing some values my question for you is what's going to happen to the parent when it gets to that printf like what's again a print	printf	670
right great ok so unless some implement a stack and will implement stack but is bounded by two things first of all you'll see that i data store here my little array here can only handle ten items also we can't pull anything from the stack if my stack is empty so now push and pop methods need to block if they are unable to continue right so let's let's have a good figure out how we're going to implement this first of all let's just pretend that with i cs two twenty five or some other course right and right than on the single threaded version ok so what are we going to have we're going to have things like the push method will be take my data structure my ray and after i've used the value of n increment it and density equal to be ok right what else you want to do so for multithreaded code i need to make sure that i'm the only person using this value of end otherwise two threads might call this code at the same time and both right into the same slot the same entry inside the away so less using mutex lock for that so we're definitely going to need mutex lock	block	296
right great ok so unless some implement a stack and will implement stack but is bounded by two things first of all you'll see that i data store here my little array here can only handle ten items also we can't pull anything from the stack if my stack is empty so now push and pop methods need to block if they are unable to continue right so let's let's have a good figure out how we're going to implement this first of all let's just pretend that with i cs two twenty five or some other course right and right than on the single threaded version ok so what are we going to have we're going to have things like the push method will be take my data structure my ray and after i've used the value of n increment it and density equal to be ok right what else you want to do so for multithreaded code i need to make sure that i'm the only person using this value of end otherwise two threads might call this code at the same time and both right into the same slot the same entry inside the away so less using mutex lock for that so we're definitely going to need mutex lock	a struct	646
right great ok so unless some implement a stack and will implement stack but is bounded by two things first of all you'll see that i data store here my little array here can only handle ten items also we can't pull anything from the stack if my stack is empty so now push and pop methods need to block if they are unable to continue right so let's let's have a good figure out how we're going to implement this first of all let's just pretend that with i cs two twenty five or some other course right and right than on the single threaded version ok so what are we going to have we're going to have things like the push method will be take my data structure my ray and after i've used the value of n increment it and density equal to be ok right what else you want to do so for multithreaded code i need to make sure that i'm the only person using this value of end otherwise two threads might call this code at the same time and both right into the same slot the same entry inside the away so less using mutex lock for that so we're definitely going to need mutex lock	code	792
right great ok so unless some implement a stack and will implement stack but is bounded by two things first of all you'll see that i data store here my little array here can only handle ten items also we can't pull anything from the stack if my stack is empty so now push and pop methods need to block if they are unable to continue right so let's let's have a good figure out how we're going to implement this first of all let's just pretend that with i cs two twenty five or some other course right and right than on the single threaded version ok so what are we going to have we're going to have things like the push method will be take my data structure my ray and after i've used the value of n increment it and density equal to be ok right what else you want to do so for multithreaded code i need to make sure that i'm the only person using this value of end otherwise two threads might call this code at the same time and both right into the same slot the same entry inside the away so less using mutex lock for that so we're definitely going to need mutex lock	thread	530
soapy said mutex lock and as luck would have it i've already got my variables up here ready to go right so let me call peter mutex lock on my mutex there we go so that might block for a short while if someone else is currently acquired the lock which is why a later on we are going to release it	block	174
so now we've got code which where only one third of the time can push things what about if our array is full of what if i stack is full so remember stepping	code	17
busy checking this right so while while n is equal to the maximum number go round the loop now we know we could put a sleeping here if we wanted to we know that right now this is a terrible test because we're holding the lock if all of our code uses a lot no one else will be able to do this fortunately for us we're going to be using p thread condition wait	the loop	82
busy checking this right so while while n is equal to the maximum number go round the loop now we know we could put a sleeping here if we wanted to we know that right now this is a terrible test because we're holding the lock if all of our code uses a lot no one else will be able to do this fortunately for us we're going to be using p thread condition wait	code	240
busy checking this right so while while n is equal to the maximum number go round the loop now we know we could put a sleeping here if we wanted to we know that right now this is a terrible test because we're holding the lock if all of our code uses a lot no one else will be able to do this fortunately for us we're going to be using p thread condition wait	thread	337
and that will release the lock whilst it's blocking ok so here's our condition variable that were going to sleep in and watched was sleeping unlock that mutex and then before returning lock it again so the big idea here is that in all the code that we write let's do i make a highlighter well let's do it like like a yellow ok it all this code every single piece of this	block	43
and that will release the lock whilst it's blocking ok so here's our condition variable that were going to sleep in and watched was sleeping unlock that mutex and then before returning lock it again so the big idea here is that in all the code that we write let's do i make a highlighter well let's do it like like a yellow ok it all this code every single piece of this	code	239
that we are in the matrix log so we could reason that we are the only thread that continue to run so great i've got all these other threads running at the same time but my head doesn't need to explode thinking about the possible interleavings of all of these expressions from this thread and another third because we own the mutex lock right and anybody else has to wait until we finished so it simplifies reasoning about this back down to just simple single threaded code again alright so great we've got our push method to work	code	468
that we are in the matrix log so we could reason that we are the only thread that continue to run so great i've got all these other threads running at the same time but my head doesn't need to explode thinking about the possible interleavings of all of these expressions from this thread and another third because we own the mutex lock right and anybody else has to wait until we finished so it simplifies reasoning about this back down to just simple single threaded code again alright so great we've got our push method to work	thread	70
if anything else we need to do yeah well we're writing a method which both to push and pop can can block so if i just put something onto this onto my way it could be that there's another thread waiting to pop things from the data structure so after i've modified it i'm going to call p threat condition broadcast	block	99
if anything else we need to do yeah well we're writing a method which both to push and pop can can block so if i just put something onto this onto my way it could be that there's another thread waiting to pop things from the data structure so after i've modified it i'm going to call p threat condition broadcast	the data structure	221
if anything else we need to do yeah well we're writing a method which both to push and pop can can block so if i just put something onto this onto my way it could be that there's another thread waiting to pop things from the data structure so after i've modified it i'm going to call p threat condition broadcast	a struct	228
if anything else we need to do yeah well we're writing a method which both to push and pop can can block so if i just put something onto this onto my way it could be that there's another thread waiting to pop things from the data structure so after i've modified it i'm going to call p threat condition broadcast	thread	187
there we go so if there happens to be someone sleeping in on this condition variable because that waiting to pop then now they can wake up so we could for performance reasons a little bit more about this and say the only time we need to do this the only possible time that someone could be blocked while popping from this away would be if the value of n was zero so in other words we have just increased it up to one otherwise there's no way that anyone could be sleeping right now so we could weight using about that and we could also reason that we've just added one thing	block	290
then maybe we could call pizza hut conditions signal as well but i would have to be a lot more careful about reasoning about that so i'm going to use p thread condition broadcast just in case there were multiple threads gone to sleep we want to make sure that if we're only going to wake up in that transition that we work them all up so	thread	152
so the pop ok so what should my pop method look like ok so first of all let's write the code which is going to	code	88
k so we turned my v where does become from i'm going to have something like double v equals so i go to my way now i want to pre decrement my value of n there we go alright so what about the blocking all right so we need something like look if my value of n is zero then go to sleep ok right so i'm going to have my p thread conditioned wait ok did you do today and here is my condition variable i'd like to sleep in and don't forget that mutex lock ok what is the mutex lock code look like are right so we've seen this before that's just	block	190
k so we turned my v where does become from i'm going to have something like double v equals so i go to my way now i want to pre decrement my value of n there we go alright so what about the blocking all right so we need something like look if my value of n is zero then go to sleep ok right so i'm going to have my p thread conditioned wait ok did you do today and here is my condition variable i'd like to sleep in and don't forget that mutex lock ok what is the mutex lock code look like are right so we've seen this before that's just	code	475
k so we turned my v where does become from i'm going to have something like double v equals so i go to my way now i want to pre decrement my value of n there we go alright so what about the blocking all right so we need something like look if my value of n is zero then go to sleep ok right so i'm going to have my p thread conditioned wait ok did you do today and here is my condition variable i'd like to sleep in and don't forget that mutex lock ok what is the mutex lock code look like are right so we've seen this before that's just	thread	317
right are we done no we might need to wake up some threads so let's put that code in as well about this kind of	code	77
right are we done no we might need to wake up some threads so let's put that code in as well about this kind of	thread	51
dark published right so let's in here wake up any thread switch might be sleeping on the condition variable so p thread condition broadcast	thread	50
all right and again we could reason about this we could say if there's if there's any locks if there's any threads sleeping on this waiting to push the only time that that can occur is if the reached the maximum number so if any is equal to now nine then i know that	thread	107
time to broadcast however this is kind of a optimization it's very easy to get these wrong it's very tricky to start modeling thinking about this when you've got multiple threads which might call pop of multiple threads which might call push gets a little bit easier to think about if you've only got one thread of each kind so my advice is treat these optimizations with extreme caution you're introducing possible edge cases which not easy to discover or think about and so if in doubt	optimizations	353
time to broadcast however this is kind of a optimization it's very easy to get these wrong it's very tricky to start modeling thinking about this when you've got multiple threads which might call pop of multiple threads which might call push gets a little bit easier to think about if you've only got one thread of each kind so my advice is treat these optimizations with extreme caution you're introducing possible edge cases which not easy to discover or think about and so if in doubt	thread	171
if you don't care about absolute performance just called prefect ingram forecast that performance head is not that great ok so we've got some working code we think let's actually have a go at testing this	code	150
ok so here's my code	code	16
that is going to actually run this and i've got some testing code where my producer is going to call the	code	61
push say ten thousand times but we're actually going to do that with two threads and then i've got a consumer method that is going to call pop twenty thousand times is just one of those today so let's check that we actually get all values of all the double values that we pushed in so we know that we know that we're going to push in the	thread	73
help for help in the background ok great so we know we're going to push in the values zero up to nine hundred and ninety nine nine have enough ninth ok right and so if we're just going to some these so we have the sum of values from zero up to that number there ok but in fact we're having two threads actually push all those values in so	thread	294
help for help in the background ok great so we know we're going to push in the values zero up to nine hundred and ninety nine nine have enough ninth ok right and so if we're just going to some these so we have the sum of values from zero up to that number there ok but in fact we're having two threads actually push all those values in so	background	21
i'm going to sum up the integers and if you know i'm sure you've seen this inside once every three right or you can do it recursively you can do this inductively or you can do it with lego as well you know that the sum is equal to n times n plus one over two right so in other words we expect a total of that right by the way i said you could do it with lego blocks here's the reasoning with lego blocks if you still some lego blocks from your younger sibling	block	359
lego block proved there right so let's let's actually have a go at running this ok so do we have code right so we called it block and let's let's run this thing ok you'll notice that we only exit after we managed to join all three threats so will compile it stop the cake monster stop consuming cake	block	5
lego block proved there right so let's let's actually have a go at running this ok so do we have code right so we called it block and let's let's run this thing ok you'll notice that we only exit after we managed to join all three threats so will compile it stop the cake monster stop consuming cake	code	97
compile ok block right so let's do that	block	11
ok gcc minus p thread block	block	22
ok gcc minus p thread block	thread	15
alright and great we got the correct some who are so are we convinced that our code works or like i said we've firmed given it a fair shake we called the	code	79
push and pop in a tight loop and we called it for ten thousand times so empirically we've shown that maybe if there's a likelihood of it failing we've at least tested it to the kind of point one percent level but is that is that is that does that give me confidence to put this into production no i'd actually want to kind of actually do a code review and think carefully about how my code works so so in multithreaded code it's a very important we have strong understanding about how our code works and rather than just simple going to lightweight testing and say oh yeah great it appears to work if we actually want to use this code and trust it on our game or driving a car or an aircraft or website which is going to make our livelihood we actually want to be confident that we've got this multithreaded coding correct ok that's it for now bye	code	340
push and pop in a tight loop and we called it for ten thousand times so empirically we've shown that maybe if there's a likelihood of it failing we've at least tested it to the kind of point one percent level but is that is that is that does that give me confidence to put this into production no i'd actually want to kind of actually do a code review and think carefully about how my code works so so in multithreaded code it's a very important we have strong understanding about how our code works and rather than just simple going to lightweight testing and say oh yeah great it appears to work if we actually want to use this code and trust it on our game or driving a car or an aircraft or website which is going to make our livelihood we actually want to be confident that we've got this multithreaded coding correct ok that's it for now bye	thread	410
ok right so what have we seen what can we what can we conclude from from our little paper demo well let's try to think a little bit more general than just the example we've seen and also maybe we can understand why what happens when we actually use this ok so first of all it's actually really hard to prove anything from these is often the case that we actually want to run real simulations on real examples so for example you might actually run your memory allocator as part of a web server or database or a chat client or chat server or some other large piece of software that needs to run	memory	452
uh would be concerned about well our big problem is we're concerned about fragmentation and there were several reasons we care about fragmentation there's the obvious one which is that now i've got pieces of memory that i can't use very well because they will sparsely separated	memory	208
the second is that now i've got a lot of entries inside say my linked list or whatever date other data structure i want to use which are useless to me or i have to keep iterating over them in order to find a useful piece of memory that is going to work for the next malik request right so what's the outcome of the three placement strategy that we've seen so surprisingly best fit is not the best ok what does that mean let me give him an unhappy smiley face here ok so best fit should it sounded google the beginning here's my unhappy smiley face right but what's the problem of always actually trying to find the fit that is their closest well something that wasn't quite obvious from our very simple kind of little integer example that we just did here is that	memory	224
the second is that now i've got a lot of entries inside say my linked list or whatever date other data structure i want to use which are useless to me or i have to keep iterating over them in order to find a useful piece of memory that is going to work for the next malik request right so what's the outcome of the three placement strategy that we've seen so surprisingly best fit is not the best ok what does that mean let me give him an unhappy smiley face here ok so best fit should it sounded google the beginning here's my unhappy smiley face right but what's the problem of always actually trying to find the fit that is their closest well something that wasn't quite obvious from our very simple kind of little integer example that we just did here is that	a struct	101
real memory allocations can differ just by a small number of bytes so for example imagine i've got a piece of memory which is one hundred and eighteen bites and somebody requests one hundred twelve bytes ok so now i've got a small piece of just six six bytes that no one is ever going to be able to use effectively and it's very deep inside my link list etc right so it's going to take a long time to find and it's going to	memory	5
real memory allocations can differ just by a small number of bytes so for example imagine i've got a piece of memory which is one hundred and eighteen bites and somebody requests one hundred twelve bytes ok so now i've got a small piece of just six six bytes that no one is ever going to be able to use effectively and it's very deep inside my link list etc right so it's going to take a long time to find and it's going to	memory allocation	5
slow my performance down so because memory allocations tend to be scattered or many different sizes we end up with lots of tiny holes because invariably will find something which is pretty good but just a little bit bigger than what we needed and so we end up with	memory	36
slow my performance down so because memory allocations tend to be scattered or many different sizes we end up with lots of tiny holes because invariably will find something which is pretty good but just a little bit bigger than what we needed and so we end up with	memory allocation	36
very quickly we eat into our largest space and so you know if i'd kind of just sketch this out here if this is all of my memory if i've divided my memory up into two areas for some reason because i've got an object say in the middle here then very quickly i'm going to start eating into this space so this space is going to get smaller but so is this space whichever one happens to be largest at the time will be eaten away will be used to assign more objects so with worst fear we tend to see is lots of medium size holes lots of medium fragments ok so we see lots of medium spaces simply because the largest space can't exist for very long because it's going to be nibbled away from the next allocation so lots of kind of medium spaces which are all about approximately the same size so that sounds great until you need to run it with an application that actually needs occasionally to allocate lots of space because now if we were to look at our memory we would find ok i got some free space here i got a bit of free space here i've got a bit of free space here i've got some free space tear operator right is that um now i can't do large allocation requests so sorry for worst fits you turned out to be maybe a little bit	memory	121
better than best fit for some applications but maybe we can do better and surprisingly then the one which we just thought was just the scrappy dog of hagia systems we find something that surprised me actually works surprisingly well	system	156
it's pretty good pretty has pretty good performance that as soon as we find a reasonable fit we're not going to keep looking through our linked list jumping through a link list is actually kind of slow we're not doing memory any favors because quite often now we were busting their caches we keep going back to different parts that made memory to say oh i need to follow this link over there so it's not cache friendly which means i often we're talking to main memory which is so slow	memory	218
all the others yeah sure ok so i'm not going to talk about it today but if you would implement a fast memory allocator i personally think nextfit is kind of fun	memory	102
where rather than always starting at the beginning of our linked list we have some other pointer that allows us to start from a different spot inside are linked list that would also have a different fragmentation pattern i'm going to put this in parentheses though because writing a memory allocator is tricky and so my advice is always starts start with something simple and only add complexity when you have something working and only add complexity after you've done a git commit that you've actually got some working code so that you can go back to that working code in the future and be very careful about trying to edit this kind of code if you're tired or sleepy writing a memory allocator is requires some bravery and a lot of careful thinking	memory	283
where rather than always starting at the beginning of our linked list we have some other pointer that allows us to start from a different spot inside are linked list that would also have a different fragmentation pattern i'm going to put this in parentheses though because writing a memory allocator is tricky and so my advice is always starts start with something simple and only add complexity when you have something working and only add complexity after you've done a git commit that you've actually got some working code so that you can go back to that working code in the future and be very careful about trying to edit this kind of code if you're tired or sleepy writing a memory allocator is requires some bravery and a lot of careful thinking	code	521
where rather than always starting at the beginning of our linked list we have some other pointer that allows us to start from a different spot inside are linked list that would also have a different fragmentation pattern i'm going to put this in parentheses though because writing a memory allocator is tricky and so my advice is always starts start with something simple and only add complexity when you have something working and only add complexity after you've done a git commit that you've actually got some working code so that you can go back to that working code in the future and be very careful about trying to edit this kind of code if you're tired or sleepy writing a memory allocator is requires some bravery and a lot of careful thinking	pointer	89
hi welcome to lecture ten where we're going to start looking at how to build a memory allocator and today we're going to start by thinking about how we can build a better version of realloc ok so here's the story so far i have got	memory	79
and for each entry i'm going to make a note of whether that it corresponds to piece of memory that is free and other words available for future allocations i need to make a note of its size in other words how many bytes the user could actually stored a certain location	memory	87
and also i have a pointer to where the users areas actually going to start which typically is going to be just after the end of each one of these entries but it doesn't have to be so that's one advantage of having this little point here ok so what do we need we also need a way to make a note of where my link list starts so now i've done this typedef i can just write end you underscore t and it's a pointer and i'm going to call it head and notice i'd made it static meaning that only the code that is inside the same compilation unit will be able to see my variable here ok wait so the next video then will start will assume that we've actually written version of malloc and now we're going to think about how we can implement reallocate as as as our next step ok see you then	type	344
and also i have a pointer to where the users areas actually going to start which typically is going to be just after the end of each one of these entries but it doesn't have to be so that's one advantage of having this little point here ok so what do we need we also need a way to make a note of where my link list starts so now i've done this typedef i can just write end you underscore t and it's a pointer and i'm going to call it head and notice i'd made it static meaning that only the code that is inside the same compilation unit will be able to see my variable here ok wait so the next video then will start will assume that we've actually written version of malloc and now we're going to think about how we can implement reallocate as as as our next step ok see you then	code	491
and also i have a pointer to where the users areas actually going to start which typically is going to be just after the end of each one of these entries but it doesn't have to be so that's one advantage of having this little point here ok so what do we need we also need a way to make a note of where my link list starts so now i've done this typedef i can just write end you underscore t and it's a pointer and i'm going to call it head and notice i'd made it static meaning that only the code that is inside the same compilation unit will be able to see my variable here ok wait so the next video then will start will assume that we've actually written version of malloc and now we're going to think about how we can implement reallocate as as as our next step ok see you then	pointer	18
ok let's round out this lecture with two little non virtual memory ideas first of all i've hinted at this	memory	60
ok where we used a shared memory using the virtual memory mechanisms some more that we're going to look at in the future again it be pipes where we can treat pipes a bit like files or at least streams where i can stream in some bites and then another process constrain them out in the same order and then we're going to talk about networking as well so the idea that i can create tcp and udp sockets so that i can pass messages between my processes right the other thing i want to finish with is amdahl's law so great we've learned a lot about threads and processes and concurrency let's actually kind of take a different tack and say just how much speed up could we actually get so on those law yes there was a formula but you never need to memorize that that formula instead it's very easy to workout from first principles what kind of speed up you can actually get so let's take a look at this as a kind of worked example	memory	26
ok where we used a shared memory using the virtual memory mechanisms some more that we're going to look at in the future again it be pipes where we can treat pipes a bit like files or at least streams where i can stream in some bites and then another process constrain them out in the same order and then we're going to talk about networking as well so the idea that i can create tcp and udp sockets so that i can pass messages between my processes right the other thing i want to finish with is amdahl's law so great we've learned a lot about threads and processes and concurrency let's actually kind of take a different tack and say just how much speed up could we actually get so on those law yes there was a formula but you never need to memorize that that formula instead it's very easy to workout from first principles what kind of speed up you can actually get so let's take a look at this as a kind of worked example	thread	544
have a process which right now takes or single threaded program something that takes one hundred seconds ok and all of that code there's going to be part of it that i'm going to work on and then the other parts that i'm not going to work on so i'm going to try to make it as parallelize it in order to make it faster but of course i'm not going to change the whole codebase and if i've done some performance tests i'll know	code	124
have a process which right now takes or single threaded program something that takes one hundred seconds ok and all of that code there's going to be part of it that i'm going to work on and then the other parts that i'm not going to work on so i'm going to try to make it as parallelize it in order to make it faster but of course i'm not going to change the whole codebase and if i've done some performance tests i'll know	a process	5
have a process which right now takes or single threaded program something that takes one hundred seconds ok and all of that code there's going to be part of it that i'm going to work on and then the other parts that i'm not going to work on so i'm going to try to make it as parallelize it in order to make it faster but of course i'm not going to change the whole codebase and if i've done some performance tests i'll know	thread	47
say debit for loop and then twenty five twenty five seconds spent say during the initial reading in the file app put the code which i return i change so let's let's sketch this out ok so in terms of time	code	121
alright i'm going to scrunch down my seventy five seconds down to twenty five seconds in other words i actually got to work to make my code three times faster	code	135
ok that's going to benefit a lot of my code let's say	code	39
only see still a modest speed up so i'm does law says that you'll never get as much speed up as you hoped because there is usually a significant fraction of the code that is not parallelizable either because it's inherently parallelizable or simply because that's just not the code that you're working on today	code	161
so as a goodwill of firm is make sure that before you spend time trying to parallelize parts of your code make sure it actually represents a significant portion of the runtime in other words benchmarking is is important	code	101
and secondly don't bother to expect a big massive speed up your running on two cpus are going to need at least three or four cpus before you start to see a significant improvement and even then you won't get the full fold difference so if i run for cpus i still don't expect to see a four fold improvement in runtime right so you can read more about lawndale slow but it's not necessary to memorize a formula you could always calculate it yourself just simply by sketching out a timeline of thinking about ok this is the code that i'm i'm running in the code that i'm going to improve an last comment is what's the difference between concurrency whoops and parallelization so concurrency is the idea of doing two things potentially do different things at the same time so for example you might make a phone call while baking cookies so you're able to do these two tasks at the same time but you're not going to leave the kitchen until both are done and then this parallelization	code	521
at the same time by input both in into the oven at the same time so parallelization is about taking the same task and running it twice or thousands of times in parallel just for example like a gpu can run the same piece of code not just kind of once but say three hundred times in parallel which is great if you want to run say the same shading algorithm on three hundred different pixels as part of your screen at the same time so that we have a fundamental idea about how gpu 's work and the idea is that we've seen in this course in terms of concurrency in parallel vitalization and synchronization primitives	code	223
they all apply to c code to python code and even to gpu design as well right so that's it for this video and that's the end of lecture	code	20
ok so let's try these pipes on my mac and we'll see how many bytes we can send before it blocks. so we'll have a little counter right so here we go will have c size_t to say right this is number of bytes sent	block	89
great and now let's have a little loop and will try to see how many bytes we can send to this pipe before it blocks. so let's go right so print out number of bytes sent so far, and we can just work all that an integer	block	109
k so that's the second remember yes read write and watch we said well let's give it the address of one bite doesn't matter kind of what it is but how about just this little so the string literal meaning i've that's got an address an i just want that single character gay so let's increment my counter here key	string	180
k so that's the second remember yes read write and watch we said well let's give it the address of one bite doesn't matter kind of what it is but how about just this little so the string literal meaning i've that's got an address an i just want that single character gay so let's increment my counter here key	address	88
bite sent and if i wish i could check the right actually works how could i do that well let's just check return value of right means that this better be actually equal to one ok so let's run this and see what happens on my mac how your linux system may be different but we'll see how far we get before it blocks. ok, so i save that ok so let's compile it type	block	305
bite sent and if i wish i could check the right actually works how could i do that well let's just check return value of right means that this better be actually equal to one ok so let's run this and see what happens on my mac how your linux system may be different but we'll see how far we get before it blocks. ok, so i save that ok so let's compile it type	type	355
bite sent and if i wish i could check the right actually works how could i do that well let's just check return value of right means that this better be actually equal to one ok so let's run this and see what happens on my mac how your linux system may be different but we'll see how far we get before it blocks. ok, so i save that ok so let's compile it type	system	242
great ok so it didn't like trying to use just nature let's use the recommended type so we've got	type	79
off we go oh right so on my system, today! these limits can be but modified i can send close to sixty four kilobytes in fact this is sixty five that is exactly sixty four so if i have to do say python	system	28
characters out of this then i could actually kind of keeping anymore however as you can see it's dangerous to use a pipe if you're only using it as a communication protocol between within one process just sending a few bytes is unlikely to block with right but sending much larger data structures over pipe you might run into this limit about how many bytes pipe is prepared to store before it blocks right so pipes are much more useful when you actually want to communicate between different processes and in fact they used by the by the shell so if for example i take the output of a program so let's use cat for example	block	240
characters out of this then i could actually kind of keeping anymore however as you can see it's dangerous to use a pipe if you're only using it as a communication protocol between within one process just sending a few bytes is unlikely to block with right but sending much larger data structures over pipe you might run into this limit about how many bytes pipe is prepared to store before it blocks right so pipes are much more useful when you actually want to communicate between different processes and in fact they used by the by the shell so if for example i take the output of a program so let's use cat for example	a struct	284
special in the sense that we just using this pipe mechanism that we've just seen inside the c code and it means that cat at some point will block it will block trying to write data into this pipe which is useful we don't want to keep generating gigabytes of data but overtime grep will start reading that source from that pipe and as it starts to exhaust	block	140
special in the sense that we just using this pipe mechanism that we've just seen inside the c code and it means that cat at some point will block it will block trying to write data into this pipe which is useful we don't want to keep generating gigabytes of data but overtime grep will start reading that source from that pipe and as it starts to exhaust	code	94
data from that pipe, a 'cat' can be unblocked again and continue can continue to be sent more data so pipes are very useful and they allow us to kind of change things together like this on the command line so let's	block	38
i had instead passed it to head which will just tell me the kind of very first ten lines is cat going to continue or will it block forever ok right so we'll see that in the next video. ok, bye.	block	125
hi welcome to lecture eighteen so let's start off with a challenge we want to make it barrier just using a single mutex lock and a single unlock core so that seems impossible let's see how we can kind of get unstuck and then talk about why this is actually a terrible barrier ok so here's a sketch of what we want to do here we want multiple threads be able to call or barrier function here will have a keep some kind of count for the number of threads that have got stuck inside our barrier	thread	342
and then we want to wait until somehow wait until the order the threads that we need about actually called	thread	64
first of all this plus plus is not atomic so we definitely need to protect that with a p thread lock so only one thread at a time can write this so before calling count	thread	89
we definitely need to call pthread mutex lock	thread	28
and afterwards we need to release that locks the other threads can call call count ok call cam plus plus so will need to unlock it somehow right ok unlock	thread	55
great so we will short that critical section in here the count behaves now as if its atomic because if two threads try to do at the same time water then we'll have to wait	section	37
great so we will short that critical section in here the count behaves now as if its atomic because if two threads try to do at the same time water then we'll have to wait	thread	107
what about this waiting until the count has reached are required barrier number case so i suppose we could consider the following rights let's just do nothing ok let's just keep going around the loop yeah let's burn that cpu baby 'cause we're going to just keep checking the value of count	the following	116
what about this waiting until the count has reached are required barrier number case so i suppose we could consider the following rights let's just do nothing ok let's just keep going around the loop yeah let's burn that cpu baby 'cause we're going to just keep checking the value of count	the loop	191
on a particular processor on the lucky day you stand a good chance of it working right now let me explain why i have all those provisors so the first problem is that when a thread is running this code continuously checking the value of count what's it do it just keeps going keeps on checking so we're unnecessarily using cpu core to do that if another thread wants to run then either it will be running on a a second cpu core or it will be automatically given the cpu after a millisecond of time or so but for the whole millisecond we were just wasting cpu time whilst a first read just needlessly check the value of count so ideally we would want to give up the cpu at this point and sleep until the value of count changed but i said we are only allowed to use one mutex lock and one on local ok so at the very least i might put a p thread yielding here to say i'm done with the cpu for now give it back to me in a millisecond or two ok right so	code	196
on a particular processor on the lucky day you stand a good chance of it working right now let me explain why i have all those provisors so the first problem is that when a thread is running this code continuously checking the value of count what's it do it just keeps going keeps on checking so we're unnecessarily using cpu core to do that if another thread wants to run then either it will be running on a a second cpu core or it will be automatically given the cpu after a millisecond of time or so but for the whole millisecond we were just wasting cpu time whilst a first read just needlessly check the value of count so ideally we would want to give up the cpu at this point and sleep until the value of count changed but i said we are only allowed to use one mutex lock and one on local ok so at the very least i might put a p thread yielding here to say i'm done with the cpu for now give it back to me in a millisecond or two ok right so	a thread	171
on a particular processor on the lucky day you stand a good chance of it working right now let me explain why i have all those provisors so the first problem is that when a thread is running this code continuously checking the value of count what's it do it just keeps going keeps on checking so we're unnecessarily using cpu core to do that if another thread wants to run then either it will be running on a a second cpu core or it will be automatically given the cpu after a millisecond of time or so but for the whole millisecond we were just wasting cpu time whilst a first read just needlessly check the value of count so ideally we would want to give up the cpu at this point and sleep until the value of count changed but i said we are only allowed to use one mutex lock and one on local ok so at the very least i might put a p thread yielding here to say i'm done with the cpu for now give it back to me in a millisecond or two ok right so	thread	173
at least now it's only going to pull the value of count every millisecond this is still a pretty bad solution however and here's why that there's two reasons why the value of count may never change for this poor thread	thread	212
one of them is that code is written with the optimized	code	20
a second reason why this value might cheat never change is that if the cpu distri is the cash version of count it might never get updated by a different thread changing the memory version of counter or at least a version of count which is running which is held inside the cache of another cpu now on a modern intel x eighty six architecture chip you're very very lucky that these chips even if you have different physical chips on the motherboard so say you bought a couple of expensive zian processors here then actually there is a special bus between them that will automatically update cache information from one chip to another but that's not generally true on other architectures so how can we ensure that the value we read actually is the value which is shared between multiple processes and the answer is to	memory	173
a second reason why this value might cheat never change is that if the cpu distri is the cash version of count it might never get updated by a different thread changing the memory version of counter or at least a version of count which is running which is held inside the cache of another cpu now on a modern intel x eighty six architecture chip you're very very lucky that these chips even if you have different physical chips on the motherboard so say you bought a couple of expensive zian processors here then actually there is a special bus between them that will automatically update cache information from one chip to another but that's not generally true on other architectures so how can we ensure that the value we read actually is the value which is shared between multiple processes and the answer is to	thread	153
to actually in close this with a pthread mutex lock call so pthread_mutex_lock not only waits to acquire exclusively acquire a lock it actually operates as a memory fence to ensure that any dirty rights inside a cash have been flushed out to main memory	memory	158
to actually in close this with a pthread mutex lock call so pthread_mutex_lock not only waits to acquire exclusively acquire a lock it actually operates as a memory fence to ensure that any dirty rights inside a cash have been flushed out to main memory	thread	34
so it like i said this is a bad barrier we can do much better let's use peterek condition wait as a better implementation of a barrier alright so in the next video let's talk once more about how we could actually implement p thread mutex lock just by disabling interrupts on the cpu ok bye	thread	225
sorry simple http server and in both these cases you can specify a port number so if we wanted to comment that one out if we wanted to specify a port then i could specify a different part number here so let's choose for example if i try to do a low port number like port eighty it won't be very happy we got permission denied because i'm not root right now on this system and so port numbers less than a thousand and twenty four are restricted their privileged ports so you have to be an administrator to listen on those ports so let's not connect on let's not listen on port eighty let's listen on say port eighty eighty ok great and off it goes again so now again i can make a connection using my favorite web browser and off we go and see the contents again wait and you'll see this particular	system	365
web browser also prints out who's connecting to it and when and what resources they're requesting so another useful tool is called netcat let's have a look at that ok so	resources	69
or mac ports install on a linux system you might be doing things like a apt install you just need to find a quick google look up will find it anyway so let's look at netcat so netcat behaves a bit like cat except rather than concatenating from files we can send stuff to and from a network connection and by default all we need is a host name and port, and after that you can start to describe whether you want to make it to listen on a port whether you want to use tcp or udp etc etc etc so let's try this i will do netcat	system	32
ok so great we've connected i don't have the prompt anymore let me just send some garbage blah blah blah to the server that's listening on that port alright and you'll see that my little web server over here in pythons did not like my message here it says hey bad request and in response to my request it sent the following it said ok you i didn't like you you're as an error code of four hundred	the following	310
ok so great we've connected i don't have the prompt anymore let me just send some garbage blah blah blah to the server that's listening on that port alright and you'll see that my little web server over here in pythons did not like my message here it says hey bad request and in response to my request it sent the following it said ok you i didn't like you you're as an error code of four hundred	code	376
and the protocol that i'd like to use today is http	the protocol	4
have a blank line and there we go ok so this is what the server replied is there's right yeah yes i have that resource for you so it's ok so status code two hundred	code	148
tells me a little bit about itself the date and the contents it's giving back is just plain text that's a mime type and there's going to be twenty one bytes case so after the header's complete after we see this black line we expect to have twenty one more bytes we get twenty one bytes we know we got the whole file so there it is once upon a time	the header	171
tells me a little bit about itself the date and the contents it's giving back is just plain text that's a mime type and there's going to be twenty one bytes case so after the header's complete after we see this black line we expect to have twenty one more bytes we get twenty one bytes we know we got the whole file so there it is once upon a time	type	111
you'll see that great it's now given me a content type	type	50
subnet can sniff our packets ok so that's a problem they'll be able to sniff our password ok so telnet is barely used today there's a few cases of embedded hardware that might offer a very very simple telnet interface say just for debugging purposes but today telnet is not installed by default on most machines you have to install it yourself let me show you one still fine example use of telnet and that's not following that there is a telnet server running on the following ip address so let's try connecting to it ok right and off it goes and rather than giving your password prompt and asking me what i'd like to do instead it serves characters with a few delays in	the following	463
subnet can sniff our packets ok so that's a problem they'll be able to sniff our password ok so telnet is barely used today there's a few cases of embedded hardware that might offer a very very simple telnet interface say just for debugging purposes but today telnet is not installed by default on most machines you have to install it yourself let me show you one still fine example use of telnet and that's not following that there is a telnet server running on the following ip address so let's try connecting to it ok right and off it goes and rather than giving your password prompt and asking me what i'd like to do instead it serves characters with a few delays in	address	480
tcp will automatically assemble any packets will wait for lost packets to be re sent so we just have a nice stream a data stream ok so how do we set one up right so if we're setting up a client all i need to do is first of all i'm going to be lazy and call get address info this does a lot of heavy lifting for me to actually figure out the correct parameters i'm going to send into my next two calls so technically this is not formally required but it does make my life a lot easier the two things which are definitely required is of course i need a socket then a socket is there abstract object owned by the kernel which allows my code to talk to the outside world and to be able to talk to other sockets maybe on this machine but maybe not ok so once i've made a socket and for a client all i need to do is ask it to connect so let's	parameter	349
tcp will automatically assemble any packets will wait for lost packets to be re sent so we just have a nice stream a data stream ok so how do we set one up right so if we're setting up a client all i need to do is first of all i'm going to be lazy and call get address info this does a lot of heavy lifting for me to actually figure out the correct parameters i'm going to send into my next two calls so technically this is not formally required but it does make my life a lot easier the two things which are definitely required is of course i need a socket then a socket is there abstract object owned by the kernel which allows my code to talk to the outside world and to be able to talk to other sockets maybe on this machine but maybe not ok so once i've made a socket and for a client all i need to do is ask it to connect so let's	code	633
tcp will automatically assemble any packets will wait for lost packets to be re sent so we just have a nice stream a data stream ok so how do we set one up right so if we're setting up a client all i need to do is first of all i'm going to be lazy and call get address info this does a lot of heavy lifting for me to actually figure out the correct parameters i'm going to send into my next two calls so technically this is not formally required but it does make my life a lot easier the two things which are definitely required is of course i need a socket then a socket is there abstract object owned by the kernel which allows my code to talk to the outside world and to be able to talk to other sockets maybe on this machine but maybe not ok so once i've made a socket and for a client all i need to do is ask it to connect so let's	address	261
call connect here ok and again with the socket and connect calls the parameters i need for here are going to come from whatever get address info returns	parameter	69
call connect here ok and again with the socket and connect calls the parameters i need for here are going to come from whatever get address info returns	address	132
now we might see a little bit of traffic actual packets leaving machine my machine first of all when you call get address info because it's going to convert say a host name to an ip address and of course we'll see packets leaving when we call connect handshake is required between tcp client and server and so the moment you could connect we are going to send out a packet to that server to say hi please will you connect me let's do a handshake let's do our tcp handshake	address	114
right now one surprising thing about get address info is that it can return zero one or more results	address	41
the last entry is actually a linked list entry have my next pointer and that will be null so if you're writing kind of code very lazily or just wanted short simple demo code we can ignore the fact that it returns multiple entries but if you want to write robust code then realize that there may be more than one way to connect to the server for example perhaps the server offers an ip four address and an ip six address so you might try both you might try one after another or you might create a whole lot of threads and do it asynchronously and see which one actually kinda connect faster ok so let's	code	119
the last entry is actually a linked list entry have my next pointer and that will be null so if you're writing kind of code very lazily or just wanted short simple demo code we can ignore the fact that it returns multiple entries but if you want to write robust code then realize that there may be more than one way to connect to the server for example perhaps the server offers an ip four address and an ip six address so you might try both you might try one after another or you might create a whole lot of threads and do it asynchronously and see which one actually kinda connect faster ok so let's	thread	509
the last entry is actually a linked list entry have my next pointer and that will be null so if you're writing kind of code very lazily or just wanted short simple demo code we can ignore the fact that it returns multiple entries but if you want to write robust code then realize that there may be more than one way to connect to the server for example perhaps the server offers an ip four address and an ip six address so you might try both you might try one after another or you might create a whole lot of threads and do it asynchronously and see which one actually kinda connect faster ok so let's	address	390
the last entry is actually a linked list entry have my next pointer and that will be null so if you're writing kind of code very lazily or just wanted short simple demo code we can ignore the fact that it returns multiple entries but if you want to write robust code then realize that there may be more than one way to connect to the server for example perhaps the server offers an ip four address and an ip six address so you might try both you might try one after another or you might create a whole lot of threads and do it asynchronously and see which one actually kinda connect faster ok so let's	pointer	60
let's remind ourselves about what what the entries are ok so our flags is a hint to get address info as to what kind of connection we want do we want ip four ip six or some mixture do we wanted to do something else for us we have there address family so that's do we care about excuse me i{4 versus ip6 we have the socket type which is do we care about stream based socket or a datagram another packet light socket the protocol is usually left zero	type	322
let's remind ourselves about what what the entries are ok so our flags is a hint to get address info as to what kind of connection we want do we want ip four ip six or some mixture do we wanted to do something else for us we have there address family so that's do we care about excuse me i{4 versus ip6 we have the socket type which is do we care about stream based socket or a datagram another packet light socket the protocol is usually left zero	the protocol	415
let's remind ourselves about what what the entries are ok so our flags is a hint to get address info as to what kind of connection we want do we want ip four ip six or some mixture do we wanted to do something else for us we have there address family so that's do we care about excuse me i{4 versus ip6 we have the socket type which is do we care about stream based socket or a datagram another packet light socket the protocol is usually left zero	address	88
correctly set up socket address which is going to be great for calls to either connect or bind however c does not allow us to use inheritance so this strat here this socket address address is the simplest kind of socket address and	address	24
and for different kinds for example ip six we can actually have a different kind of a socket structure so that's why we need also to pass in how big is socket address	address	159
so that's why i will see a lot of casting to this very simple type of struct and also we need to pass just how big our real struct is just as a kind of a way to verify that we're reading the reading and writing bytes correctly in a valid struct	type	62
get address info is a complicated beast it's quite long but it itself doesn't because it calls many other calls including doing their dns look up to convert host name to an ip address it actually has a special way of returning errors rather than returning something we'd never know it actually returns a non zero value	address	4
ok there's something like gi a get address info	address	35
str error and that gives us a string ok so we'll be seeing that in the actual code that we write also realize that if it returns a non zero value then it means it never actually found us a way to connect and so that result pointer probably hasn't been changed so just assume that it doesn't point to anything valid right ok some other things you need to know so i mentioned ip four our thirty two bit addressing scheme that today if you were to pick up a random packet would discover it's an ipv4 based packet but we're trying to transition over to a more flexible addressing scheme which is much larger so today we would like to use ip six but is not fully supported by all routers yet so	code	78
str error and that gives us a string ok so we'll be seeing that in the actual code that we write also realize that if it returns a non zero value then it means it never actually found us a way to connect and so that result pointer probably hasn't been changed so just assume that it doesn't point to anything valid right ok some other things you need to know so i mentioned ip four our thirty two bit addressing scheme that today if you were to pick up a random packet would discover it's an ipv4 based packet but we're trying to transition over to a more flexible addressing scheme which is much larger so today we would like to use ip six but is not fully supported by all routers yet so	string	30
str error and that gives us a string ok so we'll be seeing that in the actual code that we write also realize that if it returns a non zero value then it means it never actually found us a way to connect and so that result pointer probably hasn't been changed so just assume that it doesn't point to anything valid right ok some other things you need to know so i mentioned ip four our thirty two bit addressing scheme that today if you were to pick up a random packet would discover it's an ipv4 based packet but we're trying to transition over to a more flexible addressing scheme which is much larger so today we would like to use ip six but is not fully supported by all routers yet so	address	401
str error and that gives us a string ok so we'll be seeing that in the actual code that we write also realize that if it returns a non zero value then it means it never actually found us a way to connect and so that result pointer probably hasn't been changed so just assume that it doesn't point to anything valid right ok some other things you need to know so i mentioned ip four our thirty two bit addressing scheme that today if you were to pick up a random packet would discover it's an ipv4 based packet but we're trying to transition over to a more flexible addressing scheme which is much larger so today we would like to use ip six but is not fully supported by all routers yet so	pointer	223
and i'll write it out like this version six is that it's addressing scheme uses one hundred and twenty eight bits for addressing so that should be big enough for everybody two to the one hundred and twenty eight is a lot better than just two to the thirty two which is all we have for ip four ok so in code how do we specify that i'd like an ip for ip six address answer just use this constant constant for the address family if you truly want just an ip four address then you can just say underscore on it for ip4 before ok that's colored out though because he let's try ip six	code	302
and i'll write it out like this version six is that it's addressing scheme uses one hundred and twenty eight bits for addressing so that should be big enough for everybody two to the one hundred and twenty eight is a lot better than just two to the thirty two which is all we have for ip four ok so in code how do we specify that i'd like an ip for ip six address answer just use this constant constant for the address family if you truly want just an ip four address then you can just say underscore on it for ip4 before ok that's colored out though because he let's try ip six	address	57
right now speak if ip six addresses here's one which is very useful it's your home address ok say here is your notice	address	26
that it behaves a lot like a hundred and twenty seven point zero point zero point one this is special ip six address that if you send packets to this address it's not leaving your machine it's defined to be your local machine right so let's put this together now let's actually set up a tcp client ok so	address	109
i'm going to just quickly review how you use get address info right and i want to	address	49
k just fix this this is actually not going to be a client this is going to be a server right ok and just remind ourselves how we do this so we're going to set up our hints object to say everything we like about this connection but what is important is to remember that there are many fields in that struct that we're not going to touch so let's initialize them all to zero here's one way to do that we can say right memset let's take the address of that struct it is and set them all to zero like and how many bytes would you like to set to zero ok so if we use the pointer here that would be incorrect we actually want the size of the whole struct so i could write struct address info	address	438
k just fix this this is actually not going to be a client this is going to be a server right ok and just remind ourselves how we do this so we're going to set up our hints object to say everything we like about this connection but what is important is to remember that there are many fields in that struct that we're not going to touch so let's initialize them all to zero here's one way to do that we can say right memset let's take the address of that struct it is and set them all to zero like and how many bytes would you like to set to zero ok so if we use the pointer here that would be incorrect we actually want the size of the whole struct so i could write struct address info	pointer	566
like that or i could just say size of hints so great i've set it all to zero now i can start initializing the fields that i actually care about right so we wanted ip four so inside here we can say address family inet by the way there is an inet any which means so if any means i'll take ip4 or ip6 i just want to serve i know care about the exact mechanism all of the ip addresses but today in this problem we care about inet four so let's use that and the socket type well i want stream based so	type	464
like that or i could just say size of hints so great i've set it all to zero now i can start initializing the fields that i actually care about right so we wanted ip four so inside here we can say address family inet by the way there is an inet any which means so if any means i'll take ip4 or ip6 i just want to serve i know care about the exact mechanism all of the ip addresses but today in this problem we care about inet four so let's use that and the socket type well i want stream based so	address	197
let's specify our correct socket type so that's sock stream if i wanted to use datagrams in other words kind of packet based connection then i would use socket dgram here	type	33
anyway so we've set up our request here now i need to go get address info so let's do that right we'll call get address info and just confusing i only have two results here so we will call this one two that's not very large let's do that like this get address there we go	address	61
right so what do we need to hear well first of all we need the ip address i can specify that as a string either as	string	98
right so what do we need to hear well first of all we need the ip address i can specify that as a string either as	address	66
an actual string like this or i can specify it as a host name so for example like illinois dot edu ok if i do this then there's probably going to be a packet leaving my machine in the next moment to say hey we need to figure out the ip address of this host name can you help me please	string	10
an actual string like this or i can specify it as a host name so for example like illinois dot edu ok if i do this then there's probably going to be a packet leaving my machine in the next moment to say hey we need to figure out the ip address of this host name can you help me please	address	236
now we need the hints so here's the address of my hints	address	36
and finally we need here's the address of that pointer please change this please and it will do so if it successfully manage is to take the information we gave and figure out a way to connect to that server ok so what would we do for each entry here ok so for each entry i would call that i want a socket and then i'm going to try to connect and i would use the results inside each of these result objects to that linked list to	address	31
and finally we need here's the address of that pointer please change this please and it will do so if it successfully manage is to take the information we gave and figure out a way to connect to that server ok so what would we do for each entry here ok so for each entry i would call that i want a socket and then i'm going to try to connect and i would use the results inside each of these result objects to that linked list to	pointer	47
excuse me do make use of error messages when you get them and do remember to zero out everything inside the hints object otherwise get address info will be scratching his head going i don't understand what you're asking for ok because you're giving me information which just happened to be on the stack and you never set to zero so with that i think it's time for part two in another video bye	address	135
hi ok so here's a little quiz i'm using f printf today and i'm going to print out four things so what do you think is going to produce i'm sending cs 241 &nbsp;system programming and new line but you might notice i'm sending it to two different places stderr stdout stderr and stdout ok so are you ready have you made your guess to what we're going to see let's try it out	printf	42
hi ok so here's a little quiz i'm using f printf today and i'm going to print out four things so what do you think is going to produce i'm sending cs 241 &nbsp;system programming and new line but you might notice i'm sending it to two different places stderr stdout stderr and stdout ok so are you ready have you made your guess to what we're going to see let's try it out	system	160
ok so i've got questions seven ready to go is the same code again i've just wrapped it with standard io in a main method so let's run this let's compile it hey questions seven and i'll produce some output they call it questions seven so now i've got a question seven exists so let me run it and what do you think is going to say	code	55
ok it says hello cs two forty one programming system wait what happened why did my lines come out in a different order ok so to answer this question we need to understand a little bit about the buffering that the c library gives us the c library supports buffering in order to ensure good performance making a system call is a lot more expensive than just a regular function call so rather than just sending a few bytes at a time let's only make that system call when when we want to ok so what's the default behavior of the c library here ok right so the default behavior is actually kind of reasonable when we kind of think about it first of all if you're sending stuff to standard error is probably a good idea that we see this as soon as possible we if our programs about crash or this or there's any kind of problem let's not keep that information hidden inside our process instead let's write it as soon as possible so by default standard error	a system call	308
ok it says hello cs two forty one programming system wait what happened why did my lines come out in a different order ok so to answer this question we need to understand a little bit about the buffering that the c library gives us the c library supports buffering in order to ensure good performance making a system call is a lot more expensive than just a regular function call so rather than just sending a few bytes at a time let's only make that system call when when we want to ok so what's the default behavior of the c library here ok right so the default behavior is actually kind of reasonable when we kind of think about it first of all if you're sending stuff to standard error is probably a good idea that we see this as soon as possible we if our programs about crash or this or there's any kind of problem let's not keep that information hidden inside our process instead let's write it as soon as possible so by default standard error	system	46
but we also saw their kind of hello early as well while i was that well the c library when the output appears to be going to the terminal will flush that the moment that it sees a new line the thinking here and if you think about it it's pretty reasonable is if you send a new line you probably now might be waiting for input from the user perhaps you still said to the user hey please enter your password or you sure you really want to do this so the default behavior is prettify if you're sending me a new line i'm going to take that all that content you've given me so far and then call right in other words we're going to flush the buffer we're going to now right out what you've given me anything else that i've stored in my buffer so that behavior is the default behavior like i said if you're sending stuff to the output of a terminal let's change things up let's	a terminal	831
ok with that let's try sending this output not to the toggle i send it someone else ok so we can do that by running our program and sending the standard out in standard error to different places for example i can send a stamped out to a file so i can call this hello dot text and i can send the up the error output to somewhere else so for example i could send the error to stream number two which we know is now the error i will look i can send that to say error so let me run that and now what if i got after it runs i've got my output in try again not there i've got my output inside hello dot text so there we see hello and system and i've got the stuff we sent to the standard error in the other file so if we look at error will see we've got cs two forty one and programming	system	628
right so the last kind of quick comment on all of this code is when else when else would we expect up rc lie beat a flush things out so the answer here is if we exceed the size of the buffer and typically it's going to be about four thousand book bites or so so at that point we will flush the buffer and everything else the other answer is when we're closing a filestream so if we gracefully shutting down a file object so for example we've called f close on it or wear exiting gracefully our program then will send out everything that we've currently got inside the memory the c library flushed out if you crash your program then this policy likely never has a chance to actually send those bites so will never actually see that output ok alright in the next video let's talk about how we can use aprintf correctly and incorrectly by	memory	568
right so the last kind of quick comment on all of this code is when else when else would we expect up rc lie beat a flush things out so the answer here is if we exceed the size of the buffer and typically it's going to be about four thousand book bites or so so at that point we will flush the buffer and everything else the other answer is when we're closing a filestream so if we gracefully shutting down a file object so for example we've called f close on it or wear exiting gracefully our program then will send out everything that we've currently got inside the memory the c library flushed out if you crash your program then this policy likely never has a chance to actually send those bites so will never actually see that output ok alright in the next video let's talk about how we can use aprintf correctly and incorrectly by	code	55
right so the last kind of quick comment on all of this code is when else when else would we expect up rc lie beat a flush things out so the answer here is if we exceed the size of the buffer and typically it's going to be about four thousand book bites or so so at that point we will flush the buffer and everything else the other answer is when we're closing a filestream so if we gracefully shutting down a file object so for example we've called f close on it or wear exiting gracefully our program then will send out everything that we've currently got inside the memory the c library flushed out if you crash your program then this policy likely never has a chance to actually send those bites so will never actually see that output ok alright in the next video let's talk about how we can use aprintf correctly and incorrectly by	printf	800
we've got a case where my files use ten direct blocks and we have our dis block numbers	block	47
use thirty two bit numbers ok so the maximum number of disk blocks	block	60
which are addressable two to the thirty two and if	address	10
each disk block is four kb let's just work out how bigger disk we can actually use before we run out of addressable space here so what is two to the thirty two minutes at home ok so i can think of that as two to the ten times two to the ten times two to the ten times two to the two	block	10
each disk block is four kb let's just work out how bigger disk we can actually use before we run out of addressable space here so what is two to the thirty two minutes at home ok so i can think of that as two to the ten times two to the ten times two to the ten times two to the two	address	104
terabytes and so this scheme allows me to address up to sixteen terabytes worth of memory so today we're right about limit that i can already easily by a say twelve terabyte disk	memory	83
terabytes and so this scheme allows me to address up to sixteen terabytes worth of memory so today we're right about limit that i can already easily by a say twelve terabyte disk	address	42
right so in practice then e x two actually provides actually has is limit based on choice of saying dis blocks must be represented using just thirty two bits and each disk block is exactly four kb	block	104
scheme here of actually how we reference a information about files and look at how many blocks and indirect blocks that we can reference here so for how many indirect blocks can be re reference we work this out by saying	block	88
so therefore i can have a thousand twenty four indirect blocks	block	56
because that's the size of my table that can fit inside one dis block	block	64
right so the next question is how large the file in lots of data if the indirect block index is half full	block	81
ten direct blocks k so	block	11
plus five hundred and twelve indirect blocks so in other words we have five hundred twenty two blocks is the size of my file	block	38
gay right and let's see what is question three what is the total number blocks used	block	72
in this example then we have five hundred and twenty two blocks worth of data but the actual storage space on the disk is going to be five hundred and twenty three y one extra because we have this overhead of actually storing the table and notice i didn't bother to consider the i node as as extra block we've already to set aside some space for the i node entries when we format it the disk	block	57
the largest file that we could have here where is going to be let's see forty kilobytes for the direct blocks and then we had four megabytes for the indirect blocks and then we had four gigabytes for the double indirect blocks and then four terabytes for the triple indirect blocks so providing you don't need to make files much greater than four terabytes this scheme will work now of course in practice today were actually now i really do want to make files greater than four terabytes plus four gigabytes plus four megabytes plus forty kb so in practice today on a modern file system we're not going to use e x t two	block	103
the largest file that we could have here where is going to be let's see forty kilobytes for the direct blocks and then we had four megabytes for the indirect blocks and then we had four gigabytes for the double indirect blocks and then four terabytes for the triple indirect blocks so providing you don't need to make files much greater than four terabytes this scheme will work now of course in practice today were actually now i really do want to make files greater than four terabytes plus four gigabytes plus four megabytes plus forty kb so in practice today on a modern file system we're not going to use e x t two	system	580
hello great welcome to the next lecture so off we go on a lecture thirty one we're going to keep looking at files a little bit and also talk about how we can actually run a virtual machine today so i think that's pretty cool and exciting and also as part of files were going to talk about quick introduction first look at memory mapped files as well where we used a virtual memory machinery that we have to actually directly access files as part of memory ok so first of all let's talk about umask so i made hints about umask at the end of the previous lecture that this is something that every process has and umask comes into play whenever we make a new file so if you're just changing files you're not going to need to umask but the idea of the umask is that by default we want to remove some permissions that otherwise would be given some read write access access permissions for say others in our group or other people on the system	memory	322
hello great welcome to the next lecture so off we go on a lecture thirty one we're going to keep looking at files a little bit and also talk about how we can actually run a virtual machine today so i think that's pretty cool and exciting and also as part of files were going to talk about quick introduction first look at memory mapped files as well where we used a virtual memory machinery that we have to actually directly access files as part of memory ok so first of all let's talk about umask so i made hints about umask at the end of the previous lecture that this is something that every process has and umask comes into play whenever we make a new file so if you're just changing files you're not going to need to umask but the idea of the umask is that by default we want to remove some permissions that otherwise would be given some read write access access permissions for say others in our group or other people on the system	system	931
so you might imagine that you could write a lot of code that says ok create a file and then change its mask d'espies change its mode bits to be something else	code	51
but there's an option to say you know what i'm telling you ls actually i want to care about the actual directory itself ok so just tell me about t three directly so here it is as you can see no we can go into this directory so you mask is really useful when you want to run script and you want to ensure that anything it does is isn't publicly world readable on the system and then it's going to keep inheriting that until the day we change it back so let's put it back as the default here so you mask we had a default of just twenty two k right notice that uh that it affected creation of nude files and new directory 's so if you had by default let's make a umask of seven seven seven ok so now let's make a directory	system	366
hi ok so we both through five different examples of where we sought deadlock or not no deadlock and fundamentally it was the request sequence that determines whether we actually ran into deadlock or not so what can we do to prevent deadlock and one algorithm that our system could use is something called the bankers algorithm so if the operating system knew in advance what resources particular process wanted so if we knew an example example for example the process one is going to need let's say eight aa whatever azar and say three bees whatever bees are but no season dies	resources	375
hi ok so we both through five different examples of where we sought deadlock or not no deadlock and fundamentally it was the request sequence that determines whether we actually ran into deadlock or not so what can we do to prevent deadlock and one algorithm that our system could use is something called the bankers algorithm so if the operating system knew in advance what resources particular process wanted so if we knew an example example for example the process one is going to need let's say eight aa whatever azar and say three bees whatever bees are but no season dies	system	268
then the bank side my bankers algorithm can ensure that the bank never goes into an overdraft right and never we never allow our process is to continue so that so that there's a possibility that that i would resource i would exhaust the resources for certain type so for example if i have one hundred days and i know that my process two and my process three and so on only ever going to	type	259
then the bank side my bankers algorithm can ensure that the bank never goes into an overdraft right and never we never allow our process is to continue so that so that there's a possibility that that i would resource i would exhaust the resources for certain type so for example if i have one hundred days and i know that my process two and my process three and so on only ever going to	resources	237
ten then the moment that p three comes along and request these if i grant that request so if i've given all of my resources of type a to process three then we can immediately reason that any future requests by these other processes will	type	127
ten then the moment that p three comes along and request these if i grant that request so if i've given all of my resources of type a to process three then we can immediately reason that any future requests by these other processes will	resources	114
will potentially get stuck and potentially we can run into deadlock so the bankers algorithm which we're not going to go into a detailed today is this idea that i can keep if i know in advance and that is the crux but if i know in advance the maximum number of requests for each resource type then i can ensure that the sequence of that we allow our process is to be given exclusive access to our resource types we can ensure that will never going to have an overdraft and we can never therefore go into a deadlock alright so this is an example of kind of deadlock avoidance and you can read about bankers algorithm on wikipedia etc but i instead i want to spend a little bit i'm talking about the linux and windows strategy for avoiding deadlock	type	288
ok so first of all some theory and i'll ask you to guess which guess which what lennox in windows uses ok so here's an idea we could actually think about our process is in some kind of conceptual space so let me just think about say two processes about how they advanced through this space so my process runs through different states so for example it might be that it requires a mutex one and then later it acquires mutex too ok then it does some things and then it releases mutex server two and one ok so over here right but you can see the idea that my first process is going to slowly advance along my access here and i could do the same thing for another process i could talk about the state of my second process and	a mutex	378
the sequence of operations in my system as a whole represents a little walk through this state of spaces where the actual walk depends upon the sequence in which my process one or processed to acquire the mutex locks or some other exclusive access to some other resource ok so look at this my process one is acquired	system	33
so we could actually think about the state that positions in this state space of possible states my two processes which actually correspond to when things get stuck in other words when do they correspond with circle cycles in my weight for graph and what we would discover is that they all interior points on this particular graph right so if example process one didn't do anything but process two acquired all of the resources and then release them and then process want acquired all of the resources it needed and then release them we've gone around the edges where says if i interleaved my two process process the two processor or thread operations then i'm trying to take a more dangerous path through the middle of this and some of these points i'm going to get stuck at i cannot continue ok so what does the lyrics do does it attempt to kind of look at what states in this state space	thread	634
so we could actually think about the state that positions in this state space of possible states my two processes which actually correspond to when things get stuck in other words when do they correspond with circle cycles in my weight for graph and what we would discover is that they all interior points on this particular graph right so if example process one didn't do anything but process two acquired all of the resources and then release them and then process want acquired all of the resources it needed and then release them we've gone around the edges where says if i interleaved my two process process the two processor or thread operations then i'm trying to take a more dangerous path through the middle of this and some of these points i'm going to get stuck at i cannot continue ok so what does the lyrics do does it attempt to kind of look at what states in this state space	resources	418
ok and finally the head stuck in the ground yes it's called the ostrich algorithm which is that uh if it's look scary quick stick your head in the sand and don't look so the looks of windows strategy for deadlock avoidance is called let's just hope for the best which the ostrich algorithm is basically it's let's pretend it's not our problem their system is going to let you write code that can cause deadlock it's up to you the system programmer to make sure that deadlock cannot	code	382
ok and finally the head stuck in the ground yes it's called the ostrich algorithm which is that uh if it's look scary quick stick your head in the sand and don't look so the looks of windows strategy for deadlock avoidance is called let's just hope for the best which the ostrich algorithm is basically it's let's pretend it's not our problem their system is going to let you write code that can cause deadlock it's up to you the system programmer to make sure that deadlock cannot	system	349
occur so the system does not prevent you from causing deadlock right so good luck you're on your own on this one and that's why it's important to make sure that we don't enter possible deadlock which brings us to our final little point which is how can we possibly do this ok so here's the secret source here's the most important part of this lecture	system	13
let's make sure that our all of our threads or processes always require resources in the same order so will have a meeting with all of our programmers and say look here's the things which you are saying a quiet calling peter mutex lock on abc and d we just need you to always acquire them in agreed apon order so for	thread	36
let's make sure that our all of our threads or processes always require resources in the same order so will have a meeting with all of our programmers and say look here's the things which you are saying a quiet calling peter mutex lock on abc and d we just need you to always acquire them in agreed apon order so for	resources	72
example if you're going to acquire a lock in order to access a then get this lot first before getting be and if you going to acquire a lock be then acquire lock be before accessing see and then if you get the idea so we need to rank order or resources so another was given some kind of simple mapping to integers here so on and so on and so on and so on and if you acquire something when exclusive access if we always agree to acquire them in small integer to large integer order then deadlock is impossible right to see why i'm going to sketch this out not as a formal proof but i want you to see that if i have acquired something so here's my first process and i've got	resources	242
acquire in the same order i can never generate the case where i've got a process to which has now acquired this but then also goes backwards and create awaiting condition on an earlier resource all of my lines which correspond to it waiting for resources must be to the right i cannot generate that cycle in the wakeful graph which pictorially always kind of looks like a bow tie where i've ended up with weights on resources which are both before and after in my resource order so all of my weights i'm going to be to the right and therefore is always possible for the earlier resources to be complete my process is complete so therefore i cannot set up a chain or between my process is where i end up say with process three waiting for process one and process one waiting for process doing ok so that is the secret source it's always make sure that we get resources in the same order so i want you to think about how you would implement that suppose for example you had a set of integers say they might be under a one of a link list and each one of those integers has a mutex lock so m one m two m three m four m five etc how can i make sure that if i need to lock let's say two or three mutex locks in order to modify those integers how can i ensure that all of my code always locks the necessary integers in the same order case how would you do that and answers that will be in a future lecture video bye for now	code	1268
acquire in the same order i can never generate the case where i've got a process to which has now acquired this but then also goes backwards and create awaiting condition on an earlier resource all of my lines which correspond to it waiting for resources must be to the right i cannot generate that cycle in the wakeful graph which pictorially always kind of looks like a bow tie where i've ended up with weights on resources which are both before and after in my resource order so all of my weights i'm going to be to the right and therefore is always possible for the earlier resources to be complete my process is complete so therefore i cannot set up a chain or between my process is where i end up say with process three waiting for process one and process one waiting for process doing ok so that is the secret source it's always make sure that we get resources in the same order so i want you to think about how you would implement that suppose for example you had a set of integers say they might be under a one of a link list and each one of those integers has a mutex lock so m one m two m three m four m five etc how can i make sure that if i need to lock let's say two or three mutex locks in order to modify those integers how can i ensure that all of my code always locks the necessary integers in the same order case how would you do that and answers that will be in a future lecture video bye for now	a mutex	1070
acquire in the same order i can never generate the case where i've got a process to which has now acquired this but then also goes backwards and create awaiting condition on an earlier resource all of my lines which correspond to it waiting for resources must be to the right i cannot generate that cycle in the wakeful graph which pictorially always kind of looks like a bow tie where i've ended up with weights on resources which are both before and after in my resource order so all of my weights i'm going to be to the right and therefore is always possible for the earlier resources to be complete my process is complete so therefore i cannot set up a chain or between my process is where i end up say with process three waiting for process one and process one waiting for process doing ok so that is the secret source it's always make sure that we get resources in the same order so i want you to think about how you would implement that suppose for example you had a set of integers say they might be under a one of a link list and each one of those integers has a mutex lock so m one m two m three m four m five etc how can i make sure that if i need to lock let's say two or three mutex locks in order to modify those integers how can i ensure that all of my code always locks the necessary integers in the same order case how would you do that and answers that will be in a future lecture video bye for now	a process	71
acquire in the same order i can never generate the case where i've got a process to which has now acquired this but then also goes backwards and create awaiting condition on an earlier resource all of my lines which correspond to it waiting for resources must be to the right i cannot generate that cycle in the wakeful graph which pictorially always kind of looks like a bow tie where i've ended up with weights on resources which are both before and after in my resource order so all of my weights i'm going to be to the right and therefore is always possible for the earlier resources to be complete my process is complete so therefore i cannot set up a chain or between my process is where i end up say with process three waiting for process one and process one waiting for process doing ok so that is the secret source it's always make sure that we get resources in the same order so i want you to think about how you would implement that suppose for example you had a set of integers say they might be under a one of a link list and each one of those integers has a mutex lock so m one m two m three m four m five etc how can i make sure that if i need to lock let's say two or three mutex locks in order to modify those integers how can i ensure that all of my code always locks the necessary integers in the same order case how would you do that and answers that will be in a future lecture video bye for now	resources	245
and here's my tcp packet and i'm going to set the synchronization bit here's my synchronization number here's my ip address up here inside the ip part of the header here's my port number that i'm coming from here's the port number that i want to connect to please to meet you	the header	154
and here's my tcp packet and i'm going to set the synchronization bit here's my synchronization number here's my ip address up here inside the ip part of the header here's my port number that i'm coming from here's the port number that i want to connect to please to meet you	address	116
and for each one of these connections connection attempts the kernel has to put aside some memory because it needs to remember the synchronization number in the port and it has to get it ready to be a real connection	memory	91
so we can drown out this poor server we can run it out with these fake connection attempts making it harder for real connections to actually get a chance to talk to the talk to the server so this is called sin flooding and it was a very kind of early examples of a tcp level type attack on a server today there are mechanisms for a server can implement to prevent this and one of them is in the bag not is not to actually commit any significant resources when the syn packet first arrives so you say how can we actually remember the synchronization number well the trick that a server can play is to actually embed the synchronize your synchronization number client synchronization number inside its own acknowledgement synchronization number	type	275
so we can drown out this poor server we can run it out with these fake connection attempts making it harder for real connections to actually get a chance to talk to the talk to the server so this is called sin flooding and it was a very kind of early examples of a tcp level type attack on a server today there are mechanisms for a server can implement to prevent this and one of them is in the bag not is not to actually commit any significant resources when the syn packet first arrives so you say how can we actually remember the synchronization number well the trick that a server can play is to actually embed the synchronize your synchronization number client synchronization number inside its own acknowledgement synchronization number	resources	445
and so basically it's like yes ok i've got your synchronization numbering encode it in some way inside my acknowledgement number inside my synchronization but i'm not going to tell you how that encoding works so that if you send me another packet in the future the third packet of part of that handshake that i can recover my original synchronization number and only then will actually start to treat you as a real connection attempt so today synchronization flood still occur but less effective as they used to be a there's an attempt at a denial of service so let's one up the game let's think about how we can create larger problems for a server and the next kind of attempts that we saw start starting five years ago which really took off with the distributed denial of service so now let's start making real connections	code	76
to subvert the protocol now we're going to actually make complete connections but we're just simply going to try to flood the server similar get exhausted by sending gigabytes of information per second gigabytes of connections real connections per second in order to do this then as a malicious actor maybe i've taken over a few core machines on the internet with big fat	the protocol	11
pipes that i can use to send lots and lots of packets to my target my target for example might be github it might be microsoft so it might be some hospital that i want to extort money form for example ok so our attack here is just based on kind of pure bandwidth concerns that i'm going to try to simply exhaust the resources of your machine by sending it lots of real socket requests	resources	316
so today protecting this is somewhat harder how do we can't protect against this well well what we've seen now is the rise of cloud based resources and scalable resources where first of all i don't necessarily have a single server so that means you can connect to say microsoft or office three sixty five and the same url can actually correspond to multiple machines so now we can simply scale up a lot of very quickly scale up a lot of machine resources so that i can still actually connect to regular traffic but there's more we can do today which is today we put intelligent intelligent firewalls and network devices in front of our our precious databases and web servers and we can try to identify in real time these fake connections versus real connections and so we only provide a limited amount of resources for these kind of fake connection attempts	resources	138
and protect our valuable but slightly slower resources like a web 's real web server or real database from these from all these kind of smaller packets which don't necessarily it could've do much but don't ask her bona fide requests for server ok so that was kind of distributed in other services where we have many machines on the internet trying to attack our machines and today that can produce kind of gigabytes of bandwidth or hundreds of gigabytes of bandwidth connections because attackers will take over many devices perhaps you've heard of bot nets for example so i could use every machine or my botnet to attack a particular service which leads us now too	resources	45
we actually we can do a lot more with this and it's much harder to discern beg you ate the malicious traffic or the fake traffic versus the actual real traffic and so here's the plan is let's say that you put a web server what i can do is if my bot net if if i'm a malicious attacker and i own millions of machines i can make those requests from those millions of machines look like bona fide traffic i can make it look like real requests from real ip addresses that actually request your homepage for example or request your login page or attempt to log in for real so now it's much harder for a company sophisticated company to identify the fake traffic i can no longer say oh yes well if it's just as simple kind of packet i can write a simple regular expression which discuss the wheat from the chaff which discards the fake attempts versus the real attempts because now someone is sophisticated attacker has now actually understood say my website or how my back end for my android on my phone service works and now i can't just simply discard those connection attempts because if i do then i'm discarding real attempts so this these kinds of high level attacks on my service are much harder to defend against and why are they called internet of things do not have service simply because today	address	452
such as wifi enabled light bulbs that connects to the internet and have some kind of ability to run arbitrary code because they are so pure so badly configured so they're vulnerable to simple attacks for example maybe the admin interface still has a password like admin or maybe they are running extremely out of date web server which is got known vulnerabilities or maybe they have some other well known a backdoor into them which allows an attacker to take over these devices but there's not just one or two devices as a malicious malicious actor you can find a millions of these devices or even billions of these devices soon so now i can create very large attacks from a very large swaths of the entire ip address and then send all those packets to a single enterprise in attempt to kind of take it down and possibly extort some service or extort money forward from a company so this is device of the internet of things based in out of service it's extremely hard to protect against	code	110
such as wifi enabled light bulbs that connects to the internet and have some kind of ability to run arbitrary code because they are so pure so badly configured so they're vulnerable to simple attacks for example maybe the admin interface still has a password like admin or maybe they are running extremely out of date web server which is got known vulnerabilities or maybe they have some other well known a backdoor into them which allows an attacker to take over these devices but there's not just one or two devices as a malicious malicious actor you can find a millions of these devices or even billions of these devices soon so now i can create very large attacks from a very large swaths of the entire ip address and then send all those packets to a single enterprise in attempt to kind of take it down and possibly extort some service or extort money forward from a company so this is device of the internet of things based in out of service it's extremely hard to protect against	address	710
the day the best hope of a company is to have a cloud based system and to attempt in real time to identify when they're under attack so as you can see we're continuing to see arise in these levels of attacks are hard to say we're going to see tomorrow and if you're writing code for internet of things i employ you to write create devices which are more secure because tomorrow these devices could literally bring down our our internet at least for a short period of time until we discover how to	code	274
the day the best hope of a company is to have a cloud based system and to attempt in real time to identify when they're under attack so as you can see we're continuing to see arise in these levels of attacks are hard to say we're going to see tomorrow and if you're writing code for internet of things i employ you to write create devices which are more secure because tomorrow these devices could literally bring down our our internet at least for a short period of time until we discover how to	system	60
will have a tcp ip four so we want address family inet so in other words that's going to be an ip four socket we want to use tcp so we'll have a stream based protocol please right there we go so that's going to tcp and	address	35
so let's do some error checking remember that if getaddrinfo fails it will use its own little helper function to print an error but i'm also going to check the return values of all of my other network code as well and if something goes wrong with one if these calls returns negative one i'm going to just quit so my quit function is very simple it just prints out the errno message together with my little message of what happened and they just exits so that's that's quick very simple program there simple simple function right so what do we do ok right so let's call socket	code	201
will use the result this time to say there's my family so expect that to be afinet is the only one we wanted will have the socket type in there and will have a protocol which is actually usually just the value o for our regular tcp ip type sockets right ok so we've made ourselves a socket will check to see if it worked if we got a valid file descriptor now let's bind that to an actual network port ok so this is when we actually start saying right i want to use a particular port ok so we've done that ok now it turns out that if you hadn't actually specified an explicit port in other words if you just ask for zero it would be nice to know which port it was actually bound to so we can do that the surprising thing is rather than being called get sock port it is actually getsockname() "	a protocol	158
will use the result this time to say there's my family so expect that to be afinet is the only one we wanted will have the socket type in there and will have a protocol which is actually usually just the value o for our regular tcp ip type sockets right ok so we've made ourselves a socket will check to see if it worked if we got a valid file descriptor now let's bind that to an actual network port ok so this is when we actually start saying right i want to use a particular port ok so we've done that ok now it turns out that if you hadn't actually specified an explicit port in other words if you just ask for zero it would be nice to know which port it was actually bound to so we can do that the surprising thing is rather than being called get sock port it is actually getsockname() "	type	130
that way this is not on the test but it is kind of useful code to know about getting information about your socket so here's what we'll do we have this little structure here called sockaddr_in called sin and because there could be different kinds of sockets you have to pass through these kinds of functions not only an address of your struct but how big it is as well so that's a little bit of code here just to say say ok i want to know the size of this	code	58
that way this is not on the test but it is kind of useful code to know about getting information about your socket so here's what we'll do we have this little structure here called sockaddr_in called sin and because there could be different kinds of sockets you have to pass through these kinds of functions not only an address of your struct but how big it is as well so that's a little bit of code here just to say say ok i want to know the size of this	address	320
and while the amusingly you pass in the address of this as well	address	40
cast there right so out of this one let's print out the actual port number ok which should be the same as the port number that we asked for which is a thousand twenty four the rest of the code doesn't do much will say that we are prepared to accept a backlog of up to one hundred one hundred connections from a hundred clients in other words if i don't call accept at all the first hundred people are lucky but after that one hundred and first person gets turned away ok so here's my little service loop here we're going to do is when someone connects great will have now a client file descriptor we'll print it out and we could immediately tell this socket hey by the way we refuse to read anymore i'm just not listening anymore to any bytes that are going to arrive on this socket that will actually also give a hint to the client as well to say hey stop sending anymore bytes then will say hi we'll write three bytes which is h and i and a new line to the client and because we don't want to say anymore let's shut down now that client file descriptor for writing as well and then finally because we have done we can actually close it we can release the file descriptor so we can reuse it ok and then we'll go round again so let's compile this and run it ok so off we go like will run it and	code	188
gave me a file descriptor and it went down the loop and decided to block again ok if i use instead of netcat if i use telnet	the loop	43
gave me a file descriptor and it went down the loop and decided to block again ok if i use instead of netcat if i use telnet	block	67
uh annoying in the current code where we actually explicitly put in thousand and twenty four but even bigger problem when we actually say you know what just find me any old freeport because i'm doing some development and i don't want to specify the port right now just find me a free one ok so now we have a bigger problem that if i run it this port number is completely wrong so if i try to connect it doesn't work right so what did we forget what did we miss what we missed is that this low level c structure that we are getting information about the socket embeds it's information using the network representation of port numbers and ip addresses and all that good stuff so we can't just simply print out the port number like we're attempting to do here the bits that are inside this field of this c structure are not in the correct order to represent the right integer we need to convert it how do you do that we need to say ok i want to go from network to host and ports are equivalent to sixteen bits of the words we want this short ok and let's convert that right and now it should give us the correct result so let's try that ok so we will recompile this run it again and ok now i've got a port number let's see if we believe it ok so we'll get back over here and will try to get to it and congratulations now it works now it's giving us the correct port number ok so that's kind of the big gotcha that realize that that these low level c structures used port numbers etc in the network byte order and using network representation which may or may not be different from the way that your cpu represents integers ok in this case we wanted to go from network to host hence ntohs if you were setting up the c structures explicitly because you didn't want to get address info	code	27
uh annoying in the current code where we actually explicitly put in thousand and twenty four but even bigger problem when we actually say you know what just find me any old freeport because i'm doing some development and i don't want to specify the port right now just find me a free one ok so now we have a bigger problem that if i run it this port number is completely wrong so if i try to connect it doesn't work right so what did we forget what did we miss what we missed is that this low level c structure that we are getting information about the socket embeds it's information using the network representation of port numbers and ip addresses and all that good stuff so we can't just simply print out the port number like we're attempting to do here the bits that are inside this field of this c structure are not in the correct order to represent the right integer we need to convert it how do you do that we need to say ok i want to go from network to host and ports are equivalent to sixteen bits of the words we want this short ok and let's convert that right and now it should give us the correct result so let's try that ok so we will recompile this run it again and ok now i've got a port number let's see if we believe it ok so we'll get back over here and will try to get to it and congratulations now it works now it's giving us the correct port number ok so that's kind of the big gotcha that realize that that these low level c structures used port numbers etc in the network byte order and using network representation which may or may not be different from the way that your cpu represents integers ok in this case we wanted to go from network to host hence ntohs if you were setting up the c structures explicitly because you didn't want to get address info	address	640
so i can now already if i can get there in time yeah connect right notice that i successfully connect to the host that's because we'd already called listen and so the kernel was willing to be the welcoming host in a restaurant that kind of welcomes you there right and then right please to meet you and shakes your hand right it does the protocol handshake so that's so that's listen in action we could have up to a hundred people arrived to our restaurant before we call it call accept and now if i keep connecting you'll notice on the other side i'm starting to use up my file descriptors here let's connect again right and eventually i'm accept is going to fail because there's no spare file descriptors left my process has a limited number of file descriptors that it's able to use ok right and that's the security idea because we don't want one process using up all of the kernel resources	the protocol	334
so i can now already if i can get there in time yeah connect right notice that i successfully connect to the host that's because we'd already called listen and so the kernel was willing to be the welcoming host in a restaurant that kind of welcomes you there right and then right please to meet you and shakes your hand right it does the protocol handshake so that's so that's listen in action we could have up to a hundred people arrived to our restaurant before we call it call accept and now if i keep connecting you'll notice on the other side i'm starting to use up my file descriptors here let's connect again right and eventually i'm accept is going to fail because there's no spare file descriptors left my process has a limited number of file descriptors that it's able to use ok right and that's the security idea because we don't want one process using up all of the kernel resources	resources	885
will sign off here because now we're going to start talking about files and file systems and how to represent files on a disk right bye for now	system	81
hi what do you think happens if we asked to print out the address of a function or even libra call ok so that's what this question six is asking us to do the percent p says hey treat the following thing as an address and print it out in hexadecimal for me so we're going to pass in maine and malik and surprisingly yes this is valid so stop thinking about our functions as pieces of algorithms and start thinking about them as something that cpu can execute in other words it's perfectly reasonable to say hey i've got a function over here what's this address and so notice there's no parentheses here and if we do this we can actually protect those addresses so let's actually try this i've got the carried over here find it we've got this malloc address so if i compile and run this you'll see that the address of maine is some smallish value versus aggressive malloc is much higher that kind of shows us how process space is organized into different areas we actually get to find the library calls separate from the rest of our code that we've written	the following	183
hi what do you think happens if we asked to print out the address of a function or even libra call ok so that's what this question six is asking us to do the percent p says hey treat the following thing as an address and print it out in hexadecimal for me so we're going to pass in maine and malik and surprisingly yes this is valid so stop thinking about our functions as pieces of algorithms and start thinking about them as something that cpu can execute in other words it's perfectly reasonable to say hey i've got a function over here what's this address and so notice there's no parentheses here and if we do this we can actually protect those addresses so let's actually try this i've got the carried over here find it we've got this malloc address so if i compile and run this you'll see that the address of maine is some smallish value versus aggressive malloc is much higher that kind of shows us how process space is organized into different areas we actually get to find the library calls separate from the rest of our code that we've written	code	1031
hi what do you think happens if we asked to print out the address of a function or even libra call ok so that's what this question six is asking us to do the percent p says hey treat the following thing as an address and print it out in hexadecimal for me so we're going to pass in maine and malik and surprisingly yes this is valid so stop thinking about our functions as pieces of algorithms and start thinking about them as something that cpu can execute in other words it's perfectly reasonable to say hey i've got a function over here what's this address and so notice there's no parentheses here and if we do this we can actually protect those addresses so let's actually try this i've got the carried over here find it we've got this malloc address so if i compile and run this you'll see that the address of maine is some smallish value versus aggressive malloc is much higher that kind of shows us how process space is organized into different areas we actually get to find the library calls separate from the rest of our code that we've written	address	58
ok so yeah that's a kind of perfectly valid piece of code right so in our next video we're going to figure out how we can actually find out the number of items in a integer array but using point arithmetic and see you then bye	code	53
library the patriots and they come with four important course here they are initiate lock unlock and destroy right so remember that actually we can skip writing p thread mutex initiative we initialize are available to magic value first alright so my first question for you is which one of these calls will block	block	306
library the patriots and they come with four important course here they are initiate lock unlock and destroy right so remember that actually we can skip writing p thread mutex initiative we initialize are available to magic value first alright so my first question for you is which one of these calls will block	thread	163
so that will happen when another thread	thread	33
has locked the mutex so i like to joke about our mutex locks being a little duck when you call look here's what's going to happen you're trying to grab dot trying to take it it's mine right now and you get to hold onto it until the day that you declare that you finished and you call unlock and you release it back into the wild so once you're holding onto it is like the conformally lord of the flies no one else gets to speak they do not continue their call to lock will block set doctor seuss ok so now we can answer this next question right let's turn on my little writing tool here their case which of the following calls will block the answer is lock	the following	607
has locked the mutex so i like to joke about our mutex locks being a little duck when you call look here's what's going to happen you're trying to grab dot trying to take it it's mine right now and you get to hold onto it until the day that you declare that you finished and you call unlock and you release it back into the wild so once you're holding onto it is like the conformally lord of the flies no one else gets to speak they do not continue their call to lock will block set doctor seuss ok so now we can answer this next question right let's turn on my little writing tool here their case which of the following calls will block the answer is lock	block	473
so lock is the call is going to be blocked and what needs to happen in order for it to unblock in other words	block	35
what needs to happen in order for it to return right so think of lock as your two year old saying i want the duck that can only happen when the thread that currently has the duck calls unlock so that i'm here so if i was to sketch this out with time so let's do time granted rights i've got one little thread here here's my first thread right it's like thread one ok coming along calls lock here	thread	144
another thread is running	thread	8
and they call lock on the same mutex lock ok can they carry on and execute their next piece of code no there blocked there stuck in effect that cpu goes to sleep in practice the kernel can say oh i can see you you're stuck right now you're short order cook can't device because there is no voice yet so i'm actually going to sign the physical cpu to do something else i've got another thread that would love to get started love to get do some work right now so let me tell us you're going to do something else but from this thread perspective nothing was going to happen it does not pass go does not execute the next line of code until the day that our thread one has finished doing what it's doing inside those critical section	block	109
and they call lock on the same mutex lock ok can they carry on and execute their next piece of code no there blocked there stuck in effect that cpu goes to sleep in practice the kernel can say oh i can see you you're stuck right now you're short order cook can't device because there is no voice yet so i'm actually going to sign the physical cpu to do something else i've got another thread that would love to get started love to get do some work right now so let me tell us you're going to do something else but from this thread perspective nothing was going to happen it does not pass go does not execute the next line of code until the day that our thread one has finished doing what it's doing inside those critical section	code	95
and they call lock on the same mutex lock ok can they carry on and execute their next piece of code no there blocked there stuck in effect that cpu goes to sleep in practice the kernel can say oh i can see you you're stuck right now you're short order cook can't device because there is no voice yet so i'm actually going to sign the physical cpu to do something else i've got another thread that would love to get started love to get do some work right now so let me tell us you're going to do something else but from this thread perspective nothing was going to happen it does not pass go does not execute the next line of code until the day that our thread one has finished doing what it's doing inside those critical section	section	721
and they call lock on the same mutex lock ok can they carry on and execute their next piece of code no there blocked there stuck in effect that cpu goes to sleep in practice the kernel can say oh i can see you you're stuck right now you're short order cook can't device because there is no voice yet so i'm actually going to sign the physical cpu to do something else i've got another thread that would love to get started love to get do some work right now so let me tell us you're going to do something else but from this thread perspective nothing was going to happen it does not pass go does not execute the next line of code until the day that our thread one has finished doing what it's doing inside those critical section	thread	385
and now cause unlog on this mutex so it releases the mutex let's that duck fly away back to the pond ok great at that moment thread two can wake up and in doing so it acquires that mutex it's going to grab it and say ha it's mine now and	thread	125
hold on a moment supposed with the thread that also try to lock so say somewhere inside here it called lock so now i've got two threads that was sleep desperately waiting for that duck ok so what's going to happen the moment that thread one calls unlock the answer is one of them is going to win and only one of them is going to win so in this case that two is one thread three i'm afraid is going to continue to be asleep until the day that it is able to acquire and lock that new text itself so that's why we can ensure that uh we satisfied all critical section constraints that there's no way to continue unless you grab that duck unless you have acquired the mutex right so i think we've answered nearly all of these questions what about this one why is it that peter mutex lock	section	556
hold on a moment supposed with the thread that also try to lock so say somewhere inside here it called lock so now i've got two threads that was sleep desperately waiting for that duck ok so what's going to happen the moment that thread one calls unlock the answer is one of them is going to win and only one of them is going to win so in this case that two is one thread three i'm afraid is going to continue to be asleep until the day that it is able to acquire and lock that new text itself so that's why we can ensure that uh we satisfied all critical section constraints that there's no way to continue unless you grab that duck unless you have acquired the mutex right so i think we've answered nearly all of these questions what about this one why is it that peter mutex lock	thread	35
does not block	block	9
ok this one should be easy for you to answer we've already seen it that was our case when thread one called lock and no one had the duck it was like like traffic like area something where no one else is or four way stop right there when no one else is in the intersection right now so you can just go straight straight forward just quick rolling stop there right and say how the intersection is mine so why my pee thread retakes not block the answer is because the mutex is available it's no one else has locked it currently right so you can immediately continue	block	433
ok this one should be easy for you to answer we've already seen it that was our case when thread one called lock and no one had the duck it was like like traffic like area something where no one else is or four way stop right there when no one else is in the intersection right now so you can just go straight straight forward just quick rolling stop there right and say how the intersection is mine so why my pee thread retakes not block the answer is because the mutex is available it's no one else has locked it currently right so you can immediately continue	section	264
ok this one should be easy for you to answer we've already seen it that was our case when thread one called lock and no one had the duck it was like like traffic like area something where no one else is or four way stop right there when no one else is in the intersection right now so you can just go straight straight forward just quick rolling stop there right and say how the intersection is mine so why my pee thread retakes not block the answer is because the mutex is available it's no one else has locked it currently right so you can immediately continue	thread	90
ok great i'll see you in the next video where we come back here we go where we actually start applying this to code alright see you then	code	111
ok so let's play with race conditions and then fixing with locks right so what do you think the following code is going to print here we have a counter variable which is global as you can see anybody can reach into it and read it or write it and in fact like a little function here that is going to loop looks like a million times and each time around the loop we're going to implement that counter now the value of eyes a stack variable which means i can create a whole load of threads and each one is going to get his own value of i but they are all picking at this global variable this countered so they're going to share access to that that variable right and then i've got some code on here peter create peter create and then two p thread joins so out of the two p thread joins we print out the value of counter right so what do you think about this code what's it going to print let's give it ago so i need to compile it ok i've compiled it off we go right it did not print out of course two million it we run it it just happy prints out different values each and every time so why do you think that is a key so actually there's two reasons the first one is because it the value that we get depends upon the actual interleaving of my two threads to how they do this increment so even though we plus plus hear	the following	92
ok so let's play with race conditions and then fixing with locks right so what do you think the following code is going to print here we have a counter variable which is global as you can see anybody can reach into it and read it or write it and in fact like a little function here that is going to loop looks like a million times and each time around the loop we're going to implement that counter now the value of eyes a stack variable which means i can create a whole load of threads and each one is going to get his own value of i but they are all picking at this global variable this countered so they're going to share access to that that variable right and then i've got some code on here peter create peter create and then two p thread joins so out of the two p thread joins we print out the value of counter right so what do you think about this code what's it going to print let's give it ago so i need to compile it ok i've compiled it off we go right it did not print out of course two million it we run it it just happy prints out different values each and every time so why do you think that is a key so actually there's two reasons the first one is because it the value that we get depends upon the actual interleaving of my two threads to how they do this increment so even though we plus plus hear	the loop	352
ok so let's play with race conditions and then fixing with locks right so what do you think the following code is going to print here we have a counter variable which is global as you can see anybody can reach into it and read it or write it and in fact like a little function here that is going to loop looks like a million times and each time around the loop we're going to implement that counter now the value of eyes a stack variable which means i can create a whole load of threads and each one is going to get his own value of i but they are all picking at this global variable this countered so they're going to share access to that that variable right and then i've got some code on here peter create peter create and then two p thread joins so out of the two p thread joins we print out the value of counter right so what do you think about this code what's it going to print let's give it ago so i need to compile it ok i've compiled it off we go right it did not print out of course two million it we run it it just happy prints out different values each and every time so why do you think that is a key so actually there's two reasons the first one is because it the value that we get depends upon the actual interleaving of my two threads to how they do this increment so even though we plus plus hear	code	106
ok so let's play with race conditions and then fixing with locks right so what do you think the following code is going to print here we have a counter variable which is global as you can see anybody can reach into it and read it or write it and in fact like a little function here that is going to loop looks like a million times and each time around the loop we're going to implement that counter now the value of eyes a stack variable which means i can create a whole load of threads and each one is going to get his own value of i but they are all picking at this global variable this countered so they're going to share access to that that variable right and then i've got some code on here peter create peter create and then two p thread joins so out of the two p thread joins we print out the value of counter right so what do you think about this code what's it going to print let's give it ago so i need to compile it ok i've compiled it off we go right it did not print out of course two million it we run it it just happy prints out different values each and every time so why do you think that is a key so actually there's two reasons the first one is because it the value that we get depends upon the actual interleaving of my two threads to how they do this increment so even though we plus plus hear	thread	479
the big news flash is that this is not an atomic operation so what we mean by atomic well you enough uranium together no we don't mean that what we mean by atomic here is it is that an atomic operation it behaves as if it completes as one complete operation but that's not true not for plus plus here so instead what is going on we're saying ok read the value of counter add one to it and then right back into memory so there's three distinct stages here	memory	410
we go over to main memory you will see he may maybe i need to read the following four bytes please ok we pull that into a cpu register then we invoke the arithmetic logic unit to add one to our register ok so we've recalculated new value and then we take that bit pattern and we throw it back towards memory here you go memory have a new value the adding one is extremely fast writing to main memory is extremely slow compared to what the cpu can do so of course practice we have levels of cash operating but let's	the following	67
we go over to main memory you will see he may maybe i need to read the following four bytes please ok we pull that into a cpu register then we invoke the arithmetic logic unit to add one to our register ok so we've recalculated new value and then we take that bit pattern and we throw it back towards memory here you go memory have a new value the adding one is extremely fast writing to main memory is extremely slow compared to what the cpu can do so of course practice we have levels of cash operating but let's	memory	19
alright so that's the kind of first idea is that i've got two chefs two threads running as fast as possible really from memory adding on writing it back	memory	120
alright so that's the kind of first idea is that i've got two chefs two threads running as fast as possible really from memory adding on writing it back	thread	72
life would be fine if they did this carefully synchronized but instead you could imagine that are two threads go over and read the same value and then they add one at about the same time and then they write back their new values so instead of increasing the value by two we've only increased it by one you can imagine more extreme variations where one thread is running a bit slow perhaps my cpu keeps on being interrupted because it's being asked to transcode some videos as as i as i'm talking to you and so now the other thread is able to run forward a bit so imagine the following one thread reaches in grabs the number	the following	571
life would be fine if they did this carefully synchronized but instead you could imagine that are two threads go over and read the same value and then they add one at about the same time and then they write back their new values so instead of increasing the value by two we've only increased it by one you can imagine more extreme variations where one thread is running a bit slow perhaps my cpu keeps on being interrupted because it's being asked to transcode some videos as as i as i'm talking to you and so now the other thread is able to run forward a bit so imagine the following one thread reaches in grabs the number	code	456
life would be fine if they did this carefully synchronized but instead you could imagine that are two threads go over and read the same value and then they add one at about the same time and then they write back their new values so instead of increasing the value by two we've only increased it by one you can imagine more extreme variations where one thread is running a bit slow perhaps my cpu keeps on being interrupted because it's being asked to transcode some videos as as i as i'm talking to you and so now the other thread is able to run forward a bit so imagine the following one thread reaches in grabs the number	thread	102
i know it's doing the calculation or at least it's going to get to the calculations soon meanwhile the other thread reaches in grabs the number add one send it back breaches in addison number as well and send it back which anson does like like a million times then our first red wakes up again a few i got cpu again fantastic what was i doing oh yes i was adding one at one right it back so it's just managed to write over all of those results taking years back to a really low number so that is kind of the problem of just letting our threads run without any kind of proper synchronization so i mentioned there were two bugs the other one actually is just an insidious copy paste bug did you spot it ok so we call pthread create here	thread	109
or with the same id address here which means that our second thread id here is actually was never initialized	thread	61
or with the same id address here which means that our second thread id here is actually was never initialized	address	20
so we never actually truly going to wait for that second thread to actually complete case so so we should fix that let's make sure that we are writing into two different two different variables	thread	57
right so i promise we start using p thread mutex locks so here we go let's figure out how we can fix this program alright so xm ideas we can try here first of all let's get our self lock will make it a global so all my programs can see it if i didn't use globals i'd have to pass it around or least pass a pointer around to it right so p three edit musics type i'm going to call it a duck i want to imagine little duck quack quack that's very important little lock and today i'll use the the magic value piece red mutex initializer	type	356
right so i promise we start using p thread mutex locks so here we go let's figure out how we can fix this program alright so xm ideas we can try here first of all let's get our self lock will make it a global so all my programs can see it if i didn't use globals i'd have to pass it around or least pass a pointer around to it right so p three edit musics type i'm going to call it a duck i want to imagine little duck quack quack that's very important little lock and today i'll use the the magic value piece red mutex initializer	thread	36
right so i promise we start using p thread mutex locks so here we go let's figure out how we can fix this program alright so xm ideas we can try here first of all let's get our self lock will make it a global so all my programs can see it if i didn't use globals i'd have to pass it around or least pass a pointer around to it right so p three edit musics type i'm going to call it a duck i want to imagine little duck quack quack that's very important little lock and today i'll use the the magic value piece red mutex initializer	pointer	306
ok how do you feel about this so before doing any work in my data structure i'm going to grab the duck here so how do i do that as a pthread mutex lock and here's the address of my variable	a struct	64
ok how do you feel about this so before doing any work in my data structure i'm going to grab the duck here so how do i do that as a pthread mutex lock and here's the address of my variable	thread	134
ok how do you feel about this so before doing any work in my data structure i'm going to grab the duck here so how do i do that as a pthread mutex lock and here's the address of my variable	address	167
but we never let it go so when the second thread starts and calls preferred mutex locked it's going to be waiting for a very long time an infinite amount of time it never gets that duck that duck has been stolen by the first red and never returned so as a result the second thread will never finish so as a result rp so join in maine will never complete so as a result will never put the counter ok i think we better fix that let's put in their pthread mutex unlock there you go after i finished in my surgery on the data structure i'm going to give the duck back at which point is this anybody else waiting for the duck they too can grab the duck and then carry on	the data structure	513
but we never let it go so when the second thread starts and calls preferred mutex locked it's going to be waiting for a very long time an infinite amount of time it never gets that duck that duck has been stolen by the first red and never returned so as a result the second thread will never finish so as a result rp so join in maine will never complete so as a result will never put the counter ok i think we better fix that let's put in their pthread mutex unlock there you go after i finished in my surgery on the data structure i'm going to give the duck back at which point is this anybody else waiting for the duck they too can grab the duck and then carry on	a struct	520
but we never let it go so when the second thread starts and calls preferred mutex locked it's going to be waiting for a very long time an infinite amount of time it never gets that duck that duck has been stolen by the first red and never returned so as a result the second thread will never finish so as a result rp so join in maine will never complete so as a result will never put the counter ok i think we better fix that let's put in their pthread mutex unlock there you go after i finished in my surgery on the data structure i'm going to give the duck back at which point is this anybody else waiting for the duck they too can grab the duck and then carry on	thread	42
ok and ha who've are yes guess gratulation 's we've managed to make another fiendishly complicated program to add up to two million by using now kind of three for threads the main thread which doesn't do much it just delegates like a manager doesn't actually do any work and then two threads which are independently adding up a million but you did notice that actually we don't actually do any of the work in parallel first a thread probably the probably thread one but who knows actual add a million and then when it's finished it releases the duck and so the other thread gets to continue it requires a duck carries on adds a million to it and then unlock the duck ok so	a thread	424
ok and ha who've are yes guess gratulation 's we've managed to make another fiendishly complicated program to add up to two million by using now kind of three for threads the main thread which doesn't do much it just delegates like a manager doesn't actually do any work and then two threads which are independently adding up a million but you did notice that actually we don't actually do any of the work in parallel first a thread probably the probably thread one but who knows actual add a million and then when it's finished it releases the duck and so the other thread gets to continue it requires a duck carries on adds a million to it and then unlock the duck ok so	thread	163
maybe we should allow our threads to work in smaller units so what we think we could try here is k let's make a version three right well now i'm going to only acquire my doc for a very short period of time ok so now i'm going to rap each call navigate to before i change the counter	thread	26
k von function three so for a million times we acquire the lock we had wanted to counter and then we unlock the duck ok so let's compile this run it ok it gave us a correct answer and will always give us a correct answer but is now actually a little bit slower do you know why well in this contrived example adding one to a variable is an extremely fast operation compared to a typical program where we've got thousand instructions to do and in a typical program we only want to access this data structure this shared data structure occasionally so we've just managed to modify our original program	a struct	494
which would just increment the counter to now accessing the mutex changing the counter unlocking the mutex so we've actually added a lot more complexity in terms of number of instructions that have to be executed for each iteration around our loop ok so that wasn't didn't make a program any faster and in fact it slowed it down a bit just because we're using their lock in such a fine grained manner but it did ensure that are two threads could actually carry carry on now and finish it about the same time so now we've got an interleaving of our two threads but we've ensured that the actual change of the data structure only happens in one thread or the other thread at a time	the data structure	604
which would just increment the counter to now accessing the mutex changing the counter unlocking the mutex so we've actually added a lot more complexity in terms of number of instructions that have to be executed for each iteration around our loop ok so that wasn't didn't make a program any faster and in fact it slowed it down a bit just because we're using their lock in such a fine grained manner but it did ensure that are two threads could actually carry carry on now and finish it about the same time so now we've got an interleaving of our two threads but we've ensured that the actual change of the data structure only happens in one thread or the other thread at a time	a struct	611
which would just increment the counter to now accessing the mutex changing the counter unlocking the mutex so we've actually added a lot more complexity in terms of number of instructions that have to be executed for each iteration around our loop ok so that wasn't didn't make a program any faster and in fact it slowed it down a bit just because we're using their lock in such a fine grained manner but it did ensure that are two threads could actually carry carry on now and finish it about the same time so now we've got an interleaving of our two threads but we've ensured that the actual change of the data structure only happens in one thread or the other thread at a time	thread	432
my i've got two threads two cpus actually trying to read a right to the same piece piece of memory what if that value was cached or the good news actually is depleted mutex lock takes care of that as well for us that if this cpu supports some caching mechanisms peter mutex lock will ensure that that values are flushed out to main memory if any other cpu wants to read these	memory	92
my i've got two threads two cpus actually trying to read a right to the same piece piece of memory what if that value was cached or the good news actually is depleted mutex lock takes care of that as well for us that if this cpu supports some caching mechanisms peter mutex lock will ensure that that values are flushed out to main memory if any other cpu wants to read these	thread	16
magnets so technically it's called memory fence what memory barrier	memory	35
we're not going to write code that does not explicitly instead we're just kind of allowing the factor period mutex lock makes our world saying again makes our programs be equal to all the process is i've actually	code	25
running at least that's what it appears to be like that the values in memory other values that we expect to see in memory ok with some of course slight slight loss in performance when we do that ok so that's our first example of of contrived example of using petered mutex lock	memory	70
and what about the actual protections for each page of memory ok so we want to be able to read and we want to be able to write to these pages of memory but i don't need to be able to execute them i don't care where inside my virtual address space this memory ends up and i want four thousand and ninety six bytes please ok so if this succeeds great i get it back a pointer which i can actually start to use it will be the contents of alice dot text but we of course were able to change it so let's do that right so here's a little demo where i'm actually going to now do some communication between a parent and a child so strong copy and i can copy contents directly into that memory location so here's the child writing something into there and what about the parent the parent can read from the same address now back at the beginning of two forty one and we talked about forking we said hey these are completely different address spaces and actually there are no longer connected after you called fork ok well guess what that was a little lie why because you couldn't handle the truth but now let's actually have a look at the truth with mmap we can share things and this is the really cool part of mapping memory here that both the child and the parents will see this piece of memory and it will be the same piece of memory the same physical piece of ram for both the parent and the child for this particular mapping to alice dot text so the moment that the child starts writing into those piece that pieces of ramp the parent can read it as well so isn't that cool let's actually kind of a look at this let's actually do some rp cs sorry some interprocess communication some ipc between the parent and a child so off we go right	memory	55
and what about the actual protections for each page of memory ok so we want to be able to read and we want to be able to write to these pages of memory but i don't need to be able to execute them i don't care where inside my virtual address space this memory ends up and i want four thousand and ninety six bytes please ok so if this succeeds great i get it back a pointer which i can actually start to use it will be the contents of alice dot text but we of course were able to change it so let's do that right so here's a little demo where i'm actually going to now do some communication between a parent and a child so strong copy and i can copy contents directly into that memory location so here's the child writing something into there and what about the parent the parent can read from the same address now back at the beginning of two forty one and we talked about forking we said hey these are completely different address spaces and actually there are no longer connected after you called fork ok well guess what that was a little lie why because you couldn't handle the truth but now let's actually have a look at the truth with mmap we can share things and this is the really cool part of mapping memory here that both the child and the parents will see this piece of memory and it will be the same piece of memory the same physical piece of ram for both the parent and the child for this particular mapping to alice dot text so the moment that the child starts writing into those piece that pieces of ramp the parent can read it as well so isn't that cool let's actually kind of a look at this let's actually do some rp cs sorry some interprocess communication some ipc between the parent and a child so off we go right	mmap	1140
and what about the actual protections for each page of memory ok so we want to be able to read and we want to be able to write to these pages of memory but i don't need to be able to execute them i don't care where inside my virtual address space this memory ends up and i want four thousand and ninety six bytes please ok so if this succeeds great i get it back a pointer which i can actually start to use it will be the contents of alice dot text but we of course were able to change it so let's do that right so here's a little demo where i'm actually going to now do some communication between a parent and a child so strong copy and i can copy contents directly into that memory location so here's the child writing something into there and what about the parent the parent can read from the same address now back at the beginning of two forty one and we talked about forking we said hey these are completely different address spaces and actually there are no longer connected after you called fork ok well guess what that was a little lie why because you couldn't handle the truth but now let's actually have a look at the truth with mmap we can share things and this is the really cool part of mapping memory here that both the child and the parents will see this piece of memory and it will be the same piece of memory the same physical piece of ram for both the parent and the child for this particular mapping to alice dot text so the moment that the child starts writing into those piece that pieces of ramp the parent can read it as well so isn't that cool let's actually kind of a look at this let's actually do some rp cs sorry some interprocess communication some ipc between the parent and a child so off we go right	address	233
and what about the actual protections for each page of memory ok so we want to be able to read and we want to be able to write to these pages of memory but i don't need to be able to execute them i don't care where inside my virtual address space this memory ends up and i want four thousand and ninety six bytes please ok so if this succeeds great i get it back a pointer which i can actually start to use it will be the contents of alice dot text but we of course were able to change it so let's do that right so here's a little demo where i'm actually going to now do some communication between a parent and a child so strong copy and i can copy contents directly into that memory location so here's the child writing something into there and what about the parent the parent can read from the same address now back at the beginning of two forty one and we talked about forking we said hey these are completely different address spaces and actually there are no longer connected after you called fork ok well guess what that was a little lie why because you couldn't handle the truth but now let's actually have a look at the truth with mmap we can share things and this is the really cool part of mapping memory here that both the child and the parents will see this piece of memory and it will be the same piece of memory the same physical piece of ram for both the parent and the child for this particular mapping to alice dot text so the moment that the child starts writing into those piece that pieces of ramp the parent can read it as well so isn't that cool let's actually kind of a look at this let's actually do some rp cs sorry some interprocess communication some ipc between the parent and a child so off we go right	pointer	365
ok so in one corner i have the child here that every two seconds is going to print out forty bytes out and then directly reads forty bytes from that address ok so organized and say is hey take this memory and send forty bytes of it directly to stand it out meanwhile my parent process is modifying the memory so let's use s printf to directly write to this memory address that we got back from a map and we will write the following formatted string will say hello from the other side and followed by a little number account here ok	the following	418
ok so in one corner i have the child here that every two seconds is going to print out forty bytes out and then directly reads forty bytes from that address ok so organized and say is hey take this memory and send forty bytes of it directly to stand it out meanwhile my parent process is modifying the memory so let's use s printf to directly write to this memory address that we got back from a map and we will write the following formatted string will say hello from the other side and followed by a little number account here ok	memory	198
ok so in one corner i have the child here that every two seconds is going to print out forty bytes out and then directly reads forty bytes from that address ok so organized and say is hey take this memory and send forty bytes of it directly to stand it out meanwhile my parent process is modifying the memory so let's use s printf to directly write to this memory address that we got back from a map and we will write the following formatted string will say hello from the other side and followed by a little number account here ok	printf	324
ok so in one corner i have the child here that every two seconds is going to print out forty bytes out and then directly reads forty bytes from that address ok so organized and say is hey take this memory and send forty bytes of it directly to stand it out meanwhile my parent process is modifying the memory so let's use s printf to directly write to this memory address that we got back from a map and we will write the following formatted string will say hello from the other side and followed by a little number account here ok	string	442
ok so in one corner i have the child here that every two seconds is going to print out forty bytes out and then directly reads forty bytes from that address ok so organized and say is hey take this memory and send forty bytes of it directly to stand it out meanwhile my parent process is modifying the memory so let's use s printf to directly write to this memory address that we got back from a map and we will write the following formatted string will say hello from the other side and followed by a little number account here ok	address	149
ok and off you go right so every second will see great this hello from the other side plus an alice as well here's why that we are necessarily over writing a full forty bytes and so if we were to look at the beginning of the file we would see this hello from the other side followed by a newline and alice ok but there we go great i've got two processes communicating directly by overwriting the same piece of shared ram ok so will kind of get out of that let's actually how look to see if it updated the file so if i do say hex dump of alice dot text pipe that into less than we don't see too much ok right so oops that's a little hard to read let's actually have a look at just text here it is we gotta hello from the other side then there kind of the terminating c string character and then the rest of the alice dot text ok so welcome the looking glass welcome to kind of	string	768
escaping out of a single process using nmap also realize that would have made the malik mp really easy if instead we said ok just hey kennel give me some more memory and in fact today this is how real mallocworks it will actually use mmap to request more memory from the system	memory	159
escaping out of a single process using nmap also realize that would have made the malik mp really easy if instead we said ok just hey kennel give me some more memory and in fact today this is how real mallocworks it will actually use mmap to request more memory from the system	mmap	234
escaping out of a single process using nmap also realize that would have made the malik mp really easy if instead we said ok just hey kennel give me some more memory and in fact today this is how real mallocworks it will actually use mmap to request more memory from the system	system	271
ok right so the last thing i want to show you is how easy m map can make writing some code so	code	86
let's have a think about how we can look for strings inside a	string	45
what i want to do is kind of hunt for printable strings	string	48
inside a particular file so let me kind of give an example of how this would actually work there is actually a utility called strings if i say run strings on test dot iso it might find something possibly useful so but possibly not because it's encrypted oh i should have actually limited this out but it's going to keep going for a little while ok there we go let's run it on something smaller like a toy out and will see there's a whole lot of strings hidden inside that executable including any strings that we've actually written as well and even the names of functions that it wants wants to bind once it's loaded ok so	string	126
how can we pull those out how can we write a version of strings alright so let's actually have a look at one	string	56
and it's relatively easy to do if we can just load the whole file into memory so we could already do that using same alakan stat however that requires us to actually get all of that memory at the same time with them map the pages can be loaded on demand as we need them ok so let's have a look at this how it works right so we want to of course called open	memory	71
and then stat it as well to find out how big it is ok so now i've got that information i'll check the s stat actually works correctly so now i can use my map skills by saying right so i need this many bytes pleads and i've got that from stat and i want to read from this file and now let's just kind of see if we can find a useful string and the cool thing here is that i can just directly use the pointer returned by mem map i don't need to mess around reading individual characters etc and so when i find a sequence of characters which are all printable then great looks like i found a sequence of bytes which might be a secret string inside my file so let me then print it out ok so we could have run this now so i'll just compile it	string	331
and then stat it as well to find out how big it is ok so now i've got that information i'll check the s stat actually works correctly so now i can use my map skills by saying right so i need this many bytes pleads and i've got that from stat and i want to read from this file and now let's just kind of see if we can find a useful string and the cool thing here is that i can just directly use the pointer returned by mem map i don't need to mess around reading individual characters etc and so when i find a sequence of characters which are all printable then great looks like i found a sequence of bytes which might be a secret string inside my file so let me then print it out ok so we could have run this now so i'll just compile it	pointer	398
ok so now let's rerun s one on a doubt and we'll see kind of very similar output to what i form the kind of strings utility ok so it kind of found all those useful strings this have a look to see how we might have written this if we didn't know about nmap ok so here's an alternative then using c can get	string	108
ok very similar code but now i'm reading just kind of one character at a time for my file and if it's not if it is a printable character great fits continue otherwise i'm going to start seeking around when the file in order get backwards in order to print out each character so this is kind of very different code to right now i'm thinking about positions within files and seeking around it's much easier to read and write so it's much easier to create this kind of code if i can just simply say hey my entire file is mapped into my memory space and i can just move around my file just by using memory offsets so it allows us to write kind of that kind of kind of code very efficiently quite final quick comment is that nmap however doesn't necessarily increase the performance of your code the kernel is very good at buffering and reading files continuously so just using nmap doesn't necessarily make your your code anymore efficient or more performant just makes it a little bit easier to write ok so that's enough for one video in the next video we will start talking about wait i'll see you then bye	memory	533
ok very similar code but now i'm reading just kind of one character at a time for my file and if it's not if it is a printable character great fits continue otherwise i'm going to start seeking around when the file in order get backwards in order to print out each character so this is kind of very different code to right now i'm thinking about positions within files and seeking around it's much easier to read and write so it's much easier to create this kind of code if i can just simply say hey my entire file is mapped into my memory space and i can just move around my file just by using memory offsets so it allows us to write kind of that kind of kind of code very efficiently quite final quick comment is that nmap however doesn't necessarily increase the performance of your code the kernel is very good at buffering and reading files continuously so just using nmap doesn't necessarily make your your code anymore efficient or more performant just makes it a little bit easier to write ok so that's enough for one video in the next video we will start talking about wait i'll see you then bye	code	16
hi so let's talk about how we can use reallocate reallocate is going to allow you to beat your cs two twenty five friends and others when it comes to creating memory structures which can grow very quickly so let's have a look to see why ok so realloc behaves a lot like malloc	memory	159
but allows you to change your mind you can say hey i previously got back some memory safe from catalog called malloc and i decided that i didn't want a hundred bytes i actually want two hundred bytes what can you do for me now the great thing about realloc is that it potentially says hey don't worry i can give you two hundred bytes	memory	78
and in fact you're going to continue using the same address so we can think of this is like in a big apartment block where you said you know what i'd like to double from a hundred square foot to two hundred square foot and the apartment manager comes back and says hey you are really lucky that no one was living next door to use so actually this didn't take very long at all i'm just going to allow you to stay living in the same place and you can now go two hundred feet out don't worry about it	block	111
and in fact you're going to continue using the same address so we can think of this is like in a big apartment block where you said you know what i'd like to double from a hundred square foot to two hundred square foot and the apartment manager comes back and says hey you are really lucky that no one was living next door to use so actually this didn't take very long at all i'm just going to allow you to stay living in the same place and you can now go two hundred feet out don't worry about it	address	52
ok oh more less common is that if it does actually move stuff to a new location it automatically frees the old memory that you had inside the heap so let's have a look at how we can use this right so let's have this accessory legs ample that time i'm reading in some values perhaps and i don't know how many i have so how would i do this let's say i'm reading in some double values so let me keep track of	memory	111
ok oh more less common is that if it does actually move stuff to a new location it automatically frees the old memory that you had inside the heap so let's have a look at how we can use this right so let's have this accessory legs ample that time i'm reading in some values perhaps and i don't know how many i have so how would i do this let's say i'm reading in some double values so let me keep track of	the heap	138
i mean i'll read doubles for example ok so i've got a value and somewhere somehow i get get another value maybe i'm reading in from a file maybe it's coming in from the network but for whatever reason we want to store this value ok what should we do next right well we better actually have some memory on the heap for this so i will have	memory	295
i mean i'll read doubles for example ok so i've got a value and somewhere somehow i get get another value maybe i'm reading in from a file maybe it's coming in from the network but for whatever reason we want to store this value ok what should we do next right well we better actually have some memory on the heap for this so i will have	the heap	305
my little data structure here and	a struct	13
now we need to get some more memory so we can say hey real ac have a look at my old data structure there it is and actually the size i want now is capacity right so what do you think about that so first of all you say hold on a moment realloc can return	memory	29
now we need to get some more memory so we can say hey real ac have a look at my old data structure there it is and actually the size i want now is capacity right so what do you think about that so first of all you say hold on a moment realloc can return	a struct	87
indirect after i've used it k and i will say ok numb items you can be the value alright so we'll keep going down around the loop until something happens so typically say get if value with zero perhaps you want to break out of the loop ok right so what do you think about this well first question might be well what happens when	the loop	120
i've just passed in null into realloc well good news there is that if you do that then real it behaves exactly like malloc ok so the very first time we're going to ask for just enough space for wait for it yes one bite what we forgot to do and this is a common error is real it works with bites it doesn't know what we're trying to store in there actually is these double values so it's very common to forget to put the size of the thing that we want to put in here and what do we want to put in so another common mistake is to accidentally get the type here well we don't want pointers daredevils we actually want the thing itself which is the double	type	549
i've just passed in null into realloc well good news there is that if you do that then real it behaves exactly like malloc ok so the very first time we're going to ask for just enough space for wait for it yes one bite what we forgot to do and this is a common error is real it works with bites it doesn't know what we're trying to store in there actually is these double values so it's very common to forget to put the size of the thing that we want to put in here and what do we want to put in so another common mistake is to accidentally get the type here well we don't want pointers daredevils we actually want the thing itself which is the double	pointer	578
ok so called real lock and i've got some some memory back we're cheating a little bit but better code would actually check to see if realloc failed i'm not going to buy their air condition today instead i want to think about how to make this a little bit more performant right now we are going back to the building manager saying hey mister heap i need a slightly bigger apartment pleased another four bytes you another four bytes me ok we can do better than that of course we can only do this occasionally so let's	memory	46
ok so called real lock and i've got some some memory back we're cheating a little bit but better code would actually check to see if realloc failed i'm not going to buy their air condition today instead i want to think about how to make this a little bit more performant right now we are going back to the building manager saying hey mister heap i need a slightly bigger apartment pleased another four bytes you another four bytes me ok we can do better than that of course we can only do this occasionally so let's	code	97
ask real lock for more space and at that point when it returns like i said data maybe pointed to some a different memory but it's moved all of my old data for me	memory	114
ok so what do we think about that one little problem right now is that our capacity value started at zero so let's change that this to start saying which kind of some reasonable number like sixteen right so good we've got away now to start reading values one kind of cute trick is at some point you know when you finished the actually you'll never going to grow this array anymore so we could be a little bit more efficient with memory we could say hey by the way i've actually changed my mind the actual space i need is no longer capacity but just before i returned i now know i need exactly this amount of space so this allows the heat to reclaim that unused extra capacity at the end that you and i know we will never use for particular program ok so we've got little program now we'd have to store the data on the number items in in a data structure	memory	429
ok so what do we think about that one little problem right now is that our capacity value started at zero so let's change that this to start saying which kind of some reasonable number like sixteen right so good we've got away now to start reading values one kind of cute trick is at some point you know when you finished the actually you'll never going to grow this array anymore so we could be a little bit more efficient with memory we could say hey by the way i've actually changed my mind the actual space i need is no longer capacity but just before i returned i now know i need exactly this amount of space so this allows the heat to reclaim that unused extra capacity at the end that you and i know we will never use for particular program ok so we've got little program now we'd have to store the data on the number items in in a data structure	a struct	842
we've now got away to read in values and to efficiently use our heap memory ok the last thing we didn't do is too if you want to write production quality code let's see if we add up failed so i would have another pointer in here ok to see if	heap memory	64
we've now got away to read in values and to efficiently use our heap memory ok the last thing we didn't do is too if you want to write production quality code let's see if we add up failed so i would have another pointer in here ok to see if	memory	69
we've now got away to read in values and to efficiently use our heap memory ok the last thing we didn't do is too if you want to write production quality code let's see if we add up failed so i would have another pointer in here ok to see if	code	154
we've now got away to read in values and to efficiently use our heap memory ok the last thing we didn't do is too if you want to write production quality code let's see if we add up failed so i would have another pointer in here ok to see if	pointer	213
quit kind of out of memory	memory	20
we could handle that and exit or something right so if there's no no real to memory we better stop otherwise hey let's update our data pointed that key and you'll notice i'm not writing any kind of casting in here so i was some people traditionally like to put casting here 'cause we're changing the type from a void pointer to a double pointer in practice i found i don't like to do that i think it's necessary and be leads to more visual clutter when the most likely mistake is to accidentally request the incorrect amount of memory so i had much more other kind of like this coder stand out where we actually think about the exact number of bytes where we are requesting ok so that's our example use of real ac it's very powerful it can be very fast to change the amount of memory allocated and it's a good little trick to learn so i'll see you in the next video bye	memory	77
we could handle that and exit or something right so if there's no no real to memory we better stop otherwise hey let's update our data pointed that key and you'll notice i'm not writing any kind of casting in here so i was some people traditionally like to put casting here 'cause we're changing the type from a void pointer to a double pointer in practice i found i don't like to do that i think it's necessary and be leads to more visual clutter when the most likely mistake is to accidentally request the incorrect amount of memory so i had much more other kind of like this coder stand out where we actually think about the exact number of bytes where we are requesting ok so that's our example use of real ac it's very powerful it can be very fast to change the amount of memory allocated and it's a good little trick to learn so i'll see you in the next video bye	type	300
we could handle that and exit or something right so if there's no no real to memory we better stop otherwise hey let's update our data pointed that key and you'll notice i'm not writing any kind of casting in here so i was some people traditionally like to put casting here 'cause we're changing the type from a void pointer to a double pointer in practice i found i don't like to do that i think it's necessary and be leads to more visual clutter when the most likely mistake is to accidentally request the incorrect amount of memory so i had much more other kind of like this coder stand out where we actually think about the exact number of bytes where we are requesting ok so that's our example use of real ac it's very powerful it can be very fast to change the amount of memory allocated and it's a good little trick to learn so i'll see you in the next video bye	code	578
we could handle that and exit or something right so if there's no no real to memory we better stop otherwise hey let's update our data pointed that key and you'll notice i'm not writing any kind of casting in here so i was some people traditionally like to put casting here 'cause we're changing the type from a void pointer to a double pointer in practice i found i don't like to do that i think it's necessary and be leads to more visual clutter when the most likely mistake is to accidentally request the incorrect amount of memory so i had much more other kind of like this coder stand out where we actually think about the exact number of bytes where we are requesting ok so that's our example use of real ac it's very powerful it can be very fast to change the amount of memory allocated and it's a good little trick to learn so i'll see you in the next video bye	pointer	317
i've gone ok so now it's finished with that it means a process two can continue ok so it's no longer waiting for this resource	a process	53
ok from the chocolate ok so now process two ok do you have everything you need yes you do so process two can continue ok right 'cause we don't have anymore instructions down here about anything that opposes need so we can infer that there is no deadlock at this at this point versus two has everything it needs we cannot see a cycle so eventually process one will finish process two will finish and when it does do todo todo todo ok we can see that process three can now acquire his resources and so it will take that an process four will require d it continue as well so in this last example there was no deadlock alright so one kind of final comment in all of this is that we've been playing with	resources	483
single resources down here there is an extension to this model that we're going to think about inside	resources	7
cs two forty one but you can imagine how this is actually now a finite set of resources i just want to line here so rather than just having like a zero or one inside here like here's one resource it's one resource that one crisis has you could imagine i could tell my sisters off ok i could have say a fixed set of resources inside here so why then just one i might have to say two or three resources type type b or c maybe see can be say rahman i want some exclusive access to my random access memory and so this might be say eight megabytes in here so instead of just like access or no access i would start to then it wouldn't matter whether i gave it this piece of memory or that piece of memory just that process three say needs four megabytes of memory so let's give it to that that piece right and process want they might need this piece over here so we can see how if we had this kind of extension of this model how there might be situations where process process two now needs twelve megabytes of memory so it can't continue its waiting	memory	495
cs two forty one but you can imagine how this is actually now a finite set of resources i just want to line here so rather than just having like a zero or one inside here like here's one resource it's one resource that one crisis has you could imagine i could tell my sisters off ok i could have say a fixed set of resources inside here so why then just one i might have to say two or three resources type type b or c maybe see can be say rahman i want some exclusive access to my random access memory and so this might be say eight megabytes in here so instead of just like access or no access i would start to then it wouldn't matter whether i gave it this piece of memory or that piece of memory just that process three say needs four megabytes of memory so let's give it to that that piece right and process want they might need this piece over here so we can see how if we had this kind of extension of this model how there might be situations where process process two now needs twelve megabytes of memory so it can't continue its waiting	type	401
cs two forty one but you can imagine how this is actually now a finite set of resources i just want to line here so rather than just having like a zero or one inside here like here's one resource it's one resource that one crisis has you could imagine i could tell my sisters off ok i could have say a fixed set of resources inside here so why then just one i might have to say two or three resources type type b or c maybe see can be say rahman i want some exclusive access to my random access memory and so this might be say eight megabytes in here so instead of just like access or no access i would start to then it wouldn't matter whether i gave it this piece of memory or that piece of memory just that process three say needs four megabytes of memory so let's give it to that that piece right and process want they might need this piece over here so we can see how if we had this kind of extension of this model how there might be situations where process process two now needs twelve megabytes of memory so it can't continue its waiting	resources	78
to get more memory from their system so from this resource type	memory	12
to get more memory from their system so from this resource type	type	59
to get more memory from their system so from this resource type	system	30
so that's just an extension of this like i said we're not going to consider inside cs two forty one where we're going to stick to just kind of simple resource types instead in the next video i want to go over the following points i'll see you then	the following	209
so that's just an extension of this like i said we're not going to consider inside cs two forty one where we're going to stick to just kind of simple resource types instead in the next video i want to go over the following points i'll see you then	type	159
hi sue allocator can not only allocate memory reallocate reallocate memory when the user wants a bit larger space it was smaller space it can also tell us how well it's doing this kind of sketched out and see what that would look like ok so this story so far we've got our little metadata entry and we're going to represent that using with a linked list of all of our entries	memory	39
how do we want to instrument memory allocator well perhaps we care about things like the following like the total number of bytes which we've actually given to the user right now pass we care about the overhead of our implementation so remember that every time we've made an entry that is additional ram that we had to buy that we are using internally that we cannot actually give to the program so that represents an overhead we also might care about light switches not available so i'll talk about that in a little bit but let's first of all let's let's implement come with some of these first ones so how do i implement this well remember we're just going to walk through this this link list so i need my entry point are here right	the following	85
how do we want to instrument memory allocator well perhaps we care about things like the following like the total number of bytes which we've actually given to the user right now pass we care about the overhead of our implementation so remember that every time we've made an entry that is additional ram that we had to buy that we are using internally that we cannot actually give to the program so that represents an overhead we also might care about light switches not available so i'll talk about that in a little bit but let's first of all let's let's implement come with some of these first ones so how do i implement this well remember we're just going to walk through this this link list so i need my entry point are here right	memory	29
ok it is the pointer and will start by looking use my little global variable here my little static variable head kate and we want to keep going around whilst i got a valid point at once that gets to null i'm going to stop so the end of my loop i'm just going to use that	pointer	13
next pointer to look at the next one ok so	pointer	5
would be equal to that count times how big each one is ok so size of my entry type	type	78
right so what about unavailable bites well it depends bought definition we mean by kind of unavailable and i'm going to get you to think for a moment about the following idea which is that we have these entries we've been calling malloc and free with our little metadata at the front and so you could imagine that i've got say four hundred bytes here but the user only asked for three hundred fine yes say	the following	156
lock code listing but what if they only ask for say three block splitting but what if they only ask for say three hundred and ninety six then their actual usage is only these three hundred and ninety six bytes and we've got all of these bytes over here which are wasted space no one can see them similarly if we were very lazy or very fast with our real ac and we said oh you only want to now you say two hundred bytes and we just returned then again i've got this piece of ram that i paid for but is never going to be used so let's have a look at that wasted space so for that if we if we care if we actually care about this then we might start to keep track of not only the size of each entry here but how much is actually been asked for so we could say that we actually requested size that in other parts are just truly going to be stored there	block	58
lock code listing but what if they only ask for say three block splitting but what if they only ask for say three hundred and ninety six then their actual usage is only these three hundred and ninety six bytes and we've got all of these bytes over here which are wasted space no one can see them similarly if we were very lazy or very fast with our real ac and we said oh you only want to now you say two hundred bytes and we just returned then again i've got this piece of ram that i paid for but is never going to be used so let's have a look at that wasted space so for that if we if we care if we actually care about this then we might start to keep track of not only the size of each entry here but how much is actually been asked for so we could say that we actually requested size that in other parts are just truly going to be stored there	code	5
i just sitting there taking up silicon then let's look for cases where these two values are different so so again i actually care about blocks which have currently in use	block	136
perhaps you only implement block splitting really late in the game for example like an on demand for example in which case this is not quite a valid expression but i just want to kind of sketch this idea about the last thing we might care about his says just simply the number of fragments of memory because ideally all of our	memory	293
perhaps you only implement block splitting really late in the game for example like an on demand for example in which case this is not quite a valid expression but i just want to kind of sketch this idea about the last thing we might care about his says just simply the number of fragments of memory because ideally all of our	block	27
space is actually just inside one region then we can satisfy very large requests without having to go back to the kernel and then also allocate will be pretty fast because then it doesn't have to keep going through a long list of of entries so let's just keep track of the also the number of fragments of available memory so i might have something like this could be an int as well just available	memory	315
frag so i might write the following late so if this actually is a free fragment then i'll increment my account but i hope you can see there's actually lots of instrumentation you could do if you care about performance both in terms of its speed and how well you're using memory then your meta data structure can tell you a lot about have my lock is performing in real situations when you actually run it with python and other programs ok right with that i'll see you in the next video bye	the following	22
frag so i might write the following late so if this actually is a free fragment then i'll increment my account but i hope you can see there's actually lots of instrumentation you could do if you care about performance both in terms of its speed and how well you're using memory then your meta data structure can tell you a lot about have my lock is performing in real situations when you actually run it with python and other programs ok right with that i'll see you in the next video bye	memory	271
frag so i might write the following late so if this actually is a free fragment then i'll increment my account but i hope you can see there's actually lots of instrumentation you could do if you care about performance both in terms of its speed and how well you're using memory then your meta data structure can tell you a lot about have my lock is performing in real situations when you actually run it with python and other programs ok right with that i'll see you in the next video bye	a struct	296
hi so we started this little lecture with the idea that every time we wanted to have more memory every time you called malloc we could implement that just by going back to the kernel to say hey colonel please raise the watermark will call ask break would just get some more ram that way but we can do better than that we need a heap allocator that can keep track of blocks of memory that have been freed so that in future allocations we can reuse those pieces of memory and so how can we do this efficiently actually this is a nontrivial problem actually this is an np hard problem because we need to try to find the best allocation of a sequence of of allocations and we're not clairvoyant either so we can't actually do the perfect possible set of, or sequences of allocations so instead we need an algorithm to choose where to place the next malloc request that allocation request that is fast and house reasonably good performance	memory	90
hi so we started this little lecture with the idea that every time we wanted to have more memory every time you called malloc we could implement that just by going back to the kernel to say hey colonel please raise the watermark will call ask break would just get some more ram that way but we can do better than that we need a heap allocator that can keep track of blocks of memory that have been freed so that in future allocations we can reuse those pieces of memory and so how can we do this efficiently actually this is a nontrivial problem actually this is an np hard problem because we need to try to find the best allocation of a sequence of of allocations and we're not clairvoyant either so we can't actually do the perfect possible set of, or sequences of allocations so instead we need an algorithm to choose where to place the next malloc request that allocation request that is fast and house reasonably good performance	block	366
what we'd like to avoid is a lot of fragmentation if we end up with a heap where all the spare space is actually in very tiny short blocks then that means that i can no longer allocate very large requests and many requests that what i have to do for many requests is just keep walking through my data of representation of all these entries and none of them will be any good because they're all too small so my performance will be awful i'll take a long time to find a good place for the next allocation so let's get started let's have a look at this we've got a little simulation that we're going to use here paper based simulation and we will use this simulation to understand a little	block	132
so his default of the game that we're going to maintain our idea of heap just using a simple link list and each link each node in my linked list data structure just represents a segment of memory that is either currently in use meaning it's been allocated or is available is free so we'll keep our linked list in sorted order and everytime malloc is called we're going to actually walk through that link list looking for	memory	189
so his default of the game that we're going to maintain our idea of heap just using a simple link list and each link each node in my linked list data structure just represents a segment of memory that is either currently in use meaning it's been allocated or is available is free so we'll keep our linked list in sorted order and everytime malloc is called we're going to actually walk through that link list looking for	a struct	148
place that we can use to satisfy that request for some contiguous memory	memory	66
right when we find a piece of memory that third is large enough and free we're actually going to do two things	memory	30
were actually going to obviously return that address back to the caller so that they have their memory that they requested but the piece of memory that we found is probably larger than what was requested which means there's going to be some unused space at the end so let's change our link list let's add a new entry for that unused part so that future calls to malloc can potentially make use of that spare space	memory	96
were actually going to obviously return that address back to the caller so that they have their memory that they requested but the piece of memory that we found is probably larger than what was requested which means there's going to be some unused space at the end so let's change our link list let's add a new entry for that unused part so that future calls to malloc can potentially make use of that spare space	address	45
simile when free is called we're going to do two things we want to mark that entry in our link list is now available for future allocations but it could be that my linked list actually has two neighboring entries which are both free so at this point let's clean up our linked list so that rather than having two separate entries we can represent that as just a single entry of a much larger space and similarly we could i actually think about the fact that there might be some spam space behind the current entry as well but we won't go into those details today we're not going to implement a full piece of working c code here instead we can think about conceptually about how these placement strategies work and for that to have a feel for what's going on we're going to play the following little game so we want to get out of it ok there we go right so here's the rules of the game is that i've got the following allocations were going to occur in order i've got three k four k three k and then we're going to free our memory and then we're going to make some more allocations in another deallocation right so we're going to run through this little sequence of malloc and free calls and we have to satisfy those calls secondly there might be a toy point when	the following	777
simile when free is called we're going to do two things we want to mark that entry in our link list is now available for future allocations but it could be that my linked list actually has two neighboring entries which are both free so at this point let's clean up our linked list so that rather than having two separate entries we can represent that as just a single entry of a much larger space and similarly we could i actually think about the fact that there might be some spam space behind the current entry as well but we won't go into those details today we're not going to implement a full piece of working c code here instead we can think about conceptually about how these placement strategies work and for that to have a feel for what's going on we're going to play the following little game so we want to get out of it ok there we go right so here's the rules of the game is that i've got the following allocations were going to occur in order i've got three k four k three k and then we're going to free our memory and then we're going to make some more allocations in another deallocation right so we're going to run through this little sequence of malloc and free calls and we have to satisfy those calls secondly there might be a toy point when	memory	1021
simile when free is called we're going to do two things we want to mark that entry in our link list is now available for future allocations but it could be that my linked list actually has two neighboring entries which are both free so at this point let's clean up our linked list so that rather than having two separate entries we can represent that as just a single entry of a much larger space and similarly we could i actually think about the fact that there might be some spam space behind the current entry as well but we won't go into those details today we're not going to implement a full piece of working c code here instead we can think about conceptually about how these placement strategies work and for that to have a feel for what's going on we're going to play the following little game so we want to get out of it ok there we go right so here's the rules of the game is that i've got the following allocations were going to occur in order i've got three k four k three k and then we're going to free our memory and then we're going to make some more allocations in another deallocation right so we're going to run through this little sequence of malloc and free calls and we have to satisfy those calls secondly there might be a toy point when	code	617
when there's actually two reasonable areas memory that we could return in which case we're going to have if we have that type break we will choose the earliest segment that satisfies our placement strategy ok so here's the plan we will run through this with different	memory	43
when there's actually two reasonable areas memory that we could return in which case we're going to have if we have that type break we will choose the earliest segment that satisfies our placement strategy ok so here's the plan we will run through this with different	type	121
ok great so puzzle for you let's think about so now taking me address of things so have a look at this code we've got ourselves a global variable so that's not going to be on the stack ok i'm going to initialize that to five but this is what we do inside our main we call a function f one we passing the value of ten and we also pass in the address of our global variable so just sometimes we actually don't want the value of our variables we actually want to know where they live	code	103
ok great so puzzle for you let's think about so now taking me address of things so have a look at this code we've got ourselves a global variable so that's not going to be on the stack ok i'm going to initialize that to five but this is what we do inside our main we call a function f one we passing the value of ten and we also pass in the address of our global variable so just sometimes we actually don't want the value of our variables we actually want to know where they live	address	62
that's the purpose of this address of operate say tell me where something is because maybe i want to write something directly into that those memory locations right so that's going to pass in the address of my global and also the value of ten meanwhile there's going to look inside f one because our challenges to work out which one of these lines will actually which one or two or three of these lines will actually print out an address in the stack ok so our first contender is going to actually print out the address of v one what is v one is a parameter of this function ok our second will print out the address of v two and the third book has a typo is fixed that let's make that actually print out v two so we will fix that line ok so let's go in and look at our code here right	memory	142
that's the purpose of this address of operate say tell me where something is because maybe i want to write something directly into that those memory locations right so that's going to pass in the address of my global and also the value of ten meanwhile there's going to look inside f one because our challenges to work out which one of these lines will actually which one or two or three of these lines will actually print out an address in the stack ok so our first contender is going to actually print out the address of v one what is v one is a parameter of this function ok our second will print out the address of v two and the third book has a typo is fixed that let's make that actually print out v two so we will fix that line ok so let's go in and look at our code here right	parameter	548
that's the purpose of this address of operate say tell me where something is because maybe i want to write something directly into that those memory locations right so that's going to pass in the address of my global and also the value of ten meanwhile there's going to look inside f one because our challenges to work out which one of these lines will actually which one or two or three of these lines will actually print out an address in the stack ok so our first contender is going to actually print out the address of v one what is v one is a parameter of this function ok our second will print out the address of v two and the third book has a typo is fixed that let's make that actually print out v two so we will fix that line ok so let's go in and look at our code here right	code	769
that's the purpose of this address of operate say tell me where something is because maybe i want to write something directly into that those memory locations right so that's going to pass in the address of my global and also the value of ten meanwhile there's going to look inside f one because our challenges to work out which one of these lines will actually which one or two or three of these lines will actually print out an address in the stack ok so our first contender is going to actually print out the address of v one what is v one is a parameter of this function ok our second will print out the address of v two and the third book has a typo is fixed that let's make that actually print out v two so we will fix that line ok so let's go in and look at our code here right	address	27
right now we have reasonable code so i think we're ready to compile it and half ago but before i do which one of these three expressions will actually print out a stack address are you already go	code	29
right now we have reasonable code so i think we're ready to compile it and half ago but before i do which one of these three expressions will actually print out a stack address are you already go	address	169
ok times up time to try so let's compile it right gcc stack addresses	address	60
and we've got a problem here yes we've got the fact that if one is an invalid function at this point so what's going on our problem is that we're trying to use this function f one before the compiler has seen it so maybe we'll have a dot h file an include file that actually defines it but let's just instead this declare it directly here so we're going to say i'm a compiler there's going to be a function i promise you that takes two integers taker takes an int and an eight pointer and returns and it ok and i'm not going to tell you anything more about it and not going to give you its definition ok so now we can compile and we've got our control which that because i never returned from f one so i could to make it warnings go away return something ok right	pointer	477
so now we run it let's deal with gots ok so the first two did return address is on the stack did you get that right let's have a look at our code one last time	code	141
so now we run it let's deal with gots ok so the first two did return address is on the stack did you get that right let's have a look at our code one last time	address	69
ok put it out using cats case or two parameters v one v two they themselves are just automatic variables there part of the parameters are f one they're going to disappear they go out of scope that moment that we return from f one so they are going to live on the stack along with any other automatic variables that we declare inside f one so when we print out the address of those variables they will be on the stack and they're only going to be valid for the duration of that function the moment we return from that function those variables are gone and that address those addresses can be used for something else	parameter	37
ok put it out using cats case or two parameters v one v two they themselves are just automatic variables there part of the parameters are f one they're going to disappear they go out of scope that moment that we return from f one so they are going to live on the stack along with any other automatic variables that we declare inside f one so when we print out the address of those variables they will be on the stack and they're only going to be valid for the duration of that function the moment we return from that function those variables are gone and that address those addresses can be used for something else	address	364
but the last one we actually print out the contents the value of v2 that's where we actually print out what was passed in so what is v two storing v two is storing a pointer and pointer and where do we get the endpoint of form it's dear dress of our global variable so that's why the very last value	pointer	166
that we rent was actually a load number that's part of our global variables that's actually the address of a at the global variable abc with that right	address	96
hi so let's talk about how we can implement free ok so the first part of implementation is trivial if you call free with null are there's nothing to do so let's test for that right so if the pointer value with zero in other words if it's null then don't do anything just immediately return	pointer	191
ok for what about all other values well remember we have are linked list and are linked list is of these metadata entry objects each one of those has a size next pointer and whether it correspond to some maybe that's commonly in use or not ok so let's walk through that link list looking for the entry that corresponds to this piece of memory that we're trying to free ok so how do we do that right so i'll initialize our little it available to the beginning the linked list	memory	336
ok for what about all other values well remember we have are linked list and are linked list is of these metadata entry objects each one of those has a size next pointer and whether it correspond to some maybe that's commonly in use or not ok so let's walk through that link list looking for the entry that corresponds to this piece of memory that we're trying to free ok so how do we do that right so i'll initialize our little it available to the beginning the linked list	pointer	162
and we've got that static global variable there called head right so let's get started at the beginning and keep going around whilst p is not null and at the end of each iteration update peas in the next pointer	pointer	204
ok so we have we found the right entry or not it would be a mistake to directly compare p with the users addressed	address	105
been passed in with the parameter value because remember they don't point to these metadata entries instead we've we internally have got to access that from our struct so let's use our metadata entry struct here and look at the pointer value and see if we found the right one if we have great now it's time to mark that entry as available for future allocations right how do we do that are this easy we can just say ok p let's update our counting here so that we don't need to change the	parameter	24
been passed in with the parameter value because remember they don't point to these metadata entries instead we've we internally have got to access that from our struct so let's use our metadata entry struct here and look at the pointer value and see if we found the right one if we have great now it's time to mark that entry as available for future allocations right how do we do that are this easy we can just say ok p let's update our counting here so that we don't need to change the	pointer	228
size just that the entry is now non zero for free ok so future calls to malloc will look at this block and	block	97
ok so one advantage of this implementation is that i can pass in completely erroneous point values and they won't have any effect because will never trigger this if statement but we could do even better than that we could even check to see if what you're passing in corresponds to a block that is currently in use in other words we could probably detect double freeze ok but the downside of course is that we had to walk the linked list and if my linked list is very large say millions of items then it's going to take a significant amount of time we don't have any cash coherency were pulling in from all different parts of memory pass we should do better than that will look at how to do that later on in this lecture	memory	625
ok so one advantage of this implementation is that i can pass in completely erroneous point values and they won't have any effect because will never trigger this if statement but we could do even better than that we could even check to see if what you're passing in corresponds to a block that is currently in use in other words we could probably detect double freeze ok but the downside of course is that we had to walk the linked list and if my linked list is very large say millions of items then it's going to take a significant amount of time we don't have any cash coherency were pulling in from all different parts of memory pass we should do better than that will look at how to do that later on in this lecture	block	283
you have to look longingly the outside of this box of chocolates ok you are not allowed have be yet why because process won't have it so you can see that when at some point versus one finishes it can continue but we got next ok it's a process four request d ok guys so let's do that process four i'm sorry you have to wait as well there we go and then process to main requests be ok so be get in line i'm sorry you're going to have to wait as well are we done not quite because now process one request see ok so let's draw that in a different color ok let's do this kind of light blue alright so process one request see ok we can sketch it in here here it is versus one before it can continue i didn't want to now i just wanted a straight line there we go right process one before is prepared to finish get through this quagmire of lines here there we go is waiting for this resource and now you can see where we've got deadlock process one is waiting for c but process resource c is being held by process two process two won't give it up because it's waiting for b and b is being held by process one so we've got a deadlock between process one and process two that's the cause of our deadlock that's the cycle in our weight for graph and i guess we could sketched out if we wanted to	a process	233
ok so it's this is all cycle goes down here up to here over here and then back up to here so it's like kind of bow tie again i guess that's the cause of all of our deadlock this fight over two resources b and c but it's not just process one and process two which unfortunately stuck process three will never get to see our resource be so it's stuck it's in deadlock and process for is also in deadlock because it's never going to get resource d as well	resources	193
ok so that's how resource allocation graphs can inform us as to why up machine is in deadlock we've simulated it just by kind of these kind of paper based examples but i hope you can imagine that in a more complicated system let's suppose you wanted to do a little video sales service i don't know let's call it netflix or something or maybe youtube lots of moving parts everything some captions to	system	218
to be able to take comments etc lots of pieces lots of synchronization you need to do if you wanted to understand why your service has got stuck due to deadlock you could actually replay the order in which you're acquiring resources and it doesn't even need to be on a single machine if you've got the storyline of the resources that you needed exclusive access to actually understand and debug and why your system kind of ground to a halt	resources	223
to be able to take comments etc lots of pieces lots of synchronization you need to do if you wanted to understand why your service has got stuck due to deadlock you could actually replay the order in which you're acquiring resources and it doesn't even need to be on a single machine if you've got the storyline of the resources that you needed exclusive access to actually understand and debug and why your system kind of ground to a halt	system	408
so synchronization wonderful thing we need it in order to make our data structures consistent sometimes we need it for hardware access but we have to be careful about deadlock alright so we've seen a few examples	a struct	70
i guess i i've been pulling it off but now i think it's actually time to talk a little bit about these address structures which we've been happily throwing around and not really worrying too much about what they look like	address	103
because getting drinks have get address info filled them out for us	address	32
if i was actually manually setting up one of these structs myself so if i wasn't actually relying on get address info to do the work for me	address	105
ok an to network to host long as well so this is long which is thirty two bits back from the day when lungs were thirty two bits and this is used to describe ip four addresses as well so if you wanted a numeric version of an ip four address and needed to convert it from the network implementation to number which is understood why we assume you'll be using this as well	address	166
c code which is compatible and it doesn't matter whether your cpu uses a little endian format a big endian format	code	2
the kind of lasting here is that a notice that accept has a couple of arguments that i'm not using i can actually use accept to tell me a little bit more about who is connecting so with every tcp socket we not only have the destination address we also have the source address so we know where that socket where that client is coming from i know its ip address and so if i wish i can make use of that so for example i could check your ip address and if you're connecting from a certain machine i might give you a version of the website which is out of date or i might deliberately give you a website which has thousands of links so you can keep clicking for anywhere and so you're poor robot will never escape this is recursive clicking how trying to troll my website and it will never find a way out ok	address	236
so i can do a lot with accept and i can i can perhaps if i find out your ip address i i might try to connect back to you to see what kind of servers are running on your machine ok so the summary however is these are the big four calls that we need	address	76
to make a server they are right so we've got a socket course we need to suck it then we need to bind it to a network card right after that we need to listen to basically open up shop to allow clients to connect and then finally we need to accept and we're going to put except inside a loop and accept is the only one of these calls which will block if there's no new clients to service with that i'm signing out and see you in a future video by	block	343
different clients and servers and it's easier to debug the actual connections which are happening over i'll tcp or udp connection and it's easier to write a specification which uses a simple text based protocol so for example if you want to get a web resource today you would make a connection to a server and you'd say hey server can you get me the following so let me get resource so if i just care about the home page then that is just slash if for example i want a particular subreddit page	the following	346
would actually have to write code to cope with the fact that packets might go missing but this is useful if you want for example to provide an interactive feedback as soon as the user starts typing something into the search part you want to be able to display immediately some potential results so that sounds to me like udp might be a great course so if you're prepared to employ a lots of great system programmers from say from illinois then if you don't mind that expense then udp gives you a lower latency response and besides if you're doing this just for incremental search is you don't care anyway if you drop a packet because in a moment the user is going to be typing another character anyway and so you can reissue a new search based on that new information right but most packets today for http are using tcp	code	29
would actually have to write code to cope with the fact that packets might go missing but this is useful if you want for example to provide an interactive feedback as soon as the user starts typing something into the search part you want to be able to display immediately some potential results so that sounds to me like udp might be a great course so if you're prepared to employ a lots of great system programmers from say from illinois then if you don't mind that expense then udp gives you a lower latency response and besides if you're doing this just for incremental search is you don't care anyway if you drop a packet because in a moment the user is going to be typing another character anyway and so you can reissue a new search based on that new information right but most packets today for http are using tcp	system	397
ok so that's a very short introduction to http we wrote in fact our very first piece of http right here where we request a picture of a cat and will be seeing more examples of this in the future but for now let's actually stop talking about conceptual stuff actually let's actually now make our own http so our own client inside some c code so let's actually start looking to see what network code looks like for real ok bye	code	336
p fit all the votes and what i mean by that is take a look at my original version which had this nested for loop what about if i said well artie or i'll make this activity this inner last for loop as something that one thread should do and so if i've got to say five hundred or so rows then why don't i just make five hundred threads ok so let's try this and what will have to do then is take these three lines of code here turn this into some little function let's call it to like like rolex is going to run a thread and somehow pass in the value of y right so let's	code	414
p fit all the votes and what i mean by that is take a look at my original version which had this nested for loop what about if i said well artie or i'll make this activity this inner last for loop as something that one thread should do and so if i've got to say five hundred or so rows then why don't i just make five hundred threads ok so let's try this and what will have to do then is take these three lines of code here turn this into some little function let's call it to like like rolex is going to run a thread and somehow pass in the value of y right so let's	a thread	509
p fit all the votes and what i mean by that is take a look at my original version which had this nested for loop what about if i said well artie or i'll make this activity this inner last for loop as something that one thread should do and so if i've got to say five hundred or so rows then why don't i just make five hundred threads ok so let's try this and what will have to do then is take these three lines of code here turn this into some little function let's call it to like like rolex is going to run a thread and somehow pass in the value of y right so let's	thread	219
right so here we go what do you think of the following right and this is definitely a very hacky way to do it so here's what we'll do we will have a little loop here	the following	41
and my little loop will know when i call pizza create i have to pass in a void pointer but what if that void pointer actually was just the y value in other words somehow will take the value that we want to give to a thread and convert it into just the void pointer type so we're literally just casting it pretending that the values zero is a memory location pretending that value one is a memory location etc so we're not actually passing in the address of a real piece of memory we're just converting the integer into a void pointer into a memory pointer we have to do the same hack when we receive this information so we've asked thread create to start a thread and to get a new cpu for us to run this calc one so what is calc one here it is ok and the value that we pass into hack here so here's hack which is going to appear here that's going to be passed into this variable here avoid pointed here and rather than try to dereference that no we're treating that memory location that address as the actual integer that we want ok so we're passing it casting it back into it so this is an exciting hack honestly we have no true way to know whether enters officially going to be as large or smaller than what can be represented by a void pointer i certainly wouldn't recommend this in production code but i hope you can see how it works and certainly you will come across these kind	memory	342
and my little loop will know when i call pizza create i have to pass in a void pointer but what if that void pointer actually was just the y value in other words somehow will take the value that we want to give to a thread and convert it into just the void pointer type so we're literally just casting it pretending that the values zero is a memory location pretending that value one is a memory location etc so we're not actually passing in the address of a real piece of memory we're just converting the integer into a void pointer into a memory pointer we have to do the same hack when we receive this information so we've asked thread create to start a thread and to get a new cpu for us to run this calc one so what is calc one here it is ok and the value that we pass into hack here so here's hack which is going to appear here that's going to be passed into this variable here avoid pointed here and rather than try to dereference that no we're treating that memory location that address as the actual integer that we want ok so we're passing it casting it back into it so this is an exciting hack honestly we have no true way to know whether enters officially going to be as large or smaller than what can be represented by a void pointer i certainly wouldn't recommend this in production code but i hope you can see how it works and certainly you will come across these kind	type	265
and my little loop will know when i call pizza create i have to pass in a void pointer but what if that void pointer actually was just the y value in other words somehow will take the value that we want to give to a thread and convert it into just the void pointer type so we're literally just casting it pretending that the values zero is a memory location pretending that value one is a memory location etc so we're not actually passing in the address of a real piece of memory we're just converting the integer into a void pointer into a memory pointer we have to do the same hack when we receive this information so we've asked thread create to start a thread and to get a new cpu for us to run this calc one so what is calc one here it is ok and the value that we pass into hack here so here's hack which is going to appear here that's going to be passed into this variable here avoid pointed here and rather than try to dereference that no we're treating that memory location that address as the actual integer that we want ok so we're passing it casting it back into it so this is an exciting hack honestly we have no true way to know whether enters officially going to be as large or smaller than what can be represented by a void pointer i certainly wouldn't recommend this in production code but i hope you can see how it works and certainly you will come across these kind	code	1297
and my little loop will know when i call pizza create i have to pass in a void pointer but what if that void pointer actually was just the y value in other words somehow will take the value that we want to give to a thread and convert it into just the void pointer type so we're literally just casting it pretending that the values zero is a memory location pretending that value one is a memory location etc so we're not actually passing in the address of a real piece of memory we're just converting the integer into a void pointer into a memory pointer we have to do the same hack when we receive this information so we've asked thread create to start a thread and to get a new cpu for us to run this calc one so what is calc one here it is ok and the value that we pass into hack here so here's hack which is going to appear here that's going to be passed into this variable here avoid pointed here and rather than try to dereference that no we're treating that memory location that address as the actual integer that we want ok so we're passing it casting it back into it so this is an exciting hack honestly we have no true way to know whether enters officially going to be as large or smaller than what can be represented by a void pointer i certainly wouldn't recommend this in production code but i hope you can see how it works and certainly you will come across these kind	a thread	214
and my little loop will know when i call pizza create i have to pass in a void pointer but what if that void pointer actually was just the y value in other words somehow will take the value that we want to give to a thread and convert it into just the void pointer type so we're literally just casting it pretending that the values zero is a memory location pretending that value one is a memory location etc so we're not actually passing in the address of a real piece of memory we're just converting the integer into a void pointer into a memory pointer we have to do the same hack when we receive this information so we've asked thread create to start a thread and to get a new cpu for us to run this calc one so what is calc one here it is ok and the value that we pass into hack here so here's hack which is going to appear here that's going to be passed into this variable here avoid pointed here and rather than try to dereference that no we're treating that memory location that address as the actual integer that we want ok so we're passing it casting it back into it so this is an exciting hack honestly we have no true way to know whether enters officially going to be as large or smaller than what can be represented by a void pointer i certainly wouldn't recommend this in production code but i hope you can see how it works and certainly you will come across these kind	thread	216
and my little loop will know when i call pizza create i have to pass in a void pointer but what if that void pointer actually was just the y value in other words somehow will take the value that we want to give to a thread and convert it into just the void pointer type so we're literally just casting it pretending that the values zero is a memory location pretending that value one is a memory location etc so we're not actually passing in the address of a real piece of memory we're just converting the integer into a void pointer into a memory pointer we have to do the same hack when we receive this information so we've asked thread create to start a thread and to get a new cpu for us to run this calc one so what is calc one here it is ok and the value that we pass into hack here so here's hack which is going to appear here that's going to be passed into this variable here avoid pointed here and rather than try to dereference that no we're treating that memory location that address as the actual integer that we want ok so we're passing it casting it back into it so this is an exciting hack honestly we have no true way to know whether enters officially going to be as large or smaller than what can be represented by a void pointer i certainly wouldn't recommend this in production code but i hope you can see how it works and certainly you will come across these kind	address	446
and my little loop will know when i call pizza create i have to pass in a void pointer but what if that void pointer actually was just the y value in other words somehow will take the value that we want to give to a thread and convert it into just the void pointer type so we're literally just casting it pretending that the values zero is a memory location pretending that value one is a memory location etc so we're not actually passing in the address of a real piece of memory we're just converting the integer into a void pointer into a memory pointer we have to do the same hack when we receive this information so we've asked thread create to start a thread and to get a new cpu for us to run this calc one so what is calc one here it is ok and the value that we pass into hack here so here's hack which is going to appear here that's going to be passed into this variable here avoid pointed here and rather than try to dereference that no we're treating that memory location that address as the actual integer that we want ok so we're passing it casting it back into it so this is an exciting hack honestly we have no true way to know whether enters officially going to be as large or smaller than what can be represented by a void pointer i certainly wouldn't recommend this in production code but i hope you can see how it works and certainly you will come across these kind	pointer	79
of hacks again in the future if you ever look at someone elses code alright so that's kind of an interesting idea we will play with this in a moment and then let's see what this calc want does ok so it then just runs through all values of x so for a particular value of why we are going to run through an calculate them and walk for that ok so each thread is going to run from left to right filling in my pixels and in this case my pixels is just a global variable so we can see it from any threat ok so let's run this	code	63
of hacks again in the future if you ever look at someone elses code alright so that's kind of an interesting idea we will play with this in a moment and then let's see what this calc want does ok so it then just runs through all values of x so for a particular value of why we are going to run through an calculate them and walk for that ok so each thread is going to run from left to right filling in my pixels and in this case my pixels is just a global variable so we can see it from any threat ok so let's run this	thread	349
well hopefully you notice something about our calculation here which is that not all rows are created equal in this case that some rows are not going to require that much computation because we get out of our little man a bootloop really really early that for each of these pixels up here at the very top and the bottom of the picture we didn't need to do many iterations before we discovered we had a value greater than two versus this centerline most of these are going to be running for the full eight thousand iterations before we give up playing the game for that particular pixel so this particular row takes a long time but we assigned it to one thread it's not like we can ask a different part of our cpu to now split that job into two so though it works we've got some limitations that the speed of this is limited to the waiting for this slowest row here perhaps we could do a little bit better by splitting this up into different regions second comment on this is creating this many threads five hundred threads	thread	653
is exciting model systems are going to support that or at least you might run into some limits on the shared system would be fun to see what happens if we run this for example on a shared linux system there it wouldn't surprise me if there's been some limits set up to say no i'm sorry i'm going to let you one five hundred threads	thread	324
is exciting model systems are going to support that or at least you might run into some limits on the shared system would be fun to see what happens if we run this for example on a shared linux system there it wouldn't surprise me if there's been some limits set up to say no i'm sorry i'm going to let you one five hundred threads	system	18
so to get this job done are real cpus actually had to jump from one active thread to another active thread but it does that so quickly that we don't notice i'll run it once more again so we can actually see the output	thread	75
ok so this is going to be a story of the child not paying for the parents sins and kind of the best analogy i could think of so here's what we're going to do is we're going to make a process it sends a signal to itself and then it will see what happens after forking when will let both the parent and child lower the drawbridge so here's our plan is that will first of all set up signal set will say ok should be empty and then we'll add one signal to uitsig it ok so we're going to block that signal right so now the sig pop mask i can say something like cig say set mask to say right don't let siggins be delivered they're going to have to stay pending outside right now rather than me trying to press ctrl	block	483
ok so this is going to be a story of the child not paying for the parents sins and kind of the best analogy i could think of so here's what we're going to do is we're going to make a process it sends a signal to itself and then it will see what happens after forking when will let both the parent and child lower the drawbridge so here's our plan is that will first of all set up signal set will say ok should be empty and then we'll add one signal to uitsig it ok so we're going to block that signal right so now the sig pop mask i can say something like cig say set mask to say right don't let siggins be delivered they're going to have to stay pending outside right now rather than me trying to press ctrl	a process	181
ok and i don't care about what it used to be i already know that right so i'm going to allow both the chip parent and the child from now to have cigarettes be delivered what's going to happen to them ok so if we get this far then one of them will print child 's life and one of them open to parents alive so let's see what happens ok so i've got that code	code	351
where are you ok pending yeah pending folk right so same code the only difference is our game using sick term in this little demo but other than that same idea that at some point we lower the drawbridge ok after the fork ok so let's run this we gotta pending fork here right	code	57
k and you'll see that we raised we blocked sigterm then we raised it so we've generated that signal kay but because we blocked it is not yet delivered it's in this pending state ok so now my two little process is the original one and the child are resetting the process mask what is going to happen and you'll see that surprisingly the child is carries on the child is not stopped	block	35
the last demo thick today is yeah ok will use signal sig wait so this is my view one of the cleanest ways to actually work with signals especially if you're working with multithreaded code because what you can do is actually set up a separate thread whose job it is to synchronously work with each signal as it appears so you might remember that welcome back there we get that before with things like signal and cig action we said well that code that we put inside the signal handler let me try spell sick action here there we go	code	184
the last demo thick today is yeah ok will use signal sig wait so this is my view one of the cleanest ways to actually work with signals especially if you're working with multithreaded code because what you can do is actually set up a separate thread whose job it is to synchronously work with each signal as it appears so you might remember that welcome back there we get that before with things like signal and cig action we said well that code that we put inside the signal handler let me try spell sick action here there we go	thread	175
these guys will set up a little function little handler when that's called asynchronously but we're really limited about what we can do inside that we can't use of any code that calls malloc for example there's a very limited number of system calls that were allowed to use there's even the mutex locks the whole order stuff we just can't use inside our signal handlers why because we've temporarily interrupting our other code and that might be deep inside that other code already in that code is not re enterable so a better way to do this is to actually just have a thread that pulls off the next signal and it just behaves like any normal regular thread so let's see how we can use this here's the big idea is to use	code	168
these guys will set up a little function little handler when that's called asynchronously but we're really limited about what we can do inside that we can't use of any code that calls malloc for example there's a very limited number of system calls that were allowed to use there's even the mutex locks the whole order stuff we just can't use inside our signal handlers why because we've temporarily interrupting our other code and that might be deep inside that other code already in that code is not re enterable so a better way to do this is to actually just have a thread that pulls off the next signal and it just behaves like any normal regular thread so let's see how we can use this here's the big idea is to use	a thread	567
these guys will set up a little function little handler when that's called asynchronously but we're really limited about what we can do inside that we can't use of any code that calls malloc for example there's a very limited number of system calls that were allowed to use there's even the mutex locks the whole order stuff we just can't use inside our signal handlers why because we've temporarily interrupting our other code and that might be deep inside that other code already in that code is not re enterable so a better way to do this is to actually just have a thread that pulls off the next signal and it just behaves like any normal regular thread so let's see how we can use this here's the big idea is to use	thread	569
these guys will set up a little function little handler when that's called asynchronously but we're really limited about what we can do inside that we can't use of any code that calls malloc for example there's a very limited number of system calls that were allowed to use there's even the mutex locks the whole order stuff we just can't use inside our signal handlers why because we've temporarily interrupting our other code and that might be deep inside that other code already in that code is not re enterable so a better way to do this is to actually just have a thread that pulls off the next signal and it just behaves like any normal regular thread so let's see how we can use this here's the big idea is to use	system	236
and this will tell me when it returns what signal has just been delivered and so signal weight is a way to standard the drawbridge munching signals one at a time as they come over but we want to make sure that the signals that we care about only delivered to this particular thread so we better pull up any of the other drawbridges ok so that's what we're going to do here inside my main thread i don't want my main thread to ever have to worry about getting a signal hey i don't want any signals being delivered to it so the first thing i'm going to do inside my main method here my main function so is to set a cig mask to say hey block all these signals in fact block sigterm blocks eginton if i wish i could walk a whole other brothers right so this this mask here is then used to say right ok on the main thread it pulled up this drawbridge so we cannot deliver these signals to the main thread	block	633
and this will tell me when it returns what signal has just been delivered and so signal weight is a way to standard the drawbridge munching signals one at a time as they come over but we want to make sure that the signals that we care about only delivered to this particular thread so we better pull up any of the other drawbridges ok so that's what we're going to do here inside my main thread i don't want my main thread to ever have to worry about getting a signal hey i don't want any signals being delivered to it so the first thing i'm going to do inside my main method here my main function so is to set a cig mask to say hey block all these signals in fact block sigterm blocks eginton if i wish i could walk a whole other brothers right so this this mask here is then used to say right ok on the main thread it pulled up this drawbridge so we cannot deliver these signals to the main thread	thread	275
ok after we've done that we're going to create lots of threads and one of them will be our very special thread that's designed to handle signals synchronously one at a time so when we call p thread create initially	thread	55
the new threads get a copy of the same signal mask so initially we got all these threads and all the drawbridges are up but this is where our signal weight comes in so sigwait provides a mechanism to say	thread	8
hey i care about some specific signals if they're outside if they are pending then i'm going to eat them one at a time ok just tell me about one of them so in this case as you can see we are going to we're going to sell tell sick wait two kinds of signals that we care about sigint or sigterm for example and guess what that actually happens to be exactly how we set up the mask earlier so great let's use the same mask and then when this will block until the day that a signal is is delivered to sgwait just write regular code and now we can put things like printf and file code and other normal code inside here we don't have to worry about whether it's signal safe anymore so let's actually have a look at that code and you'll notice by the way that yet we we have this inside a little loop because after we've consumed one signal we want to go around again and seeing the next one ok so where is that here's my sig weight demo	block	444
hey i care about some specific signals if they're outside if they are pending then i'm going to eat them one at a time ok just tell me about one of them so in this case as you can see we are going to we're going to sell tell sick wait two kinds of signals that we care about sigint or sigterm for example and guess what that actually happens to be exactly how we set up the mask earlier so great let's use the same mask and then when this will block until the day that a signal is is delivered to sgwait just write regular code and now we can put things like printf and file code and other normal code inside here we don't have to worry about whether it's signal safe anymore so let's actually have a look at that code and you'll notice by the way that yet we we have this inside a little loop because after we've consumed one signal we want to go around again and seeing the next one ok so where is that here's my sig weight demo	the mask	370
hey i care about some specific signals if they're outside if they are pending then i'm going to eat them one at a time ok just tell me about one of them so in this case as you can see we are going to we're going to sell tell sick wait two kinds of signals that we care about sigint or sigterm for example and guess what that actually happens to be exactly how we set up the mask earlier so great let's use the same mask and then when this will block until the day that a signal is is delivered to sgwait just write regular code and now we can put things like printf and file code and other normal code inside here we don't have to worry about whether it's signal safe anymore so let's actually have a look at that code and you'll notice by the way that yet we we have this inside a little loop because after we've consumed one signal we want to go around again and seeing the next one ok so where is that here's my sig weight demo	code	523
hey i care about some specific signals if they're outside if they are pending then i'm going to eat them one at a time ok just tell me about one of them so in this case as you can see we are going to we're going to sell tell sick wait two kinds of signals that we care about sigint or sigterm for example and guess what that actually happens to be exactly how we set up the mask earlier so great let's use the same mask and then when this will block until the day that a signal is is delivered to sgwait just write regular code and now we can put things like printf and file code and other normal code inside here we don't have to worry about whether it's signal safe anymore so let's actually have a look at that code and you'll notice by the way that yet we we have this inside a little loop because after we've consumed one signal we want to go around again and seeing the next one ok so where is that here's my sig weight demo	printf	559
i'm going to each time around the loop called course equates then find out which signal happens and then print something out so	the loop	30
meanwhile ok my main thread is doing a big calculation it's just counting counting down i think problems fully septa again nine problems initially or so and it's just going to print out some docs as it works but now because i've used sick wait i can actually do things like print out use print f to actually print out useful information about my process ok so let's run this weight demo	thread	21
so of it goes to main thread is turning away and i press control c and you can see it's responding to my different signals automatically on the thread so this in fact is the very way that java works java actually sets up a special thread just account of handle signals so remember this later next time you decide to start your own language you decide to javascript is not the language for you or you're starting a gnu system and you need to quickly a new interpreter you might need another thread to	thread	22
so of it goes to main thread is turning away and i press control c and you can see it's responding to my different signals automatically on the thread so this in fact is the very way that java works java actually sets up a special thread just account of handle signals so remember this later next time you decide to start your own language you decide to javascript is not the language for you or you're starting a gnu system and you need to quickly a new interpreter you might need another thread to	system	418
oops we we need one more for pb then we have pc right pc you are going to be these three blocks here ok right and then we got the free space at the end ok so right so i won't bother to put all the little lines in to indicate this 'cause we've seen it so many times but you could understand that we're going to link lists which is holding this representation right so then we free pb rights and now this becomes a free space for available for future allocations i can give you that space providing you don't want more than four kb ok so what comes in next we have allocation request for let's choose a nice color here asking for this ok so we have an allocation for three kilobytes ok now we're doing first fit and the first fit is the scrappy doo approach here which is that let's just find an entry inside of linked list that is which works and as soon as we can find a viable one let's stop so will go through linked list the first entry that's no good because i actually corresponds to a piece of memory that is in use but our second entry ok we're bouncing along tile link list and we're iterating through it our second entry is of size four which is fine we only need three kilobytes so we're done we don't need to look any further through our link list so we do the usual thing of look we can split this up so will split up the three kilobytes so will split it into a three kilobyte which is going to be available for the caller and rpd will point to their beginning of that right and into our linked list we will have a new entry here with the one kilobyte which is remaining here ok and then what happens next right so then	memory	1000
oops we we need one more for pb then we have pc right pc you are going to be these three blocks here ok right and then we got the free space at the end ok so right so i won't bother to put all the little lines in to indicate this 'cause we've seen it so many times but you could understand that we're going to link lists which is holding this representation right so then we free pb rights and now this becomes a free space for available for future allocations i can give you that space providing you don't want more than four kb ok so what comes in next we have allocation request for let's choose a nice color here asking for this ok so we have an allocation for three kilobytes ok now we're doing first fit and the first fit is the scrappy doo approach here which is that let's just find an entry inside of linked list that is which works and as soon as we can find a viable one let's stop so will go through linked list the first entry that's no good because i actually corresponds to a piece of memory that is in use but our second entry ok we're bouncing along tile link list and we're iterating through it our second entry is of size four which is fine we only need three kilobytes so we're done we don't need to look any further through our link list so we do the usual thing of look we can split this up so will split up the three kilobytes so will split it into a three kilobyte which is going to be available for the caller and rpd will point to their beginning of that right and into our linked list we will have a new entry here with the one kilobyte which is remaining here ok and then what happens next right so then	block	89
ok so how do we do with first fit well you can see that our fragmentation in this example has three three bits of fragmentation we've got some memory here's some free space here some three space here so even though i've got let's see two plus three two plus one is three i've got my six kilobytes space here then old altogether so if you wanted six kilobytes of contiguous memory i cannot satisfy that request	memory	143
'cause my my memory use is fragmented ok so right is there anything else we want to say about this yeah there's a few other things ok so first of all there was a little detail that you may not have noticed earlier which was if something fits perfectly so if for example i now called another request for	memory	13
let's say three kilobytes and so here's a the only place that we could put it right so we could we would mark this areas in use it would be while the city in our code to split this into a three killer by entry which is in use and a zero kilobyte entry which is now available there's no point having entries inside the the link list which corresponds to zero kb all they do is they just slow	code	162
hi, so a big idea is that most file system devices are what note is known as block based devices meaning that at the hardware level we don't ask for a single bite from a disk instead we have a convention and we say you know i'd like give me the first block of bytes please will give me the second block of bytes or i'd like to update this block of bytes with some new values so for performance reasons we don't make requests down to just very small units we much prefer to say to a disk system an external system gave me a whole bunch of bikes and useful ideas to make the same disk blocks the same size as our memory blocks in fact what we're going to see is all over our system examples where the blocks are based around four kilobyte chunks	memory	611
hi, so a big idea is that most file system devices are what note is known as block based devices meaning that at the hardware level we don't ask for a single bite from a disk instead we have a convention and we say you know i'd like give me the first block of bytes please will give me the second block of bytes or i'd like to update this block of bytes with some new values so for performance reasons we don't make requests down to just very small units we much prefer to say to a disk system an external system gave me a whole bunch of bikes and useful ideas to make the same disk blocks the same size as our memory blocks in fact what we're going to see is all over our system examples where the blocks are based around four kilobyte chunks	block	77
hi, so a big idea is that most file system devices are what note is known as block based devices meaning that at the hardware level we don't ask for a single bite from a disk instead we have a convention and we say you know i'd like give me the first block of bytes please will give me the second block of bytes or i'd like to update this block of bytes with some new values so for performance reasons we don't make requests down to just very small units we much prefer to say to a disk system an external system gave me a whole bunch of bikes and useful ideas to make the same disk blocks the same size as our memory blocks in fact what we're going to see is all over our system examples where the blocks are based around four kilobyte chunks	system	36
or you will find examples where the chunks are slightly smaller and also we can talk about blocks or super block such a much larger today but let's let's concentrate on this main convention here so in other words i'm throwing around four thousand ninety six bytes anytime i want to load or read something from the disk so you've probably been talking about kind of cache lines and this idea that if you make a request in main memory	memory	426
or you will find examples where the chunks are slightly smaller and also we can talk about blocks or super block such a much larger today but let's let's concentrate on this main convention here so in other words i'm throwing around four thousand ninety six bytes anytime i want to load or read something from the disk so you've probably been talking about kind of cache lines and this idea that if you make a request in main memory	block	91
for one byte you're going to get say the whole cache line which might be sixty four bytes or thirty two bites or hundred depending on the system whole load of bytes are free they all come across right depending on the width of the actual physical number of lines between main memory in your cpu so you get all these bits for free	memory	276
for one byte you're going to get say the whole cache line which might be sixty four bytes or thirty two bites or hundred depending on the system whole load of bytes are free they all come across right depending on the width of the actual physical number of lines between main memory in your cpu so you get all these bits for free	system	138
so the same thing applies for our fault based systems and we are kind of at the lowest level saying hey i want to send a block of data tool for my device so why do we make these same size is my virtual memory is because think back to our virtual memory table where i needed to have a mapping from virtual addresses to physical addresses and the very first thing we did is we took our	memory	202
so the same thing applies for our fault based systems and we are kind of at the lowest level saying hey i want to send a block of data tool for my device so why do we make these same size is my virtual memory is because think back to our virtual memory table where i needed to have a mapping from virtual addresses to physical addresses and the very first thing we did is we took our	block	121
so the same thing applies for our fault based systems and we are kind of at the lowest level saying hey i want to send a block of data tool for my device so why do we make these same size is my virtual memory is because think back to our virtual memory table where i needed to have a mapping from virtual addresses to physical addresses and the very first thing we did is we took our	address	305
so the same thing applies for our fault based systems and we are kind of at the lowest level saying hey i want to send a block of data tool for my device so why do we make these same size is my virtual memory is because think back to our virtual memory table where i needed to have a mapping from virtual addresses to physical addresses and the very first thing we did is we took our	system	46
physical memory and divided it up into these chunks into these rammed into these disk sort into these memory blocks here and we needed to do things like say well these bites right now i don't care about no one seems to be using word to paginate tables so all that code inside here is just wasting ram so why don't i evicted out of my memory meanwhile i've got some other stuff that i would like to have inside my ram inside my memory so i want to page that into from disk into memory maybe it's some code that i now need maybe it's part of a data structure that i haven't needed for several minutes	memory	9
physical memory and divided it up into these chunks into these rammed into these disk sort into these memory blocks here and we needed to do things like say well these bites right now i don't care about no one seems to be using word to paginate tables so all that code inside here is just wasting ram so why don't i evicted out of my memory meanwhile i've got some other stuff that i would like to have inside my ram inside my memory so i want to page that into from disk into memory maybe it's some code that i now need maybe it's part of a data structure that i haven't needed for several minutes	block	109
physical memory and divided it up into these chunks into these rammed into these disk sort into these memory blocks here and we needed to do things like say well these bites right now i don't care about no one seems to be using word to paginate tables so all that code inside here is just wasting ram so why don't i evicted out of my memory meanwhile i've got some other stuff that i would like to have inside my ram inside my memory so i want to page that into from disk into memory maybe it's some code that i now need maybe it's part of a data structure that i haven't needed for several minutes	a struct	545
physical memory and divided it up into these chunks into these rammed into these disk sort into these memory blocks here and we needed to do things like say well these bites right now i don't care about no one seems to be using word to paginate tables so all that code inside here is just wasting ram so why don't i evicted out of my memory meanwhile i've got some other stuff that i would like to have inside my ram inside my memory so i want to page that into from disk into memory maybe it's some code that i now need maybe it's part of a data structure that i haven't needed for several minutes	code	264
but now i'm starting to work on that part of the document or now i'm rendering this now i'm inside of game inside a new area of the world it's time to bring that stuff into memory so we want to be able to make our disk blocks on line it neatly with our memory blocks and like i said for most operations today we're going to be talking about four kilobyte blocks as our standard unit in practice systems might actually support smaller blocks for example a hundred and twenty eight bytes often owners sectors but we're going to ignore those particular implementation dipped implementation details and all will stick with four kb 's are kind of standard unit when we kind of work through some examples	memory	173
but now i'm starting to work on that part of the document or now i'm rendering this now i'm inside of game inside a new area of the world it's time to bring that stuff into memory so we want to be able to make our disk blocks on line it neatly with our memory blocks and like i said for most operations today we're going to be talking about four kilobyte blocks as our standard unit in practice systems might actually support smaller blocks for example a hundred and twenty eight bytes often owners sectors but we're going to ignore those particular implementation dipped implementation details and all will stick with four kb 's are kind of standard unit when we kind of work through some examples	block	219
but now i'm starting to work on that part of the document or now i'm rendering this now i'm inside of game inside a new area of the world it's time to bring that stuff into memory so we want to be able to make our disk blocks on line it neatly with our memory blocks and like i said for most operations today we're going to be talking about four kilobyte blocks as our standard unit in practice systems might actually support smaller blocks for example a hundred and twenty eight bytes often owners sectors but we're going to ignore those particular implementation dipped implementation details and all will stick with four kb 's are kind of standard unit when we kind of work through some examples	system	395
wait so with this in mind given that i can now store a file by saying right let's store the contents in block number seven block number nine block number eleven twelve fifteen etc let's think about what else you want to store about the file so obviously for each file that we want to store we've actually got the content statue of bytes of the file but what else would you like	block	104
so we might want to say if you are the following user you can read it if you are the following user you can write it if this user belongs to a certain group you can delete it so the simplest form in linux today considers users to be in three different kinds we have the owner we have	the following	35
eddie access the tool so that's the simplest kind of access control that we might have there are more complicated versions today in other file systems what else could we have well in addition to the actual contents we've probably care about its eyes are some interesting meta information	system	143
cape we might care about the mind type so what kind of thing is this file and today we represent that using these types for example we've already seen a few of these we have things like if it's an html file then it's my type is text slash html we can have a mind type for images in my own type for gifts for jeffs depending how you'd like to pronounce it we have a mind type of jpeg images we have a my type of a word documents etc so these are all different types of files	type	34
ok so we might care about how often or how recently these events occured we also might care about who as well so pass we want to keep an audit log of who created it who modified it and who accessed it modern linux systems	system	214
we could also store things like how about its name ok so presumably off file is going to exist and we need to build a refer it we don't want to keep saying hey why don't we load file number seven while file number eight he let me share file number ten with you we like to give our files some kind of name we also might want to store some other additional matter information so we might have kind of search meter information so for example there might be key value pairs like who is the artist if it was a gps coordinates of where something was stored or found maybe if it was an image say the camera settings lens you used that kind of stuff ok so we can have an arbitrary key value pairs to help come searching right so we could kind of keep going on here and we could keep kind of brainstorming a whole load of things that we might want to store about the file but i want to kind of simplify it back down to linux does and what we see in most file systems ok right so	system	950
really used in fact it disabled because we may for performance reasons not want to keep updating our disk all solid state drive every time someone touches a file so every time someone reads a file access control like i've already mentioned is kind of simplified down to just kind of a single group single owner and everybody else yes we definitely want the size yes of course we want the contents but no we don't use mine types so as much as mine types would be useful today we have much clunkier system which is to either look at the extension so for example will claim that a file that ends with say gi f is a gift or jeff dot png is a png file that kind of thing or maybe we could have dosey is a microsoft word document so will just look at some extension or we might look at the first few bytes of the file and try to infer from those bytes as to what it's likely to be but both of these systems are kind of clunky compared to actually having real mayo types	type	422
really used in fact it disabled because we may for performance reasons not want to keep updating our disk all solid state drive every time someone touches a file so every time someone reads a file access control like i've already mentioned is kind of simplified down to just kind of a single group single owner and everybody else yes we definitely want the size yes of course we want the contents but no we don't use mine types so as much as mine types would be useful today we have much clunkier system which is to either look at the extension so for example will claim that a file that ends with say gi f is a gift or jeff dot png is a png file that kind of thing or maybe we could have dosey is a microsoft word document so will just look at some extension or we might look at the first few bytes of the file and try to infer from those bytes as to what it's likely to be but both of these systems are kind of clunky compared to actually having real mayo types	system	497
the other thing we're going to have is always nice meta search informations or regular filesystems don't give us that but here's the big one that i want to kind of surprise you with is that	system	91
yes has contents has size has some of this kind of meta information but it does not have a name instead what we're going to discover it is our file has this wonderful thing called and i know number so that is going to replace how we think about data being stored on a disk and a name is just something that which lives inside directory listing so if you happen to be inside particular directory for example you happen to be inside say directory called sub two then inside that particular directory there's going to be a whole load of names that school directory listing an each name is going to map two and i'd known number so the i node number becomes the authorative way to talk about a particular file on a particular file system name is just a kind of secondary add on our name is just a cute way for us to be able to have	system	726
so in other words were which dis blocks should i go to to actually start reading the contents of my cat dot jpeg so	block	33
ok so if you're google with a lot of servers in a lot of bandwidth you care about using those efficiently you also care about getting information as fast as possible back to users so for example even a ten twenty millisecond delay which is barely perceptible is enough to make fewer people actually use fewer search results and if your google you really care about making sure your search results are as valuable as possible secondly us think about today about if you're searching as you type google wants to send you information back with suggested search terms search queries and it can do that at the speed at which you can type which is incredible so you can actually find things on the web faster than you can even find them on your local disk so we need a fast efficient way to be able to connect send that information to google and get it back so as a headline this is why quick was invented	type	488
so we saw this in various forms where say you wanted to get a web page and we use this as motivation for h t p two to say hey we should be able to get all these resources at the same time hey we solve the problem well we haven't solved entire problem because beneath http two we were still running on tcp and this thing back to what tcp did ttp says great we've got these packets arriving and the kernal 'is going to assemble them into the correct order ok so we could use this sequence number for that but then a packet is missing meanwhile other packets continue to arrive	resources	161
your call to read were block right here until we get this information and only then will all of these other packets be sent so google kind of rejected this instead we can do better if we start with udp we can actually implement all of the transmission control and resending control	block	23
directly as part of our user process and besides if we own both ends we can evaluate and evolve new ideas about how that could work better faster than we could and then if it's a kernel code an formal protocol low level protocol like tcp that everybody relies on	code	186
ok so we've kind of talked a little bit about this idea before so it could i implement p thread mutex lock just by disabling interrupts on on the cpu so the idea here is that if my code is running on the cpu if i disable interrupts then i cannot be stopped become agent smith out of the matrix that now i own the cpu so no one else can can take it for me so one of the limitations of this first of all that yes we can ensure that we're the only ones going into the critical section if one there is only one cpu	code	181
ok so we've kind of talked a little bit about this idea before so it could i implement p thread mutex lock just by disabling interrupts on on the cpu so the idea here is that if my code is running on the cpu if i disable interrupts then i cannot be stopped become agent smith out of the matrix that now i own the cpu so no one else can can take it for me so one of the limitations of this first of all that yes we can ensure that we're the only ones going into the critical section if one there is only one cpu	section	474
ok so we've kind of talked a little bit about this idea before so it could i implement p thread mutex lock just by disabling interrupts on on the cpu so the idea here is that if my code is running on the cpu if i disable interrupts then i cannot be stopped become agent smith out of the matrix that now i own the cpu so no one else can can take it for me so one of the limitations of this first of all that yes we can ensure that we're the only ones going into the critical section if one there is only one cpu	thread	89
ok so if i control the one and only cpu and i cannot be interrupted then i get to do everything inside the critical section until i give up the cpu ok so providing i don't make any system calls providing i'm just updating my data structure no one can stop me because i disabled into apps	a struct	228
ok so if i control the one and only cpu and i cannot be interrupted then i get to do everything inside the critical section until i give up the cpu ok so providing i don't make any system calls providing i'm just updating my data structure no one can stop me because i disabled into apps	section	116
ok so if i control the one and only cpu and i cannot be interrupted then i get to do everything inside the critical section until i give up the cpu ok so providing i don't make any system calls providing i'm just updating my data structure no one can stop me because i disabled into apps	system	181
ok the second is that i require an here's a big problem here is that actually require sufficient privileges to disable the interrupts and because this is such a powerful operation by default that is disabled for normal user programs we need interrupts in order to make a cpu stop running one thread and start running another in order to handle hardware interrupt you too do to devices iot devices being ready to either take data from the system or give data from the system for example the network card might report that her new packages arrived and here's some data or a disk or solid state disk might report hey i've now finally got the data you can now read this into memory or gpu might ask for more memory more data so there's lots	memory	671
ok the second is that i require an here's a big problem here is that actually require sufficient privileges to disable the interrupts and because this is such a powerful operation by default that is disabled for normal user programs we need interrupts in order to make a cpu stop running one thread and start running another in order to handle hardware interrupt you too do to devices iot devices being ready to either take data from the system or give data from the system for example the network card might report that her new packages arrived and here's some data or a disk or solid state disk might report hey i've now finally got the data you can now read this into memory or gpu might ask for more memory more data so there's lots	thread	292
ok the second is that i require an here's a big problem here is that actually require sufficient privileges to disable the interrupts and because this is such a powerful operation by default that is disabled for normal user programs we need interrupts in order to make a cpu stop running one thread and start running another in order to handle hardware interrupt you too do to devices iot devices being ready to either take data from the system or give data from the system for example the network card might report that her new packages arrived and here's some data or a disk or solid state disk might report hey i've now finally got the data you can now read this into memory or gpu might ask for more memory more data so there's lots	system	438
of reasons why we in over a normal complex system we cannot just disable disable interrupts ok so this	system	43
is one solution to the critical section but like i said it's not a generally useful solution to the critical section we need to find a way to be able to kind of implement these correctly and will talk about some algorithmic concerns about that in the future instead now is what i've got a real challenge for you which is i want to implement a barrier in fact i'm going to give you all the code that you need here it is i just want to implement a barrier that will wait until five threads call this method called this function and i've got to keep track of how many there we go and all i'm going to give you is the following code which uses a counting semaphore so you get to choose how what you would like to implement what you'd like to to initialize is counting semaphore with and all you have to do is rearrange these lines enter the correct order so that's my challenge to you pause this video and see if you can work it out i'll give you the solution next video but before you do that make some brain new brain cell connections and actually think about how you're going to rearrange this code to the actually works by	the following	610
is one solution to the critical section but like i said it's not a generally useful solution to the critical section we need to find a way to be able to kind of implement these correctly and will talk about some algorithmic concerns about that in the future instead now is what i've got a real challenge for you which is i want to implement a barrier in fact i'm going to give you all the code that you need here it is i just want to implement a barrier that will wait until five threads call this method called this function and i've got to keep track of how many there we go and all i'm going to give you is the following code which uses a counting semaphore so you get to choose how what you would like to implement what you'd like to to initialize is counting semaphore with and all you have to do is rearrange these lines enter the correct order so that's my challenge to you pause this video and see if you can work it out i'll give you the solution next video but before you do that make some brain new brain cell connections and actually think about how you're going to rearrange this code to the actually works by	code	389
is one solution to the critical section but like i said it's not a generally useful solution to the critical section we need to find a way to be able to kind of implement these correctly and will talk about some algorithmic concerns about that in the future instead now is what i've got a real challenge for you which is i want to implement a barrier in fact i'm going to give you all the code that you need here it is i just want to implement a barrier that will wait until five threads call this method called this function and i've got to keep track of how many there we go and all i'm going to give you is the following code which uses a counting semaphore so you get to choose how what you would like to implement what you'd like to to initialize is counting semaphore with and all you have to do is rearrange these lines enter the correct order so that's my challenge to you pause this video and see if you can work it out i'll give you the solution next video but before you do that make some brain new brain cell connections and actually think about how you're going to rearrange this code to the actually works by	section	32
is one solution to the critical section but like i said it's not a generally useful solution to the critical section we need to find a way to be able to kind of implement these correctly and will talk about some algorithmic concerns about that in the future instead now is what i've got a real challenge for you which is i want to implement a barrier in fact i'm going to give you all the code that you need here it is i just want to implement a barrier that will wait until five threads call this method called this function and i've got to keep track of how many there we go and all i'm going to give you is the following code which uses a counting semaphore so you get to choose how what you would like to implement what you'd like to to initialize is counting semaphore with and all you have to do is rearrange these lines enter the correct order so that's my challenge to you pause this video and see if you can work it out i'll give you the solution next video but before you do that make some brain new brain cell connections and actually think about how you're going to rearrange this code to the actually works by	thread	480
dead but they're not doing anything anymore they haven't gone away yet we still know things about like their process id and their exit status in fact they're going to clutch up the process table inside the kernel and if we make enough of these zombies then in future calls to fork inside our code and other users of the system that may fail so at some point we won't be able to make any more processes so it's important to clean up as on bits and not try to make an infinite number hoffman	code	292
dead but they're not doing anything anymore they haven't gone away yet we still know things about like their process id and their exit status in fact they're going to clutch up the process table inside the kernel and if we make enough of these zombies then in future calls to fork inside our code and other users of the system that may fail so at some point we won't be able to make any more processes so it's important to clean up as on bits and not try to make an infinite number hoffman	system	320
supports a wonderfull idea called signals and what's just happened to put your poor little process is that we said sent it a sig int we generated a cig interrupt and the default behavior of that is to stop the process and of course you could find this out using the weight pid macros here's another one if we write bad code and we try to read write to some invalid memory location we get segfault or a cig i think a sig fault	memory	365
supports a wonderfull idea called signals and what's just happened to put your poor little process is that we said sent it a sig int we generated a cig interrupt and the default behavior of that is to stop the process and of course you could find this out using the weight pid macros here's another one if we write bad code and we try to read write to some invalid memory location we get segfault or a cig i think a sig fault	code	319
to discover when our children who finished and we can use this as one way to prevent zombies now i don't need to write code that just blocks and waits for my child to finish i could start many children and then	block	134
to discover when our children who finished and we can use this as one way to prevent zombies now i don't need to write code that just blocks and waits for my child to finish i could start many children and then	code	119
definition of it doesn't have the id so chilled without the eye but that's that's what its purposes and unlike sigint and sig segfault it it does not actually kill a parent process but we can set it up so that runs special code when we get this signal more about that in a future lecture but for our last content today we're going to talk about a quick review of common mistakes nc and see if we can start spotting some common mistakes alright	code	223
ok so this build ourselves a web client so this isn't gonna be quite as good as firefox or chrome but i promise you that it's a lot fresher and also a lot smaller let's just one little downside which is that if you want to navigate to a different page you're going to have to recompile it but never lied is for technical audience anyway so here we go we want to build build a web server and we want to specify names like illinois dot edu and we need to convert that there into a tcp address right for that here's a really really useful function get address info and fat it does many things but we're going to use it today to create the information we need to create a socket and also to call connect and so we eventually will get back a family a socket type and address length and and address as well so we'll use these too kind of plug into the socket connect calls ok right so let's get started the way their address info works is that we actually set up	type	753
ok so this build ourselves a web client so this isn't gonna be quite as good as firefox or chrome but i promise you that it's a lot fresher and also a lot smaller let's just one little downside which is that if you want to navigate to a different page you're going to have to recompile it but never lied is for technical audience anyway so here we go we want to build build a web server and we want to specify names like illinois dot edu and we need to convert that there into a tcp address right for that here's a really really useful function get address info and fat it does many things but we're going to use it today to create the information we need to create a socket and also to call connect and so we eventually will get back a family a socket type and address length and and address as well so we'll use these too kind of plug into the socket connect calls ok right so let's get started the way their address info works is that we actually set up	address	483
is we're going to cool get address info we're going to pass in host and the port that would like to connect to this can either be number but it has to be a string otherwise we get a segfault or it can be name like http s for example	string	156
is we're going to cool get address info we're going to pass in host and the port that would like to connect to this can either be number but it has to be a string otherwise we get a segfault or it can be name like http s for example	address	27
but here's where we get a passing then a pointer to an existing struct and then here's where we pass in a variable appointed to a pointer and it's going to	pointer	41
create some heat memory force with the results so that's what we need to get to let's think about how we can set up this hints object what does that look like gay so here's the plan we get to say what kind of connection we want do we want to say an ip four	memory	17
and zero it all out ok so take the address of it and the number of bytes that i need for this struct will be the number of bytes that i'm just going to set equal to zero so memset is going to walk through order those bytes setting it or alter zero so if i don't set some of the all of the parameters inside that fields sorry aside that's trucked then by default they will have a value of zero which is a good thing the other thing we're going to need in here is a pointer to result as well so i don't need	parameter	289
and zero it all out ok so take the address of it and the number of bytes that i need for this struct will be the number of bytes that i'm just going to set equal to zero so memset is going to walk through order those bytes setting it or alter zero so if i don't set some of the all of the parameters inside that fields sorry aside that's trucked then by default they will have a value of zero which is a good thing the other thing we're going to need in here is a pointer to result as well so i don't need	address	35
and zero it all out ok so take the address of it and the number of bytes that i need for this struct will be the number of bytes that i'm just going to set equal to zero so memset is going to walk through order those bytes setting it or alter zero so if i don't set some of the all of the parameters inside that fields sorry aside that's trucked then by default they will have a value of zero which is a good thing the other thing we're going to need in here is a pointer to result as well so i don't need	pointer	464
and addressing flow i just need a pointer to one right so we can start to set this up now if i'm going to set up a tcp then the address family idea is af address family and i need high net which means ip version four for my next for short for internet if you wanted ip version six then you would use af inet underscore inet six	address	4
and addressing flow i just need a pointer to one right so we can start to set this up now if i'm going to set up a tcp then the address family idea is af address family and i need high net which means ip version four for my next for short for internet if you wanted ip version six then you would use af inet underscore inet six	pointer	34
there's also i net any if you would say i don't care about which of these so today we're going to only care about trying to get an ip four address right and what kind of socket type well this is where we can say i actually want either udp or tcp and the constants here either d gram for for a datagram udp or stream for a tcp so we're going to use stream i will look up the correct name for this error moment from a man page but it's something like socks stream yes in fact this what is soccer underscore stream	type	177
there's also i net any if you would say i don't care about which of these so today we're going to only care about trying to get an ip four address right and what kind of socket type well this is where we can say i actually want either udp or tcp and the constants here either d gram for for a datagram udp or stream for a tcp so we're going to use stream i will look up the correct name for this error moment from a man page but it's something like socks stream yes in fact this what is soccer underscore stream	address	139
get address info please and i'd like to connect on port eighty because that is where unencrypted web traffic should be requested for and now here is the address of my hint structure and here is the address of my result pointer which is going to be changed as well	address	4
get address info please and i'd like to connect on port eighty because that is where unencrypted web traffic should be requested for and now here is the address of my hint structure and here is the address of my result pointer which is going to be changed as well	pointer	219
ok so we'll get address info change my result pointer who knows to be sure we better actually check to see whether the get address info actually succeeds or not so it's important with all of these network calls to check their return value so if it did not succeed then my result pointer can you point into anything game because we never set it maybe it's pointing to this smiley over here so a little bit more of a bus code would have actually explicitly set result equal to zero	code	419
ok so we'll get address info change my result pointer who knows to be sure we better actually check to see whether the get address info actually succeeds or not so it's important with all of these network calls to check their return value so if it did not succeed then my result pointer can you point into anything game because we never set it maybe it's pointing to this smiley over here so a little bit more of a bus code would have actually explicitly set result equal to zero	address	16
ok so we'll get address info change my result pointer who knows to be sure we better actually check to see whether the get address info actually succeeds or not so it's important with all of these network calls to check their return value so if it did not succeed then my result pointer can you point into anything game because we never set it maybe it's pointing to this smiley over here so a little bit more of a bus code would have actually explicitly set result equal to zero	pointer	46
but certainly we don't want to assume that's been set unless get address info returns zero so if it doesn't return zero then it actually has a useful error function down here ga get address info gi underscore string error and that is the way that we can actually print out some useful to make debugging information as to why this occurred so you don't use air nose is the one of the few times that were not using error to find out what happened instead the error is actually encoded by the return value directly ok so we've got all get address info	code	477
but certainly we don't want to assume that's been set unless get address info returns zero so if it doesn't return zero then it actually has a useful error function down here ga get address info gi underscore string error and that is the way that we can actually print out some useful to make debugging information as to why this occurred so you don't use air nose is the one of the few times that were not using error to find out what happened instead the error is actually encoded by the return value directly ok so we've got all get address info	string	209
but certainly we don't want to assume that's been set unless get address info returns zero so if it doesn't return zero then it actually has a useful error function down here ga get address info gi underscore string error and that is the way that we can actually print out some useful to make debugging information as to why this occurred so you don't use air nose is the one of the few times that were not using error to find out what happened instead the error is actually encoded by the return value directly ok so we've got all get address info	address	65
now we can make the calls for a socket and connect so rather than do that here let's actually do that as part of the live code so we can start writing this	code	122
ok right so yeah i was right the socket type with sock underscore stream so great we've got that now it's time to actually make our connection ok so i want to make myself a socket so let me have a	type	40
ok that's fixed indenting here right ok so let's have a socket fire scripture this is how we're going to talk to the server so will make a socket right so the first thing is the kind of socket well ok where do i get that from i get that from the result and you'll see i've made a note of the different fields inside here and the first thing that socket is the domain that is the actually the family that we need here so the socket family ok and then it's the socket type ok so that's a i type ok and that's the last thing is the protocol which usually is just zero for some kinds of families that could be different kinds of protocols but so we need to get loops socket here there we go result and then	type	466
ok that's fixed indenting here right ok so let's have a socket fire scripture this is how we're going to talk to the server so will make a socket right so the first thing is the kind of socket well ok where do i get that from i get that from the result and you'll see i've made a note of the different fields inside here and the first thing that socket is the domain that is the actually the family that we need here so the socket family ok and then it's the socket type ok so that's a i type ok and that's the last thing is the protocol which usually is just zero for some kinds of families that could be different kinds of protocols but so we need to get loops socket here there we go result and then	the protocol	525
right so the parameters for connect is first of all is the socket far descriptor ok so we've got that	parameter	13
but then we need to pass in a pointer to a struct now all styles coding for networks would have is actually assembled and create this structure ourselves directly	a struct	41
but then we need to pass in a pointer to a struct now all styles coding for networks would have is actually assembled and create this structure ourselves directly	pointer	30
so in theory that's why you actually only need the socket in the connect calls but we've been lazy today we've been using this swiss army nice chord get address info that actually set this set this up for us so we need to pass in two things one is a pointer to this struct and secondly how big	address	153
so in theory that's why you actually only need the socket in the connect calls but we've been lazy today we've been using this swiss army nice chord get address info that actually set this set this up for us so we need to pass in two things one is a pointer to this struct and secondly how big	pointer	250
this struct actually is ok so that's down here that's all address and address length let's grab those from the get address info result ok so we've got result	address	58
address and result address lynn ok as usual let's check that connect actually worked	address	0
ok so first of all this to see if this actually can connect to illinois dot edu alright let's see if there really is a web server listening on port eighty on this address i think it's time to compile this so let's clear this i want to make my text a bit larger	address	163
ok so will do well she's playing right and off we go ok all i got i didn't get the socket right because i need a type	type	113
oh did i just get a type of one here oh it's socket type not this type ok so there's that	type	20
want to write this to my output on my terminal actually want to write to socket f d k so i could have a message right so hash define a little message ok my message can be save alot all along right ok let's send that so here's the address of that message and here's how long it is extra learner message ok we don't care about zero time and i was going to send it random characters ok so will send that and should we see if it censored anything back sure ok so for that will have a buffer say thousand twenty four bytes let's see what it says so i'd like to read from	address	230
let's see so i need to type	type	23
well we're not we're just assuming that my whole message get sent in one go right so let's compile this and run it ok is connected oh it didn't it didn't send us anything back ok it's still listing is still waiting for us to send more bites fine we can do that let's send it my little message but this time actually terminate it with a slash slash r slash n and another one ok so i'm sending this because i know that this is part of the http protocol and this little sequence of four bytes for test means that the that my request has finished so off we go let's end it and it's it's send something back to us who ok so first of all we've we see a lot of things we can we can see the current date we can see that the server claims it's an apache server so if i was a hacker i could type apache two point two point one five in and look for vulnerabilities associated with this	type	781
it's telling me that it's sending hundred and twenty six bytes and it's closing the connection as well it's also telling me that is this is a character set it's using and this is what we get for two hundred and twenty eight fights we get a response code of four hundred fat sorry that's their responses back there the very top four hundred bad request the rest of it is just a nice documented formatted version that we can display inside of web browser cater your browser sending requests at this server could not understand ok so the status code is four hundred and	code	249
it didn't like arbitrary request let's send something which is actually closer to a real http request ok let's change this message now to something which is a lot more reasonable let's say that i want to get the following resource and i'm speaking a certain variant of http so http one point oh and this time i'm going to say that i know that different hosts could be living on this ip address i want you to behave as if you are illinois dot edu ok and then lastly we know that a line has to be followed by a blank line in order for this request to be finished ok so that's a full request now i'm behaving a lot more like a reasonable http client	the following	208
it didn't like arbitrary request let's send something which is actually closer to a real http request ok let's change this message now to something which is a lot more reasonable let's say that i want to get the following resource and i'm speaking a certain variant of http so http one point oh and this time i'm going to say that i know that different hosts could be living on this ip address i want you to behave as if you are illinois dot edu ok and then lastly we know that a line has to be followed by a blank line in order for this request to be finished ok so that's a full request now i'm behaving a lot more like a reasonable http client	address	386
ok so will send all that so all we have to do is recompile our web browser right so that's easy we compile it is in klang and run it an were here then we get a different response now we get a status code of three oh one moved permanently ok meaning that the resources that we want will never be available on the current request instead you'll see that it's saying that illinois now supports encrypted communications encrypted version of http and if you want to see this web page you should open a new connection on https which would be a different port now our little web client today does not support encryption yet so we're not actually going to implement that instead let's matter connect to a different server let's connect to say my local machine on a local port so how can i do that right so let's go back back here	code	199
ok so will send all that so all we have to do is recompile our web browser right so that's easy we compile it is in klang and run it an were here then we get a different response now we get a status code of three oh one moved permanently ok meaning that the resources that we want will never be available on the current request instead you'll see that it's saying that illinois now supports encrypted communications encrypted version of http and if you want to see this web page you should open a new connection on https which would be a different port now our little web client today does not support encryption yet so we're not actually going to implement that instead let's matter connect to a different server let's connect to say my local machine on a local port so how can i do that right so let's go back back here	resources	258
if i want to connect to my local machine then all i need to do is coming out this different line and uncomment this one there we go in our culture into a different machine and notice as usual that i'm using quotes double quotes here to talk about a string but i'm going to make a little mistake here i'm going to say that i forgotten that port numbers need to be quoted as well so now will connect will try to connect to this and see what happens ok so let's run clang and yes we get a warning but if we run it you'll see we get a segmentation for why because it tried to read a string to address eight thousand and of course that's not going to work so let's fix our code there we go so now i'm connecting to port eight thousand	code	668
if i want to connect to my local machine then all i need to do is coming out this different line and uncomment this one there we go in our culture into a different machine and notice as usual that i'm using quotes double quotes here to talk about a string but i'm going to make a little mistake here i'm going to say that i forgotten that port numbers need to be quoted as well so now will connect will try to connect to this and see what happens ok so let's run clang and yes we get a warning but if we run it you'll see we get a segmentation for why because it tried to read a string to address eight thousand and of course that's not going to work so let's fix our code there we go so now i'm connecting to port eight thousand	string	249
if i want to connect to my local machine then all i need to do is coming out this different line and uncomment this one there we go in our culture into a different machine and notice as usual that i'm using quotes double quotes here to talk about a string but i'm going to make a little mistake here i'm going to say that i forgotten that port numbers need to be quoted as well so now will connect will try to connect to this and see what happens ok so let's run clang and yes we get a warning but if we run it you'll see we get a segmentation for why because it tried to read a string to address eight thousand and of course that's not going to work so let's fix our code there we go so now i'm connecting to port eight thousand	address	589
will it block will it never block and what about sam wait or will that always block may block never block ok so get to choose and i'll tell you the right answer right you're ready i'll give you three seconds	block	8
ok here we go right so sem post will never block sam posts that just puts a pizza slice back in the pizza box that you can do it you can immediately return some ways some weight may block if there's no pizza slice to be eaten then it will wait around until there is one and if more than one person is called sam wait an is blocked and you then call sam post then only one of them will get that pizza slice the other person is still hungry and they will continue to block all right so now what about the following challenge	the following	499
ok here we go right so sem post will never block sam posts that just puts a pizza slice back in the pizza box that you can do it you can immediately return some ways some weight may block if there's no pizza slice to be eaten then it will wait around until there is one and if more than one person is called sam wait an is blocked and you then call sam post then only one of them will get that pizza slice the other person is still hungry and they will continue to block all right so now what about the following challenge	block	43
i've got ten threads now or calling sam wait and three of these threads immediately continue but the other seven are blocked	block	117
i've got ten threads now or calling sam wait and three of these threads immediately continue but the other seven are blocked	thread	13
k on another thread maybe once there does it twice maybe two threads independently called sam post how many additional threads will continue	thread	13
ok so i've got ten threads originally called exam wait three of these threads didn't block the immediately continued but the other seven blocked what happens next what happens after i call send post	block	85
ok so i've got ten threads originally called exam wait three of these threads didn't block the immediately continued but the other seven blocked what happens next what happens after i call send post	thread	19
ok so hope you said something like the following you can see that three were able to continue because there was pizza slices in there but the remainder got stuck in other words are count of slices went down to zero	the following	35
but then we call sem_post twice so we added two more slices in so that means of these seven two can continue so an additional two more threads can continue the remaining five still blocked so do we say which particular threads which two of these seven will continue? no, we don't have any say in that all we're doing is just putting these pizza slices into the account example for	block	181
but then we call sem_post twice so we added two more slices in so that means of these seven two can continue so an additional two more threads can continue the remaining five still blocked so do we say which particular threads which two of these seven will continue? no, we don't have any say in that all we're doing is just putting these pizza slices into the account example for	thread	135
ok so we didn't need a definition for deadlock and this idea that our our threads are frozen up maybe one thread is waiting for a mutex lock that is never going to be unlocked maybe we're waiting for something from a data structure which is never going to be given to us so here's a general definition for dead log key	a struct	220
ok so we didn't need a definition for deadlock and this idea that our our threads are frozen up maybe one thread is waiting for a mutex lock that is never going to be unlocked maybe we're waiting for something from a data structure which is never going to be given to us so here's a general definition for dead log key	a mutex	128
ok so we didn't need a definition for deadlock and this idea that our our threads are frozen up maybe one thread is waiting for a mutex lock that is never going to be unlocked maybe we're waiting for something from a data structure which is never going to be given to us so here's a general definition for dead log key	thread	74
well ok can i type so i put in some in there ok	type	14
make this thread exit it's never going to happen ok so our poor poor little fair door process is waiting some for an event maybe we're going to signal that event using a variable or some other method and it's just never going to happen so it doesn't get to complete it doesn't get to kind of run its activity or run the code and of course debugging deadlock is tricky it's often there as pairs that i could a thread maybe it's stuck inside p threat condition wait and we don't know why why that event doesn't hasn't hasn't fired hasn't occured	code	320
make this thread exit it's never going to happen ok so our poor poor little fair door process is waiting some for an event maybe we're going to signal that event using a variable or some other method and it's just never going to happen so it doesn't get to complete it doesn't get to kind of run its activity or run the code and of course debugging deadlock is tricky it's often there as pairs that i could a thread maybe it's stuck inside p threat condition wait and we don't know why why that event doesn't hasn't hasn't fired hasn't occured	a thread	407
make this thread exit it's never going to happen ok so our poor poor little fair door process is waiting some for an event maybe we're going to signal that event using a variable or some other method and it's just never going to happen so it doesn't get to complete it doesn't get to kind of run its activity or run the code and of course debugging deadlock is tricky it's often there as pairs that i could a thread maybe it's stuck inside p threat condition wait and we don't know why why that event doesn't hasn't hasn't fired hasn't occured	thread	10
ok so we've got this general definition of deadlock now actually let's see if we can kind of construct some examples where we actually cause it so let's use team mutex locks and two threads to create an example of deadlock ok bye i'm going to actually do this in a text editor ok	thread	182
let's go right do i have so if i've got thread one imagine my thread first red make the coda bigger right has called	thread	40
p thread mutex lock k and we're going to say please lock on this first mutex and then after you've done that please lock on this other mutex right so it will do some work ok do something and then after that we want to at least ok so we will call p thread unlock on both of these mutex is ok	thread	2
so for example maybe we want to take some data out of out of data store one stick it into data structure to ok it doesn't matter particular which order that we released them in just for symmetry i'm going to do it this way but let's let's think about what happens if we lock these in a different sequence inside another thread so i'm going to have now another thread that does the same sequence of operations accept ha we have swapped these around the case so we swap these two lights ok so is this a problem	a struct	93
so for example maybe we want to take some data out of out of data store one stick it into data structure to ok it doesn't matter particular which order that we released them in just for symmetry i'm going to do it this way but let's let's think about what happens if we lock these in a different sequence inside another thread so i'm going to have now another thread that does the same sequence of operations accept ha we have swapped these around the case so we swap these two lights ok so is this a problem	thread	320
like most of the time no most of the time my threads are perfectly happy doing what they need to do until the following happens until one unfortunate day thread one has called preferred mutex lock on get this choose a new color	the following	106
like most of the time no most of the time my threads are perfectly happy doing what they need to do until the following happens until one unfortunate day thread one has called preferred mutex lock on get this choose a new color	thread	45
called prefix lock on the first one case is completed that at the same time my other thread which is curiously called thread one so let's fix that thread	thread	85
so now they were both able to do this but what happens next ok i think we should choose a new color for this let's go for yes it's kinda extreme pinky purple thing let's try that ok right so now what happens thread one says i'd like to lock this mutex but of course what	thread	208
does this do it blocks ok why because another thread has that new texts between you and me we know it's thread two meanwhile thread two tries to look	block	16
does this do it blocks ok why because another thread has that new texts between you and me we know it's thread two meanwhile thread two tries to look	thread	46
it takes one and that of course blocks	block	32
it's not yet available another thread is currently quite that musics lock ok so when will we escape out of this and the answer is never ok we can read the code and see that eventually we're going to release these locks but we're never going to get to that that piece of code that thread one is waiting for thread two and thread two is waiting for thread one so it's kind of stuck for stuck forever	code	155
it's not yet available another thread is currently quite that musics lock ok so when will we escape out of this and the answer is never ok we can read the code and see that eventually we're going to release these locks but we're never going to get to that that piece of code that thread one is waiting for thread two and thread two is waiting for thread one so it's kind of stuck for stuck forever	thread	31
ok i am not occured because we constructed this with the locks being acquired in a different order if they were in the same order it would have been fine let's just kind of quickly sketch that out to see that let's imagine that i had my first thread doing mutex worn and then mute x two and then mutex wanna mutex two down here for thread two then if they both try to acquire mutex in at the same time then we can imagine that thread one would acquire the mutex lock here which would mean thread two will be forced to block	block	518
ok i am not occured because we constructed this with the locks being acquired in a different order if they were in the same order it would have been fine let's just kind of quickly sketch that out to see that let's imagine that i had my first thread doing mutex worn and then mute x two and then mutex wanna mutex two down here for thread two then if they both try to acquire mutex in at the same time then we can imagine that thread one would acquire the mutex lock here which would mean thread two will be forced to block	a mutex	306
ok i am not occured because we constructed this with the locks being acquired in a different order if they were in the same order it would have been fine let's just kind of quickly sketch that out to see that let's imagine that i had my first thread doing mutex worn and then mute x two and then mutex wanna mutex two down here for thread two then if they both try to acquire mutex in at the same time then we can imagine that thread one would acquire the mutex lock here which would mean thread two will be forced to block	thread	243
so it doesn't get to go to step two which means thread one can continue and then when it's finished it will release those locks so now thread two can finish so	thread	48
if we'd actually written our code like this in the same order it would have been impossible to get deadlock	code	29
ok so that was with a mutex lock now that's actually think about could we do something similar with counting semaphores sure ok so let's do something similar with counting semaphores where thread one calls say sam weights on counting center four as well	a mutex	20
ok so that was with a mutex lock now that's actually think about could we do something similar with counting semaphores sure ok so let's do something similar with counting semaphores where thread one calls say sam weights on counting center four as well	thread	189
i'll have another thread that does something similar or key	thread	18
and another thread does something similar ok so do we see any problems right now nope we could imagine that these counting semaphore 's my kind except for has been initialized just account of one ok so same initiate here go let's have one pizza slice in there	thread	12
there's no possibility of deadlock right now that for every same weight called we call assam post ok right so what if we could have made it a little bit more complicated though and we said that same weight here is going to in order to continue i'm going to wait on this thread and then i'm going to post on some samples to an meanwhile thread two i'm going to wait on counting semaphore two and then i'm going to post on counting semaphore three ok and then some weight three i'm going to then post inseminate one ok if all my counties are forced to started off with a value of zero you can see that no one gets to play that all of my threads have got stuck that my first thread is blocked here waiting for the value for sale wanted change well someone will change down here but unfortunately thread three is blocked waiting for the count for sam three is waiting for pizza slice and were able to get that piece of sliced form it is waiting for sam post to be called by thread two but thread two is not going to give it that pizza slice until it gets a piece of slice out of counting semaphores s two and where will i get that only from thread one when thread one finally calls stem post but that's not going to happen because thread what is still waiting for the pizza slice from thread three so now you see we've got this love triangle here between our three threads they'll never going to continue that always waiting for an event that's never going to happen so that's our example of deadlock we can construct lots of these varying bits of complexity usually we don't artificial construct them like this usually were scratching go ahead go why did my system come to a grinding halt and the other thing i want you to notice is that	block	682
there's no possibility of deadlock right now that for every same weight called we call assam post ok right so what if we could have made it a little bit more complicated though and we said that same weight here is going to in order to continue i'm going to wait on this thread and then i'm going to post on some samples to an meanwhile thread two i'm going to wait on counting semaphore two and then i'm going to post on counting semaphore three ok and then some weight three i'm going to then post inseminate one ok if all my counties are forced to started off with a value of zero you can see that no one gets to play that all of my threads have got stuck that my first thread is blocked here waiting for the value for sale wanted change well someone will change down here but unfortunately thread three is blocked waiting for the count for sam three is waiting for pizza slice and were able to get that piece of sliced form it is waiting for sam post to be called by thread two but thread two is not going to give it that pizza slice until it gets a piece of slice out of counting semaphores s two and where will i get that only from thread one when thread one finally calls stem post but that's not going to happen because thread what is still waiting for the pizza slice from thread three so now you see we've got this love triangle here between our three threads they'll never going to continue that always waiting for an event that's never going to happen so that's our example of deadlock we can construct lots of these varying bits of complexity usually we don't artificial construct them like this usually were scratching go ahead go why did my system come to a grinding halt and the other thing i want you to notice is that	thread	270
there's no possibility of deadlock right now that for every same weight called we call assam post ok right so what if we could have made it a little bit more complicated though and we said that same weight here is going to in order to continue i'm going to wait on this thread and then i'm going to post on some samples to an meanwhile thread two i'm going to wait on counting semaphore two and then i'm going to post on counting semaphore three ok and then some weight three i'm going to then post inseminate one ok if all my counties are forced to started off with a value of zero you can see that no one gets to play that all of my threads have got stuck that my first thread is blocked here waiting for the value for sale wanted change well someone will change down here but unfortunately thread three is blocked waiting for the count for sam three is waiting for pizza slice and were able to get that piece of sliced form it is waiting for sam post to be called by thread two but thread two is not going to give it that pizza slice until it gets a piece of slice out of counting semaphores s two and where will i get that only from thread one when thread one finally calls stem post but that's not going to happen because thread what is still waiting for the pizza slice from thread three so now you see we've got this love triangle here between our three threads they'll never going to continue that always waiting for an event that's never going to happen so that's our example of deadlock we can construct lots of these varying bits of complexity usually we don't artificial construct them like this usually were scratching go ahead go why did my system come to a grinding halt and the other thing i want you to notice is that	system	1655
i might have a thread that say forgets to call sam post or for some other forget or some bug causes some event not to occur and then you get all of this fall out where other threads and other processes are unable to continue because they are also waiting for that for that thread or the other process so you'll see this occasionally on your phone or on your laptop where one little issue say with their gui process or gui thread now starts to have cascading problems and your deadlock starts to affect other systems as well because everything else grinds to a halt and there's multiple dependencies between all of our threads and processes ok so that's deadlock what what we'd like to be able to do is ensure	a thread	13
i might have a thread that say forgets to call sam post or for some other forget or some bug causes some event not to occur and then you get all of this fall out where other threads and other processes are unable to continue because they are also waiting for that for that thread or the other process so you'll see this occasionally on your phone or on your laptop where one little issue say with their gui process or gui thread now starts to have cascading problems and your deadlock starts to affect other systems as well because everything else grinds to a halt and there's multiple dependencies between all of our threads and processes ok so that's deadlock what what we'd like to be able to do is ensure	thread	15
i might have a thread that say forgets to call sam post or for some other forget or some bug causes some event not to occur and then you get all of this fall out where other threads and other processes are unable to continue because they are also waiting for that for that thread or the other process so you'll see this occasionally on your phone or on your laptop where one little issue say with their gui process or gui thread now starts to have cascading problems and your deadlock starts to affect other systems as well because everything else grinds to a halt and there's multiple dependencies between all of our threads and processes ok so that's deadlock what what we'd like to be able to do is ensure	system	508
ok so let's talk about why the nation part of the operating system here that is ass break now if we were to look at the manpage of s break you'd read something like the following s break increases the process is data segment by end bites so when you call s break you can give it a number and you can say hey i'd like ten more bytes please alright so what does that actually mean	the following	165
ok so let's talk about why the nation part of the operating system here that is ass break now if we were to look at the manpage of s break you'd read something like the following s break increases the process is data segment by end bites so when you call s break you can give it a number and you can say hey i'd like ten more bytes please alright so what does that actually mean	system	60
ok so between you and me as big is not actually used anymore instead we're going to use some virtual memory tricks of all the slide this did modern c library uses some virtual memory tricks that we haven't learned yet so s breakers are simply mechanism but we will use it for cs two forty one to implement a simple memory allocator ok so remember how i said that the bottom of the memory i've got the text segment which is the program code and string literals and any other constants we've put in here and	memory	101
ok so between you and me as big is not actually used anymore instead we're going to use some virtual memory tricks of all the slide this did modern c library uses some virtual memory tricks that we haven't learned yet so s breakers are simply mechanism but we will use it for cs two forty one to implement a simple memory allocator ok so remember how i said that the bottom of the memory i've got the text segment which is the program code and string literals and any other constants we've put in here and	code	435
ok so between you and me as big is not actually used anymore instead we're going to use some virtual memory tricks of all the slide this did modern c library uses some virtual memory tricks that we haven't learned yet so s breakers are simply mechanism but we will use it for cs two forty one to implement a simple memory allocator ok so remember how i said that the bottom of the memory i've got the text segment which is the program code and string literals and any other constants we've put in here and	string	444
ok we can put any data we like inside there and by default the total amount of memory allocated to this is just sufficient for what we need ok but what about the day you call malloc and say hey my malloc i need another four thousand and ninety six bytes please this point we need need to go back to the operating system to the kernel and beg for some more ram back for some more real addresses we don't want to talk to the oblivion we don't want to avoid we actually need those memory addresses now to refer to some actual memory and that's the purpose of s break is to say yes i know i've got my heap possibly say zero bytes at the beginning but that's not enough now i need to extend it so i please i'd like to move this watermark upwards say by two hundred fifty six bytes so that now i've got some more addresses i can play with i can use to hold some data so that's one less pack gives you an ability to turn on like a tap some more some more dresses which are valid ok we just keep extending this space here and we can use that then to implement possibly the world 's worst but simplest allocator so let's have a look in a moment then how we could actually use this to implement malloc are you ready are slow you in the next video bye	memory	79
ok we can put any data we like inside there and by default the total amount of memory allocated to this is just sufficient for what we need ok but what about the day you call malloc and say hey my malloc i need another four thousand and ninety six bytes please this point we need need to go back to the operating system to the kernel and beg for some more ram back for some more real addresses we don't want to talk to the oblivion we don't want to avoid we actually need those memory addresses now to refer to some actual memory and that's the purpose of s break is to say yes i know i've got my heap possibly say zero bytes at the beginning but that's not enough now i need to extend it so i please i'd like to move this watermark upwards say by two hundred fifty six bytes so that now i've got some more addresses i can play with i can use to hold some data so that's one less pack gives you an ability to turn on like a tap some more some more dresses which are valid ok we just keep extending this space here and we can use that then to implement possibly the world 's worst but simplest allocator so let's have a look in a moment then how we could actually use this to implement malloc are you ready are slow you in the next video bye	address	384
ok we can put any data we like inside there and by default the total amount of memory allocated to this is just sufficient for what we need ok but what about the day you call malloc and say hey my malloc i need another four thousand and ninety six bytes please this point we need need to go back to the operating system to the kernel and beg for some more ram back for some more real addresses we don't want to talk to the oblivion we don't want to avoid we actually need those memory addresses now to refer to some actual memory and that's the purpose of s break is to say yes i know i've got my heap possibly say zero bytes at the beginning but that's not enough now i need to extend it so i please i'd like to move this watermark upwards say by two hundred fifty six bytes so that now i've got some more addresses i can play with i can use to hold some data so that's one less pack gives you an ability to turn on like a tap some more some more dresses which are valid ok we just keep extending this space here and we can use that then to implement possibly the world 's worst but simplest allocator so let's have a look in a moment then how we could actually use this to implement malloc are you ready are slow you in the next video bye	system	313
ok some new concepts for you let's talk about this really important idea called the working set so you've got the idea that when a process runs now that every page that contains data inside a process will map to some ram there we go so here's the ram that's actually being used to hold the heap for example and here's another piece of land is being used to hold say the program code	the heap	286
ok some new concepts for you let's talk about this really important idea called the working set so you've got the idea that when a process runs now that every page that contains data inside a process will map to some ram there we go so here's the ram that's actually being used to hold the heap for example and here's another piece of land is being used to hold say the program code	code	378
ok some new concepts for you let's talk about this really important idea called the working set so you've got the idea that when a process runs now that every page that contains data inside a process will map to some ram there we go so here's the ram that's actually being used to hold the heap for example and here's another piece of land is being used to hold say the program code	a process	129
well actually we know that's not quite true there can be times when i say this piece of my process doesn't actually contain any mapping at all so let's take delete that and say hey there is no entry inside inside memory right now well how can that be how we allow that well it turns out that right now my program isn't using this page of memory at all that might be code say to formulate to format a table for example or it might be cold inside a web browser to render an svg and right now we don't have any svg images on our page so this part of our process doesn't actually need to live in ram and right now nobody would know or for example here's a piece of pete memory that we're just currently not using and don't intend to use for the next hour again that piece of memory does not actually need to correspond to any physical ram because we're not trying to access it write down so of all the pages that you are currently accessing ok so in this case say it's these pages here plus maybe i've got some code down here that i'm currently using plus maybe i've got some stack memory up here that i'm currently accessing this is defined to be our working set it's a set of pages that we actually need to get anything done that set of pages that we are currently accessing by by the cpu and oftentimes is a very small fraction of the total memory that is part of our process there's going to be parts of the program that we only needed during startup possibly we only need during shutdown there's going to part with a c library that we just don't care about those parts of the stack for example that we don't need until our deep nested recursive function finally returns etc etc etc so what we do care about is having enough memory such that these pages you can exist inside ram if we don't have dave if we're a lot of stingy with our ram for process then we run into a big problem and that problem is called flashing so now let's think about what happens let's say that every few nanoseconds i'm going to be needed to touch all of these pages so unfortunately we didn't actually have enough ram today for to put a copy or to have all of this inside our machine so some of it right now is stored on disk so every nanosecond also pass every microsecond will say up see daisy i got a problem here this page is not available inside my ram doesn't matter what am i going to do i can page it in from ram perform disk so great i can copy it in but in doing that i need to first of all evict one of the current pages so i had to choose a page	a page	2529
well actually we know that's not quite true there can be times when i say this piece of my process doesn't actually contain any mapping at all so let's take delete that and say hey there is no entry inside inside memory right now well how can that be how we allow that well it turns out that right now my program isn't using this page of memory at all that might be code say to formulate to format a table for example or it might be cold inside a web browser to render an svg and right now we don't have any svg images on our page so this part of our process doesn't actually need to live in ram and right now nobody would know or for example here's a piece of pete memory that we're just currently not using and don't intend to use for the next hour again that piece of memory does not actually need to correspond to any physical ram because we're not trying to access it write down so of all the pages that you are currently accessing ok so in this case say it's these pages here plus maybe i've got some code down here that i'm currently using plus maybe i've got some stack memory up here that i'm currently accessing this is defined to be our working set it's a set of pages that we actually need to get anything done that set of pages that we are currently accessing by by the cpu and oftentimes is a very small fraction of the total memory that is part of our process there's going to be parts of the program that we only needed during startup possibly we only need during shutdown there's going to part with a c library that we just don't care about those parts of the stack for example that we don't need until our deep nested recursive function finally returns etc etc etc so what we do care about is having enough memory such that these pages you can exist inside ram if we don't have dave if we're a lot of stingy with our ram for process then we run into a big problem and that problem is called flashing so now let's think about what happens let's say that every few nanoseconds i'm going to be needed to touch all of these pages so unfortunately we didn't actually have enough ram today for to put a copy or to have all of this inside our machine so some of it right now is stored on disk so every nanosecond also pass every microsecond will say up see daisy i got a problem here this page is not available inside my ram doesn't matter what am i going to do i can page it in from ram perform disk so great i can copy it in but in doing that i need to first of all evict one of the current pages so i had to choose a page	memory	213
well actually we know that's not quite true there can be times when i say this piece of my process doesn't actually contain any mapping at all so let's take delete that and say hey there is no entry inside inside memory right now well how can that be how we allow that well it turns out that right now my program isn't using this page of memory at all that might be code say to formulate to format a table for example or it might be cold inside a web browser to render an svg and right now we don't have any svg images on our page so this part of our process doesn't actually need to live in ram and right now nobody would know or for example here's a piece of pete memory that we're just currently not using and don't intend to use for the next hour again that piece of memory does not actually need to correspond to any physical ram because we're not trying to access it write down so of all the pages that you are currently accessing ok so in this case say it's these pages here plus maybe i've got some code down here that i'm currently using plus maybe i've got some stack memory up here that i'm currently accessing this is defined to be our working set it's a set of pages that we actually need to get anything done that set of pages that we are currently accessing by by the cpu and oftentimes is a very small fraction of the total memory that is part of our process there's going to be parts of the program that we only needed during startup possibly we only need during shutdown there's going to part with a c library that we just don't care about those parts of the stack for example that we don't need until our deep nested recursive function finally returns etc etc etc so what we do care about is having enough memory such that these pages you can exist inside ram if we don't have dave if we're a lot of stingy with our ram for process then we run into a big problem and that problem is called flashing so now let's think about what happens let's say that every few nanoseconds i'm going to be needed to touch all of these pages so unfortunately we didn't actually have enough ram today for to put a copy or to have all of this inside our machine so some of it right now is stored on disk so every nanosecond also pass every microsecond will say up see daisy i got a problem here this page is not available inside my ram doesn't matter what am i going to do i can page it in from ram perform disk so great i can copy it in but in doing that i need to first of all evict one of the current pages so i had to choose a page	code	366
that either i have a copy on disk for example its current code or i have to copy that dirty page to disk maybe to	code	58
a file or file system dedicated to supporting my virtual memory so now what's happened now every nanosecond every little memory right is going to result in a disk access as we page in an page out ok so unfortunately our paging mechanisms are about a million times slower than direct access to main memory so congratulations we've now just made a machine which is suddenly a million times slower than normal and this this effect is called thrashing that we're constantly swapping in and out pages in order to make the smallest amount of progress and so it appears from the users perspective that the whole machine is slowed to a crawl unfortunately what do we tend to do when our machines do this invariably what we do is to say i'm too impatient to wait for this website to load or for this compiler to finish i know what i'll do i will give my machine something else to do instead like i'll open up a different web browser or i'll try to compile something else and so i just made the problem even worse that now i've actually increase the load on my poor system and so there's even fewer pages left or are you available to actually going to make any progress so thrashing is a problem we want to avoid it happens in systems which are overloaded and it's	memory	57
a file or file system dedicated to supporting my virtual memory so now what's happened now every nanosecond every little memory right is going to result in a disk access as we page in an page out ok so unfortunately our paging mechanisms are about a million times slower than direct access to main memory so congratulations we've now just made a machine which is suddenly a million times slower than normal and this this effect is called thrashing that we're constantly swapping in and out pages in order to make the smallest amount of progress and so it appears from the users perspective that the whole machine is slowed to a crawl unfortunately what do we tend to do when our machines do this invariably what we do is to say i'm too impatient to wait for this website to load or for this compiler to finish i know what i'll do i will give my machine something else to do instead like i'll open up a different web browser or i'll try to compile something else and so i just made the problem even worse that now i've actually increase the load on my poor system and so there's even fewer pages left or are you available to actually going to make any progress so thrashing is a problem we want to avoid it happens in systems which are overloaded and it's	system	15
because of this idea of a working set the actual number of pages around that we need in order to make good progress to our programs and more less common or working set is that the working set of a program can change overtime the amount of memory you need it might be for example the very beginning you need to load in a lot of the program code or it might be that overtime your rendering system needs more and more hip space in order to complete some recursive picture for example ok so these are important ideas and they strongly impacts how much ram we need and also the	memory	239
because of this idea of a working set the actual number of pages around that we need in order to make good progress to our programs and more less common or working set is that the working set of a program can change overtime the amount of memory you need it might be for example the very beginning you need to load in a lot of the program code or it might be that overtime your rendering system needs more and more hip space in order to complete some recursive picture for example ok so these are important ideas and they strongly impacts how much ram we need and also the	code	339
because of this idea of a working set the actual number of pages around that we need in order to make good progress to our programs and more less common or working set is that the working set of a program can change overtime the amount of memory you need it might be for example the very beginning you need to load in a lot of the program code or it might be that overtime your rendering system needs more and more hip space in order to complete some recursive picture for example ok so these are important ideas and they strongly impacts how much ram we need and also the	system	388
now in fact i'm describing kind of adwords that google used and one of the tas for for this class actually help kind of write such an early version of the system so all of our adwords all of our different keywords	system	155
plus a little bit more in order to hold the program code and the stack etc but i expect that i'm going to end up touching all or needing to read all of these different pages and if i don't have enough memory for that then i'm going to experience a lot of thrashing as i pull indifference caustic relying on my disk io in order to pull the right piece of memory ok now is it possible that i'm always going to need that four gigabytes loaded into memory no it could change	memory	201
plus a little bit more in order to hold the program code and the stack etc but i expect that i'm going to end up touching all or needing to read all of these different pages and if i don't have enough memory for that then i'm going to experience a lot of thrashing as i pull indifference caustic relying on my disk io in order to pull the right piece of memory ok now is it possible that i'm always going to need that four gigabytes loaded into memory no it could change	code	52
so in a real system for example at some point there's going to be less traffic say for example in the middle of night would also could be that there might be a major event and suddenly the large amount of our google search traffic is always looking for the same search term so for example maybe people inside a curtain country or with googling the word earthquake or music or some film reference in which case binary search is going to actually touchup on the same page is reliably and consistently so now the number of pages we need	system	13
to kind of load into memory it's going to be much smaller it's just going to be a handful of pages because we're always touching the same pages so now we might shrink say from four gigabytes to say under four megabytes etc right so again it's kind of a little example of working set so i mentioned this kind of word in passing demand paging and just as a reminder what this means that i can have part of my process address space ok so for example	memory	21
to kind of load into memory it's going to be much smaller it's just going to be a handful of pages because we're always touching the same pages so now we might shrink say from four gigabytes to say under four megabytes etc right so again it's kind of a little example of working set so i mentioned this kind of word in passing demand paging and just as a reminder what this means that i can have part of my process address space ok so for example	address	415
this page my processors memory maybe it's part of the heap may be part of the code maybe is part of the stack but right now it's this actual actual address is here do not uh not connected to any physical ram	memory	24
this page my processors memory maybe it's part of the heap may be part of the code maybe is part of the stack but right now it's this actual actual address is here do not uh not connected to any physical ram	the heap	50
this page my processors memory maybe it's part of the heap may be part of the code maybe is part of the stack but right now it's this actual actual address is here do not uh not connected to any physical ram	code	78
this page my processors memory maybe it's part of the heap may be part of the code maybe is part of the stack but right now it's this actual actual address is here do not uh not connected to any physical ram	address	148
so when you demand this when your cpu attempts to read a memory location inside here we know that we can actually recover this page by going back to our disk and so what we need to do then is if this is all of my random access memory that i paid lots of good money for then my demand paging is the idea that	memory	57
and now i've got it in ram i'm going to let my process continue ok so that's demand paging we load things on demand from disk and if we never had to do anything else life would be pretty easy of course in practice we never have enough ram so in practice what often happens is before you get to do this we need to page out a particular page and part of the game is to figure out which one should we page out and our choices include things like hey let's choose a page of ram	a page	460
it looks like no ones needed for the longest possible time or less choose a page of ram that actually we know we already have a copy of that on the disk for example perhaps it corresponds to some of the code of a program and we already have that program stored on the disk somewhere right so that's kind of demand paging and in the next video let's address the following little brain teaser let's suppose you actually did a benchmark on catalog versus malloc ann you were surprised to discover that these two calls take the same amount of time how could that possibly be because kellogg is defined to return memory that has been	the following	357
it looks like no ones needed for the longest possible time or less choose a page of ram that actually we know we already have a copy of that on the disk for example perhaps it corresponds to some of the code of a program and we already have that program stored on the disk somewhere right so that's kind of demand paging and in the next video let's address the following little brain teaser let's suppose you actually did a benchmark on catalog versus malloc ann you were surprised to discover that these two calls take the same amount of time how could that possibly be because kellogg is defined to return memory that has been	a page	74
it looks like no ones needed for the longest possible time or less choose a page of ram that actually we know we already have a copy of that on the disk for example perhaps it corresponds to some of the code of a program and we already have that program stored on the disk somewhere right so that's kind of demand paging and in the next video let's address the following little brain teaser let's suppose you actually did a benchmark on catalog versus malloc ann you were surprised to discover that these two calls take the same amount of time how could that possibly be because kellogg is defined to return memory that has been	memory	608
it looks like no ones needed for the longest possible time or less choose a page of ram that actually we know we already have a copy of that on the disk for example perhaps it corresponds to some of the code of a program and we already have that program stored on the disk somewhere right so that's kind of demand paging and in the next video let's address the following little brain teaser let's suppose you actually did a benchmark on catalog versus malloc ann you were surprised to discover that these two calls take the same amount of time how could that possibly be because kellogg is defined to return memory that has been	code	203
it looks like no ones needed for the longest possible time or less choose a page of ram that actually we know we already have a copy of that on the disk for example perhaps it corresponds to some of the code of a program and we already have that program stored on the disk somewhere right so that's kind of demand paging and in the next video let's address the following little brain teaser let's suppose you actually did a benchmark on catalog versus malloc ann you were surprised to discover that these two calls take the same amount of time how could that possibly be because kellogg is defined to return memory that has been	address	349
ok little puzzle for you here's a function that just wants to count the number of items in an array until we discover a number that's greater than one hundred ok so we've got a sketch of an idea here you can see that it's going to be given an address and we're giving a hint to the compiler to say that at this address i expect to read or write an integer	address	243
and this this code just assumes that is given a valid address if we give it a null address it's probably going to crash if we address if i wanna race or it doesn't have a number than greater than a hundred then our poor little code here doesn't know when to stop is just going to keep incrementing it's just going to keep looking through memory until it reason editor which is greater than one hundred alright so let's get started	memory	338
and this this code just assumes that is given a valid address if we give it a null address it's probably going to crash if we address if i wanna race or it doesn't have a number than greater than a hundred then our poor little code here doesn't know when to stop is just going to keep incrementing it's just going to keep looking through memory until it reason editor which is greater than one hundred alright so let's get started	code	14
and this this code just assumes that is given a valid address if we give it a null address it's probably going to crash if we address if i wanna race or it doesn't have a number than greater than a hundred then our poor little code here doesn't know when to stop is just going to keep incrementing it's just going to keep looking through memory until it reason editor which is greater than one hundred alright so let's get started	address	54
point to here and right side but another int pointer	pointer	45
ok so remember that the astrex as pop available declaration is a hint mean i'm talking about pointers rather than its other meeting which is to hey follow the pointer	pointer	93
at the pointers location and if that value is less than a hundred then what do i want to do increment my pointer and go on again ok so style people might say yeah you should put that in braces alright let's do that ok	pointer	7
let's placed clear like to say that the following code is not part of my wallet right so i've i've moved now my pointer to a place where they look very great and the one hundred how can i figure out how far i went ok so	the following	36
let's placed clear like to say that the following code is not part of my wallet right so i've i've moved now my pointer to a place where they look very great and the one hundred how can i figure out how far i went ok so	code	50
let's placed clear like to say that the following code is not part of my wallet right so i've i've moved now my pointer to a place where they look very great and the one hundred how can i figure out how far i went ok so	pointer	112
ok looking this code remember or we're working with pointer arithmetic and anytime you ask to see compiler to do pointer arithmetic for you whether it's adding or dividing sorry adding or subtracting	code	16
ok looking this code remember or we're working with pointer arithmetic and anytime you ask to see compiler to do pointer arithmetic for you whether it's adding or dividing sorry adding or subtracting	pointer	52
the compiler going to make use of the types so this is why in line three when we're adding one to a little pointer said to her i see that your point is actually pointing images and i know that on this system and each tree is going to be let's say four bytes so therefore in adding one actually i'm going to move the pointer forward by four bytes it would have moved it back by four bytes if we asked it to subtract by one one of the case of subtracting two pointers this is only valid when the pointers are actually the same kind of same type so in this case is actually not going to tell us	type	38
the compiler going to make use of the types so this is why in line three when we're adding one to a little pointer said to her i see that your point is actually pointing images and i know that on this system and each tree is going to be let's say four bytes so therefore in adding one actually i'm going to move the pointer forward by four bytes it would have moved it back by four bytes if we asked it to subtract by one one of the case of subtracting two pointers this is only valid when the pointers are actually the same kind of same type so in this case is actually not going to tell us	system	201
the compiler going to make use of the types so this is why in line three when we're adding one to a little pointer said to her i see that your point is actually pointing images and i know that on this system and each tree is going to be let's say four bytes so therefore in adding one actually i'm going to move the pointer forward by four bytes it would have moved it back by four bytes if we asked it to subtract by one one of the case of subtracting two pointers this is only valid when the pointers are actually the same kind of same type so in this case is actually not going to tell us	pointer	107
the difference in bytes is going to tell us the difference in terms of the number of elements between the two so i do not need to divide by the size of my pointer types	type	163
the difference in bytes is going to tell us the difference in terms of the number of elements between the two so i do not need to divide by the size of my pointer types	pointer	155
and so is this expression correct pointer minus start let's imagine that the very first value was one hundred and one in which case pointer and start would be still actually looking at the same piece of memory so that would be a value of zero and that is the actual value that we'd like in this case so in other words we do not have an off by whatever	memory	203
and so is this expression correct pointer minus start let's imagine that the very first value was one hundred and one in which case pointer and start would be still actually looking at the same piece of memory so that would be a value of zero and that is the actual value that we'd like in this case so in other words we do not have an off by whatever	pointer	34
in this case so all we need to do is just subtract those two pointers and return	pointer	61
which were greater than one hundred my little code here we just walk off the end of the rate would keep going where do you go on forever probably not here's what would happen either but by the sheer luck would come across a bite a series of bytes which represented a large enough integer value or my little program here would walk into a memory address that is no longer valid piece of memory to read we would have expected that we would have left the existing memory segment and perhaps we had entered no man's land where there is no actual physical memory map to that address anymore at which point we would get a segmentation fault ok the possibility other kind of fun thing here is that my little code here doesn't	memory	338
which were greater than one hundred my little code here we just walk off the end of the rate would keep going where do you go on forever probably not here's what would happen either but by the sheer luck would come across a bite a series of bytes which represented a large enough integer value or my little program here would walk into a memory address that is no longer valid piece of memory to read we would have expected that we would have left the existing memory segment and perhaps we had entered no man's land where there is no actual physical memory map to that address anymore at which point we would get a segmentation fault ok the possibility other kind of fun thing here is that my little code here doesn't	code	46
which were greater than one hundred my little code here we just walk off the end of the rate would keep going where do you go on forever probably not here's what would happen either but by the sheer luck would come across a bite a series of bytes which represented a large enough integer value or my little program here would walk into a memory address that is no longer valid piece of memory to read we would have expected that we would have left the existing memory segment and perhaps we had entered no man's land where there is no actual physical memory map to that address anymore at which point we would get a segmentation fault ok the possibility other kind of fun thing here is that my little code here doesn't	address	345
know anything about the address that you give it perhaps you're going to give at the start of it away but you don't have to you could give it any address which is a reasonable place to start looking for perhaps you want to give it an address for example that starts right in the middle of an away	address	24
as for this concert is simply giving it a pointer that it's going to point it is going to use an appointed that to read directly and it's just going to start looking at the subsequent memory locations right so let's see what our next little video is going to be about ok and next video is going to be talking about using asserts and then put in that altogether to kind of build useful little program which can hopefully detect errors early with that why	memory	184
as for this concert is simply giving it a pointer that it's going to point it is going to use an appointed that to read directly and it's just going to start looking at the subsequent memory locations right so let's see what our next little video is going to be about ok and next video is going to be talking about using asserts and then put in that altogether to kind of build useful little program which can hopefully detect errors early with that why	pointer	42
run concurrently that when they are performing the read we should have millions or billions of people free able to access that data but when we actually want to do any writing when it actually change the data structure maybe it's an entry inside a particular table maybe it's a file then at that moment only we get access to it ok so anybody else gets temporarily blocked last we change it	block	364
run concurrently that when they are performing the read we should have millions or billions of people free able to access that data but when we actually want to do any writing when it actually change the data structure maybe it's an entry inside a particular table maybe it's a file then at that moment only we get access to it ok so anybody else gets temporarily blocked last we change it	the data structure	200
run concurrently that when they are performing the read we should have millions or billions of people free able to access that data but when we actually want to do any writing when it actually change the data structure maybe it's an entry inside a particular table maybe it's a file then at that moment only we get access to it ok so anybody else gets temporarily blocked last we change it	a struct	207
ok so let's have our first to go here it is here's our first attempt i'm just going to use a standard mutex lock and then want to analyze this and decide if it's any good so i'm going to have two mutex locks here they are read law can write log and just for fun today let's actually make these pointers so that i can create some memory on the heap for it ok so let me malloc and	memory	329
ok so let's have our first to go here it is here's our first attempt i'm just going to use a standard mutex lock and then want to analyze this and decide if it's any good so i'm going to have two mutex locks here they are read law can write log and just for fun today let's actually make these pointers so that i can create some memory on the heap for it ok so let me malloc and	the heap	339
ok so let's have our first to go here it is here's our first attempt i'm just going to use a standard mutex lock and then want to analyze this and decide if it's any good so i'm going to have two mutex locks here they are read law can write log and just for fun today let's actually make these pointers so that i can create some memory on the heap for it ok so let me malloc and	pointer	294
how much memory on the heap do i need the size of my my little type here and a reminder that yes these are variables and they represent some memory sure but the actual objects themselves you can think of them like file handles that they actually exist as part of the part of the kernel so that's why i need to call p thread mutex initiate please create an object for me based on store a reference to that inside this memory structure so i've got my two locks now let's see what happens right so as part of the read i'm going to call read lock ok so i'm just going to call p thread mutex lock and then afterwards petered mutex unlock key and then the right i first of all i'm going to get the right lock then i'm going to get the read lock and i'm going to do some writing so what do we think about this is mutex locks sufficient to implement this right so take a moment to think about that and then i'll tell you in my point of view	memory	9
how much memory on the heap do i need the size of my my little type here and a reminder that yes these are variables and they represent some memory sure but the actual objects themselves you can think of them like file handles that they actually exist as part of the part of the kernel so that's why i need to call p thread mutex initiate please create an object for me based on store a reference to that inside this memory structure so i've got my two locks now let's see what happens right so as part of the read i'm going to call read lock ok so i'm just going to call p thread mutex lock and then afterwards petered mutex unlock key and then the right i first of all i'm going to get the right lock then i'm going to get the read lock and i'm going to do some writing so what do we think about this is mutex locks sufficient to implement this right so take a moment to think about that and then i'll tell you in my point of view	the heap	19
how much memory on the heap do i need the size of my my little type here and a reminder that yes these are variables and they represent some memory sure but the actual objects themselves you can think of them like file handles that they actually exist as part of the part of the kernel so that's why i need to call p thread mutex initiate please create an object for me based on store a reference to that inside this memory structure so i've got my two locks now let's see what happens right so as part of the read i'm going to call read lock ok so i'm just going to call p thread mutex lock and then afterwards petered mutex unlock key and then the right i first of all i'm going to get the right lock then i'm going to get the read lock and i'm going to do some writing so what do we think about this is mutex locks sufficient to implement this right so take a moment to think about that and then i'll tell you in my point of view	type	63
how much memory on the heap do i need the size of my my little type here and a reminder that yes these are variables and they represent some memory sure but the actual objects themselves you can think of them like file handles that they actually exist as part of the part of the kernel so that's why i need to call p thread mutex initiate please create an object for me based on store a reference to that inside this memory structure so i've got my two locks now let's see what happens right so as part of the read i'm going to call read lock ok so i'm just going to call p thread mutex lock and then afterwards petered mutex unlock key and then the right i first of all i'm going to get the right lock then i'm going to get the read lock and i'm going to do some writing so what do we think about this is mutex locks sufficient to implement this right so take a moment to think about that and then i'll tell you in my point of view	thread	317
ok right so a preferred mutex lock let's talk about positive things first let's do like positive code review here so the good news with this implementation is that only one writer at a time actually gets to run ok that the only way you can get through to the being an active writer is to first acquire these two mutex logs ok so that's good the bad news however is that readers are forced to read the data just one at a time if i have multiple threads calling my read here then only one of them can acquire this this lock and the others get blocked ok so now i can't have a million people on using my cash they're going to be serialized so just one at a time gets to go through this code and actually do the read so that's not good but like i said the nice thing is that the implementation is written so far is that once the writer actually wants to change it they're going to also acquire the read lock so that	block	541
ok right so a preferred mutex lock let's talk about positive things first let's do like positive code review here so the good news with this implementation is that only one writer at a time actually gets to run ok that the only way you can get through to the being an active writer is to first acquire these two mutex logs ok so that's good the bad news however is that readers are forced to read the data just one at a time if i have multiple threads calling my read here then only one of them can acquire this this lock and the others get blocked ok so now i can't have a million people on using my cash they're going to be serialized so just one at a time gets to go through this code and actually do the read so that's not good but like i said the nice thing is that the implementation is written so far is that once the writer actually wants to change it they're going to also acquire the read lock so that	code	97
ok right so a preferred mutex lock let's talk about positive things first let's do like positive code review here so the good news with this implementation is that only one writer at a time actually gets to run ok that the only way you can get through to the being an active writer is to first acquire these two mutex logs ok so that's good the bad news however is that readers are forced to read the data just one at a time if i have multiple threads calling my read here then only one of them can acquire this this lock and the others get blocked ok so now i can't have a million people on using my cash they're going to be serialized so just one at a time gets to go through this code and actually do the read so that's not good but like i said the nice thing is that the implementation is written so far is that once the writer actually wants to change it they're going to also acquire the read lock so that	thread	444
change this reading variable become an active reader to true and alta my reading here so what is the writer do when we want to write when we want to change the data structure we will first see if there's anybody reading or anybody writing if there is then do nothing but just go balance in a while loop again so i'm going to keep pulling these values and i can only escape out of this while loop this infinite while loop wants their both false when that occurs then i will raise this flag to say ok we've got an active writer on the scene and now i'm going to do my surgery and change the data structure right and you file updater link this whatever right and then afterwards set my writing to false ok search what do you think about this and what was it good about how to think about this and then i'll tell you my opinions	the data structure	156
change this reading variable become an active reader to true and alta my reading here so what is the writer do when we want to write when we want to change the data structure we will first see if there's anybody reading or anybody writing if there is then do nothing but just go balance in a while loop again so i'm going to keep pulling these values and i can only escape out of this while loop this infinite while loop wants their both false when that occurs then i will raise this flag to say ok we've got an active writer on the scene and now i'm going to do my surgery and change the data structure right and you file updater link this whatever right and then afterwards set my writing to false ok search what do you think about this and what was it good about how to think about this and then i'll tell you my opinions	a struct	163
ok great so what did you decide this is contestant too though winner ok no we've got several problems here we've got several race conditions so here's some example problems for example suppose writers appeared at the same time so they both would see that right now there's no readers and there's no writers so great i'm the only writer on the scene and they would both set writing equal to true oh now we have two writers inside the critical section	section	442
and so we're going to collect data structure so we can't do that we failed to have just one active writer	a struct	33
anybody writing no great i get to continue to so because of that race condition because they both check those conditions at the same time now we have a reader thinking that it's ok to read and we have in writer thinking ok two two right so the now they can both read and write at the same time but now i've got a reader that might need some invalid data of might and might get corrupted as well so no that's not going to work for us ok the other race conditions and other concerns as well which is let's think about some meters coming in ok so in they go and they're doing their reading that opening files finding the right part of the table that kind of thing but the moments that the very first reader exit out of here they said reading defaults but hold on him i would i still got other readers still performing the reading so this kind of simple balyan register of saying yes i'm reading or not is not sufficient what we really wanted to do was actually keep track about the number of readers which actually doing some meeting and only when that reading count goes down to zero should we allow writers to continue ok so hopefully these these two contestants though they were clearly failures they've actually given as a lot of insight into how we can start to write a better version of this we're going to need to keep track of the active number of readers and we want to make sure the only one writer data type can get into	type	1411
i'm going to lock a mutex ok before i do anything ok so now my testing here will will remain true so if i say whilst anybody is writing then block we know that that is going to be true until the data i'll unlock my code because all of my code uses the same mutex lock ok ok so lock mutex and if there's anybody writing go to sleep great so the	block	141
i'm going to lock a mutex ok before i do anything ok so now my testing here will will remain true so if i say whilst anybody is writing then block we know that that is going to be true until the data i'll unlock my code because all of my code uses the same mutex lock ok ok so lock mutex and if there's anybody writing go to sleep great so the	code	215
i'm going to lock a mutex ok before i do anything ok so now my testing here will will remain true so if i say whilst anybody is writing then block we know that that is going to be true until the data i'll unlock my code because all of my code uses the same mutex lock ok ok so lock mutex and if there's anybody writing go to sleep great so the	a mutex	18
ok let's see what the writers doing ok so on the writing side let's acquire the mutex ok and then will check to see if anybody else is currently reading or writing so if there's anybody touching the patient right now for reading or writing then we want to block so we're going to block inside this condition wait alright if we get past that then we know no one else is around fantastic ok so now we're going to say ok right on the scene there is now an active right there so we change the data structure after that we will document are active writer and then we'll wake someone up ok so how can we improve this like there's several things we want to do first of all	block	256
ok let's see what the writers doing ok so on the writing side let's acquire the mutex ok and then will check to see if anybody else is currently reading or writing so if there's anybody touching the patient right now for reading or writing then we want to block so we're going to block inside this condition wait alright if we get past that then we know no one else is around fantastic ok so now we're going to say ok right on the scene there is now an active right there so we change the data structure after that we will document are active writer and then we'll wake someone up ok so how can we improve this like there's several things we want to do first of all	the data structure	485
ok let's see what the writers doing ok so on the writing side let's acquire the mutex ok and then will check to see if anybody else is currently reading or writing so if there's anybody touching the patient right now for reading or writing then we want to block so we're going to block inside this condition wait alright if we get past that then we know no one else is around fantastic ok so now we're going to say ok right on the scene there is now an active right there so we change the data structure after that we will document are active writer and then we'll wake someone up ok so how can we improve this like there's several things we want to do first of all	a struct	492
unlock it though you could argue that that is unnecessary because we don't want anyone to play anyway but the reason i do that is because i would like my new readers that appear or any new writers to appear i'd actually like them to get stuck inside condition wait ok that we're actually going to send their thread to sleep	thread	308
so making threads block on peter mutex lock for extended periods of time will work but it's not best practices	block	18
so making threads block on peter mutex lock for extended periods of time will work but it's not best practices	thread	10
ok partly because it might spin the cpu for a little while which is in our case unnecessary we know we want that friend to go to sleep we know we wanted to actually be blocked inside p three condition wait ok so now we've unlock the mutex right so we only going to hold the mutex whilst we're filling in checking are variables so got these little bits of code here but	block	168
ok partly because it might spin the cpu for a little while which is in our case unnecessary we know we want that friend to go to sleep we know we wanted to actually be blocked inside p three condition wait ok so now we've unlock the mutex right so we only going to hold the mutex whilst we're filling in checking are variables so got these little bits of code here but	code	355
do we have now working code alright so now you can see that my writers if there's an active writer that is already changed values of writing to one then any future writers will see that and get stuck similarly if i've got a reader there's incremented the count from zero to one or increased it even higher than any new writers will also	code	23
my poor little writer even though it arrives at nine o'clock in the morning here never gets a chance to run always stuck inside this p thread condition wait there's never a time when reading gets down down to zero so everybody continue because my website so popular continues to see yesterday's content i never have a chance to update it right so we need to think about how to fix that and we'll talk about that in a future video by	thread	135
hi welcome to lecture twenty four we're going to start with a quick code review let's see look at this attempted waiting a fixed sized ring buffer and we'll see if we can figure out how it might go wrong ok so some of the things that we want to ask are is deadlock possible in other words could get stuck so that's never able to continue is underflow possible in other words could it be that we attempt to write so attempt to read some data that's not actually inside the ring buffer so will just be reading back some garbage information or perhaps overflow as possible which means that we're able to put more data into my buffer then it can actually hold so presumably we were going to corrupt something possibly value that we have not yet written out so what do we got here we have	code	68
two counting semaphores and will see the s one is initialized to two hundred and fifty six so this smells to me like some kind of capacity counting thing which is going to go down as we started add things and as two is initialized to zero so s two sounds to me like it's going to be counting the number of items in ok let's touch you have a look at the code then for my enqueue and dequeue or nq and deck so i see i'm going to move text lock ok so that's good so that only one thread at the time can be actually inside this code and in fact for this particular implementation is chosen to use the same mutex lock for both the nq in the dequeue ok but i do notice inside this implementation is that normally what do we do normally send post so the same way it happens first and we normally only have the mutex lock that wraps the buffer call as well so yeah	code	353
two counting semaphores and will see the s one is initialized to two hundred and fifty six so this smells to me like some kind of capacity counting thing which is going to go down as we started add things and as two is initialized to zero so s two sounds to me like it's going to be counting the number of items in ok let's touch you have a look at the code then for my enqueue and dequeue or nq and deck so i see i'm going to move text lock ok so that's good so that only one thread at the time can be actually inside this code and in fact for this particular implementation is chosen to use the same mutex lock for both the nq in the dequeue ok but i do notice inside this implementation is that normally what do we do normally send post so the same way it happens first and we normally only have the mutex lock that wraps the buffer call as well so yeah	thread	477
hi, so let's address a point of confusion and start talking about how we can write and read things inside the c library, but also how it works underneath. so let me change to laptop mode. ok, great. so here's the big idea	address	13
that, at the heart of it all, if i want to stream some information out, and it doesn't matter whether it's to a pipe or network socket or file, i'm going to use the low level system calls called read and write. and they work with file descriptors. and initially, you get actually three file descriptors for free: one for input, one for output, and one for an output error stream as well. and we can make more by opening files [using?] other objects, but that is the lowest level interface. and inside cs 241 then, we're actually going to use both of these. we're going to work with this low level interface. but we'll also see how the c library wraps this up into something more useful. for example and perhaps i want to read some formatted information like i've got scientific numbers, or maybe i want to write out some formatted information like numbers which only have a limited number of decimal points, or i want to read in certain words and tokenize them. so in this course, actually, we're going to be playing with both, but it's important to realize whether you're at the c library level, or whether you're playing with the lowest forms, these read and write calls. and what's actually "really cool about these, this gets ""lowest level,"" there" is the fact that they can be used with different kinds of objects. so	system	175
and when we want to ensure good performance as well. because the c library, when we actually say, """hey, print out the following numbers for me or send me to" """send the following strings,"" isn't necessarily" going to immediately call write. it's not immediately going to call the system. instead, for performance, it may choose to buffer all of that content inside the memory until the day that we decide to flush it out until the day we decide to send it. so let's turn our attention then to the kind of c library version of the world where,	the following	116
and when we want to ensure good performance as well. because the c library, when we actually say, """hey, print out the following numbers for me or send me to" """send the following strings,"" isn't necessarily" going to immediately call write. it's not immediately going to call the system. instead, for performance, it may choose to buffer all of that content inside the memory until the day that we decide to flush it out until the day we decide to send it. so let's turn our attention then to the kind of c library version of the world where,	memory	373
and when we want to ensure good performance as well. because the c library, when we actually say, """hey, print out the following numbers for me or send me to" """send the following strings,"" isn't necessarily" going to immediately call write. it's not immediately going to call the system. instead, for performance, it may choose to buffer all of that content inside the memory until the day that we decide to flush it out until the day we decide to send it. so let's turn our attention then to the kind of c library version of the world where,	string	182
and when we want to ensure good performance as well. because the c library, when we actually say, """hey, print out the following numbers for me or send me to" """send the following strings,"" isn't necessarily" going to immediately call write. it's not immediately going to call the system. instead, for performance, it may choose to buffer all of that content inside the memory until the day that we decide to flush it out until the day we decide to send it. so let's turn our attention then to the kind of c library version of the world where,	system	284
there we go. we have standard in (stdin), standard out (stdout), and standard error (stderr). and i can use these where i can use standard out and standard error, for example, with fprintf.	printf	182
so all those times you been writing printf, that's "actually just equivalent to saying, ""hey, fprintf" please send those bytes that i want to send "to standard out. right, so if tomorrow i said, ""no more printf,""" "you today could say, ""oh, no problem! i'm going to use" fprintf instead, and i'm going to send my output to "standard out."" what are these objects by the way they" are just objects which is of type: file pointer. and so	type	413
so all those times you been writing printf, that's "actually just equivalent to saying, ""hey, fprintf" please send those bytes that i want to send "to standard out. right, so if tomorrow i said, ""no more printf,""" "you today could say, ""oh, no problem! i'm going to use" fprintf instead, and i'm going to send my output to "standard out."" what are these objects by the way they" are just objects which is of type: file pointer. and so	printf	36
so all those times you been writing printf, that's "actually just equivalent to saying, ""hey, fprintf" please send those bytes that i want to send "to standard out. right, so if tomorrow i said, ""no more printf,""" "you today could say, ""oh, no problem! i'm going to use" fprintf instead, and i'm going to send my output to "standard out."" what are these objects by the way they" are just objects which is of type: file pointer. and so	pointer	424
tomorrow, if you wanted, you could make a new file object by calling fopen. and what's inside a file pointer? what is	pointer	101
this struct, what is this thing? and the answer is don't ask. it's actually an opaque type where we don't get to peer inside it. instead it's details are left for the internals of things like fprintf and fopen, so the implementation of those functions will use what's inside that data structure. but we personally don't actually kind of peer inside it. i'll talk in the future about how we might implement	type	86
this struct, what is this thing? and the answer is don't ask. it's actually an opaque type where we don't get to peer inside it. instead it's details are left for the internals of things like fprintf and fopen, so the implementation of those functions will use what's inside that data structure. but we personally don't actually kind of peer inside it. i'll talk in the future about how we might implement	a struct	283
this struct, what is this thing? and the answer is don't ask. it's actually an opaque type where we don't get to peer inside it. instead it's details are left for the internals of things like fprintf and fopen, so the implementation of those functions will use what's inside that data structure. but we personally don't actually kind of peer inside it. i'll talk in the future about how we might implement	printf	193
a file, but for now let's just think of it as a way to make life a little bit easier for most programmers who are not going to be thinking about reading or writing at the lowest level. they're not going to be using those system calls. instead, they're going to be using the c library. right so with that, our next little video will be on: what do you think the following code will produce?	the following	357
a file, but for now let's just think of it as a way to make life a little bit easier for most programmers who are not going to be thinking about reading or writing at the lowest level. they're not going to be using those system calls. instead, they're going to be using the c library. right so with that, our next little video will be on: what do you think the following code will produce?	code	371
a file, but for now let's just think of it as a way to make life a little bit easier for most programmers who are not going to be thinking about reading or writing at the lowest level. they're not going to be using those system calls. instead, they're going to be using the c library. right so with that, our next little video will be on: what do you think the following code will produce?	system	221
what do you think we will see when we run this code?	code	47
hi so we started this little lecture with the idea that every time we wanted to have more memory every time you called malac we could implement that just by going back to the kernel to say hey kernal please raise the watermark will call sbrk would just get some more ram that way but we can do better than that we need a heap allocator that can keep track of blocks of memory that have been freed so that in future allocations we can reuse those pieces of memory and so how can we do this efficiently actually this is a nontrivial problem actually this is an np hard problem because we need to try to find the best allocation of a sequence of of allocations and we're not clairvoyant either so we can't actually do the perfect possible sedative or sequences of allocations so instead we need an algorithm to choose where to place the next malloc request that allocation request that is fast and house reasonably good performance	memory	90
hi so we started this little lecture with the idea that every time we wanted to have more memory every time you called malac we could implement that just by going back to the kernel to say hey kernal please raise the watermark will call sbrk would just get some more ram that way but we can do better than that we need a heap allocator that can keep track of blocks of memory that have been freed so that in future allocations we can reuse those pieces of memory and so how can we do this efficiently actually this is a nontrivial problem actually this is an np hard problem because we need to try to find the best allocation of a sequence of of allocations and we're not clairvoyant either so we can't actually do the perfect possible sedative or sequences of allocations so instead we need an algorithm to choose where to place the next malloc request that allocation request that is fast and house reasonably good performance	block	359
what we'd like to avoid is a lot of fragmentation if we end up with a heap where all the spare space is actually in very tiny short blocks then that means that i can no longer allocate very large requests and many requests that what i have to do for many requests is just keep walking through my data of representation of all these entries and none of them will be any good because they're all too small so my performance will be awful i'll take a long time to find a good place for the next allocation so let's get started let's have a look at this we've got a little simulation that we're going to use here paper based simulation and we will use this simulation to understand a little	block	132
so his default of the game that we're going to maintain our idea of heap just using a simple link list and each link each node in my linked list data structure just represents a segment of memory that is either currently in use meaning it's been allocated or is available is free so we'll keep our linked list in sorted order and everytime malloc is called we're going to actually walk through that link list looking for	memory	189
so his default of the game that we're going to maintain our idea of heap just using a simple link list and each link each node in my linked list data structure just represents a segment of memory that is either currently in use meaning it's been allocated or is available is free so we'll keep our linked list in sorted order and everytime malloc is called we're going to actually walk through that link list looking for	a struct	148
place that we can use to satisfy that request for some contiguous memory	memory	66
right when we find a piece of memory that third is large enough and free we're actually going to do two things	memory	30
were actually going to obviously return that address back to the caller so that they have their memory that they requested but the piece of memory that we found is probably larger than what was requested which means there's going to be some unused space at the end so let's change our link list let's add a new entry for that unused part so that future calls to malloc can potentially make use of that spare space	memory	96
were actually going to obviously return that address back to the caller so that they have their memory that they requested but the piece of memory that we found is probably larger than what was requested which means there's going to be some unused space at the end so let's change our link list let's add a new entry for that unused part so that future calls to malloc can potentially make use of that spare space	address	45
similarly when free is called we're going to do two things we want to mark that entry in our link list is now available for future allocations but it could be that my linked list actually has two neighboring entries which are both free so at this point let's clean up our linked list so that rather than having two separate entries we can represent that as just a single entry of a much larger space and similarly we could i actually think about the fact that there might be some spam space behind the current entry as well but we won't go into those details today we're not going to implement a full piece of working c code here instead we can think about conceptually about how these placement strategies work and for that to have a feel for what's going on we're going to play the following little game so we want to get out of it ok there we go right so here's the rules of the game is that i've got the following allocations were going to occur in order i've got three k four k three k and then we're going to free our memory and then we're going to make some more allocations in another deallocation right so we're going to run through this little sequence of malloc and free calls and we have to satisfy those calls secondly there might be a toy point when	the following	780
similarly when free is called we're going to do two things we want to mark that entry in our link list is now available for future allocations but it could be that my linked list actually has two neighboring entries which are both free so at this point let's clean up our linked list so that rather than having two separate entries we can represent that as just a single entry of a much larger space and similarly we could i actually think about the fact that there might be some spam space behind the current entry as well but we won't go into those details today we're not going to implement a full piece of working c code here instead we can think about conceptually about how these placement strategies work and for that to have a feel for what's going on we're going to play the following little game so we want to get out of it ok there we go right so here's the rules of the game is that i've got the following allocations were going to occur in order i've got three k four k three k and then we're going to free our memory and then we're going to make some more allocations in another deallocation right so we're going to run through this little sequence of malloc and free calls and we have to satisfy those calls secondly there might be a toy point when	memory	1024
similarly when free is called we're going to do two things we want to mark that entry in our link list is now available for future allocations but it could be that my linked list actually has two neighboring entries which are both free so at this point let's clean up our linked list so that rather than having two separate entries we can represent that as just a single entry of a much larger space and similarly we could i actually think about the fact that there might be some spam space behind the current entry as well but we won't go into those details today we're not going to implement a full piece of working c code here instead we can think about conceptually about how these placement strategies work and for that to have a feel for what's going on we're going to play the following little game so we want to get out of it ok there we go right so here's the rules of the game is that i've got the following allocations were going to occur in order i've got three k four k three k and then we're going to free our memory and then we're going to make some more allocations in another deallocation right so we're going to run through this little sequence of malloc and free calls and we have to satisfy those calls secondly there might be a toy point when	code	620
when there's actually two reasonable areas memory that we could return in which case we're going to have if we have that type break we will choose the earliest segment that satisfies our placement strategy ok so here's the plan we will run through this with different	memory	43
when there's actually two reasonable areas memory that we could return in which case we're going to have if we have that type break we will choose the earliest segment that satisfies our placement strategy ok so here's the plan we will run through this with different	type	121
ok let's review this one what do you think the following code will print ok so	the following	43
ok let's review this one what do you think the following code will print ok so	code	57
how can we analyze this right so i've got a pizza it create and i'm storing somewhere the thread ids and i'm going to say ok i want a thread that is going to start function a and let's start function be and we're going to pass a void pointer the address of the string literals so the address of the capital a and address of the capital x to each one right so what will function b do function b then get this pointer and so we're giving it the address of xyz so when this runs and we're not quite sure when it will run it will print out xyz	a thread	132
how can we analyze this right so i've got a pizza it create and i'm storing somewhere the thread ids and i'm going to say ok i want a thread that is going to start function a and let's start function be and we're going to pass a void pointer the address of the string literals so the address of the capital a and address of the capital x to each one right so what will function b do function b then get this pointer and so we're giving it the address of xyz so when this runs and we're not quite sure when it will run it will print out xyz	string	261
how can we analyze this right so i've got a pizza it create and i'm storing somewhere the thread ids and i'm going to say ok i want a thread that is going to start function a and let's start function be and we're going to pass a void pointer the address of the string literals so the address of the capital a and address of the capital x to each one right so what will function b do function b then get this pointer and so we're giving it the address of xyz so when this runs and we're not quite sure when it will run it will print out xyz	thread	90
how can we analyze this right so i've got a pizza it create and i'm storing somewhere the thread ids and i'm going to say ok i want a thread that is going to start function a and let's start function be and we're going to pass a void pointer the address of the string literals so the address of the capital a and address of the capital x to each one right so what will function b do function b then get this pointer and so we're giving it the address of xyz so when this runs and we're not quite sure when it will run it will print out xyz	address	246
how can we analyze this right so i've got a pizza it create and i'm storing somewhere the thread ids and i'm going to say ok i want a thread that is going to start function a and let's start function be and we're going to pass a void pointer the address of the string literals so the address of the capital a and address of the capital x to each one right so what will function b do function b then get this pointer and so we're giving it the address of xyz so when this runs and we're not quite sure when it will run it will print out xyz	pointer	234
now what about function a so functionally when it runs let's see is given the address of abc ok but it doesn't do anything instead it just simply exits this thread and it returns an address so it takes the pointer that we gave it which was a pointer to the string in memory abc and a zero bite if it is	memory	267
now what about function a so functionally when it runs let's see is given the address of abc ok but it doesn't do anything instead it just simply exits this thread and it returns an address so it takes the pointer that we gave it which was a pointer to the string in memory abc and a zero bite if it is	string	257
now what about function a so functionally when it runs let's see is given the address of abc ok but it doesn't do anything instead it just simply exits this thread and it returns an address so it takes the pointer that we gave it which was a pointer to the string in memory abc and a zero bite if it is	thread	157
now what about function a so functionally when it runs let's see is given the address of abc ok but it doesn't do anything instead it just simply exits this thread and it returns an address so it takes the pointer that we gave it which was a pointer to the string in memory abc and a zero bite if it is	address	78
now what about function a so functionally when it runs let's see is given the address of abc ok but it doesn't do anything instead it just simply exits this thread and it returns an address so it takes the pointer that we gave it which was a pointer to the string in memory abc and a zero bite if it is	pointer	206
ok and we take that caster character add one in other words we just calculated a pointer that now points to the b ok and we return that so if and when these two threads run we know that the first first one returns a pointer to bc string and the second one prints out xyz right what is the rest of the code to write so equals p thread join on thread a and grab the result and so in stores that in there area code result ok so what what is going to be put inside this result so this line is going to wait is going to wait until it's able to join p thread so that means we wait until functionary has finished at which point we set this result variable to be a pointer and it's pointing to here we go do that be right there which we print out ok so this will print bc add a new line	code	301
ok and we take that caster character add one in other words we just calculated a pointer that now points to the b ok and we return that so if and when these two threads run we know that the first first one returns a pointer to bc string and the second one prints out xyz right what is the rest of the code to write so equals p thread join on thread a and grab the result and so in stores that in there area code result ok so what what is going to be put inside this result so this line is going to wait is going to wait until it's able to join p thread so that means we wait until functionary has finished at which point we set this result variable to be a pointer and it's pointing to here we go do that be right there which we print out ok so this will print bc add a new line	string	230
ok and we take that caster character add one in other words we just calculated a pointer that now points to the b ok and we return that so if and when these two threads run we know that the first first one returns a pointer to bc string and the second one prints out xyz right what is the rest of the code to write so equals p thread join on thread a and grab the result and so in stores that in there area code result ok so what what is going to be put inside this result so this line is going to wait is going to wait until it's able to join p thread so that means we wait until functionary has finished at which point we set this result variable to be a pointer and it's pointing to here we go do that be right there which we print out ok so this will print bc add a new line	thread	161
ok and we take that caster character add one in other words we just calculated a pointer that now points to the b ok and we return that so if and when these two threads run we know that the first first one returns a pointer to bc string and the second one prints out xyz right what is the rest of the code to write so equals p thread join on thread a and grab the result and so in stores that in there area code result ok so what what is going to be put inside this result so this line is going to wait is going to wait until it's able to join p thread so that means we wait until functionary has finished at which point we set this result variable to be a pointer and it's pointing to here we go do that be right there which we print out ok so this will print bc add a new line	pointer	81
ok right so now we hopefully you can conclude what this code is going to print right so if you said it's going to print bc or the new line then you'd be correct if you said it's going to print bc in a new line and xyz you'd be correct if you said is going to print xyz with a new line and bc you'd be correct yes so what code is actually indeterminate fethard create makes no promises about when these threads now going to stop maybe in a microsecond maybe in a millisecond time there's a very real chance that	code	56
ok right so now we hopefully you can conclude what this code is going to print right so if you said it's going to print bc or the new line then you'd be correct if you said it's going to print bc in a new line and xyz you'd be correct if you said is going to print xyz with a new line and bc you'd be correct yes so what code is actually indeterminate fethard create makes no promises about when these threads now going to stop maybe in a microsecond maybe in a millisecond time there's a very real chance that	thread	402
the first thread thread a could could start up exit and main thread could join on that we could print out an exit before thread b has a chance to start this would be particularly true on sale really busy system or a system that's only got one cpu core are poor threadbear it hasn't had a cpu scheduled yet and so our main thread is done before it he has a chance to start up ok right so all those those as possible if we modified our code so that we included p three exit on the main thread then you know that that means that because we are never returning from maine now our program is going to run until both those threads finish so now we expect both the bc to be printed and the xyz to be printed though we can't actually say definitively what order these two things can print we can make a guess as to which ones more likely but we haven't actually	code	434
the first thread thread a could could start up exit and main thread could join on that we could print out an exit before thread b has a chance to start this would be particularly true on sale really busy system or a system that's only got one cpu core are poor threadbear it hasn't had a cpu scheduled yet and so our main thread is done before it he has a chance to start up ok right so all those those as possible if we modified our code so that we included p three exit on the main thread then you know that that means that because we are never returning from maine now our program is going to run until both those threads finish so now we expect both the bc to be printed and the xyz to be printed though we can't actually say definitively what order these two things can print we can make a guess as to which ones more likely but we haven't actually	thread	10
the first thread thread a could could start up exit and main thread could join on that we could print out an exit before thread b has a chance to start this would be particularly true on sale really busy system or a system that's only got one cpu core are poor threadbear it hasn't had a cpu scheduled yet and so our main thread is done before it he has a chance to start up ok right so all those those as possible if we modified our code so that we included p three exit on the main thread then you know that that means that because we are never returning from maine now our program is going to run until both those threads finish so now we expect both the bc to be printed and the xyz to be printed though we can't actually say definitively what order these two things can print we can make a guess as to which ones more likely but we haven't actually	system	204
so fun stuff with threads fun stuff with thinking about interleaving and i hope you bear this in mind as you write your own multithreaded programs	thread	18
right file globbing so what is fargo bing far globbing is the idea that on the shell i can type things like	type	91
someone had deleted slash bin ls oh dear so how would you still list the contents of your current directory well you could say echo star and that would allow you to see all of the current files and typically echo is actually built into the shell so even if there was no echo command we still stand a chance of running this this kind of tricks were once used to rescue a satellite where someone had accidentally managed to delete most of the operating system from the satellite but they still had a and interactive prompts like this and they were able to play enough games to recover the system so that satellite did not become a floating piece of dead metal up in the sky	system	451
did i forget something right there we go you often more than having to specifically type all this all those out let's just look for	type	84
and oh yes so finally just another kind of quick fun things you can do with slash proc ok so let's just go and look to see at sea the total amount of memory and other information we've got ok so you can see i can find out all sorts of cool things about my system like how many megabytes i've got how big swap area is so i can page out memory how much of it is being used this system has quite a better memory ok that's good	memory	150
and oh yes so finally just another kind of quick fun things you can do with slash proc ok so let's just go and look to see at sea the total amount of memory and other information we've got ok so you can see i can find out all sorts of cool things about my system like how many megabytes i've got how big swap area is so i can page out memory how much of it is being used this system has quite a better memory ok that's good	system	256
i can look to see how fast my cpus are and when your linux system starts up it has a simple timing loop simple for loop that goes around as fast as possible and it uses this to try to estimate how fast how many millions of operations per second your cpu could do but this is a relatively bogus way of measuring cpu speed so therefore was called bogomips ok so this actually information is stored by each cpu so it's going to have a look at this	system	59
ok like cat slash procs cpu info given whole loada stuff like the fact that i thought i'd bought a sixty four bit machine but in fact my actual wires coming out of my cpu there's only actually forty addressable wires coming out of my cpu so it was a lie it was a cheat so we do this of course for energy and for space and for cost reasons so it pretends to be a sixty four but i don't truly have a sixty four bit addressable machine here ok i can find out what operations distinct supports what cpu type it claims to be k and how big the caches but today we just want to see how did it do it start up and you'll see that i've actually got four cpus inside this machine and each of them claimed to have about four billion instructions per second at least bogost instructions per second	type	499
ok like cat slash procs cpu info given whole loada stuff like the fact that i thought i'd bought a sixty four bit machine but in fact my actual wires coming out of my cpu there's only actually forty addressable wires coming out of my cpu so it was a lie it was a cheat so we do this of course for energy and for space and for cost reasons so it pretends to be a sixty four but i don't truly have a sixty four bit addressable machine here ok i can find out what operations distinct supports what cpu type it claims to be k and how big the caches but today we just want to see how did it do it start up and you'll see that i've actually got four cpus inside this machine and each of them claimed to have about four billion instructions per second at least bogost instructions per second	address	199
ok so that's bogomips and finally let's how she could have a look at a particular program let's go into cd proc self and see if you can workout what my program is ok so what is cd proc self maybe we should have a convertible hint here so let me go and look at the clock self and you'll see actually it's a number it happens to be processed fifteen oh sixty one so basically now my program is talking about itself what do we have here hold other things ok so let's find out what the memory maps look like	memory	482
right so this should give it give it away right so much tells me about the actual memory mapping of a process which i think is pretty cool ok so this process currently got you can see it's got a whole load of libraries which are mapped into different parts of the address space let me keep scrolling backwards here there's a lot of mappings	memory	82
right so this should give it give it away right so much tells me about the actual memory mapping of a process which i think is pretty cool ok so this process currently got you can see it's got a whole load of libraries which are mapped into different parts of the address space let me keep scrolling backwards here there's a lot of mappings	a process	100
right so this should give it give it away right so much tells me about the actual memory mapping of a process which i think is pretty cool ok so this process currently got you can see it's got a whole load of libraries which are mapped into different parts of the address space let me keep scrolling backwards here there's a lot of mappings	address	264
great then you might notice that i've got some address space over here which is mapped to the file slash bin slash bash yes that's right i've got different parts of bash matt of the file bin bash mapped and the difference here is whether they are rewritable etc so this one is actually executable part this is just a read only part and then i've also got some memory which is dedicated to the heap so i can see how big my heap is here	memory	360
great then you might notice that i've got some address space over here which is mapped to the file slash bin slash bash yes that's right i've got different parts of bash matt of the file bin bash mapped and the difference here is whether they are rewritable etc so this one is actually executable part this is just a read only part and then i've also got some memory which is dedicated to the heap so i can see how big my heap is here	the heap	389
great then you might notice that i've got some address space over here which is mapped to the file slash bin slash bash yes that's right i've got different parts of bash matt of the file bin bash mapped and the difference here is whether they are rewritable etc so this one is actually executable part this is just a read only part and then i've also got some memory which is dedicated to the heap so i can see how big my heap is here	address	47
and then i've got other things in here which is the sum of the standard libraries that we've dynamically loaded when this program started today the addresses which we map the virtual addresses that we use randomized somewhat to make it harder for attackers to guess where pieces of code are actually going to be found inside the virtual address of the system so that's called address randomization and it's kind of another piece of the security arsenal of the kernel for how we try to prevent attackers from taking over our machines right with that i'll stop and see you in a future lecture ok bye	code	282
and then i've got other things in here which is the sum of the standard libraries that we've dynamically loaded when this program started today the addresses which we map the virtual addresses that we use randomized somewhat to make it harder for attackers to guess where pieces of code are actually going to be found inside the virtual address of the system so that's called address randomization and it's kind of another piece of the security arsenal of the kernel for how we try to prevent attackers from taking over our machines right with that i'll stop and see you in a future lecture ok bye	address	148
and then i've got other things in here which is the sum of the standard libraries that we've dynamically loaded when this program started today the addresses which we map the virtual addresses that we use randomized somewhat to make it harder for attackers to guess where pieces of code are actually going to be found inside the virtual address of the system so that's called address randomization and it's kind of another piece of the security arsenal of the kernel for how we try to prevent attackers from taking over our machines right with that i'll stop and see you in a future lecture ok bye	system	352
now in the previous video i mentioned the correct version of catalog actually checks for overflow so how she would do that well it's actually not that easy so we've got a couple of choices i could open my favorite bit twiddling book how hackers delight and check to see how we get there quickly test for overflow when multiplying two numbers together we could do some kind of simple type size check so if we have a kind of max size we could divide by say count and check to see weather we've got a value that is going to work with our size or not right so or if i had a type that was greater than my pointers for example if i had some kind of one hundred and twenty eight bit integer that was fast	type	383
now in the previous video i mentioned the correct version of catalog actually checks for overflow so how she would do that well it's actually not that easy so we've got a couple of choices i could open my favorite bit twiddling book how hackers delight and check to see how we get there quickly test for overflow when multiplying two numbers together we could do some kind of simple type size check so if we have a kind of max size we could divide by say count and check to see weather we've got a value that is going to work with our size or not right so or if i had a type that was greater than my pointers for example if i had some kind of one hundred and twenty eight bit integer that was fast	pointer	600
on my machine i would implement it like using that and that in practice is how modern compilers will use it if this modern cpu supports an even larger type that is typically the fastest way to check to see if the multiplication can fit inside our sixty four bits of a pointer	type	151
on my machine i would implement it like using that and that in practice is how modern compilers will use it if this modern cpu supports an even larger type that is typically the fastest way to check to see if the multiplication can fit inside our sixty four bits of a pointer	pointer	268
and let's write some some nice code that we will put some braces around that so what do we got next we've got the idea to set all these bikes to zero so i want to write something like ok so let me go through each of these bytes that's not user int let's have	code	31
useful type a size t and well i is less that ok now in this kind of code let's make sure we choose the right variable i've got a choice of three counts size or total so let me slow down and make sure you still at one k and now i will need to set all of those bikes to zero oh ok so for this i would need to say a character pointer right so i could cast my result	type	7
useful type a size t and well i is less that ok now in this kind of code let's make sure we choose the right variable i've got a choice of three counts size or total so let me slow down and make sure you still at one k and now i will need to set all of those bikes to zero oh ok so for this i would need to say a character pointer right so i could cast my result	code	68
useful type a size t and well i is less that ok now in this kind of code let's make sure we choose the right variable i've got a choice of three counts size or total so let me slow down and make sure you still at one k and now i will need to set all of those bikes to zero oh ok so for this i would need to say a character pointer right so i could cast my result	pointer	323
ok now i've got a character pointer looking at the	pointer	28
beginning of that bites and now i'd use i and set that equal to zero hold on new moment you might say well it shouldn't i use an issue pointing out that way i can set more bites well yeah maybe but that is kind of tricky now because now every time we advance by i'm going to advanced by four bytes so it actually end up overwriting way too much memory instead of writing it to say a thousand bytes would have written to say four thousand bytes so i would have completely written to memory that i shouldn't have had access to ok so that wasn't a good idea and in fact we should probably do better than this if i just want to zero out some memory surely there's a way to do this which is faster than me writing a full loop and in fact yes there is there's something called memset an memset 's implementation actually will make use of cpu instructions which can do this and much more quickly than any code that we could write in c so how do i use memset well there's a big hint on here to say this is the signature of memset we take a pointer	memory	345
beginning of that bites and now i'd use i and set that equal to zero hold on new moment you might say well it shouldn't i use an issue pointing out that way i can set more bites well yeah maybe but that is kind of tricky now because now every time we advance by i'm going to advanced by four bytes so it actually end up overwriting way too much memory instead of writing it to say a thousand bytes would have written to say four thousand bytes so i would have completely written to memory that i shouldn't have had access to ok so that wasn't a good idea and in fact we should probably do better than this if i just want to zero out some memory surely there's a way to do this which is faster than me writing a full loop and in fact yes there is there's something called memset an memset 's implementation actually will make use of cpu instructions which can do this and much more quickly than any code that we could write in c so how do i use memset well there's a big hint on here to say this is the signature of memset we take a pointer	code	898
beginning of that bites and now i'd use i and set that equal to zero hold on new moment you might say well it shouldn't i use an issue pointing out that way i can set more bites well yeah maybe but that is kind of tricky now because now every time we advance by i'm going to advanced by four bytes so it actually end up overwriting way too much memory instead of writing it to say a thousand bytes would have written to say four thousand bytes so i would have completely written to memory that i shouldn't have had access to ok so that wasn't a good idea and in fact we should probably do better than this if i just want to zero out some memory surely there's a way to do this which is faster than me writing a full loop and in fact yes there is there's something called memset an memset 's implementation actually will make use of cpu instructions which can do this and much more quickly than any code that we could write in c so how do i use memset well there's a big hint on here to say this is the signature of memset we take a pointer	pointer	1032
so another example of where is often great to kind of write code slowly use the manpages check to make	code	60
ok so that's my implementation of of calc is it going to be as fast as the real of implementation of calc probably not and also it the real version can make use of some secret facts so for example if we ask for some more memory from the system that's going to actually be zeroed out because we knew pages we get from the system must must be cleared so we so it doesn't	memory	221
ok so that's my implementation of of calc is it going to be as fast as the real of implementation of calc probably not and also it the real version can make use of some secret facts so for example if we ask for some more memory from the system that's going to actually be zeroed out because we knew pages we get from the system must must be cleared so we so it doesn't	system	237
but anyway we've got that so now the next video let's start talking about kind of one of the way that we can interact with the heap and that is with	the heap	123
ok so sometimes we'll see livelock if example you are constantly polling things and it looks like you're able to actually execute the next line of code but your program is not doing anything useful because it never actually kind of completes gets past a certain condition that you've set so that's an example of livelock it is like i said it does not meet the formal requirements of deadlock but as an end user we're still unhappy when it occurs right so in the next video let's get time attention back to the four conditions of deadlock okay bye	code	147
so technically a context switch is when let me do it down here when you say thank you very much cpu i know you're working on say one particular process going to prepare so that now the cpu can work on a different process it is not correct to describe a context switch to when switching from one thread to a different thread of the same process ok so you can't say right i'm in thread ten and i'm going to say thread eleven of the same process that is not a context switch however many people erroneously used the word context switch to describe those kind of switches when you're actually switching from one thread to another fit inside the same process so it should be different processes right	thread	295
so let's think about then what actually needs to happen when we do this and will only look at it in terms of our fairly simple model of cpu etc navarre of our kernel a real context which will have many additional more steps so so what are we going to be able to do is to explain why context switches are expensive in other words why there's a significant overhead to moving from one process to another right so what are the kind of some of the things that we need to two right so first of all we've got the virtual memory address mapping in other words are page tables these only makes sense for a particular process that a particular memory inside a particular process is going to be mapped or not to actual physical piece of ram and so the same address inside a different physical process	memory	515
so let's think about then what actually needs to happen when we do this and will only look at it in terms of our fairly simple model of cpu etc navarre of our kernel a real context which will have many additional more steps so so what are we going to be able to do is to explain why context switches are expensive in other words why there's a significant overhead to moving from one process to another right so what are the kind of some of the things that we need to two right so first of all we've got the virtual memory address mapping in other words are page tables these only makes sense for a particular process that a particular memory inside a particular process is going to be mapped or not to actual physical piece of ram and so the same address inside a different physical process	address	522
could be mapped in a completely different fashion so we need to change the process the page table from page table for process one to page table process too the second thing we need to do is that we keep a lot of accounting information so let's update how much time are processor has actually been working on process one because at some point is going to exhaust goodwill is going to exhaust the amount of time we want it to actually have running on running a particular cpu on a particular process and so we better keep track of that because at some point we might want to say right now it's time to not go back to process one plus two pets want to process three instead ok so we gotta update this accounting information about just exactly how much cpu time where we are spending on a particular process ok so are we done no absolutely not here's something which is perhaps surprising which is do you remember the tlb ok what was the purpose of the tlb the tlb was to make our memory look up so fast that if in my process one	memory	977
i know that i want to read a particular memory ok let's read this piece of memory here	memory	40
then i can bypass all of the page table vlookups if i've read the same piece of memory or a nearby piece of memory in the very near future so if i swap now from process one process two i have lost all that information about the tlb in other words if i now inside process two then in order to read or write even a single bite of main memory i've got to follow the page tables and remember page table will typically for your process down slow it down say two or three times compared to just begun to access memory immediately so tlb here makes naively our programs run say two three times slower simply because all of these look up so it needs to do just in order to access a piece of memory ok doesn't sound too good to me right eh	memory	80
quick comment about how we teach this or how it's disgusting interviews and what happens in real life right so the kind of the model that is often discussed in terms of videos and exams etc is the assumption that when you change one process to another process you're just simply going to flush the entire tlb because all the information in there is no longer relevant to the mapping for the new process ok that's somewhat true it's in many processes except for the latest intel processors where we actually play a cute trick which is where hey you know what will probably be context switching back to this process so let me stash the tlb indices and look up 's in some side memory and we won't worry about it until the day that we decided to context switch back to this very same process ok so this is why context switches are expensive we have a lot to do and the typical you pay for context switches in two different ways one is the actual setting up of all the different registers for everything from getting the program counter already to say copying out the tlb and other information the second is actually to do with the tv itself so there's can have no good tlb information so remember the tlb	memory	674
it's very purpose is to avoid all of those look up we need to do in order to convert a virtual address to a physical address so all conversions from fit virtual address	address	95
to a a virtual or conversions from virtual address to a physical address	address	43
that allows us to put a block on other threads so how's it going to work ok so here it is i will do it over here	block	24
that allows us to put a block on other threads so how's it going to work ok so here it is i will do it over here	thread	39
right so you seen so already the idea i could make these type thread things which represent a running thread of execution now what else does posix give us when i say posix this is posix standard part of unix is the	type	57
right so you seen so already the idea i could make these type thread things which represent a running thread of execution now what else does posix give us when i say posix this is posix standard part of unix is the	thread	62
standard which writing all the code ok so we're going to make one of these mutex objects let's call it say lock	code	31
and what can i do with them ok so a lot doesn't support that many operations we can lock it and unlock it so let's have a look at that code and big important idea is before we're out allowed to lock and unlock the mutex i have to initialize it so there's a couple of ways you can do that guess what you can say pthread mutex iniciat and pass in a lock and one of the great things about pizza it's implementation of mutex locks is that we can actually pass in a few attributes like we can set it up to debug we can actually create recursive locks but i'm going to anyway we're going to stick with this vanilla logs today again this is kind of one of the example where where the posix implementation the positive definition of mutex logs goes a little bit further than what the new c standards do ok so i want to initialize my lock and i'm not going to pass in any special attributes today right so that's one way of doing it	code	135
and what can i do with them ok so a lot doesn't support that many operations we can lock it and unlock it so let's have a look at that code and big important idea is before we're out allowed to lock and unlock the mutex i have to initialize it so there's a couple of ways you can do that guess what you can say pthread mutex iniciat and pass in a lock and one of the great things about pizza it's implementation of mutex locks is that we can actually pass in a few attributes like we can set it up to debug we can actually create recursive locks but i'm going to anyway we're going to stick with this vanilla logs today again this is kind of one of the example where where the posix implementation the positive definition of mutex logs goes a little bit further than what the new c standards do ok so i want to initialize my lock and i'm not going to pass in any special attributes today right so that's one way of doing it	thread	312
so that in the future when i call the loc method on my mutex it will automatically initialize at that point so you can choose one of these but don't choose both particular mutex right so how can i find out more about these mutex locks well guess what the i've got a lot of information inside my manual for example i could all this stuff about the p threads and what i can do in a detached state which i kind of skipped over	thread	349
but we care about which is the p thread mutex lock here we go and you'll see it doesn't take that many parameters this was really easy we just take the address or mutex object ok so the definition here is if the mutex is already locked the calling third will block until the mutex becomes available ok so let's write this out as an example so i've got my pthread mutex lock here and i pass in the address of my little object here called lock right	block	259
but we care about which is the p thread mutex lock here we go and you'll see it doesn't take that many parameters this was really easy we just take the address or mutex object ok so the definition here is if the mutex is already locked the calling third will block until the mutex becomes available ok so let's write this out as an example so i've got my pthread mutex lock here and i pass in the address of my little object here called lock right	parameter	103
but we care about which is the p thread mutex lock here we go and you'll see it doesn't take that many parameters this was really easy we just take the address or mutex object ok so the definition here is if the mutex is already locked the calling third will block until the mutex becomes available ok so let's write this out as an example so i've got my pthread mutex lock here and i pass in the address of my little object here called lock right	thread	33
but we care about which is the p thread mutex lock here we go and you'll see it doesn't take that many parameters this was really easy we just take the address or mutex object ok so the definition here is if the mutex is already locked the calling third will block until the mutex becomes available ok so let's write this out as an example so i've got my pthread mutex lock here and i pass in the address of my little object here called lock right	address	152
and then i go off and do my critical section stuff so do critical section stuff here do critical section stuff like eg update the data structure or read from the data structure	the data structure	126
and then i go off and do my critical section stuff so do critical section stuff here do critical section stuff like eg update the data structure or read from the data structure	a struct	133
and then i go off and do my critical section stuff so do critical section stuff here do critical section stuff like eg update the data structure or read from the data structure	section	37
but i can be sure that if all of my code follows this pattern so after this i call p thread mutex unlock right and then here's the address of my mutex i can be clear that that that only one thread at a time can be accessed in the data structure so that sounds like a big overhead and in theory it might be if that's the only thing you're doing but remember in practice in real programs ninety nine percent of the time your thread is working on something else it's only when it's actually got a result or once more data that would actually go to this shared data structure	the data structure	226
but i can be sure that if all of my code follows this pattern so after this i call p thread mutex unlock right and then here's the address of my mutex i can be clear that that that only one thread at a time can be accessed in the data structure so that sounds like a big overhead and in theory it might be if that's the only thing you're doing but remember in practice in real programs ninety nine percent of the time your thread is working on something else it's only when it's actually got a result or once more data that would actually go to this shared data structure	a struct	233
but i can be sure that if all of my code follows this pattern so after this i call p thread mutex unlock right and then here's the address of my mutex i can be clear that that that only one thread at a time can be accessed in the data structure so that sounds like a big overhead and in theory it might be if that's the only thing you're doing but remember in practice in real programs ninety nine percent of the time your thread is working on something else it's only when it's actually got a result or once more data that would actually go to this shared data structure	code	36
but i can be sure that if all of my code follows this pattern so after this i call p thread mutex unlock right and then here's the address of my mutex i can be clear that that that only one thread at a time can be accessed in the data structure so that sounds like a big overhead and in theory it might be if that's the only thing you're doing but remember in practice in real programs ninety nine percent of the time your thread is working on something else it's only when it's actually got a result or once more data that would actually go to this shared data structure	thread	85
but i can be sure that if all of my code follows this pattern so after this i call p thread mutex unlock right and then here's the address of my mutex i can be clear that that that only one thread at a time can be accessed in the data structure so that sounds like a big overhead and in theory it might be if that's the only thing you're doing but remember in practice in real programs ninety nine percent of the time your thread is working on something else it's only when it's actually got a result or once more data that would actually go to this shared data structure	address	131
ok so that's all basic pattern this is how we bring order to our madness all the examples we've seen so far would have helped if we had this ability to pause or threats to implement synchronization now is a couple of limitations with rp thread mutex is which	thread	237
we will be able to relax when we look at other synchronization primitives but here's the big one we have to write these things in pairs we have to put the lock and unlock together on the same thread	thread	192
when we finished we should clean up so we will call p thread mutex destroy right and here's the address of my lock	thread	54
when we finished we should clean up so we will call p thread mutex destroy right and here's the address of my lock	address	96
this is not actual father spain stored on disk it's just the variable and it's the same idea with this this mutex lock its represents a mutex but it's not the attribute x itself ok see what else do you want to say right so you call peter mutex lock and we get to continue great what happens if another thread now calls peter mutex lock on the same object on the same mutex	a mutex	134
this is not actual father spain stored on disk it's just the variable and it's the same idea with this this mutex lock its represents a mutex but it's not the attribute x itself ok see what else do you want to say right so you call peter mutex lock and we get to continue great what happens if another thread now calls peter mutex lock on the same object on the same mutex	thread	302
right so we can imagine that we've got this global variable here it calls peter mutex lock guess what it has to wait it's called preferred mutex lock is blocked so right so we know for sure that this coal here either continues if no one else has the log right now and if it continues then you have acquired that look you get to play ball right the rock is yours	block	153
it may block meaning your poor cpu is not allowed to pass go and not allowed to execute a single more instruction of your code it's stuck inside here waiting	block	7
it may block meaning your poor cpu is not allowed to pass go and not allowed to execute a single more instruction of your code it's stuck inside here waiting	code	122
so great now what happens if i've got ten threads or piling together all calling petered mutex log at exactly the same nanosecond what this mutex log guarantees is is that one of them will win	thread	42
that's that one thread will acquire the lock and will continue the other nine or however many it is day or block they have to wait	block	107
that's that one thread will acquire the lock and will continue the other nine or however many it is day or block they have to wait	thread	16
at some point in the future you release the lock you it's no longer yours and out of those nine threads that are called mutex look one of them	thread	96
is going to win the others will remain blocked ok so it guarantees you that there's only one thread at a time that can acquire the lock so only zero threads are one third of the time now the piece that mutex lock doesn't do anything special other than that it doesn't bless your code in the middle it doesn't declare to the compiler that something wonderful is about to happen no it's basic pricing mechanism is very simple it either blocks or allows you to continue if no one else has acquired that look and only one thread at a time even if two threads at exactly the same clock cycle call preferred mutex locked even if even in that extreme case only one of them is guaranteed to win of course this arbitrary as to which one wins but	block	39
is going to win the others will remain blocked ok so it guarantees you that there's only one thread at a time that can acquire the lock so only zero threads are one third of the time now the piece that mutex lock doesn't do anything special other than that it doesn't bless your code in the middle it doesn't declare to the compiler that something wonderful is about to happen no it's basic pricing mechanism is very simple it either blocks or allows you to continue if no one else has acquired that look and only one thread at a time even if two threads at exactly the same clock cycle call preferred mutex locked even if even in that extreme case only one of them is guaranteed to win of course this arbitrary as to which one wins but	code	279
is going to win the others will remain blocked ok so it guarantees you that there's only one thread at a time that can acquire the lock so only zero threads are one third of the time now the piece that mutex lock doesn't do anything special other than that it doesn't bless your code in the middle it doesn't declare to the compiler that something wonderful is about to happen no it's basic pricing mechanism is very simple it either blocks or allows you to continue if no one else has acquired that look and only one thread at a time even if two threads at exactly the same clock cycle call preferred mutex locked even if even in that extreme case only one of them is guaranteed to win of course this arbitrary as to which one wins but	thread	93
ensures that we have now the ability to control are critical sections and right start to write threadsafe code so that's that big idea right so we've talked about how we can create it either used to magic initialize the constant or copy said dark addition iniciat we told how do you lock and unlock and i had mentioned how you destroyed me text by just calling peter mutex destroy ok and that's just like kind of closing a file to say ok colonel done with this resource alright see you in the next video bye	code	106
ensures that we have now the ability to control are critical sections and right start to write threadsafe code so that's that big idea right so we've talked about how we can create it either used to magic initialize the constant or copy said dark addition iniciat we told how do you lock and unlock and i had mentioned how you destroyed me text by just calling peter mutex destroy ok and that's just like kind of closing a file to say ok colonel done with this resource alright see you in the next video bye	section	61
ensures that we have now the ability to control are critical sections and right start to write threadsafe code so that's that big idea right so we've talked about how we can create it either used to magic initialize the constant or copy said dark addition iniciat we told how do you lock and unlock and i had mentioned how you destroyed me text by just calling peter mutex destroy ok and that's just like kind of closing a file to say ok colonel done with this resource alright see you in the next video bye	thread	95
okay, right so what do we got so we're taking a pointer to a pointer okay right so that sounds like we're going to be changing not result but what result actually points too	pointer	48
and here's our input this message which is a pointer to some character in other words were promising not to change the string there wait see what this code does then so we've got a little position variable int and then we're using their see libra function code is digit and we're going to pull out one character timeform the message kasel read from the current position and determine if it is a simple numerical digit or not and in fact the libra has a lot of these little useful functions here which work either with a single character or whole c string so whilst it's a digit or position is less than the length of the string keep going well we actually want to terminate if either of these conditions surf fail so i'm going to change that	code	151
and here's our input this message which is a pointer to some character in other words were promising not to change the string there wait see what this code does then so we've got a little position variable int and then we're using their see libra function code is digit and we're going to pull out one character timeform the message kasel read from the current position and determine if it is a simple numerical digit or not and in fact the libra has a lot of these little useful functions here which work either with a single character or whole c string so whilst it's a digit or position is less than the length of the string keep going well we actually want to terminate if either of these conditions surf fail so i'm going to change that	string	119
and here's our input this message which is a pointer to some character in other words were promising not to change the string there wait see what this code does then so we've got a little position variable int and then we're using their see libra function code is digit and we're going to pull out one character timeform the message kasel read from the current position and determine if it is a simple numerical digit or not and in fact the libra has a lot of these little useful functions here which work either with a single character or whole c string so whilst it's a digit or position is less than the length of the string keep going well we actually want to terminate if either of these conditions surf fail so i'm going to change that	pointer	45
and when i get to when position is equal to position to stroll in i know that i have actually already reached an all by it so it's ok to pass in a zero into it we're not passing a pointer but i might have actually written this code with these to the other way around so let's	code	227
and when i get to when position is equal to position to stroll in i know that i have actually already reached an all by it so it's ok to pass in a zero into it we're not passing a pointer but i might have actually written this code with these to the other way around so let's	pointer	180
we then we know when we exit that out of the loop then	the loop	41
ok so then what do we do right now we're changing the the value that result is pointing to so in other words if you give me the address of your variable i'm going to change the contents of your variable to point to something else this is what i want to make your variable look at i want you available to now look at some heat memory and i'm allocating this number of bytes i think the intention here is to try to put a c string in there let's see how well it does so we men copy into this is not right right now we're trying to copy it into where your variable is	memory	326
ok so then what do we do right now we're changing the the value that result is pointing to so in other words if you give me the address of your variable i'm going to change the contents of your variable to point to something else this is what i want to make your variable look at i want you available to now look at some heat memory and i'm allocating this number of bytes i think the intention here is to try to put a c string in there let's see how well it does so we men copy into this is not right right now we're trying to copy it into where your variable is	string	421
ok so then what do we do right now we're changing the the value that result is pointing to so in other words if you give me the address of your variable i'm going to change the contents of your variable to point to something else this is what i want to make your variable look at i want you available to now look at some heat memory and i'm allocating this number of bytes i think the intention here is to try to put a c string in there let's see how well it does so we men copy into this is not right right now we're trying to copy it into where your variable is	address	128
if that's on the stack i'm just yeah i'm going to actually start over writing directly over your variable ways in fact what i wanted to do was your variable supposed to holding a pointer so i actually want to change there we go your variable the thing that my variables pointing to what do we want to put in there we actually want to use the beginning of the message and here's a number of characters well did we put these in the right order in any way to truly check that is to use demand page and also notice that i'm using mem copy not stroke copies and mem copy behaves in a very similar way we give a target and a source but now we have to say exactly how many bytes and did we copy do we actually create a c string no we didn't because we copy the digits but we never terminated it so we should remember to before returning if we want to see string we should remember to set that equal to zero so result pause you better equals the	string	714
if that's on the stack i'm just yeah i'm going to actually start over writing directly over your variable ways in fact what i wanted to do was your variable supposed to holding a pointer so i actually want to change there we go your variable the thing that my variables pointing to what do we want to put in there we actually want to use the beginning of the message and here's a number of characters well did we put these in the right order in any way to truly check that is to use demand page and also notice that i'm using mem copy not stroke copies and mem copy behaves in a very similar way we give a target and a source but now we have to say exactly how many bytes and did we copy do we actually create a c string no we didn't because we copy the digits but we never terminated it so we should remember to before returning if we want to see string we should remember to set that equal to zero so result pause you better equals the	pointer	179
super bite but if we do that now we better check that we've actually allocated enough memory and so if we have a little bit of thought will realize that the memory that we should have requested is actually going to be pause plus one ok so great now we've got a function to ashley finds the digits at the beginning and then creates a brand new c string just for those digits it's possibly an empty string	memory	86
super bite but if we do that now we better check that we've actually allocated enough memory and so if we have a little bit of thought will realize that the memory that we should have requested is actually going to be pause plus one ok so great now we've got a function to ashley finds the digits at the beginning and then creates a brand new c string just for those digits it's possibly an empty string	string	345
hi so let's talk about processes processes are a fundamental unit of computation when it comes to the kernel and how it thinks about things it needs to do for users logged into the system so a process is a kind of based container for users when they want to do anything	a process	191
hi so let's talk about processes processes are a fundamental unit of computation when it comes to the kernel and how it thinks about things it needs to do for users logged into the system so a process is a kind of based container for users when they want to do anything	system	181
and any time that we started program we're actually creating a process so for example you might have a process compilation process and i might have a compilation process they both actually refer to the same program perhaps gcc c lang or some other compiler but your process is independent of my process and there's many resources which are provided to a process in a secure manner so for example you can't easily see the files that i have open and change them unless you you sell yourself actually open those files and you may or may not have access to them another important one is memories so when we create a process we assign some ram to that process and we assign around to different segments so it'll be parts of that ram that process can only read or can only execute or can we do right or parts of that memory space which don't don't belong to any room at all and these process containers then provide a strong piece of security	memory	811
and any time that we started program we're actually creating a process so for example you might have a process compilation process and i might have a compilation process they both actually refer to the same program perhaps gcc c lang or some other compiler but your process is independent of my process and there's many resources which are provided to a process in a secure manner so for example you can't easily see the files that i have open and change them unless you you sell yourself actually open those files and you may or may not have access to them another important one is memories so when we create a process we assign some ram to that process and we assign around to different segments so it'll be parts of that ram that process can only read or can only execute or can we do right or parts of that memory space which don't don't belong to any room at all and these process containers then provide a strong piece of security	a process	61
and any time that we started program we're actually creating a process so for example you might have a process compilation process and i might have a compilation process they both actually refer to the same program perhaps gcc c lang or some other compiler but your process is independent of my process and there's many resources which are provided to a process in a secure manner so for example you can't easily see the files that i have open and change them unless you you sell yourself actually open those files and you may or may not have access to them another important one is memories so when we create a process we assign some ram to that process and we assign around to different segments so it'll be parts of that ram that process can only read or can only execute or can we do right or parts of that memory space which don't don't belong to any room at all and these process containers then provide a strong piece of security	resources	320
to our linux system if your process has a bug it a bug in it and crashes it hopefully it won't bring down the entire system hopefully your process won't be able to read or write directly into the memory of my process will talk about exceptions to that world later on but this idea of a process being the kind of secure container that looks linux provides is a really really important concept and we're going to see this especially we start talking about the memory of a process and what virtual memory can give us	memory	196
to our linux system if your process has a bug it a bug in it and crashes it hopefully it won't bring down the entire system hopefully your process won't be able to read or write directly into the memory of my process will talk about exceptions to that world later on but this idea of a process being the kind of secure container that looks linux provides is a really really important concept and we're going to see this especially we start talking about the memory of a process and what virtual memory can give us	a process	284
to our linux system if your process has a bug it a bug in it and crashes it hopefully it won't bring down the entire system hopefully your process won't be able to read or write directly into the memory of my process will talk about exceptions to that world later on but this idea of a process being the kind of secure container that looks linux provides is a really really important concept and we're going to see this especially we start talking about the memory of a process and what virtual memory can give us	system	13
so great we can talk conceptive processes but how about we actually create one and this is where the fun begins so let's see if we have a drawing here great so how can i create a process here's the big news we're going to look at a system groups i don't want to know	a process	177
so great we can talk conceptive processes but how about we actually create one and this is where the fun begins so let's see if we have a drawing here great so how can i create a process here's the big news we're going to look at a system groups i don't want to know	system	232
so that's right we're not calling maine again we're not running from disk instead we are saying hey colonel look at my current process give me a complete copy of it that's right the whole stack all of the heap memory all of the process all of the constants that we have inside memory we're going to copy all of that into a completely new independent process the new process is going to be called the child and the original is going to be called the pat and from that moment on so they made look backward and say hey look at my variables hey look at my open files look at my memory from that point on they are independent processes so if the parents start changing its variables that child is not going to see that is a separate process just like if you have a compiler and i have a compiler running their independent processes with their own variables in their own heat space and their own stack space they've separated they forked into two different happy independent processes	heap memory	205
so that's right we're not calling maine again we're not running from disk instead we are saying hey colonel look at my current process give me a complete copy of it that's right the whole stack all of the heap memory all of the process all of the constants that we have inside memory we're going to copy all of that into a completely new independent process the new process is going to be called the child and the original is going to be called the pat and from that moment on so they made look backward and say hey look at my variables hey look at my open files look at my memory from that point on they are independent processes so if the parents start changing its variables that child is not going to see that is a separate process just like if you have a compiler and i have a compiler running their independent processes with their own variables in their own heat space and their own stack space they've separated they forked into two different happy independent processes	memory	210
so that's right we're not calling maine again we're not running from disk instead we are saying hey colonel look at my current process give me a complete copy of it that's right the whole stack all of the heap memory all of the process all of the constants that we have inside memory we're going to copy all of that into a completely new independent process the new process is going to be called the child and the original is going to be called the pat and from that moment on so they made look backward and say hey look at my variables hey look at my open files look at my memory from that point on they are independent processes so if the parents start changing its variables that child is not going to see that is a separate process just like if you have a compiler and i have a compiler running their independent processes with their own variables in their own heat space and their own stack space they've separated they forked into two different happy independent processes	the heap	201
well it great let's actually have a play with this let's actually kind of try to fork and create some new process is ok so this is just a very quick demo about this we're going to see a lot more about forking in the future right so i need a little program here ok right so here's my starting point i've got uni standard because i'm going to be calling fork so let's for example have some stack memory	memory	394
and notice today i'm being lazy and saying i have a method called maine but with just a two parentheses that that's saying and you know what i'm not going to even tell you how many arguments that this function has rights so we have main and we have a little stack variable inside it here's my variable say ten i could make some heap memory as well by calling malloc had some global variables as well etc but that's just enough for today right now it's time to clone my process so i'm going to call fork	heap memory	328
and notice today i'm being lazy and saying i have a method called maine but with just a two parentheses that that's saying and you know what i'm not going to even tell you how many arguments that this function has rights so we have main and we have a little stack variable inside it here's my variable say ten i could make some heap memory as well by calling malloc had some global variables as well etc but that's just enough for today right now it's time to clone my process so i'm going to call fork	memory	333
address ok so let's take it's a dress like that and that will do is let's add a newline ok right so one of the things could happen what is this going to print	address	0
and so the operating system says fine ok you could for all duplicate you or you could fall to our clone you as well now i've got four processes so we could sketch this out in time	system	21
ok that original process will return from fork so it's just going to keep keep going on in time and eventually will print something else to say hey is valuable but operating system says great i will clone you and make a new process so a few milliseconds later brand new process has appeared on off it goes	system	174
ok so now we got full process is running all four processes are going to call the third line here there all running the same piece of code but they're different process is just like you can run ls i can run ls there the same pieces of code running but their separate process is running ok so the other local fork each one of these processes is therefore cloned duplicated so when they call fork and this one calls for corn this one calls for when there's one called spoke we end up with four more processes so this one gets duplicated visional process	code	134
get stupid k this one gets duplicated and this one gets duplicated right so now you can see that we've ended up with eight indypendent processes each process has its own memory each process is doing its own thing if i change the value now inside one of these processes the other side kind of see it just suppose we were using the debugger and so i'm deliberately going to modify a value let me choose a strong purple color here so for example suppose we	memory	170
don't affect each other so all of these are the process is that we see testing to print out ten they don't know or don't care about the change that process memory	memory	156
now one point of confusion here is if we actually look at the output of this it looks like these variables are all inside the same memory location ok very important idea and point here is that these addresses of variables and in fact the addresses of anything outside our process are specific to that particular process so we're going to learn more later about virtual memory that these addresses actually each process can be mapped to completely different pieces of physical ram so even though they appear to be the same address actually those numbers are	memory	131
now one point of confusion here is if we actually look at the output of this it looks like these variables are all inside the same memory location ok very important idea and point here is that these addresses of variables and in fact the addresses of anything outside our process are specific to that particular process so we're going to learn more later about virtual memory that these addresses actually each process can be mapped to completely different pieces of physical ram so even though they appear to be the same address actually those numbers are	address	199
only sensible inside a specific process and if we're talking about different processes might actually be connected to different pieces of of hardware that allows us then to be able to change the value of one variable inside process and for it to not affect a different process which is using a different physical piece of memory so it's a very important idea right so that's what i enough today about forking processes i kind of want to leave you with one idea but in the beginning when our system boots up there is just one user process	memory	322
only sensible inside a specific process and if we're talking about different processes might actually be connected to different pieces of of hardware that allows us then to be able to change the value of one variable inside process and for it to not affect a different process which is using a different physical piece of memory so it's a very important idea right so that's what i enough today about forking processes i kind of want to leave you with one idea but in the beginning when our system boots up there is just one user process	system	491
so you can take any process which is currently running now and traces history back you can say oh an its parent was this process and its parent was that person is it pears apples eccentric cetera and you could trace it's linear all the way back to that original process that started when our system booted up that's it our next video is about environment variables by	system	292
ok so great we've started thinking about our allocation in terms of these blocks and in fact rather than hardcoding sixteen bytes i'm going to use size of my size t operator here's why this is this is a great little integer it's potentially larger than just a c int and it represents lots of interesting useful things like the total number of bytes that i want to	block	74
allocate my pointers cannot hold values greater my point is cannot point to memory address is greater than this value so if i've chunked up my memory into the size of these things i know that my location is going to be robust and powerful ok so we've kind of stressed this idea that we gotta think about bytes anymore instead my memory is become one big array	memory	76
allocate my pointers cannot hold values greater my point is cannot point to memory address is greater than this value so if i've chunked up my memory into the size of these things i know that my location is going to be robust and powerful ok so we've kind of stressed this idea that we gotta think about bytes anymore instead my memory is become one big array	address	83
allocate my pointers cannot hold values greater my point is cannot point to memory address is greater than this value so if i've chunked up my memory into the size of these things i know that my location is going to be robust and powerful ok so we've kind of stressed this idea that we gotta think about bytes anymore instead my memory is become one big array	pointer	12
of these size t type entries	type	16
let's have a look at this so i need my my little point is here here's our here's our basic plan that when you ask me for some memory let's say you need space for a hundred of these blocks or block is one of these sixteen by or eight by entries here i'm going to make a note of that at the beginning and at the end so if you wanted a hundred blocks i actually need space for one hundred and two there we go but i'm going to write what you asked for the beginning and the end ok right so i see that you been busy have also asked me for sixty four so i put my sixty four here i jumped forward of sixty four plus one in order to write sixty four into that location and you have also asked me for a hundred and thirty two bites so here's a hundred thirty two i gave you	memory	126
let's have a look at this so i need my my little point is here here's our here's our basic plan that when you ask me for some memory let's say you need space for a hundred of these blocks or block is one of these sixteen by or eight by entries here i'm going to make a note of that at the beginning and at the end so if you wanted a hundred blocks i actually need space for one hundred and two there we go but i'm going to write what you asked for the beginning and the end ok right so i see that you been busy have also asked me for sixty four so i put my sixty four here i jumped forward of sixty four plus one in order to write sixty four into that location and you have also asked me for a hundred and thirty two bites so here's a hundred thirty two i gave you	block	181
plus one here's your memory address and also wrote the hundred thirty two in there	memory	21
plus one here's your memory address and also wrote the hundred thirty two in there	address	28
this one here actually you give me this pointer here to say ok i'm done with this space i would say great so if i immediately cast a point you gave me into one of these one of these block pointers here then i just need to go back by one to be able to read first of all my size and if i go back by two then i can read the previous block size so now this is great i can go back to the very beginning here to see if	block	182
this one here actually you give me this pointer here to say ok i'm done with this space i would say great so if i immediately cast a point you gave me into one of these one of these block pointers here then i just need to go back by one to be able to read first of all my size and if i go back by two then i can read the previous block size so now this is great i can go back to the very beginning here to see if	pointer	40
simile i can jump forward i can read my sixty four and jump forward to see if the next one is free or not so in this case i have to jump forward not sixty four but i have to jump forward one two three at a job for sixty four plus three in order to read the size of the next entry ok right so how can i determine if a block is free or not there's one last little trick here which is	block	317
that actually if i only have a store even numbers here then i could use the smallest bit to hold whether this represents a free block or not or similar if i decide that the highest bit is never going to be used by someone of course malloc i could store whether this is corresponds to a free or unfree area or not ok so that allows me to very efficiently store the size of my blocks and whether it's free or not	block	128
whether a user has used their memory incorrectly	memory	30
ok so you can see right now that if ok if we gave some memory they	memory	55
and the users code started writing over memory perhaps they did a buffer overflow so so they started writing into this valley here or perhaps a data underflow and started writing before that you think back to when we were writing get line code right and get line could return negative one imagine we try to adele eat a new line before even the beginning of that buffer so we've been over writing these values so we could actually use these values as a canary and what i mean by that is when the coal miners went into the minds one way they could detect the atmosphere was dangerous words by a canary of keeling over because the canary would die before they did so let's do some some sanity checks here in our malloc kodinar free code and we can do things like saying well hold on we expect this value to be	memory	40
and the users code started writing over memory perhaps they did a buffer overflow so so they started writing into this valley here or perhaps a data underflow and started writing before that you think back to when we were writing get line code right and get line could return negative one imagine we try to adele eat a new line before even the beginning of that buffer so we've been over writing these values so we could actually use these values as a canary and what i mean by that is when the coal miners went into the minds one way they could detect the atmosphere was dangerous words by a canary of keeling over because the canary would die before they did so let's do some some sanity checks here in our malloc kodinar free code and we can do things like saying well hold on we expect this value to be	code	14
equal to that value or we can go further we can actually deliberately put values into memory that we later check so for example my favorite is i might write the hexadecimal value immediately after the end of the users code here that says that something like dead code which is a hexadecimal value right so i can write dead	memory	86
equal to that value or we can go further we can actually deliberately put values into memory that we later check so for example my favorite is i might write the hexadecimal value immediately after the end of the users code here that says that something like dead code which is a hexadecimal value right so i can write dead	code	218
code as a hex value	code	0
and then later check to see if that value is still there and if it's not that's my canary to say oh someone overwrote some memory that they shouldn't have written and i probably exit at this point or perhaps i would print out some useful message or perhaps drop into the debugger ok so that's the idea of canaries you could you too can implement inside your my lock code write an one quick idea is yes you probably heard a buffer overflow we've also got buffer underflow which is where we go before the start of of the buffer so again we could put a canary there and check that that was not overwritten	memory	123
and then later check to see if that value is still there and if it's not that's my canary to say oh someone overwrote some memory that they shouldn't have written and i probably exit at this point or perhaps i would print out some useful message or perhaps drop into the debugger ok so that's the idea of canaries you could you too can implement inside your my lock code write an one quick idea is yes you probably heard a buffer overflow we've also got buffer underflow which is where we go before the start of of the buffer so again we could put a canary there and check that that was not overwritten	code	366
ok last thing we could do with your free if you don't care about performance but you care about catching memory hours	memory	105
someone is called free you could deliberately overwrite that memory so that its contents is no longer valid perhaps you want to put like dead code or dead beef or some other kind of value in there just so that you can detect use after free similarly if you don't care about performance but you care about catching errors	memory	61
someone is called free you could deliberately overwrite that memory so that its contents is no longer valid perhaps you want to put like dead code or dead beef or some other kind of value in there just so that you can detect use after free similarly if you don't care about performance but you care about catching errors	code	142
you could make your malloc rather than returning memory that might be zero you could deliberately right values into their which are non zero	memory	49
and that way you could detect hopefully when people accidentally assumed that the memory they're getting back from malloc is zeroed out 'cause you know maybe from my lock is should not be singled out ok so how can you quickly do that the trick is to use memset	memory	82
ok so we've kind of talked a little bit about this idea before so it could i implement p thread mutex lock just by disabling interrupts on on the cpu so the idea here is that if my code is running on the cpu if i disable interrupts then i cannot be stopped become agent smith out of the matrix that now i own the cpu so no one else can can take it for me so one of the limitations of this first of all that yes we can ensure that we're the only ones going into the critical section if one there is only one cpu	code	181
ok so we've kind of talked a little bit about this idea before so it could i implement p thread mutex lock just by disabling interrupts on on the cpu so the idea here is that if my code is running on the cpu if i disable interrupts then i cannot be stopped become agent smith out of the matrix that now i own the cpu so no one else can can take it for me so one of the limitations of this first of all that yes we can ensure that we're the only ones going into the critical section if one there is only one cpu	section	474
ok so we've kind of talked a little bit about this idea before so it could i implement p thread mutex lock just by disabling interrupts on on the cpu so the idea here is that if my code is running on the cpu if i disable interrupts then i cannot be stopped become agent smith out of the matrix that now i own the cpu so no one else can can take it for me so one of the limitations of this first of all that yes we can ensure that we're the only ones going into the critical section if one there is only one cpu	thread	89
ok so if i control the one and only cpu and i cannot be interrupted then i get to do everything inside the critical section until i give up the cpu ok so providing i don't make any system calls providing i'm just updating my data structure no one can stop me because i disabled into apps	a struct	228
ok so if i control the one and only cpu and i cannot be interrupted then i get to do everything inside the critical section until i give up the cpu ok so providing i don't make any system calls providing i'm just updating my data structure no one can stop me because i disabled into apps	section	116
ok so if i control the one and only cpu and i cannot be interrupted then i get to do everything inside the critical section until i give up the cpu ok so providing i don't make any system calls providing i'm just updating my data structure no one can stop me because i disabled into apps	system	181
ok the second is that i require an here's a big problem here is that actually require sufficient privileges to disable the interrupts and because this is such a powerful operation by default that is disabled for normal user programs we need interrupts in order to make a cpu stop running one thread and start running another in order to handle hardware interrupt you too do to devices iot devices being ready to either take data from the system or give data from the system for example the network card might report that her new packages arrived and here's some data or a disk or solid state disk might report hey i've now finally got the data you can now read this into memory or gpu might ask for more memory more data so there's lots	memory	671
ok the second is that i require an here's a big problem here is that actually require sufficient privileges to disable the interrupts and because this is such a powerful operation by default that is disabled for normal user programs we need interrupts in order to make a cpu stop running one thread and start running another in order to handle hardware interrupt you too do to devices iot devices being ready to either take data from the system or give data from the system for example the network card might report that her new packages arrived and here's some data or a disk or solid state disk might report hey i've now finally got the data you can now read this into memory or gpu might ask for more memory more data so there's lots	thread	292
ok the second is that i require an here's a big problem here is that actually require sufficient privileges to disable the interrupts and because this is such a powerful operation by default that is disabled for normal user programs we need interrupts in order to make a cpu stop running one thread and start running another in order to handle hardware interrupt you too do to devices iot devices being ready to either take data from the system or give data from the system for example the network card might report that her new packages arrived and here's some data or a disk or solid state disk might report hey i've now finally got the data you can now read this into memory or gpu might ask for more memory more data so there's lots	system	438
of reasons why we in over a normal complex system we cannot just disable disable interrupts ok so this	system	43
is one solution to the critical section but like i said it's not a generally useful solution to the critical section we need to find a way to be able to kind of implement these correctly and will talk about some algorithmic concerns about that in the future instead now is what i've got a real challenge for you which is i want to implement a barrier in fact i'm going to give you all the code that you need here it is i just want to implement a barrier that will wait until five threads call this method called this function and i've got to keep track of how many there we go and all i'm going to give you is the following code which uses a counting semaphore so you get to choose how what you would like to implement what you'd like to to initialize is counting semaphore with and all you have to do is rearrange these lines enter the correct order so that's my challenge to you pause this video and see if you can work it out i'll give you the solution next video but before you do that make some brain new brain cell connections and actually think about how you're going to rearrange this code so it actually works by	the following	610
is one solution to the critical section but like i said it's not a generally useful solution to the critical section we need to find a way to be able to kind of implement these correctly and will talk about some algorithmic concerns about that in the future instead now is what i've got a real challenge for you which is i want to implement a barrier in fact i'm going to give you all the code that you need here it is i just want to implement a barrier that will wait until five threads call this method called this function and i've got to keep track of how many there we go and all i'm going to give you is the following code which uses a counting semaphore so you get to choose how what you would like to implement what you'd like to to initialize is counting semaphore with and all you have to do is rearrange these lines enter the correct order so that's my challenge to you pause this video and see if you can work it out i'll give you the solution next video but before you do that make some brain new brain cell connections and actually think about how you're going to rearrange this code so it actually works by	code	389
is one solution to the critical section but like i said it's not a generally useful solution to the critical section we need to find a way to be able to kind of implement these correctly and will talk about some algorithmic concerns about that in the future instead now is what i've got a real challenge for you which is i want to implement a barrier in fact i'm going to give you all the code that you need here it is i just want to implement a barrier that will wait until five threads call this method called this function and i've got to keep track of how many there we go and all i'm going to give you is the following code which uses a counting semaphore so you get to choose how what you would like to implement what you'd like to to initialize is counting semaphore with and all you have to do is rearrange these lines enter the correct order so that's my challenge to you pause this video and see if you can work it out i'll give you the solution next video but before you do that make some brain new brain cell connections and actually think about how you're going to rearrange this code so it actually works by	section	32
is one solution to the critical section but like i said it's not a generally useful solution to the critical section we need to find a way to be able to kind of implement these correctly and will talk about some algorithmic concerns about that in the future instead now is what i've got a real challenge for you which is i want to implement a barrier in fact i'm going to give you all the code that you need here it is i just want to implement a barrier that will wait until five threads call this method called this function and i've got to keep track of how many there we go and all i'm going to give you is the following code which uses a counting semaphore so you get to choose how what you would like to implement what you'd like to to initialize is counting semaphore with and all you have to do is rearrange these lines enter the correct order so that's my challenge to you pause this video and see if you can work it out i'll give you the solution next video but before you do that make some brain new brain cell connections and actually think about how you're going to rearrange this code so it actually works by	thread	480
right great ok so unless some implement a stack and will implement stack but is bounded by two things first of all you'll see that i data store here my little array here can only handle ten items also we can't pull anything from the stack if my stack is empty so now push and pop methods need to block if they are unable to continue right so let's let's have a good figure out how we're going to implement this first of all let's just pretend that with i cs two twenty five or some other course right and right than on the single threaded version ok so what are we going to have we're going to have things like the push method will be take my data structure my ray and after i've used the value of n increment it and density equal to be ok right what else you want to do so for multithreaded code i need to make sure that i'm the only person using this value of end otherwise two threads might call this code at the same time and both right into the same slot the same entry inside the away so less using mutex lock for that so we're definitely going to need mutex lock	block	296
right great ok so unless some implement a stack and will implement stack but is bounded by two things first of all you'll see that i data store here my little array here can only handle ten items also we can't pull anything from the stack if my stack is empty so now push and pop methods need to block if they are unable to continue right so let's let's have a good figure out how we're going to implement this first of all let's just pretend that with i cs two twenty five or some other course right and right than on the single threaded version ok so what are we going to have we're going to have things like the push method will be take my data structure my ray and after i've used the value of n increment it and density equal to be ok right what else you want to do so for multithreaded code i need to make sure that i'm the only person using this value of end otherwise two threads might call this code at the same time and both right into the same slot the same entry inside the away so less using mutex lock for that so we're definitely going to need mutex lock	a struct	646
right great ok so unless some implement a stack and will implement stack but is bounded by two things first of all you'll see that i data store here my little array here can only handle ten items also we can't pull anything from the stack if my stack is empty so now push and pop methods need to block if they are unable to continue right so let's let's have a good figure out how we're going to implement this first of all let's just pretend that with i cs two twenty five or some other course right and right than on the single threaded version ok so what are we going to have we're going to have things like the push method will be take my data structure my ray and after i've used the value of n increment it and density equal to be ok right what else you want to do so for multithreaded code i need to make sure that i'm the only person using this value of end otherwise two threads might call this code at the same time and both right into the same slot the same entry inside the away so less using mutex lock for that so we're definitely going to need mutex lock	code	792
right great ok so unless some implement a stack and will implement stack but is bounded by two things first of all you'll see that i data store here my little array here can only handle ten items also we can't pull anything from the stack if my stack is empty so now push and pop methods need to block if they are unable to continue right so let's let's have a good figure out how we're going to implement this first of all let's just pretend that with i cs two twenty five or some other course right and right than on the single threaded version ok so what are we going to have we're going to have things like the push method will be take my data structure my ray and after i've used the value of n increment it and density equal to be ok right what else you want to do so for multithreaded code i need to make sure that i'm the only person using this value of end otherwise two threads might call this code at the same time and both right into the same slot the same entry inside the away so less using mutex lock for that so we're definitely going to need mutex lock	thread	530
soapy said mutex lock and as luck would have it i've already got my variables up here ready to go right so let me call peter mutex lock on my mutex there we go so that might block for a short while if someone else is currently acquired the lock which is why a later on we are going to release it	block	174
so now we've got code which where only one third of the time can push things what about if our array is full of what if i stack is full so remember stepping	code	17
busy checking this right so while while n is equal to the maximum number go round the loop now we know we could put a sleeping here if we wanted to we know that right now this is a terrible test because we're holding the lock if all of our code uses a lot no one else will be able to do this fortunately for us we're going to be using p thread condition wait	the loop	82
busy checking this right so while while n is equal to the maximum number go round the loop now we know we could put a sleeping here if we wanted to we know that right now this is a terrible test because we're holding the lock if all of our code uses a lot no one else will be able to do this fortunately for us we're going to be using p thread condition wait	code	240
busy checking this right so while while n is equal to the maximum number go round the loop now we know we could put a sleeping here if we wanted to we know that right now this is a terrible test because we're holding the lock if all of our code uses a lot no one else will be able to do this fortunately for us we're going to be using p thread condition wait	thread	337
and that will release the lock whilst it's blocking ok so here's our condition variable that were going to sleep in and watched was sleeping unlock that mutex and then before returning lock it again so the big idea here is that in all the code that we write let's do i make a highlighter well let's do it like like a yellow ok it all this code every single piece of this	block	43
and that will release the lock whilst it's blocking ok so here's our condition variable that were going to sleep in and watched was sleeping unlock that mutex and then before returning lock it again so the big idea here is that in all the code that we write let's do i make a highlighter well let's do it like like a yellow ok it all this code every single piece of this	code	239
that we are in the mutex lock so we could reason that we are the only thread that continue to run so great i've got all these other threads running at the same time but my head doesn't need to explode thinking about the possible interleavings of all of these expressions from this thread and another third because we own the mutex lock right and anybody else has to wait until we finished so it simplifies reasoning about this back down to just simple single threaded code again alright so great we've got our push method to work	code	468
that we are in the mutex lock so we could reason that we are the only thread that continue to run so great i've got all these other threads running at the same time but my head doesn't need to explode thinking about the possible interleavings of all of these expressions from this thread and another third because we own the mutex lock right and anybody else has to wait until we finished so it simplifies reasoning about this back down to just simple single threaded code again alright so great we've got our push method to work	thread	70
if anything else we need to do yeah well we're writing a method which both to push and pop can can block so if i just put something onto this onto my way it could be that there's another thread waiting to pop things from the data structure so after i've modified it i'm going to call p threat condition broadcast	block	99
if anything else we need to do yeah well we're writing a method which both to push and pop can can block so if i just put something onto this onto my way it could be that there's another thread waiting to pop things from the data structure so after i've modified it i'm going to call p threat condition broadcast	the data structure	221
if anything else we need to do yeah well we're writing a method which both to push and pop can can block so if i just put something onto this onto my way it could be that there's another thread waiting to pop things from the data structure so after i've modified it i'm going to call p threat condition broadcast	a struct	228
if anything else we need to do yeah well we're writing a method which both to push and pop can can block so if i just put something onto this onto my way it could be that there's another thread waiting to pop things from the data structure so after i've modified it i'm going to call p threat condition broadcast	thread	187
there we go so if there happens to be someone sleeping in on this condition variable because that waiting to pop then now they can wake up so we could for performance reasons a little bit more about this and say the only time we need to do this the only possible time that someone could be blocked while popping from this away would be if the value of n was zero so in other words we have just increased it up to one otherwise there's no way that anyone could be sleeping right now so we could weight using about that and we could also reason that we've just added one thing	block	290
then maybe we could call pizza hut conditions signal as well but i would have to be a lot more careful about reasoning about that so i'm going to use p thread condition broadcast just in case there were multiple threads gone to sleep we want to make sure that if we're only going to wake up in that transition that we work them all up so	thread	152
so the pop ok so what should my pop method look like ok so first of all let's write the code which is going to	code	88
k so we turned my v where does become from i'm going to have something like double v equals so i go to my way now i want to pre decrement my value of n there we go alright so what about the blocking all right so we need something like look if my value of n is zero then go to sleep ok right so i'm going to have my p thread conditioned wait ok did you do today and here is my condition variable i'd like to sleep in and don't forget that mutex lock ok what is the mutex lock code look like are right so we've seen this before that's just	block	190
k so we turned my v where does become from i'm going to have something like double v equals so i go to my way now i want to pre decrement my value of n there we go alright so what about the blocking all right so we need something like look if my value of n is zero then go to sleep ok right so i'm going to have my p thread conditioned wait ok did you do today and here is my condition variable i'd like to sleep in and don't forget that mutex lock ok what is the mutex lock code look like are right so we've seen this before that's just	code	475
k so we turned my v where does become from i'm going to have something like double v equals so i go to my way now i want to pre decrement my value of n there we go alright so what about the blocking all right so we need something like look if my value of n is zero then go to sleep ok right so i'm going to have my p thread conditioned wait ok did you do today and here is my condition variable i'd like to sleep in and don't forget that mutex lock ok what is the mutex lock code look like are right so we've seen this before that's just	thread	317
right are we done no we might need to wake up some threads so let's put that code in as well about this kind of	code	77
right are we done no we might need to wake up some threads so let's put that code in as well about this kind of	thread	51
dark published right so let's in here wake up any thread switch might be sleeping on the condition variable so p thread condition broadcast	thread	50
all right and again we could reason about this we could say if there's if there's any locks if there's any threads sleeping on this waiting to push the only time that that can occur is if the reached the maximum number so if any is equal to now nine then i know that	thread	107
time to broadcast however this is kind of a optimization it's very easy to get these wrong it's very tricky to start modeling thinking about this when you've got multiple threads which might call pop of multiple threads which might call push gets a little bit easier to think about if you've only got one thread of each kind so my advice is treat these optimizations with extreme caution you're introducing possible edge cases which not easy to discover or think about and so if in doubt	optimizations	353
time to broadcast however this is kind of a optimization it's very easy to get these wrong it's very tricky to start modeling thinking about this when you've got multiple threads which might call pop of multiple threads which might call push gets a little bit easier to think about if you've only got one thread of each kind so my advice is treat these optimizations with extreme caution you're introducing possible edge cases which not easy to discover or think about and so if in doubt	thread	171
if you don't care about absolute performance just called prefect ingram forecast that performance head is not that great ok so we've got some working code we think let's actually have a go at testing this	code	150
ok so here's my code	code	16
that is going to actually run this and i've got some testing code where my producer is going to call the	code	61
push say ten thousand times but we're actually going to do that with two threads and then i've got a consumer method that is going to call pop twenty thousand times is just one of those today so let's check that we actually get all values of all the double values that we pushed in so we know that we know that we're going to push in the	thread	73
help for help in the background ok great so we know we're going to push in the values zero up to nine hundred and ninety nine nine have enough ninth ok right and so if we're just going to some these so we have the sum of values from zero up to that number there ok but in fact we're having two threads actually push all those values in so	thread	294
help for help in the background ok great so we know we're going to push in the values zero up to nine hundred and ninety nine nine have enough ninth ok right and so if we're just going to some these so we have the sum of values from zero up to that number there ok but in fact we're having two threads actually push all those values in so	background	21
i'm going to sum up the integers and if you know i'm sure you've seen this inside once every three right or you can do it recursively you can do this inductively or you can do it with lego as well you know that the sum is equal to n times n plus one over two right so in other words we expect a total of that right by the way i said you could do it with lego blocks here's the reasoning with lego blocks if you still some lego blocks from your younger sibling	block	359
lego block proved there right so let's let's actually have a go at running this ok so do we have code right so we called it block and let's let's run this thing ok you'll notice that we only exit after we managed to join all three threats so will compile it stop the cake monster stop consuming cake	block	5
lego block proved there right so let's let's actually have a go at running this ok so do we have code right so we called it block and let's let's run this thing ok you'll notice that we only exit after we managed to join all three threats so will compile it stop the cake monster stop consuming cake	code	97
compile ok block right so let's do that	block	11
ok gcc minus p thread block	block	22
ok gcc minus p thread block	thread	15
alright and great we got the correct some who are so are we convinced that our code works or like i said we've firmed given it a fair shake we called the	code	79
push and pop in a tight loop and we called it for ten thousand times so empirically we've shown that maybe if there's a likelihood of it failing we've at least tested it to the kind of point one percent level but is that is that is that does that give me confidence to put this into production no i'd actually want to kind of actually do a code review and think carefully about how my code works so so in multithreaded code it's a very important we have strong understanding about how our code works and rather than just simple going to lightweight testing and say oh yeah great pistol work if we actually want to use this code and trust it on our game or driving a car or an aircraft or website which is going to make our livelihood we actually want to be confident that we've got this multithreaded coding correct ok that's it for now bye	code	340
push and pop in a tight loop and we called it for ten thousand times so empirically we've shown that maybe if there's a likelihood of it failing we've at least tested it to the kind of point one percent level but is that is that is that does that give me confidence to put this into production no i'd actually want to kind of actually do a code review and think carefully about how my code works so so in multithreaded code it's a very important we have strong understanding about how our code works and rather than just simple going to lightweight testing and say oh yeah great pistol work if we actually want to use this code and trust it on our game or driving a car or an aircraft or website which is going to make our livelihood we actually want to be confident that we've got this multithreaded coding correct ok that's it for now bye	thread	410
hi welcome to lecture 38, so let's get started right today we're going to do some review ideas and also go into some operating system ideas as well. so let's start with going all the way back to threads and ask why is the following code threadsafe ok so let's have a look at it what's it doing. right so i've got a function. it takes a pointer to some memory, sleeps for second and then it assumes that there's a string of that memory. so will cast that	the following	218
hi welcome to lecture 38, so let's get started right today we're going to do some review ideas and also go into some operating system ideas as well. so let's start with going all the way back to threads and ask why is the following code threadsafe ok so let's have a look at it what's it doing. right so i've got a function. it takes a pointer to some memory, sleeps for second and then it assumes that there's a string of that memory. so will cast that	memory	352
hi welcome to lecture 38, so let's get started right today we're going to do some review ideas and also go into some operating system ideas as well. so let's start with going all the way back to threads and ask why is the following code threadsafe ok so let's have a look at it what's it doing. right so i've got a function. it takes a pointer to some memory, sleeps for second and then it assumes that there's a string of that memory. so will cast that	code	232
hi welcome to lecture 38, so let's get started right today we're going to do some review ideas and also go into some operating system ideas as well. so let's start with going all the way back to threads and ask why is the following code threadsafe ok so let's have a look at it what's it doing. right so i've got a function. it takes a pointer to some memory, sleeps for second and then it assumes that there's a string of that memory. so will cast that	string	413
hi welcome to lecture 38, so let's get started right today we're going to do some review ideas and also go into some operating system ideas as well. so let's start with going all the way back to threads and ask why is the following code threadsafe ok so let's have a look at it what's it doing. right so i've got a function. it takes a pointer to some memory, sleeps for second and then it assumes that there's a string of that memory. so will cast that	thread	195
hi welcome to lecture 38, so let's get started right today we're going to do some review ideas and also go into some operating system ideas as well. so let's start with going all the way back to threads and ask why is the following code threadsafe ok so let's have a look at it what's it doing. right so i've got a function. it takes a pointer to some memory, sleeps for second and then it assumes that there's a string of that memory. so will cast that	system	127
hi welcome to lecture 38, so let's get started right today we're going to do some review ideas and also go into some operating system ideas as well. so let's start with going all the way back to threads and ask why is the following code threadsafe ok so let's have a look at it what's it doing. right so i've got a function. it takes a pointer to some memory, sleeps for second and then it assumes that there's a string of that memory. so will cast that	pointer	336
to say i expect to be a pointer to a character and we're going to put all that out as a string with a new line at the end. so nice simple function.	string	88
to say i expect to be a pointer to a character and we're going to put all that out as a string with a new line at the end. so nice simple function.	pointer	24
says what right. we're going to make a thread. there's our thread identifier data itself represents an array. and so remember with an array, you cannot change this variable to point to anything else. data is the array right so, if we ask for the address of array, of course, we get the first bite of the zoo at entry. right so, let "me copy into the array, ""1234567""" plus zero byte to this well and then we say peter create	a thread	37
says what right. we're going to make a thread. there's our thread identifier data itself represents an array. and so remember with an array, you cannot change this variable to point to anything else. data is the array right so, if we ask for the address of array, of course, we get the first bite of the zoo at entry. right so, let "me copy into the array, ""1234567""" plus zero byte to this well and then we say peter create	thread	39
says what right. we're going to make a thread. there's our thread identifier data itself represents an array. and so remember with an array, you cannot change this variable to point to anything else. data is the array right so, if we ask for the address of array, of course, we get the first bite of the zoo at entry. right so, let "me copy into the array, ""1234567""" plus zero byte to this well and then we say peter create	address	246
okay, we want to know the thread id and we're going to pass, as the argument for when the thread finally starts, data +4. in other words,	thread	26
inside my array here, i'm going to have the characters one two three four etc and i have the copy of that into some writable memory. where is that? of course, it's actually	memory	125
on the stack, so [the] data itself represents 8 bytes on the stack so right just here we are passing in an address on the stack of this calling function of the thread that originally ran this code case. so that sounds pretty dangerous right we're actually saying, right, inside this array you want to pass in the address of this five just here using pointer arithmetic	code	192
on the stack, so [the] data itself represents 8 bytes on the stack so right just here we are passing in an address on the stack of this calling function of the thread that originally ran this code case. so that sounds pretty dangerous right we're actually saying, right, inside this array you want to pass in the address of this five just here using pointer arithmetic	thread	160
on the stack, so [the] data itself represents 8 bytes on the stack so right just here we are passing in an address on the stack of this calling function of the thread that originally ran this code case. so that sounds pretty dangerous right we're actually saying, right, inside this array you want to pass in the address of this five just here using pointer arithmetic	address	107
on the stack, so [the] data itself represents 8 bytes on the stack so right just here we are passing in an address on the stack of this calling function of the thread that originally ran this code case. so that sounds pretty dangerous right we're actually saying, right, inside this array you want to pass in the address of this five just here using pointer arithmetic	pointer	350
ok and then we say put us p create called now which of these puts functions will run first? the thing (?) is we don't know! either them could happen first is quite possible for us to request create the thread and then immediately to continue. and for us to see that line before we actually print something out. in this case, what we print out will print out five six seven eight and a new line, of course. right so why is it that this is thread-safe? it looks pretty dangerous to actually pass in a pointer to stack memory. right ok, the reason it's thread-safe is because of this last line just here. pthread_join that we do not pass go. do not collect two hundred dollars until the thread that we created has finished. that's my definition what pthread_join does. so we can be sure that the life time of this data variable is longer than the lifetime of the thread that we created. the lifetime of the thread will be strictly less than the lifetime of that variable.	memory	516
ok and then we say put us p create called now which of these puts functions will run first? the thing (?) is we don't know! either them could happen first is quite possible for us to request create the thread and then immediately to continue. and for us to see that line before we actually print something out. in this case, what we print out will print out five six seven eight and a new line, of course. right so why is it that this is thread-safe? it looks pretty dangerous to actually pass in a pointer to stack memory. right ok, the reason it's thread-safe is because of this last line just here. pthread_join that we do not pass go. do not collect two hundred dollars until the thread that we created has finished. that's my definition what pthread_join does. so we can be sure that the life time of this data variable is longer than the lifetime of the thread that we created. the lifetime of the thread will be strictly less than the lifetime of that variable.	thread	202
ok and then we say put us p create called now which of these puts functions will run first? the thing (?) is we don't know! either them could happen first is quite possible for us to request create the thread and then immediately to continue. and for us to see that line before we actually print something out. in this case, what we print out will print out five six seven eight and a new line, of course. right so why is it that this is thread-safe? it looks pretty dangerous to actually pass in a pointer to stack memory. right ok, the reason it's thread-safe is because of this last line just here. pthread_join that we do not pass go. do not collect two hundred dollars until the thread that we created has finished. that's my definition what pthread_join does. so we can be sure that the life time of this data variable is longer than the lifetime of the thread that we created. the lifetime of the thread will be strictly less than the lifetime of that variable.	pointer	499
so that's why it's thread safe. the only thing we can't fix a for sure is the order of the two outputs but we do know for sure that we've written a program that should work. it's not production-quality code for example we haven't checked to see whether pthread	code	202
so that's why it's thread safe. the only thing we can't fix a for sure is the order of the two outputs but we do know for sure that we've written a program that should work. it's not production-quality code for example we haven't checked to see whether pthread	thread	19
create actually succeeds or not. if we were writing production quality code, we would check the the return values on the air conditions of all of our system calls, but with that little niggle-- with that little	code	71
create actually succeeds or not. if we were writing production quality code, we would check the the return values on the air conditions of all of our system calls, but with that little niggle-- with that little	system	150
annoyance, we will accept that this code is thread safe. i will see you next video bye	code	36
annoyance, we will accept that this code is thread safe. i will see you next video bye	thread	44
so we can have security errors in a protocol we might for example specify a state diagram and there might	a protocol	34
be a way through that state diagram which bypasses say login step or an authentication step or an authorization step after you log in but you not supposed to have the privileges that you actually do so we might actually have errors in our protocol but we can also have errors in our implementation of protocols and here's a very famous one called heartblead and this actually is the code from	code	383
and even the server 's own private key which if we have that means that we can now decrypt all messages being sent and received by that server so it took awhile but by careful understanding of sending the right requests all of these became possible and at the time this affected a large number of servers little note here but how many so yeah as of kind of two thousand fourteen long after infected where it was discovered three hundred thousand systems were still vulnerable to this and it was a simple simple bug as we saw just that we happily trusted	system	446
different clients and servers and it's easier to debug the actual connections which are happening over our tcp or udp connection and it's easier to write a specification which uses a simple text-based protocol so for example if you want to get a web resource today you would make a connection to a server and you'd say hey server can you get me the following so let me get resource so if i just care about the home page then that is just slash if for example i want a particular subreddit page	the following	345
would actually have to write code to cope with the fact that packets might go missing but this is useful if you want for example to provide an interactive feedback as soon as the user starts typing something into the search part you want to be able to display immediately some potential results so that sounds to me like udp might be a great course so if you're prepared to employ a lots of great system programmers from say from illinois then if you don't mind that expense then udp gives you a lower latency response and besides if you're doing this just for incremental search is you don't care anyway if you drop a packet because in a moment the user is going to be typing another character anyway and so you can reissue a new search based on that new information right but most packets today for http are using tcp	code	29
would actually have to write code to cope with the fact that packets might go missing but this is useful if you want for example to provide an interactive feedback as soon as the user starts typing something into the search part you want to be able to display immediately some potential results so that sounds to me like udp might be a great course so if you're prepared to employ a lots of great system programmers from say from illinois then if you don't mind that expense then udp gives you a lower latency response and besides if you're doing this just for incremental search is you don't care anyway if you drop a packet because in a moment the user is going to be typing another character anyway and so you can reissue a new search based on that new information right but most packets today for http are using tcp	system	397
ok so that's a very short introduction to http we wrote in fact our very first piece of http right here where we request a picture of a cat and we'll be seeing more examples of this in the future but for now let's actually stop talking about conceptual stuff actually let's actually now make our own http--sorry, our own client inside some c code so let's actually start looking to see what network code looks like for real ok bye	code	342
ok so let's have a play with this we've got this idea that every process actually has a uid and effective user id so let's write a program to actually look at those and in fact it would be great if we knew not only the number of the user user id and they voted user id but also perhaps a name associated with it be nice to actually call our users by name so we can do that and the way to find out the username is through this little function called to get password of user id so will pass in an integer and it will get a fill out other this will give a pointer to a struct so probably just struct is stored in some static memory somewhere right so that looks like a password we can't actually recover the users password from this struct	memory	622
ok so let's have a play with this we've got this idea that every process actually has a uid and effective user id so let's write a program to actually look at those and in fact it would be great if we knew not only the number of the user user id and they voted user id but also perhaps a name associated with it be nice to actually call our users by name so we can do that and the way to find out the username is through this little function called to get password of user id so will pass in an integer and it will get a fill out other this will give a pointer to a struct so probably just struct is stored in some static memory somewhere right so that looks like a password we can't actually recover the users password from this struct	a struct	564
ok so let's have a play with this we've got this idea that every process actually has a uid and effective user id so let's write a program to actually look at those and in fact it would be great if we knew not only the number of the user user id and they voted user id but also perhaps a name associated with it be nice to actually call our users by name so we can do that and the way to find out the username is through this little function called to get password of user id so will pass in an integer and it will get a fill out other this will give a pointer to a struct so probably just struct is stored in some static memory somewhere right so that looks like a password we can't actually recover the users password from this struct	pointer	553
in modern unix systems ok so what we're going to do is to say right when i run this program i want to know the uid and also the name associated with it and then let's repeat this but with the effective user id so again will actually print out the effective user id and the name associated with that so we're going to call this get password based on uid with two different arguments ok so the uid any effective user id ok so let's run that here's a program that we started earlier right so what have i been doing between likely there we go right so i've got a little program called hello and you might notice that right now i'm route on this machine who ok so i did sudo minus s to become root and then stay route so i've just compiled this and now if you look inside this current directory you'll see that i've made a program called hello it's owned by root and everybody right now is allowed to execute it so i'm going to switch windows now into a different ssh session where now i can still look inside this directory same directory where's my head i got there it is ok so i should be able to run this so let me run hello and it says great yes hello engrave your user id as a thousand and you affective user id is a thousand in other words anything this process anything this program does on my behalf has my rights has the rights of angrave so it can't start altering system files it won't be able to open ports less than one thousand twenty four for example case so it's not going to be a very good web server if it doesn't have those privileges right then so that's not stop playing with this let's	system	15
run this as say root ok so i'm going to run hello again right and will see it now i've got this magic idea of zero and so if you want to test whether a process is running as root you can test their user id or better their effective user id to see if they have root privileges ok so now let's play with some sticky bits here so i'm going to change the	a process	150
so that's a that's a way to attack a system if you can add a sticky bit to something which can do generally useful things the alternative is that maybe you've got a bona fide reason to do this for example maybe hello is now going to be a web server so great now angrave for anybody else that can run this program can start a web server so maybe i want to change the permissions on this so that only people within a certain group for example can run this program	system	37
malloc some space are use every today to say right i want to read in that number of bytes i don't need this to be a c string because i mean immediately going to call f right to output the contents of the file another going to read in exactly the bytes of the file and then i'm immediately going to print it out so i'm going to behave a bit like cat if you like ok so i'm being a good citizen and closing the resources as soon as i don't need them so i'm calling f close on the file handle	string	118
malloc some space are use every today to say right i want to read in that number of bytes i don't need this to be a c string because i mean immediately going to call f right to output the contents of the file another going to read in exactly the bytes of the file and then i'm immediately going to print it out so i'm going to behave a bit like cat if you like ok so i'm being a good citizen and closing the resources as soon as i don't need them so i'm calling f close on the file handle	resources	408
and then freeing the memory as well ok so here's what we've got here is my secret file and you'll notice that my secret file here is very secretive the only thing that you allowed to do is read it and that's if you're the owner which is potato bob ok so of course	memory	21
angrave let's see if we try to read secret dot text we get permission denied because everybody else does not have reposition on this read on this file ok but if we look at this program called how which is the code we've just been looking at your notice it's got the sticky bit set here this little s here and its	code	209
ok so here's the big idea to make tcp client i actually only need two calls i need a way to escape out of my c code and actually start talking to the network card and for that i need a socket so this is the thing that is going to give me a file descriptor and we can pass some information into this is to say what kind of socket we want do you want a tcp or udp kind of socket in other words do you want to stream based or packet based data ground based kind of suck it here so we'll talk about how to fill these pieces of information in an moment but i want you to realize that the result of calling socket is just a file descriptor so this if you like is very similar to calling open or very similar to calling pipe now i've actually got something that i can use	code	111
notice that in both these cases i careful to check the error values ok so this will be a non negative value if it is a valid file descriptor if it returns negative one then we know that my attempt to create a socket failed perhaps i don't have privileges perhaps i've created too many sockets at anyways so let's print out the string of every number and quit exit so network code has to check very carefully whether each system for work but once you've gotta suck it now you can call connect so again let's check to see if this failed if it returned negative one let's find out our value of erno and print out a useful message and quit	code	375
notice that in both these cases i careful to check the error values ok so this will be a non negative value if it is a valid file descriptor if it returns negative one then we know that my attempt to create a socket failed perhaps i don't have privileges perhaps i've created too many sockets at anyways so let's print out the string of every number and quit exit so network code has to check very carefully whether each system for work but once you've gotta suck it now you can call connect so again let's check to see if this failed if it returned negative one let's find out our value of erno and print out a useful message and quit	string	327
notice that in both these cases i careful to check the error values ok so this will be a non negative value if it is a valid file descriptor if it returns negative one then we know that my attempt to create a socket failed perhaps i don't have privileges perhaps i've created too many sockets at anyways so let's print out the string of every number and quit exit so network code has to check very carefully whether each system for work but once you've gotta suck it now you can call connect so again let's check to see if this failed if it returned negative one let's find out our value of erno and print out a useful message and quit	system	421
and let's see what else oh yeah so i can block so if i call reed and i haven't got any lights yet from the server then that recall is going to block forever until i do or an error occurs simply my right call may block until it's able to send those bytes to a buffer	block	41
but are we done? no! we should also call close just like you have a file descriptor of the file is time to have free up these resources ok so remember to close it as well	resources	126
right so with this in mind i think it's time to fill in some code here but there's one thing we haven't talked about up here so i said that our tcp server only needs actually two network calls which is true but in practice there's a third one that comes in very very useful and it's the following is this get address info this is a kind of swiss army knife of a call which can do all sorts of useful things for us and in particular is going to allow us to correctly set these kind of four parameters here for the socket and the network connection and also it allows us to not specify ip addresses directly instead we can specify domain names like illinois dot edu and get address info can convert that into an ip for address and even potentially an ip six address as well so we don't need to memorize a whole load of ip four and ip six addresses instead we can use these fully qualified host names and get a drink address info will convert those force	the following	283
right so with this in mind i think it's time to fill in some code here but there's one thing we haven't talked about up here so i said that our tcp server only needs actually two network calls which is true but in practice there's a third one that comes in very very useful and it's the following is this get address info this is a kind of swiss army knife of a call which can do all sorts of useful things for us and in particular is going to allow us to correctly set these kind of four parameters here for the socket and the network connection and also it allows us to not specify ip addresses directly instead we can specify domain names like illinois dot edu and get address info can convert that into an ip for address and even potentially an ip six address as well so we don't need to memorize a whole load of ip four and ip six addresses instead we can use these fully qualified host names and get a drink address info will convert those force	parameter	489
right so with this in mind i think it's time to fill in some code here but there's one thing we haven't talked about up here so i said that our tcp server only needs actually two network calls which is true but in practice there's a third one that comes in very very useful and it's the following is this get address info this is a kind of swiss army knife of a call which can do all sorts of useful things for us and in particular is going to allow us to correctly set these kind of four parameters here for the socket and the network connection and also it allows us to not specify ip addresses directly instead we can specify domain names like illinois dot edu and get address info can convert that into an ip for address and even potentially an ip six address as well so we don't need to memorize a whole load of ip four and ip six addresses instead we can use these fully qualified host names and get a drink address info will convert those force	code	61
right so with this in mind i think it's time to fill in some code here but there's one thing we haven't talked about up here so i said that our tcp server only needs actually two network calls which is true but in practice there's a third one that comes in very very useful and it's the following is this get address info this is a kind of swiss army knife of a call which can do all sorts of useful things for us and in particular is going to allow us to correctly set these kind of four parameters here for the socket and the network connection and also it allows us to not specify ip addresses directly instead we can specify domain names like illinois dot edu and get address info can convert that into an ip for address and even potentially an ip six address as well so we don't need to memorize a whole load of ip four and ip six addresses instead we can use these fully qualified host names and get a drink address info will convert those force	address	309
in your spare time next time you're having drifting off to sleep chatting with friends and an algorithm or an idea pops into your head think about oh how would i apply what i'm learning inside cs two forty one to make that run faster to make it actually run concurrently so as a worked example remember some of the sorting algorithms you might have seen before like merge sort has suppose you wanted to make your merge sort run faster how would you implement that in parallel ok so kind of let's do this as a little worse example but again there my suggestion to you is is think about your cs life and start thinking about well how can i use multiple threads to make this or how can i use multiple processes ok so remember how merge sort works we say if i've got say an array of data here	thread	651
ok so think of like to parcel cards so this number is smaller great i'll take this now we build the next number ok so now this number is not as small as the number might from my right hand pile so i'll take that and repeat and eventually we managed to merge these altogether and notice i relied on the recursion fairy to do most of the work so of course this happens at all levels so if i've started with nice big block of data say mb of data then first of all we call recursion ok and so on and so on and that has to be cursively run these ok so how can i now	block	414
and my calls here wouldn't be able to continue until say these two have completed and then i can start doing the merge simile this merge can happen once these two have finished so it's kind of fun to sketch out how you might actually implement this so how would you use condition way to how to use p threaded barrier to make your code run nice and fast	code	330
and my calls here wouldn't be able to continue until say these two have completed and then i can start doing the merge simile this merge can happen once these two have finished so it's kind of fun to sketch out how you might actually implement this so how would you use condition way to how to use p threaded barrier to make your code run nice and fast	thread	300
right so we got this little challenge about what will this code print ok so we know that	code	59
and then i've got also my stack another variable core pointer and what type is it it's a pointer never mind what it points to simply by the fact that it has to point to any memory address means that it's going to need to be the right number of bytes queso say on a thirty two bit machine that will be four bites on a sixty four bit machine will be a preds ok so will pretend that i've made a one two three four five six seven ok have one more byte there we go by eight bytes there and what do we put inside this these eight bytes the memory address of a literally it's looking at a it's holding that address and then we have another variable called child when we put that in here these will stack variables and we call fork right ok and what do we do inside the child rights so if with a child we do reference or pointer and we change the value to twenty in other words in the child we are writing the value or twenty inside the area here so we're going to put stupid little arrow have a blue blue arrow key	memory	173
and then i've got also my stack another variable core pointer and what type is it it's a pointer never mind what it points to simply by the fact that it has to point to any memory address means that it's going to need to be the right number of bytes queso say on a thirty two bit machine that will be four bites on a sixty four bit machine will be a preds ok so will pretend that i've made a one two three four five six seven ok have one more byte there we go by eight bytes there and what do we put inside this these eight bytes the memory address of a literally it's looking at a it's holding that address and then we have another variable called child when we put that in here these will stack variables and we call fork right ok and what do we do inside the child rights so if with a child we do reference or pointer and we change the value to twenty in other words in the child we are writing the value or twenty inside the area here so we're going to put stupid little arrow have a blue blue arrow key	type	71
and then i've got also my stack another variable core pointer and what type is it it's a pointer never mind what it points to simply by the fact that it has to point to any memory address means that it's going to need to be the right number of bytes queso say on a thirty two bit machine that will be four bites on a sixty four bit machine will be a preds ok so will pretend that i've made a one two three four five six seven ok have one more byte there we go by eight bytes there and what do we put inside this these eight bytes the memory address of a literally it's looking at a it's holding that address and then we have another variable called child when we put that in here these will stack variables and we call fork right ok and what do we do inside the child rights so if with a child we do reference or pointer and we change the value to twenty in other words in the child we are writing the value or twenty inside the area here so we're going to put stupid little arrow have a blue blue arrow key	address	180
and then i've got also my stack another variable core pointer and what type is it it's a pointer never mind what it points to simply by the fact that it has to point to any memory address means that it's going to need to be the right number of bytes queso say on a thirty two bit machine that will be four bites on a sixty four bit machine will be a preds ok so will pretend that i've made a one two three four five six seven ok have one more byte there we go by eight bytes there and what do we put inside this these eight bytes the memory address of a literally it's looking at a it's holding that address and then we have another variable called child when we put that in here these will stack variables and we call fork right ok and what do we do inside the child rights so if with a child we do reference or pointer and we change the value to twenty in other words in the child we are writing the value or twenty inside the area here so we're going to put stupid little arrow have a blue blue arrow key	pointer	54
how they exited ok so we're not going to get past line six until the child has finished and which point we print out the value of ok let's follow our pointer and read the integer that is at that moment location so what do you think is going to print is it going to pretend or twenty you get you get to choose now you're ready go	pointer	150
alright let's see if you're right so first of all let's see what happens and then see if we can explain it ok so i'll go to some code i prepared earlier kate i'm going to wait one let's hook up my fork puzzle yes cat	code	129
for puzzle same code right let's run this are today you say clang like fork puzzle get off you go and run it and what did you see well hiding in the bottom left hand corner you'll see a value of ten	code	16
in other words the child never change my value is that surprising hopefully not hopefully this reinforces the idea that the child has his own destiny now it has its own memory and even though we cloned it from before	memory	169
anything it does to its variables here and its memory space do i have	memory	47
right which is what the child is doing here is happening inside a completely different process so it's not going to affect the parent process memory at all so even though the dress value of the pointer is the same even if you say looking at address ffff liberalizing resume what something that number actually correspond to a different piece of ram and that's the idea of virtual memory that the address space of a process is unique to each process this ensures that if one process has a security or so it has a bug in it then it just it can't just suddenly start reading or writing memory from another process	memory	142
right which is what the child is doing here is happening inside a completely different process so it's not going to affect the parent process memory at all so even though the dress value of the pointer is the same even if you say looking at address ffff liberalizing resume what something that number actually correspond to a different piece of ram and that's the idea of virtual memory that the address space of a process is unique to each process this ensures that if one process has a security or so it has a bug in it then it just it can't just suddenly start reading or writing memory from another process	a process	413
right which is what the child is doing here is happening inside a completely different process so it's not going to affect the parent process memory at all so even though the dress value of the pointer is the same even if you say looking at address ffff liberalizing resume what something that number actually correspond to a different piece of ram and that's the idea of virtual memory that the address space of a process is unique to each process this ensures that if one process has a security or so it has a bug in it then it just it can't just suddenly start reading or writing memory from another process	address	241
right which is what the child is doing here is happening inside a completely different process so it's not going to affect the parent process memory at all so even though the dress value of the pointer is the same even if you say looking at address ffff liberalizing resume what something that number actually correspond to a different piece of ram and that's the idea of virtual memory that the address space of a process is unique to each process this ensures that if one process has a security or so it has a bug in it then it just it can't just suddenly start reading or writing memory from another process	pointer	194
by the way later on in the course we will show you how to process is can open up our tunnel between them so they do shared memory but that's a special feature of posix and we will look at that in the future so this what the child into is memory doesn't affect the parent is the headline ok sir in the next video let's start talking about writing very simple memory allocator ok see you then	memory	123
hi ok so we had this wonderful thing called the memory allocator so when i want some memory some dynamic memory that i might need for a while i need to get that from the heap how do i do that well is easy just got my lock and say how many bytes do you want so inside that memory maybe will store c object maybe we will solve a structured many things maybe we have an array of integers it doesn't matter in the heap allocator doesn't care what you do with that memory	memory	48
hi ok so we had this wonderful thing called the memory allocator so when i want some memory some dynamic memory that i might need for a while i need to get that from the heap how do i do that well is easy just got my lock and say how many bytes do you want so inside that memory maybe will store c object maybe we will solve a structured many things maybe we have an array of integers it doesn't matter in the heap allocator doesn't care what you do with that memory	the heap	166
hi ok so we had this wonderful thing called the memory allocator so when i want some memory some dynamic memory that i might need for a while i need to get that from the heap how do i do that well is easy just got my lock and say how many bytes do you want so inside that memory maybe will store c object maybe we will solve a structured many things maybe we have an array of integers it doesn't matter in the heap allocator doesn't care what you do with that memory	a struct	325
all we have to remember is that we are very careful to only use that piece of memory be careful so if we asked one hundred bytes only use a hundred bytes don't start using the hundred one hundred two hundred three bites step probably important and being used for something else also if we know the start of our allocation don't use the bytes before again those bytes are probably going to be used for something else and if we override them then our program will probably have undefined behavior who knows what it's going to do so let's take a look at this little puzzle here i've got two calls to malloc i'm requesting ten bites and then later eight bytes and the puzzle is how can i make these two calls actually returned the same address now you might notice in this example here that i've got these void things so avoid pointer means i want to store an address and i'm not going to tell you what there just simply treat it as a number as an address as a memory location and we won't talk about what kind of objects or what kind of primitives or anything about with storing there so we can't we can't we shouldn't do pointer arithmetic on void pointers or at least that's the official line more about that later ok so we've got our two memory allocation requests how could these possibly would be returned the same thing so the answer to our little puzzle here is what do we do the following after calling malloc we immediately say hey thanks so those bites but you know what i changed my mind i don't need them anymore so let me call free and pass in	the following	1380
all we have to remember is that we are very careful to only use that piece of memory be careful so if we asked one hundred bytes only use a hundred bytes don't start using the hundred one hundred two hundred three bites step probably important and being used for something else also if we know the start of our allocation don't use the bytes before again those bytes are probably going to be used for something else and if we override them then our program will probably have undefined behavior who knows what it's going to do so let's take a look at this little puzzle here i've got two calls to malloc i'm requesting ten bites and then later eight bytes and the puzzle is how can i make these two calls actually returned the same address now you might notice in this example here that i've got these void things so avoid pointer means i want to store an address and i'm not going to tell you what there just simply treat it as a number as an address as a memory location and we won't talk about what kind of objects or what kind of primitives or anything about with storing there so we can't we can't we shouldn't do pointer arithmetic on void pointers or at least that's the official line more about that later ok so we've got our two memory allocation requests how could these possibly would be returned the same thing so the answer to our little puzzle here is what do we do the following after calling malloc we immediately say hey thanks so those bites but you know what i changed my mind i don't need them anymore so let me call free and pass in	memory	78
all we have to remember is that we are very careful to only use that piece of memory be careful so if we asked one hundred bytes only use a hundred bytes don't start using the hundred one hundred two hundred three bites step probably important and being used for something else also if we know the start of our allocation don't use the bytes before again those bytes are probably going to be used for something else and if we override them then our program will probably have undefined behavior who knows what it's going to do so let's take a look at this little puzzle here i've got two calls to malloc i'm requesting ten bites and then later eight bytes and the puzzle is how can i make these two calls actually returned the same address now you might notice in this example here that i've got these void things so avoid pointer means i want to store an address and i'm not going to tell you what there just simply treat it as a number as an address as a memory location and we won't talk about what kind of objects or what kind of primitives or anything about with storing there so we can't we can't we shouldn't do pointer arithmetic on void pointers or at least that's the official line more about that later ok so we've got our two memory allocation requests how could these possibly would be returned the same thing so the answer to our little puzzle here is what do we do the following after calling malloc we immediately say hey thanks so those bites but you know what i changed my mind i don't need them anymore so let me call free and pass in	memory allocation	1238
all we have to remember is that we are very careful to only use that piece of memory be careful so if we asked one hundred bytes only use a hundred bytes don't start using the hundred one hundred two hundred three bites step probably important and being used for something else also if we know the start of our allocation don't use the bytes before again those bytes are probably going to be used for something else and if we override them then our program will probably have undefined behavior who knows what it's going to do so let's take a look at this little puzzle here i've got two calls to malloc i'm requesting ten bites and then later eight bytes and the puzzle is how can i make these two calls actually returned the same address now you might notice in this example here that i've got these void things so avoid pointer means i want to store an address and i'm not going to tell you what there just simply treat it as a number as an address as a memory location and we won't talk about what kind of objects or what kind of primitives or anything about with storing there so we can't we can't we shouldn't do pointer arithmetic on void pointers or at least that's the official line more about that later ok so we've got our two memory allocation requests how could these possibly would be returned the same thing so the answer to our little puzzle here is what do we do the following after calling malloc we immediately say hey thanks so those bites but you know what i changed my mind i don't need them anymore so let me call free and pass in	address	732
all we have to remember is that we are very careful to only use that piece of memory be careful so if we asked one hundred bytes only use a hundred bytes don't start using the hundred one hundred two hundred three bites step probably important and being used for something else also if we know the start of our allocation don't use the bytes before again those bytes are probably going to be used for something else and if we override them then our program will probably have undefined behavior who knows what it's going to do so let's take a look at this little puzzle here i've got two calls to malloc i'm requesting ten bites and then later eight bytes and the puzzle is how can i make these two calls actually returned the same address now you might notice in this example here that i've got these void things so avoid pointer means i want to store an address and i'm not going to tell you what there just simply treat it as a number as an address as a memory location and we won't talk about what kind of objects or what kind of primitives or anything about with storing there so we can't we can't we shouldn't do pointer arithmetic on void pointers or at least that's the official line more about that later ok so we've got our two memory allocation requests how could these possibly would be returned the same thing so the answer to our little puzzle here is what do we do the following after calling malloc we immediately say hey thanks so those bites but you know what i changed my mind i don't need them anymore so let me call free and pass in	pointer	823
that addressed it you gave me to say i'm done with those ten bytes we can't pass in p one plus five or we can't say i've done with half of it the only point if you could pass to free r is the point of that you got back originally from malloc calloc realloc right so we freed up those bytes which means that the memory allocator can put those bites back into its pool and so future cost in my lock may not guaranteed but may actually	memory	311
that addressed it you gave me to say i'm done with those ten bytes we can't pass in p one plus five or we can't say i've done with half of it the only point if you could pass to free r is the point of that you got back originally from malloc calloc realloc right so we freed up those bytes which means that the memory allocator can put those bites back into its pool and so future cost in my lock may not guaranteed but may actually	address	5
give us the same memory address in the future	memory	17
give us the same memory address in the future	address	24
height ok so let's talk about how we can implement free right so the story so so so far is that the user program is called free and now we can do the easy one it could be that they've passed pointer value of null	pointer	191
and by definition free does nothing if you pass in the value of no so great we can implement that if pointer value is zero isn't otherwise null then don't do anything just do an early return	pointer	101
right now is your done oh wait ok so here's how we're going to do this we have a link list remember let's go through that link list and find the entry that corresponds to the users pointer we remember that was the thing that we return from malloc ok so here's the plan then right i need a k	pointer	181
ok right so why can we call malloc from two thirds because it is what right hopefully you said because it is thread safe right so if i can write with this thing here we go thread safe	thread	109
each thread because each thread gets its own stack	thread	5
right so you probably got a whole lot of questions about threads in people 's at this point so what i'm going to suggest you do is post a video and by the google something or try a man page see if your system already supports the manpages for p threads and if it doesn't figure out how to install those additional manpages hint a quick google search can tell you the magic incantation if you're working with the cs two forty one virtual machine you can become root and so you can do things like sudo to become route to our pseudo minus s to stay route until that until you decide to exit and become a normal user again but whilst roots you can do things like apt install if it's an unbuntu system	thread	57
right so you probably got a whole lot of questions about threads in people 's at this point so what i'm going to suggest you do is post a video and by the google something or try a man page see if your system already supports the manpages for p threads and if it doesn't figure out how to install those additional manpages hint a quick google search can tell you the magic incantation if you're working with the cs two forty one virtual machine you can become root and so you can do things like sudo to become route to our pseudo minus s to stay route until that until you decide to exit and become a normal user again but whilst roots you can do things like apt install if it's an unbuntu system	system	202
to install additional things like the piece rate library topeka read manpages if they're not already there ok as usual google can be your friend here but try looking something up try finding out something about pthread yourself right with that i'm going to see you in the next video where we finish the following code and then will play with it to see what it actually prints by	the following	299
to install additional things like the piece rate library topeka read manpages if they're not already there ok as usual google can be your friend here but try looking something up try finding out something about pthread yourself right with that i'm going to see you in the next video where we finish the following code and then will play with it to see what it actually prints by	code	313
to install additional things like the piece rate library topeka read manpages if they're not already there ok as usual google can be your friend here but try looking something up try finding out something about pthread yourself right with that i'm going to see you in the next video where we finish the following code and then will play with it to see what it actually prints by	thread	212
ok great i welcome to like twenty eight so let's get started we're going to look a little bit more at our file system representation and then dive into stats and how we're going to have hard links and symbolic	system	111
to our files so just as a kind of quick warmup remember we're playing with the model of the ext2 file system	system	102
and my i node is the file i can't create a file in this i've actually gotten inode entry and i'm going to have will say ten entries inside my inode directly to the first ten disk blocks used by my file so in otherwise i could hold forty kb there and then i also have inside the i node that this block which holds a table with a thousand twenty four entries and then another entry side the i node for my double interact an another entry for the really large files which is actually going to be a triple indirect in those for the triple indirect i need to follow the money three times i have to load three blocks before actually can find out where the data is stored but even for very large files the beginning of the file is always stored in these direct blocks so that we have nice fast access to those	block	179
ok right so let's kind of run through this remember that my disk is when i format it i've formatted it into a super block and i may have copies of that to the rest of the rest of the disk for backup purposes have a space set aside for i nodes and the rest of the space is going to be used for the actual files and any indirect blocks that we need to store okie sue this will look at our quick first question for x two with four kilobyte blocks at thirty two bit addressing watson maximum size are disk that we can support well the idea for this question is not about the indirect and double in triple indirect it's more the fact that if i want to say to the disk hey disc actually would load a particular disk block please then i can pass in a number which is bounded by thirty two bit addressing scheme so i've got two to thirty two possible dis blocks i could request and each one is four kb so if we do the math here and i think i did it in a previous lecture here that's remember the two to the thirty two how can i think about that well two to the ten is anybody knows is about a thousand thousand and twenty four ok so two of the thirty two is actually two to the ten times two to the ten times two to ten times ten times two to the two ok so now we can see that i'm going to change my units from kilobytes to megabytes to gigabytes to terabytes queso terabytes and then i've just got this two of the two times the original four so in other words i can support up to sixteen terabyte disks alright i hope that quick back of the envelope calculation makes sense	block	116
ok right so let's kind of run through this remember that my disk is when i format it i've formatted it into a super block and i may have copies of that to the rest of the rest of the disk for backup purposes have a space set aside for i nodes and the rest of the space is going to be used for the actual files and any indirect blocks that we need to store okie sue this will look at our quick first question for x two with four kilobyte blocks at thirty two bit addressing watson maximum size are disk that we can support well the idea for this question is not about the indirect and double in triple indirect it's more the fact that if i want to say to the disk hey disc actually would load a particular disk block please then i can pass in a number which is bounded by thirty two bit addressing scheme so i've got two to thirty two possible dis blocks i could request and each one is four kb so if we do the math here and i think i did it in a previous lecture here that's remember the two to the thirty two how can i think about that well two to the ten is anybody knows is about a thousand thousand and twenty four ok so two of the thirty two is actually two to the ten times two to the ten times two to ten times ten times two to the two ok so now we can see that i'm going to change my units from kilobytes to megabytes to gigabytes to terabytes queso terabytes and then i've just got this two of the two times the original four so in other words i can support up to sixteen terabyte disks alright i hope that quick back of the envelope calculation makes sense	address	462
ok so let's have a look at the following question then so if each i'd entries are fixed size always a hundred and twenty eight bytes and i've when i formatted my disk i said please put a size sixty four kb for the i node away in the words the space up here there we go	the following	27
how large can of rb before triple indirect blocks are required ok so to answer this one it means we're going to use the ten direct blocks so that's going to be forty kilobytes then we have the indirect block so my indirect block itself is four kb but we're using thirty two bit addressing so that means each one of those entries here is going to be a number which takes four bytes for my thirty two bits ok so for my four kb block here that means i can have	block	43
how large can of rb before triple indirect blocks are required ok so to answer this one it means we're going to use the ten direct blocks so that's going to be forty kilobytes then we have the indirect block so my indirect block itself is four kb but we're using thirty two bit addressing so that means each one of those entries here is going to be a number which takes four bytes for my thirty two bits ok so for my four kb block here that means i can have	address	278
a thousand and twenty four numbers in other words i can reference a thousand and twenty fourth data blocks which means that i've got four kilobytes which means for each block which means i've got four megabytes of data here for my direct for my first indirect and then for double indirect each one of those thousand twenty four entries they themselves can actually	block	100
the largest file i can store before i need to start using triple indirect addressing is going to be forty kb plus four megabytes	address	74
plus four gigabytes an i could turn that into a an actual number of bytes if i really wanted to ok so a quick comment is so far i've been using large k here for kilobytes meaning that my units are are based on two to the ten another thousand twenty four this manufacturers however tend to would like to maximize the apparent number of bytes that they're selling you so they use a different numbering system	system	400
they prefer to think about units in a decimal system in other words in multiples of a thousand so you the correct way to write this today is to put a little small i after this for example like a kilobyte would mean one thousand bytes or a megabyte so that would be a million bytes as in one zero zero zero zero zero zero bytes however you don't be surprised if i'm the marketing materials the disk manufacturers conveniently forget to write the small i hear also if you're buying a modem we want to talk about bits then if i'm talking about say megabits per second the small b is used to represent bits not bytes so just watch out for those kind of little gotchas there and don't be surprised in the marketing materials if they really if we get to be accurate	a megabyte	237
they prefer to think about units in a decimal system in other words in multiples of a thousand so you the correct way to write this today is to put a little small i after this for example like a kilobyte would mean one thousand bytes or a megabyte so that would be a million bytes as in one zero zero zero zero zero zero bytes however you don't be surprised if i'm the marketing materials the disk manufacturers conveniently forget to write the small i hear also if you're buying a modem we want to talk about bits then if i'm talking about say megabits per second the small b is used to represent bits not bytes so just watch out for those kind of little gotchas there and don't be surprised in the marketing materials if they really if we get to be accurate	system	46
right so let's kind of go back onto our file systems	system	45
now here's a useful little command get cwd noticed that's right it tells us the process is current working directory which is going to be useful if we want to work with relative directories and in fact paths in your system of defined to have a maximum length so you can be confident that the string that you can request can never be larger than this constant here path max and we add one just to ensure that there's enough space for the c string zero bite at the end ok so if you want to know how where you currently on file system here is one way to do it right	string	292
now here's a useful little command get cwd noticed that's right it tells us the process is current working directory which is going to be useful if we want to work with relative directories and in fact paths in your system of defined to have a maximum length so you can be confident that the string that you can request can never be larger than this constant here path max and we add one just to ensure that there's enough space for the c string zero bite at the end ok so if you want to know how where you currently on file system here is one way to do it right	system	216
so that is a limitation of function here so in fact if i type c w p w for present working directory that internally is using this gets cwd command so there it is actually part of the standard library and we can either pass in some space or we can pass in null and it will allocate it on on the heap	the heap	290
so that is a limitation of function here so in fact if i type c w p w for present working directory that internally is using this gets cwd command so there it is actually part of the standard library and we can either pass in some space or we can pass in null and it will allocate it on on the heap	type	57
in general then if you want to work with kind of paths then you can use this constant which is actually part of the kernel but provided by the c library to assure that your c strings are always of sufficient size	string	175
ok so when we do that we get a pointer back this little directory entry structure and it's a very simple structure in fact it only has two entries it has name and the i node number so if you wanted to print out the i node number you can say ok dp tell me the i node numbers so it's just i know	pointer	31
so here's a little bit of code then that actually looks at the current directory to see if a certain file exists will looking	code	26
my right so just the pen it's working good right so we are just looking to see if a particular file name exists inside the current directory and what we turned what otherwise let's return zero so what do you think about this code can you spot any mistakes in it	code	225
ok so hopefully your system programming a alarm bells go off because the problem with this code is that there's a path of execution where we forget to close the current directory so if we do find the name that we're looking for we returned one we never actually execute this closed so that's a problem	code	91
ok so hopefully your system programming a alarm bells go off because the problem with this code is that there's a path of execution where we forget to close the current directory so if we do find the name that we're looking for we returned one we never actually execute this closed so that's a problem	system	21
that we haven't closed resources so this actually security problem that it might work once or twice or ten times but we're leaving a file descriptor open and eventually will run out of spare far descriptors for process and then opening files or calling opened are won't work in the future we don't have any spare file descriptors left ok the other thing that we might comment on if we were doing a code review instead opened a could fail so if this returns null for example there is no current directory 's kind of a little bit bizarre but we could imagine that happens for example someone 's deleted the current direct current directory then this open durcal would return null so we're not actually checking for that ok and by the way in case you didn't notice look we're doing this trick to hear to say ok i know that i've finished reading the current directory when this is called to read returns null that's when i know where there's no more entries left to fight but the biggest idea here is that we didn't clean up ourselves we didn't always release resources so always check your code your system programming code to make sure that in all code paths particularly error code paths you've released resources as soon as you finished using them ok and this will correspond to file descriptors to memory to any other resources to tcp sockets etc etc etc right ok so	memory	1299
that we haven't closed resources so this actually security problem that it might work once or twice or ten times but we're leaving a file descriptor open and eventually will run out of spare far descriptors for process and then opening files or calling opened are won't work in the future we don't have any spare file descriptors left ok the other thing that we might comment on if we were doing a code review instead opened a could fail so if this returns null for example there is no current directory 's kind of a little bit bizarre but we could imagine that happens for example someone 's deleted the current direct current directory then this open durcal would return null so we're not actually checking for that ok and by the way in case you didn't notice look we're doing this trick to hear to say ok i know that i've finished reading the current directory when this is called to read returns null that's when i know where there's no more entries left to fight but the biggest idea here is that we didn't clean up ourselves we didn't always release resources so always check your code your system programming code to make sure that in all code paths particularly error code paths you've released resources as soon as you finished using them ok and this will correspond to file descriptors to memory to any other resources to tcp sockets etc etc etc right ok so	code	398
that we haven't closed resources so this actually security problem that it might work once or twice or ten times but we're leaving a file descriptor open and eventually will run out of spare far descriptors for process and then opening files or calling opened are won't work in the future we don't have any spare file descriptors left ok the other thing that we might comment on if we were doing a code review instead opened a could fail so if this returns null for example there is no current directory 's kind of a little bit bizarre but we could imagine that happens for example someone 's deleted the current direct current directory then this open durcal would return null so we're not actually checking for that ok and by the way in case you didn't notice look we're doing this trick to hear to say ok i know that i've finished reading the current directory when this is called to read returns null that's when i know where there's no more entries left to fight but the biggest idea here is that we didn't clean up ourselves we didn't always release resources so always check your code your system programming code to make sure that in all code paths particularly error code paths you've released resources as soon as you finished using them ok and this will correspond to file descriptors to memory to any other resources to tcp sockets etc etc etc right ok so	resources	23
that we haven't closed resources so this actually security problem that it might work once or twice or ten times but we're leaving a file descriptor open and eventually will run out of spare far descriptors for process and then opening files or calling opened are won't work in the future we don't have any spare file descriptors left ok the other thing that we might comment on if we were doing a code review instead opened a could fail so if this returns null for example there is no current directory 's kind of a little bit bizarre but we could imagine that happens for example someone 's deleted the current direct current directory then this open durcal would return null so we're not actually checking for that ok and by the way in case you didn't notice look we're doing this trick to hear to say ok i know that i've finished reading the current directory when this is called to read returns null that's when i know where there's no more entries left to fight but the biggest idea here is that we didn't clean up ourselves we didn't always release resources so always check your code your system programming code to make sure that in all code paths particularly error code paths you've released resources as soon as you finished using them ok and this will correspond to file descriptors to memory to any other resources to tcp sockets etc etc etc right ok so	system	1097
here it is right and in this demo we're going to implement a version of ls that is going to read a directory and also not only print out the name but print out the i node number as well so i want to make my code be somewhat cross platform as i'm just bring it out i'm going to assume that this i know number is at least unsigned is no	code	207
ok if it's larger than unsigned long i don't care because i'm just printing out the number anyway so let me just cast it i wouldn't claim that this is kind of completely portable were bused bulletproof code because maybe on some systems and i know it might be a have a larger representation further than a simple long ok right so let me compile this directory list	code	202
ok if it's larger than unsigned long i don't care because i'm just printing out the number anyway so let me just cast it i wouldn't claim that this is kind of completely portable were bused bulletproof code because maybe on some systems and i know it might be a have a larger representation further than a simple long ok right so let me compile this directory list	system	229
ok so let me say alright i'd like to list a kind directory and where hey off it goes right so you can see it's happily printing out directory names and i know numbers and on a mac don't be surprised to see very large i knowed numbers ok so we've got now a program that is behaving a little bit like ls when i type eles it prints out the names in fact i can say hey this please tell me the unknown numbers i think it's minus i and there we go we can see now the i node numbers associated with each file hopefully this is going to be the same as yet eight three four twenty for my actual program here and if i wish i could say to ls ok please actually do it in a format where it's one per per per line the other thing you might notice however is that in my program it printed out two extra yeah so actually it turns out that for	type	309
and that unit will be the smallest unit of read the area that i can write on too so a sector might itself be pretty small say two hundred fifty six bytes but probably a lot smaller than our four thousand ninety six blocks that we take typically talk about	block	215
rpm are more commonly so what does that mean in terms of revolutions per second so we've got seventy two hundred revolutions per minute we want to work that out a second ok so let's do the fifty four hundred divided by sixty sixty seconds right so the other one we want to seventy two hundred divided by sixty right so i could that work that out in terms of ninety and and twelve but course anytime you don't feel like doing math remember that you could always open up your trusty python and say and just immediately type some math so we can do say fifty four hundred divided by sixty there we go so it goes around ninety times a second last thing is spinning out or something two hundred divided by sixty again is one hundred and twenty times a second right so there's other ways you bought the way you can calculate things you can even do it in bash if you put two parentheses in so for example fifty point four hundred divided by sixty though this is just by default integer arithmetic ok so we have now calculated	type	517
can type things in as well so and i forget how to use it but hey it exists or subsystems right enough of that so we've calculated this enough times we know then that	type	4
can type things in as well so and i forget how to use it but hey it exists or subsystems right enough of that so we've calculated this enough times we know then that	system	81
ok so that's pretty slow right that i can only do a hundred different things per second compare that to the number of reads that you can do inside memory you'll see now why storage gets a bad rap in terms of its performance that of order a hundred events per second is extremely slow so let's kind of go back to our virtual memory discussions when we said hey when we were running low on ram will just page out some disk block and store it to disk when you do that then the latency of a spinning disc extracts a heavy price because the most you can hope most events you can hope to do in second is about a hundred of these things so if you're paging one thing out and paging another thing in as soon as you need to do that to say more than fifty different blocks to random pieces of disk your performance is going to be extremely slow now in order for you if you're experiencing a lot of page faults in order for your process to continue your working at the speed of disk not at the speed of ram ok so which means we've gone down from ns hundreds of nanoseconds to just a few hundred events per second so we've how many orders magnitude is that about in a ten to the seven ten to the eight right we've just made a machine about ten to the eight times slower right good news today of course is if we compare with ssds ssds today can service of order a hundred thousand events per second so so we don't see such a slowdown was if i've got a high performance ssd right so that is the biggest killer with our spinning disks is that the latency of being able to access different parts of our disk is very very slow isn't of order ten milliseconds meaning that we've got of order a hundred events maximum that we can process the only time we can improve upon that behavior is when we have very simple sequential read or write and we're just simply reading to the current track and then the next track and the next track in the next track we don't pay for quite similar latency and that's in that specific circumstance	memory	147
ok so that's pretty slow right that i can only do a hundred different things per second compare that to the number of reads that you can do inside memory you'll see now why storage gets a bad rap in terms of its performance that of order a hundred events per second is extremely slow so let's kind of go back to our virtual memory discussions when we said hey when we were running low on ram will just page out some disk block and store it to disk when you do that then the latency of a spinning disc extracts a heavy price because the most you can hope most events you can hope to do in second is about a hundred of these things so if you're paging one thing out and paging another thing in as soon as you need to do that to say more than fifty different blocks to random pieces of disk your performance is going to be extremely slow now in order for you if you're experiencing a lot of page faults in order for your process to continue your working at the speed of disk not at the speed of ram ok so which means we've gone down from ns hundreds of nanoseconds to just a few hundred events per second so we've how many orders magnitude is that about in a ten to the seven ten to the eight right we've just made a machine about ten to the eight times slower right good news today of course is if we compare with ssds ssds today can service of order a hundred thousand events per second so so we don't see such a slowdown was if i've got a high performance ssd right so that is the biggest killer with our spinning disks is that the latency of being able to access different parts of our disk is very very slow isn't of order ten milliseconds meaning that we've got of order a hundred events maximum that we can process the only time we can improve upon that behavior is when we have very simple sequential read or write and we're just simply reading to the current track and then the next track and the next track in the next track we don't pay for quite similar latency and that's in that specific circumstance	block	421
ok so when talking about scheduling and how we're using our resources there's some very common terms let's go kind of threw these so first of all there's the turn around time ok so let's draw a life analogy here if i ask you to produce a report and you start sending me pages and finally give me the whole report the turn around time yet is the time between when we first request to report and when we finally get it all completed so for example if there's a web server this would be the time between you making the request and then getting the complete web page ok so this is going to be with in terms of our little formulas here things like the completion time minus the arrival time	resources	60
ok so latency you've heard this term before we fewer gamer this is the kind of delay this off introduced by a system over network or some kind of information flow and that we can measure the latency of an entire system the entire delay of a system and so typically that will be the latency due to over the response time so a delayed response time we can say oh it's because of the latency of the system	system	110
and that might be due to effects physical effects like speed of light processing effects like the time it takes us to calculate the position of a camera if we're doing say augmenredreality but it's basically is the discussion of the actual delay that's introduced by a system or system component ok and then what about starvation ok so starvation is when you'd like to get something done	system	269
but it never seems to happen because other things are getting in the way perhaps for example you're waiting to buy a ticket or a donut and these kind of little kids keep streaming in front of you and you never get to the counter ok so you'll be starving you'll never get to buy your donut well something similar might happen with a system where because other high priority jobs are given first access hyper t access over you you never get to run on the cpu in fact this even happened with the apollo missions to the moon where certain jobs were unable to complete there wasn't enough cpu time to run them anyway so that's a whole another story but there's lots of fun things about the software bugs and hardware bugs that we managed to land on the moon despite of these issues	system	332
so let's click on general terms oh i think the last one got batch so batch is the opposite of kind of interactive the idea that i've got these long running jobs they don't require a kind of user intervention i've just typically have a kind of their large heavy processing jobs and i care about typically with batch i care about things like throughput like i've got a large number of jobs i want to run between midnight and two o'clock in the morning before saying the back up once and i care about completing as many of these as possible or completely as fast as possible and i don't need any interactivity so so typically if i'm going to schedule things so batch i just want to maximize how fast i can complete more in other words i care about minimizing the total wait time of the entire system across all of my jobs across all of my jobs	system	790
a job to run on the cpu till it finishes but this may not be best for our io resources and so there's always a kind of interesting tradeoffs do i want to see some completion by some jobs early it expensive throughput or do i want to maximize my cpu resources or you want to maximize my io resources in general you can't maximize against all kind of possible measures so you have to kind of decide what's best for your particular application	resources	77
ok if alternatively we are working with the interactive system imagine we've all logged into one lennox server for example or we've got many processes running on a windows machine then i don't want to give this cpu to a single process and let it run forever because then everything else on my system will appear to be very sluggish it possibly not interactive at all i press a letter nothing happens so instead i need a way to be able to say look every every process that is ready to run should have a little bit of cpu time ever so often and even if it doesn't get to kind of fully complete its calculation at least if we give every ready process a little bit cpu time then for simple things like updating the display when you press a button updating menu as you click at least able appears kind of somewhat interactive and give fast feedback to to the user we may not have time to fully re paginate the page but that's ok those things don't need to be kind of immediate ok also if i give a little bit cpu time then then appears to the user that they at least have us all access to the cpu when in fact they're only getting a little slice of it so if we make our slices happen regular enough intervals let's say every one hundred milliseconds or ten milliseconds or one millisecond then it should appear that so we don't have too many things going on then every user actually is able to complete something so for example suppose you are currently logged into a shared linux system you're running gcc or ceiling i'm running say ls and i'm also running a compiler that all of these things will at least make some progress we don't have to wait for your very long compilation doctor complete before mine can start or if i'm using an editor like vim or something else or microsoft visual studio then list i can continue even whilst you are using some of the cpu time for your compile job	system	56
then there's things like real time systems so if i'm going to estero rocket i will have certain processes and calculations which are time critical if i am going to use a piece of c code to control the engine firing to maximize the efficiency of the engine or the performance of the edge and then i need to be able to complete my calculations based on the temperature of the outside air the temperature outside exhaust how long the manifold is been	code	181
then there's things like real time systems so if i'm going to estero rocket i will have certain processes and calculations which are time critical if i am going to use a piece of c code to control the engine firing to maximize the efficiency of the engine or the performance of the edge and then i need to be able to complete my calculations based on the temperature of the outside air the temperature outside exhaust how long the manifold is been	system	35
subject to different temperatures of the grassy i've got loads and loads of different variables and i need to kind of kind of make a decision on exactly when to fire the ignite my fuel every every every piston stroke so this is going to try and critical i better make sure that i can achieve this even when you start messing with the cd player right or some other kind of ui is kind of turn the wipers on or something or enabled bluetooth simply if i've got a thread that is controlling the steering or checking the sensor input for the the radar or kind of front end collision and check into that data is still good or whether the date or whether the sensor is broken these are important things then i probably want to make sure that i can get near real time behavior from these in order to avoid a crash	a thread	458
subject to different temperatures of the grassy i've got loads and loads of different variables and i need to kind of kind of make a decision on exactly when to fire the ignite my fuel every every every piston stroke so this is going to try and critical i better make sure that i can achieve this even when you start messing with the cd player right or some other kind of ui is kind of turn the wipers on or something or enabled bluetooth simply if i've got a thread that is controlling the steering or checking the sensor input for the the radar or kind of front end collision and check into that data is still good or whether the date or whether the sensor is broken these are important things then i probably want to make sure that i can get near real time behavior from these in order to avoid a crash	thread	460
ok so there was no kind of perfect scheduler and no perfect scheduling system but realize them that you are now into the engineering world of difficult tradeoffs and it's up to you to figure out what is going to be a good trade off for your particular application but particularly typically so your fall into kind of these three categories are kind of batch style problem in an interactive problem maybe with one or multiple users and real time systems which have prioritization needs as well ok right so let's look at some standard schedulers and we'll talk about that in the next next video bye	system	71
ok so let's just think about the kind of different information we want to be able to send over the wire to the other side ok so we've already seen one example of this which is an ent and we've got several choices we've got for example we could choose to send it in plain ascii format we could choose to send it in a binary format format but we immediately need to ask things like ok what exactly is our binary representation for example should be little endian like a typical intel cpu or big endian like a typical network representation and also how many bytes and also how do we want to represent negative numbers so we're probably going to choose two 's complement but we should be explicit about this we should be very careful to specify this so that we can write kind of portable implementations and who knows tomorrow maybe for energy purposes we might want to run our remote server end using a completely different cpu for example an arm based cpu as opposed to an x eighty six based cpu ok so that's just integers if we're going to use an ascii how do we represent our numbers are there going to be a fixed number of bytes are they going to begin to include a termination character like a null byte or cologne or comma or are we going to say pass a number to represent the number of bytes that are string version of that inches going to be going to use typically downside of using an ascii version is not only is it network	string	1306
or what about today if we want to represent something more interested in some some interesting thing like a structured piece of data like a composite piece of data like something which represents a string and integer how are we going to marshall that's how we're going to send this so you might be tempted to write	a struct	106
or what about today if we want to represent something more interested in some some interesting thing like a structured piece of data like a composite piece of data like something which represents a string and integer how are we going to marshall that's how we're going to send this so you might be tempted to write	string	198
something like the following let's just write all the bytes inside my struct so for example suppose i wrote ok i'm going to write to my file descriptor descriptor my stat	the following	15
based struct so i've got all the information about a file and the size of my stat data structure ok so one downside of that is that we don't control this particular struct and tomorrow depending on how lynn exchanges this truck it may grow in size it also may have more fields on what operating system compared to another operating system all those fields may be put in a different order	a struct	85
based struct so i've got all the information about a file and the size of my stat data structure ok so one downside of that is that we don't control this particular struct and tomorrow depending on how lynn exchanges this truck it may grow in size it also may have more fields on what operating system compared to another operating system all those fields may be put in a different order	exchange	207
based struct so i've got all the information about a file and the size of my stat data structure ok so one downside of that is that we don't control this particular struct and tomorrow depending on how lynn exchanges this truck it may grow in size it also may have more fields on what operating system compared to another operating system all those fields may be put in a different order	system	295
things on the stats that we didn't actually mean to kind of send with that would be a concern if we were writing kind of security aware code what about a linked list how would you send a link list ok so you might say well i've got a whole load of stats structures each one represents the next point but of course we don't need to do that if we just sending a marshaling a linked list we can just send the actual values so for example we might send	code	136
we don't need to send the pointers we just need to send	pointer	26
is my little code directed graph how could we	code	13
turn that into a sequence of bytes that we could send down the network so typically with a graph we have to be aware that unless it's a simple tree that we might visit a node more than once and we also have to be aware to make sure that we visit every node even if my graph is disjoint and not possible to start from one in one boat node and visit all of them so typically code that is going to push down a graph will end up having some kind of set map to do two things first of all to make sure that we only send each node once down down our father scripter across the network and secondly we typically need to label them somehow to say k so this is my first node and then the first notice set connected to the second one and the third one and i need some kind of mapping to go between say the addresses of each node and some kind of vertex or node identifier	code	373
turn that into a sequence of bytes that we could send down the network so typically with a graph we have to be aware that unless it's a simple tree that we might visit a node more than once and we also have to be aware to make sure that we visit every node even if my graph is disjoint and not possible to start from one in one boat node and visit all of them so typically code that is going to push down a graph will end up having some kind of set map to do two things first of all to make sure that we only send each node once down down our father scripter across the network and secondly we typically need to label them somehow to say k so this is my first node and then the first notice set connected to the second one and the third one and i need some kind of mapping to go between say the addresses of each node and some kind of vertex or node identifier	address	795
right so fortunately today we don't need to actually write all this code to handle these problems instead we can use a new level of abstraction and then ask tools to automatically generate the marshaling code for us and for that we're going to use language or different kinds of language which is called idls or interface design language these look a lot like kind of function definitions in the simplest case is so for example i might declare that i've got a function that returns a string	code	68
right so fortunately today we don't need to actually write all this code to handle these problems instead we can use a new level of abstraction and then ask tools to automatically generate the marshaling code for us and for that we're going to use language or different kinds of language which is called idls or interface design language these look a lot like kind of function definitions in the simplest case is so for example i might declare that i've got a function that returns a string	string	484
and is a name other collection method name or function name for example get name and takes a parameter like an int possibly we might even describe the in size	parameter	93
and typically with these design languages you have to declare whether a parameter is read in or right out or both so for example we might say that this parameter is something which is the value is passed into the function rather than being sent out of the function and the joy of using an idl is that we can specify these high level descriptions of each function and then just crank the handle hit go and our our rpc tools will automatically generate all the marshaling code force you've seen this already with rpc jen which has its one his own version of an idl an idl can get more complicated than this when we start talking about structures and composite types we're going to mention a couple of other examples of this where we are in terms of google protocol buffers but that's it for this video in their next video i'm gonna talk about complexity and the latency of yor pc calls so expensive ok bye for now	type	658
and typically with these design languages you have to declare whether a parameter is read in or right out or both so for example we might say that this parameter is something which is the value is passed into the function rather than being sent out of the function and the joy of using an idl is that we can specify these high level descriptions of each function and then just crank the handle hit go and our our rpc tools will automatically generate all the marshaling code force you've seen this already with rpc jen which has its one his own version of an idl an idl can get more complicated than this when we start talking about structures and composite types we're going to mention a couple of other examples of this where we are in terms of google protocol buffers but that's it for this video in their next video i'm gonna talk about complexity and the latency of yor pc calls so expensive ok bye for now	parameter	72
and typically with these design languages you have to declare whether a parameter is read in or right out or both so for example we might say that this parameter is something which is the value is passed into the function rather than being sent out of the function and the joy of using an idl is that we can specify these high level descriptions of each function and then just crank the handle hit go and our our rpc tools will automatically generate all the marshaling code force you've seen this already with rpc jen which has its one his own version of an idl an idl can get more complicated than this when we start talking about structures and composite types we're going to mention a couple of other examples of this where we are in terms of google protocol buffers but that's it for this video in their next video i'm gonna talk about complexity and the latency of yor pc calls so expensive ok bye for now	code	470
and typically with these design languages you have to declare whether a parameter is read in or right out or both so for example we might say that this parameter is something which is the value is passed into the function rather than being sent out of the function and the joy of using an idl is that we can specify these high level descriptions of each function and then just crank the handle hit go and our our rpc tools will automatically generate all the marshaling code force you've seen this already with rpc jen which has its one his own version of an idl an idl can get more complicated than this when we start talking about structures and composite types we're going to mention a couple of other examples of this where we are in terms of google protocol buffers but that's it for this video in their next video i'm gonna talk about complexity and the latency of yor pc calls so expensive ok bye for now	protocol buffers	754
ok so let's build ourselves a web client so this isn't gonna be quite as good as firefox or chrome but i promise you that it's a lot fresher and also a lot smaller there's just one little downside which is that if you want to navigate to a different page you're going to have to recompile it but nevermind it's for a technical audience anyway so here we go we want to build a web server and we want to specify names like illinois dot edu and we need to convert that there into a tcp address right for that here's a really really useful function getaddressinfo in fact it does many things but we're going to use it today to create the information we need to create a socket and also to call connect and so we eventually will get back a family a socket type and address length and and address as well so we'll use these to kind of plug into the socket connect calls ok right so let's get started the way their address info works is that we actually set up	type	751
ok so let's build ourselves a web client so this isn't gonna be quite as good as firefox or chrome but i promise you that it's a lot fresher and also a lot smaller there's just one little downside which is that if you want to navigate to a different page you're going to have to recompile it but nevermind it's for a technical audience anyway so here we go we want to build a web server and we want to specify names like illinois dot edu and we need to convert that there into a tcp address right for that here's a really really useful function getaddressinfo in fact it does many things but we're going to use it today to create the information we need to create a socket and also to call connect and so we eventually will get back a family a socket type and address length and and address as well so we'll use these to kind of plug into the socket connect calls ok right so let's get started the way their address info works is that we actually set up	address	483
is we're going to call get address info we're going to pass in host and the port that would like to connect to this can either be a number but it has to be a string otherwise we get a segfault or it can be a name like http for example	string	158
is we're going to call get address info we're going to pass in host and the port that would like to connect to this can either be a number but it has to be a string otherwise we get a segfault or it can be a name like http for example	address	27
but here's where we going to pass a pointer to an existing struct and then here's where we pass in a variable a - pointer to a pointer and it's going to	pointer	36
create some heat memory for us with the results so that's what we need to get to let's think about how we can set up this hints object what does that look like okay so here's the plan we get to say what kind of connection we want do we want to say an ip four	memory	17
and zero it all out ok so take the address of it and the number of bytes that i need for this struct will be the number of bytes that i'm just going to set equal to zero so memset is going to walk through all of those bytes setting it all to zero so if i don't set some of the all of the parameters inside that fields sorry inside that struct then by default they will have a value of zero which is a good thing the other thing we're going to need in here is a pointer to result as well so i don't need	parameter	288
and zero it all out ok so take the address of it and the number of bytes that i need for this struct will be the number of bytes that i'm just going to set equal to zero so memset is going to walk through all of those bytes setting it all to zero so if i don't set some of the all of the parameters inside that fields sorry inside that struct then by default they will have a value of zero which is a good thing the other thing we're going to need in here is a pointer to result as well so i don't need	address	35
and zero it all out ok so take the address of it and the number of bytes that i need for this struct will be the number of bytes that i'm just going to set equal to zero so memset is going to walk through all of those bytes setting it all to zero so if i don't set some of the all of the parameters inside that fields sorry inside that struct then by default they will have a value of zero which is a good thing the other thing we're going to need in here is a pointer to result as well so i don't need	pointer	461
an addressinfo i just need a pointer to one right so we can start to set this up now if i'm going to set up a tcp then the address family i need is af address family and i need inet which means ip version four i net short for internet if you wanted ip version six then you would use af inet underscore six	address	3
an addressinfo i just need a pointer to one right so we can start to set this up now if i'm going to set up a tcp then the address family i need is af address family and i need inet which means ip version four i net short for internet if you wanted ip version six then you would use af inet underscore six	pointer	29
there's also inet_any if you would say i don't care about which of these so today we're going to only care about trying to get an ip four address right and what kind of socket type well this is where we can say i actually want either udp or tcp and the constants here either d gram for a datagram udp or stream for a tcp so we're going to use stream i will look up the correct name for this at a moment from a man page but it's something like socks stream yes in fact this what is soccer underscore stream	type	176
there's also inet_any if you would say i don't care about which of these so today we're going to only care about trying to get an ip four address right and what kind of socket type well this is where we can say i actually want either udp or tcp and the constants here either d gram for a datagram udp or stream for a tcp so we're going to use stream i will look up the correct name for this at a moment from a man page but it's something like socks stream yes in fact this what is soccer underscore stream	address	138
get address info please and i'd like to connect on port eighty because that is where unencrypted web traffic should be requested for and now here is the address of my hint structure and here is the address of my result pointer which is going to be changed as well	address	4
get address info please and i'd like to connect on port eighty because that is where unencrypted web traffic should be requested for and now here is the address of my hint structure and here is the address of my result pointer which is going to be changed as well	pointer	219
ok so will getaddressinfo change my result pointer who knows to be sure we better actually check to see whether the getaddressinfo actually succeeds or not so it's important with all of these network calls to check their return value so if it did not succeed then my result pointer can be pointing to anything game because we never set it maybe it's pointing to this smiley over here so a little bit more of a bus code would have actually explicitly set result equal to zero	code	414
ok so will getaddressinfo change my result pointer who knows to be sure we better actually check to see whether the getaddressinfo actually succeeds or not so it's important with all of these network calls to check their return value so if it did not succeed then my result pointer can be pointing to anything game because we never set it maybe it's pointing to this smiley over here so a little bit more of a bus code would have actually explicitly set result equal to zero	address	14
ok so will getaddressinfo change my result pointer who knows to be sure we better actually check to see whether the getaddressinfo actually succeeds or not so it's important with all of these network calls to check their return value so if it did not succeed then my result pointer can be pointing to anything game because we never set it maybe it's pointing to this smiley over here so a little bit more of a bus code would have actually explicitly set result equal to zero	pointer	43
but certainly we don't want to assume that it's been set unless getaddressinfo returns zero so if it doesn't return zero then it actually has a useful error function down here ga - get address info gai underscore string error and that is the way that we can actually print out some useful debugging information as to why this occurred so you don't use errn this is one of the few times that were not using errno to find out what happened instead the error is actually encoded by the return value directly ok so we've got our get address info	code	470
but certainly we don't want to assume that it's been set unless getaddressinfo returns zero so if it doesn't return zero then it actually has a useful error function down here ga - get address info gai underscore string error and that is the way that we can actually print out some useful debugging information as to why this occurred so you don't use errn this is one of the few times that were not using errno to find out what happened instead the error is actually encoded by the return value directly ok so we've got our get address info	string	213
but certainly we don't want to assume that it's been set unless getaddressinfo returns zero so if it doesn't return zero then it actually has a useful error function down here ga - get address info gai underscore string error and that is the way that we can actually print out some useful debugging information as to why this occurred so you don't use errn this is one of the few times that were not using errno to find out what happened instead the error is actually encoded by the return value directly ok so we've got our get address info	address	67
now we can make the calls for a socket to connect so rather than do that here let's actually do that as part of the live code so we can start writing this	code	121
ok right so yeah i was right the socket type with sock underscore stream so great we've got that now it's time to actually make our connection ok so i want to make myself a socket so let me have a	type	40
ok that's fix the indenting here right ok so let's have a socket file descriptor this is how we're going to talk to the server so we'll make a socket right so the first thing is the kind of socket well ok where do i get that from i get that from the result and you'll see i've made a note of the different fields inside here and the first thing that socket is the domain that is the actually the family that we need here so the socket family ok and then it's the socket type ok so that's ai_type ok and that's the last thing is the protocol which usually is just zero for some kinds of families that could be different kinds of protocols but so we need to get loops socket here there we go result and then	type	470
ok that's fix the indenting here right ok so let's have a socket file descriptor this is how we're going to talk to the server so we'll make a socket right so the first thing is the kind of socket well ok where do i get that from i get that from the result and you'll see i've made a note of the different fields inside here and the first thing that socket is the domain that is the actually the family that we need here so the socket family ok and then it's the socket type ok so that's ai_type ok and that's the last thing is the protocol which usually is just zero for some kinds of families that could be different kinds of protocols but so we need to get loops socket here there we go result and then	the protocol	528
right so the parameters for connect is first of all is the socket file descriptor ok so we've got that	parameter	13
but then we need to pass in a pointer to a struct now all styles coding for networks would have is actually assembled and create this struct for ourselves directly	a struct	41
but then we need to pass in a pointer to a struct now all styles coding for networks would have is actually assembled and create this struct for ourselves directly	pointer	30
so in theory that's why you actually only need the socket in the connect calls but we've been lazy today we've been using this swiss army knife called getaddressinfo that actually set this set this up for us so we need to pass in two things one is a pointer to this struct and secondly how big	address	154
so in theory that's why you actually only need the socket in the connect calls but we've been lazy today we've been using this swiss army knife called getaddressinfo that actually set this set this up for us so we need to pass in two things one is a pointer to this struct and secondly how big	pointer	250
this struct actually is ok so that's down here that's our address and address length let's grab those from the getaddressinfo result ok so we've got result	address	58
address and result address length ok as usual let's check that connect actually worked	address	0
ok so first of all let's just see if this actually can connect to illinois dot edu alright let's see if there really is a web server listening on port eighty on this address i think it's time to compile this so let's clear this i want to make my text a bit larger	address	166
ok so will do well let's use clang and off we go ok what do i got i didn't get the socket right because i need a type	type	113
oh did i just get a type of one here oh it's socket type not just type ok so there's that	type	20
want to write this to my output on my terminal actually want to write to socket fd k so i could have a message right so hash define a little message ok my message can be say blarghbalrblr all along right ok let's send that so here's the address of that message and here's how long it is so strlen of message ok we don't care about zero time and i was going to send it random characters ok so wr'll send that and should we see if it sends us anything back sure ok so for that will have a buffer say thousand twenty four bytes let's see what it says so i'd like to read from	address	237
let's see so i need to type	type	23
well we're not we're just assuming that my whole message get sent in one go right so let's compile this and run it ok is connected oh it didn't it didn't send us anything back ok it's still listening is still waiting for us to send more bytes fine we can do that let's send it my little message but this time actually terminate it with a slash slash r slash n and another one ok so i'm sending this because i know that this is part of the http protocol and this little sequence of four bytes four octets mean that my request has finished so off we go let's send it and it's sent something back to us who ok so first of all we've we see a lot of things we can we can see the current date we can see that the server claims it's an apache server so if i was a hacker i could type apache two point two point one five in and look for vulnerabilities associated with this	type	772
it's telling me that it's sending two hundred and twenty six bytes and it's closing the connection as well it's also telling me that is the character set it's using and this is what we get for two hundred and twenty eight bytes we get a response code of four hundred in fact sorry that's their responses back there at the very top four hundred bad request the rest of it is just a nice documented formatted version that we can display inside of web browser so your browser sent a request that this server could not understand ok so the status code is four hundred and	code	246
it didn't like our arbitrary request let's send something which is actually closer to a real http request ok let's change this message now to something which is a lot more reasonable let's say that i want to get the following resource and i'm speaking a certain variant of http so http one point oh and this time i'm going to say that i know that different hosts could be living on this ip address i want you to behave as if you are illinois dot edu ok and then lastly we know that a line has to be followed by a blank line in order for this request to be finished ok so that's a full request now i'm behaving a lot more like a reasonable http client	the following	212
it didn't like our arbitrary request let's send something which is actually closer to a real http request ok let's change this message now to something which is a lot more reasonable let's say that i want to get the following resource and i'm speaking a certain variant of http so http one point oh and this time i'm going to say that i know that different hosts could be living on this ip address i want you to behave as if you are illinois dot edu ok and then lastly we know that a line has to be followed by a blank line in order for this request to be finished ok so that's a full request now i'm behaving a lot more like a reasonable http client	address	390
ok so will send all that so all we have to do is recompile our web browser right so that's easy we compile it is in klang and run it an were here then we get a different response now we get a status code of three oh one moved permanently ok meaning that the resources that we want will never be available on the current request instead you'll see that it's saying that illinois now supports encrypted communications encrypted version of http and if you want to see this web page you should open a new connection on https which would be a different port now our little web client today does not support encryption yet so we're not actually going to implement that instead let's actually connect to a different server let's connect to say my local machine on a local port so how can i do that right so let's go back back here	code	199
ok so will send all that so all we have to do is recompile our web browser right so that's easy we compile it is in klang and run it an were here then we get a different response now we get a status code of three oh one moved permanently ok meaning that the resources that we want will never be available on the current request instead you'll see that it's saying that illinois now supports encrypted communications encrypted version of http and if you want to see this web page you should open a new connection on https which would be a different port now our little web client today does not support encryption yet so we're not actually going to implement that instead let's actually connect to a different server let's connect to say my local machine on a local port so how can i do that right so let's go back back here	resources	258
if i want to connect to my local machine then all i need to do is comment out this different line and uncomment this one there we go we're now connecting into a different machine and notice as usual that i'm using quotes double quotes here to talk about a string but i'm going to make a little mistake here i'm going to say that i forgotten that port numbers need to be quoted as well so now will connect will try to connect to this and see what happens ok so let's run clang and yes we get a warning but if we run it you'll see we get a segmentation for why because it tried to read a string to address eight thousand and of course that's not going to work so let's fix our code there we go so now i'm connecting to port eight thousand	code	675
if i want to connect to my local machine then all i need to do is comment out this different line and uncomment this one there we go we're now connecting into a different machine and notice as usual that i'm using quotes double quotes here to talk about a string but i'm going to make a little mistake here i'm going to say that i forgotten that port numbers need to be quoted as well so now will connect will try to connect to this and see what happens ok so let's run clang and yes we get a warning but if we run it you'll see we get a segmentation for why because it tried to read a string to address eight thousand and of course that's not going to work so let's fix our code there we go so now i'm connecting to port eight thousand	string	256
if i want to connect to my local machine then all i need to do is comment out this different line and uncomment this one there we go we're now connecting into a different machine and notice as usual that i'm using quotes double quotes here to talk about a string but i'm going to make a little mistake here i'm going to say that i forgotten that port numbers need to be quoted as well so now will connect will try to connect to this and see what happens ok so let's run clang and yes we get a warning but if we run it you'll see we get a segmentation for why because it tried to read a string to address eight thousand and of course that's not going to work so let's fix our code there we go so now i'm connecting to port eight thousand	address	596
ok right so here we go let's you start to look at two things first of all the time of when my c code was modified and the time of the executable that i'm trying to create so in other words i'm trying to make make be very lazy i don't want to actually compile my program if the executable is already up to date on the other hand if it's not up to date then i i do want to call my compiler so here it is i'm going to call gc but i could also call c lang or some other compiler	code	96
and i'm going to be a little bit lazy at myself that this system called here is roughly equivalent to calling fork exacting some shell like there is actually very simple shell called sh asking shelter run the following command and then waiting for that shell command to finish so so that's going to cross platform way to invoke external commands great so it does all that call me but you of course you know about this sequence of how to do this on a posix environment using fork except wait and using focus at weight allows you to do more interesting things like piping to scan and input or capturing their standard output using a pipe right so so this is where we want to end up with hopefully we can be lazy and actually not have to do anything otherwise we're going to want to compile it	the following	205
and i'm going to be a little bit lazy at myself that this system called here is roughly equivalent to calling fork exacting some shell like there is actually very simple shell called sh asking shelter run the following command and then waiting for that shell command to finish so so that's going to cross platform way to invoke external commands great so it does all that call me but you of course you know about this sequence of how to do this on a posix environment using fork except wait and using focus at weight allows you to do more interesting things like piping to scan and input or capturing their standard output using a pipe right so so this is where we want to end up with hopefully we can be lazy and actually not have to do anything otherwise we're going to want to compile it	system	58
right so i should have some code i can write k let's go to my mic	code	28
will compile down here by calling system make a little bit larger right so system hey system please call say gcc look for on the path something called gcc and you can compile program will see right so what's my reasons for when should i compile well i better check the timing of these and we're going to pass it in is the time entry and i care about the modification time so i'll be s t on the school end time for both the source and the target k	system	34
ok sir let's compile it and let me go and then let's just run it so you'll see it it's printed out its ip address and we know it's listening on port one two three four ok so let's try connecting to that ok so i need a web browser here so i need to go to http key and actually i don't want regular port eighty on a listener port one two three four	address	106
let's see who they also this is all of the information that is included in that header not just the actual request but something about the client as well what they accept where they came from and they're happy to keep the connection alive in this case we don't keep the connection alive in order for them to get additional resources we actually remember always close the connection so in fact	resources	323
this is actually kind of knew connections each time for every resource so we'll talk about how we can improve that in a future lecture but for now who are we've made ourselves a very very simple web server and it only took like a hundred lines of code if that actually going to serve the internet and server picture ok so let's get outta here let's just see how long it was right we can say give me a word count	code	247
hi ok so i got a little bit of a challenge for you here let's go back in time and say well how would you actually implement a valid mutex lock remember these things are critical to implement our critical sections where we can only have one thread manipulating data structure or some resources at the time ok so what do you think about the following attempt right so this suppose we were	the following	335
hi ok so i got a little bit of a challenge for you here let's go back in time and say well how would you actually implement a valid mutex lock remember these things are critical to implement our critical sections where we can only have one thread manipulating data structure or some resources at the time ok so what do you think about the following attempt right so this suppose we were	a struct	263
hi ok so i got a little bit of a challenge for you here let's go back in time and say well how would you actually implement a valid mutex lock remember these things are critical to implement our critical sections where we can only have one thread manipulating data structure or some resources at the time ok so what do you think about the following attempt right so this suppose we were	section	204
hi ok so i got a little bit of a challenge for you here let's go back in time and say well how would you actually implement a valid mutex lock remember these things are critical to implement our critical sections where we can only have one thread manipulating data structure or some resources at the time ok so what do you think about the following attempt right so this suppose we were	thread	240
hi ok so i got a little bit of a challenge for you here let's go back in time and say well how would you actually implement a valid mutex lock remember these things are critical to implement our critical sections where we can only have one thread manipulating data structure or some resources at the time ok so what do you think about the following attempt right so this suppose we were	resources	283
trying to actually implement the mutex lock ourselves here's our idea don't tell anybody but actually are mutex is actually just a simple integer pointer ok and so initializing it is easy will just set it to zero	pointer	146
and then for my lock method here's what i'm going to do i'm going to check to see if the current value of my integer so i'm going to do reference that pointer is equal to one if it is then just sleep for a short period so	pointer	151
peace would yield says ok thanks for the cpu it was great but i don't need it for short period type please give it to another needy thread and let me run again in a few milliseconds time so we'll keep just keep checking this and the only purpose of the p thread yield is the idea that there's no point just checking this in a very very tight loop that would burn a lot of cpu time more unnecessary energy so slow it down	type	95
peace would yield says ok thanks for the cpu it was great but i don't need it for short period type please give it to another needy thread and let me run again in a few milliseconds time so we'll keep just keep checking this and the only purpose of the p thread yield is the idea that there's no point just checking this in a very very tight loop that would burn a lot of cpu time more unnecessary energy so slow it down	thread	132
ok right so think about that while we also think about what should i do for unlock well unlocking is easy i'm the only thread which actually has acquired mutex locks so	thread	119
i'm going to just reset it back to zero there's no need to wait for any other thread right so it's not a good implementation	thread	78
ok so what we have course is a race condition you could imagine two threads call p for mutex look at exactly the same time	thread	68
ok so the problem is that now i could have two threads actually now enter the critical section what we wanted to do is make sure one of those threads actually blocked and so our problem with this naive implementation is that there is a moment in time between when we tested value and we set the value ideally what we wanted was	block	159
ok so the problem is that now i could have two threads actually now enter the critical section what we wanted to do is make sure one of those threads actually blocked and so our problem with this naive implementation is that there is a moment in time between when we tested value and we set the value ideally what we wanted was	section	87
ok so the problem is that now i could have two threads actually now enter the critical section what we wanted to do is make sure one of those threads actually blocked and so our problem with this naive implementation is that there is a moment in time between when we tested value and we set the value ideally what we wanted was	thread	47
those two things to actually occur at the same time and to ensure that if one if we meant to set the value then another thread it another threads reading of of of of mutex occurs after that moment ok so we managed to get in there change check it and change the value as one operation so this implementation that we've written is not adequate how we're going to fix it easy using mutex look wait can't do that we're actually trying to implement a mutex lock ok so how can we fix this alright so	a mutex	444
those two things to actually occur at the same time and to ensure that if one if we meant to set the value then another thread it another threads reading of of of of mutex occurs after that moment ok so we managed to get in there change check it and change the value as one operation so this implementation that we've written is not adequate how we're going to fix it easy using mutex look wait can't do that we're actually trying to implement a mutex lock ok so how can we fix this alright so	thread	120
ok is that if we're running on a very simple system we have just a single cpu	system	45
right so if i had very very very simple system	system	40
then my code can't be interrupted	code	8
because the only way that my code can be interrupted is if i if i allow the kernel to interrupt what i'm currently doing so if i did turn off interrupts there can be kind of no opportunity for my kernel to the operating system to stop my code from running the cpu becomes very blindsided to anything else going on because it cannot be interrupted ok so of course for real systems this is hardly a practical solution anymore because one with we have more than one cpu and so actually other code can be running concurrently different cpu and secondly we don't we're not given permission to disable interrupts things start breaking when you disable interrupts for a long time we no longer getting events from the keyboard from the network etc and these devices need to give their data they only have a limited buffer so we need to service these interrupts when they occur so this is not a practical solution on	code	29
because the only way that my code can be interrupted is if i if i allow the kernel to interrupt what i'm currently doing so if i did turn off interrupts there can be kind of no opportunity for my kernel to the operating system to stop my code from running the cpu becomes very blindsided to anything else going on because it cannot be interrupted ok so of course for real systems this is hardly a practical solution anymore because one with we have more than one cpu and so actually other code can be running concurrently different cpu and secondly we don't we're not given permission to disable interrupts things start breaking when you disable interrupts for a long time we no longer getting events from the keyboard from the network etc and these devices need to give their data they only have a limited buffer so we need to service these interrupts when they occur so this is not a practical solution on	system	220
more large modern systems but it is a reasonable idea if say you're implementing your own kernel on a very simple cpu alright so we need to do better than that	system	18
and so in the next next video i'll talk about exchange ok bye	exchange	46
ok so let's talk about a very well known problem called the dining philosophers this is classic computer science stuff every good computer scientists should know about this i'm going to look at this in terms of some simple ideas about how we can solve it or not and then we'll look at some internet code that attempts to solve it when i'm not going to do is talk about some of the proposed solutions eg like stalling solutions and others that you can find say or wikipedia in through google so instead i want to give you enough information that you two could try to implement your own solution ok so here's the classic idea let's see let's invite five philosophers to your house and serve them food classically this was done with that ok will say a bowl of pasta or something and just annoy them that we can imagine we've given them chopsticks or forks either side and before philosopher can get to eat they need to actually reach out and grab the chopsticks or forks which are either side of them so here's immanuel kant and before he gets to eat his bowl of spaghetti right he needs to grab this drop stick to the left and this job stick to that right ok now philosophers don't eat all the time in fact eating represents a critical section where before it can do that it's going to need to acquire these t mutex locks but for the rest of the time it's sleeping ok so there philosophising right dozing in the chair ok but occasionally they wake up realize that they are hungry and eat some more and then go back to sleep so you'll notice that life would be easy if we actually set the table such that each philosopher had their own cutlery but we didn't do that instead each philosophers forced to share the country with their neighbor right so	code	299
ok so let's talk about a very well known problem called the dining philosophers this is classic computer science stuff every good computer scientists should know about this i'm going to look at this in terms of some simple ideas about how we can solve it or not and then we'll look at some internet code that attempts to solve it when i'm not going to do is talk about some of the proposed solutions eg like stalling solutions and others that you can find say or wikipedia in through google so instead i want to give you enough information that you two could try to implement your own solution ok so here's the classic idea let's see let's invite five philosophers to your house and serve them food classically this was done with that ok will say a bowl of pasta or something and just annoy them that we can imagine we've given them chopsticks or forks either side and before philosopher can get to eat they need to actually reach out and grab the chopsticks or forks which are either side of them so here's immanuel kant and before he gets to eat his bowl of spaghetti right he needs to grab this drop stick to the left and this job stick to that right ok now philosophers don't eat all the time in fact eating represents a critical section where before it can do that it's going to need to acquire these t mutex locks but for the rest of the time it's sleeping ok so there philosophising right dozing in the chair ok but occasionally they wake up realize that they are hungry and eat some more and then go back to sleep so you'll notice that life would be easy if we actually set the table such that each philosopher had their own cutlery but we didn't do that instead each philosophers forced to share the country with their neighbor right so	section	1234
then you can eat in other words you can access your yield critical data structures there so new critical section and then of course release both chopsticks	a struct	70
then you can eat in other words you can access your yield critical data structures there so new critical section and then of course release both chopsticks	section	105
so obviously not we can now imagine unfortunate scenario made up of a likely but it is theoretically possible that all philosophers pick up the chopstick on there right first and then they're stuck there unable to continue so both of these suffer from deadlock so these are not solutions to the dining philosophers problem right so in practice of course we don't write code that manage is philosophers eating spaghetti or whatever with chopsticks but it does illuminate how different socalled solutions behave and we can measure their ability to actually allow our processes to run efficiently or how much weight time they end up because they are unable to proceed and also what kind of over they had so for example here's another one we could say look i took cs two forty one i understand deadlock and i'm only let you eat when i tell you so with this so called solution yeah we've we can ensure that deadlock is impossible perhaps for example we're going to implement some of the bankers algorithm we're going to visually look to make sure that we never get into that process state where all of them are holding a left hand shots equal right hampshire stick so we can avoid this but we haven't really specified a full algorithm for this we just simply delegated the problem to some manager that stands in front of the table is in las i'm missing able to see everything for example and so this also has additional overhead here that we've now got to implement some management to keep track of the global state of the problem	code	369
so obviously not we can now imagine unfortunate scenario made up of a likely but it is theoretically possible that all philosophers pick up the chopstick on there right first and then they're stuck there unable to continue so both of these suffer from deadlock so these are not solutions to the dining philosophers problem right so in practice of course we don't write code that manage is philosophers eating spaghetti or whatever with chopsticks but it does illuminate how different socalled solutions behave and we can measure their ability to actually allow our processes to run efficiently or how much weight time they end up because they are unable to proceed and also what kind of over they had so for example here's another one we could say look i took cs two forty one i understand deadlock and i'm only let you eat when i tell you so with this so called solution yeah we've we can ensure that deadlock is impossible perhaps for example we're going to implement some of the bankers algorithm we're going to visually look to make sure that we never get into that process state where all of them are holding a left hand shots equal right hampshire stick so we can avoid this but we haven't really specified a full algorithm for this we just simply delegated the problem to some manager that stands in front of the table is in las i'm missing able to see everything for example and so this also has additional overhead here that we've now got to implement some management to keep track of the global state of the problem	the dining philosophers problem	291
ok so let's look at and instead another local solution where we've got the following instructions were going to give to each philosopher we're going to say ok pick up your left chopstick then try to pick up the right chopstick if that doesn't work then just put everything down so put value of both chopsticks and then try again so look menacingly at their chopstick at the philosopher to your left or right then when they finally put it down pick quickly try to pick my both up again ok so then go back to the beginning all right and then of course eaten after finished release both ok so we have to think about this one well in this one we have broken holden wait that coffman condition no longer applies so we can immediately conclude	the following	71
but at least from a theoretical point of view we've prevented deadlock alright so in one of the lab sections were going to ask you to work on a very similar problem to dining philosophers where in order for	section	100
a an assignment to it to work we actually need to send to programmers i believe to do say some pair programming so again a similar idea that you need to acquire two resources in order to continue so will be up to you to experiment and to try some different implementations of this but there's dining philosophers very classic classic system programming problem and with lots of interesting solutions if you are interested in this stuff i encourage you to go and research some kind of classic solutions to this problem	resources	165
a an assignment to it to work we actually need to send to programmers i believe to do say some pair programming so again a similar idea that you need to acquire two resources in order to continue so will be up to you to experiment and to try some different implementations of this but there's dining philosophers very classic classic system programming problem and with lots of interesting solutions if you are interested in this stuff i encourage you to go and research some kind of classic solutions to this problem	system	334
but in my next video i'm going to look at some attempt to actually solve this using some c code ok i'll see you then bye	code	91
ok right so let's talk about what what is a mutex mutex is the key thing that we need in order to implement critical sections if you think about our code from moment where our critics sections are basically	code	149
ok right so let's talk about what what is a mutex mutex is the key thing that we need in order to implement critical sections if you think about our code from moment where our critics sections are basically	a mutex	42
ok right so let's talk about what what is a mutex mutex is the key thing that we need in order to implement critical sections if you think about our code from moment where our critics sections are basically	section	117
where we want to do surgery on a data structure that moment we only want one surgeon in the room most of the time my thread can be busy say working on the sound another one could be working on the ui another one	a struct	36
where we want to do surgery on a data structure that moment we only want one surgeon in the room most of the time my thread can be busy say working on the sound another one could be working on the ui another one	thread	117
but at some point they need to come together and say send messages over data bus or some other kind of event structure so when they manipulate that structure only one of them should be changing at a time ok so that we've identified a critical section and now we need to make sure that if one thread is currently doing that then other threads get temporarily blocked put on pause if you like whilst we are in that critical piece of code and the key to doing that then is this	block	358
but at some point they need to come together and say send messages over data bus or some other kind of event structure so when they manipulate that structure only one of them should be changing at a time ok so that we've identified a critical section and now we need to make sure that if one thread is currently doing that then other threads get temporarily blocked put on pause if you like whilst we are in that critical piece of code and the key to doing that then is this	code	431
but at some point they need to come together and say send messages over data bus or some other kind of event structure so when they manipulate that structure only one of them should be changing at a time ok so that we've identified a critical section and now we need to make sure that if one thread is currently doing that then other threads get temporarily blocked put on pause if you like whilst we are in that critical piece of code and the key to doing that then is this	section	243
but at some point they need to come together and say send messages over data bus or some other kind of event structure so when they manipulate that structure only one of them should be changing at a time ok so that we've identified a critical section and now we need to make sure that if one thread is currently doing that then other threads get temporarily blocked put on pause if you like whilst we are in that critical piece of code and the key to doing that then is this	thread	292
and a mutex is actually go back there right actually a shortening of do i have i want to be able to type we try some letters here ok there we go right ashley short for	type	100
and a mutex is actually go back there right actually a shortening of do i have i want to be able to type we try some letters here ok there we go right ashley short for	a mutex	4
so the pieces sort of peaceful so we've got we've seen p thread so far now that if you look at what posix gives us for mutexes ok i'll see you in the next video	thread	57
hi so let's look at complete solution of my implementation of get line first a couple things to point out is you know we can actually check to see if the point is we're being given a valid we expect all of these pointers to actually point to be non null so let's use assert to check that each of these values is a non zero ok so our next piece of code was to check to see if we don't actually have a valid piece of heap memory to use so i'm going to follow the pointers were given because remember our point is actually pointing back	heap memory	415
hi so let's look at complete solution of my implementation of get line first a couple things to point out is you know we can actually check to see if the point is we're being given a valid we expect all of these pointers to actually point to be non null so let's use assert to check that each of these values is a non zero ok so our next piece of code was to check to see if we don't actually have a valid piece of heap memory to use so i'm going to follow the pointers were given because remember our point is actually pointing back	memory	420
hi so let's look at complete solution of my implementation of get line first a couple things to point out is you know we can actually check to see if the point is we're being given a valid we expect all of these pointers to actually point to be non null so let's use assert to check that each of these values is a non zero ok so our next piece of code was to check to see if we don't actually have a valid piece of heap memory to use so i'm going to follow the pointers were given because remember our point is actually pointing back	code	347
hi so let's look at complete solution of my implementation of get line first a couple things to point out is you know we can actually check to see if the point is we're being given a valid we expect all of these pointers to actually point to be non null so let's use assert to check that each of these values is a non zero ok so our next piece of code was to check to see if we don't actually have a valid piece of heap memory to use so i'm going to follow the pointers were given because remember our point is actually pointing back	pointer	212
i like my code to be performance so rather extending my buffer just buy one or ten or twenty if i run out of space i'm actually going to double it in size ok so if so here we go let's dereference my capacity and double that value and now before i can continue i still have some partially read information inside my old buffer so i can't free it up just yet instead i need to copy it and rather than writing a little for loop there's a much faster way to copy memory and that's to use and mem copy and then copy is great provided the two region of memory you want to copy of form and two do not overlap if you actually want to work with overlapping memory you need to move use m move instead so we know that they're not going to overlap we're actually going to write to some new memory and so that's the code here is k times call malloc again with our updated capacity value now we're going to copy the line porter from the old area and the number of bytes we need to copy is not it's all size but the total number of bytes we've actually read from the input stream overly ok so this is our	memory	459
i like my code to be performance so rather extending my buffer just buy one or ten or twenty if i run out of space i'm actually going to double it in size ok so if so here we go let's dereference my capacity and double that value and now before i can continue i still have some partially read information inside my old buffer so i can't free it up just yet instead i need to copy it and rather than writing a little for loop there's a much faster way to copy memory and that's to use and mem copy and then copy is great provided the two region of memory you want to copy of form and two do not overlap if you actually want to work with overlapping memory you need to move use m move instead so we know that they're not going to overlap we're actually going to write to some new memory and so that's the code here is k times call malloc again with our updated capacity value now we're going to copy the line porter from the old area and the number of bytes we need to copy is not it's all size but the total number of bytes we've actually read from the input stream overly ok so this is our	code	10
otherwise we still watch you want to return a valid string we've got some	string	52
we've got some bites that we've read already let's turn it into a a valid c string so let's turn that like with a zero and return the last option is that we've just read a new line so we've put that new line into our return heap area and now let's make sure that we've terminated the string and return the number of bytes red form the c string from the stream so as you can see that's quite a gnarly little function to write so isn't it great that the c library be provides it for us	string	76
so let's have a look at the following and see if you can immediately see what is wrong with the following code and was it supposed to do all right so we've got	the following	24
so let's have a look at the following and see if you can immediately see what is wrong with the following code and was it supposed to do all right so we've got	code	106
ok so now actually twenty use getline and year to say oh look at that i'm using the correct type we got it to compile but what i should have done is actually my type here	type	92
is actually ok it was compiled with optical useful what we wanted is a variable here let's just call it line which is going to hold the address of the heap memory and rather than just passing into it that whatever value happened to be inside that variable we actually wanted to know the address of that variable so that's one mistake second mistake is that both these variables should be set to zero so we fix that so will store that	heap memory	151
is actually ok it was compiled with optical useful what we wanted is a variable here let's just call it line which is going to hold the address of the heap memory and rather than just passing into it that whatever value happened to be inside that variable we actually wanted to know the address of that variable so that's one mistake second mistake is that both these variables should be set to zero so we fix that so will store that	memory	156
is actually ok it was compiled with optical useful what we wanted is a variable here let's just call it line which is going to hold the address of the heap memory and rather than just passing into it that whatever value happened to be inside that variable we actually wanted to know the address of that variable so that's one mistake second mistake is that both these variables should be set to zero so we fix that so will store that	the heap	147
is actually ok it was compiled with optical useful what we wanted is a variable here let's just call it line which is going to hold the address of the heap memory and rather than just passing into it that whatever value happened to be inside that variable we actually wanted to know the address of that variable so that's one mistake second mistake is that both these variables should be set to zero so we fix that so will store that	address	136
that line now so now great line is points to to some input and will run it ok so i don't want to live with anymore let's just quit line let's try this ok so i want to get out of this and we'll see what our little program can do ok so i want this code	code	246
and i will call it let's see him it was exact it was get line and exec k and fix me right so what do we need we want uni standard dot h will come back to those in a moment and i got my main we said that we didn't want to character pointer here we just wanted a simple light pointer here	pointer	231
ok is zero right the next issue is whoops i'm updating size here no this code suffers from the idea that get lines just returning the capacity the buffer it's not is returning the number of bytes read from the stream which is different from the capacity the capacity should be larger right so i actually need a new type here and double s for signed size and let's give it a better name like bites red ok and will change that to the address of my variable came looking good and now we want to just call exec well that's not how use exec exec see we're using the lp version which means that it's going to look up on the path and it also means i have to terminate my arguments with a character pointer with value zero in other words another point right so what do you think about that is that any good what will it do ok let's try it ok	type	315
ok is zero right the next issue is whoops i'm updating size here no this code suffers from the idea that get lines just returning the capacity the buffer it's not is returning the number of bytes read from the stream which is different from the capacity the capacity should be larger right so i actually need a new type here and double s for signed size and let's give it a better name like bites red ok and will change that to the address of my variable came looking good and now we want to just call exec well that's not how use exec exec see we're using the lp version which means that it's going to look up on the path and it also means i have to terminate my arguments with a character pointer with value zero in other words another point right so what do you think about that is that any good what will it do ok let's try it ok	code	73
ok is zero right the next issue is whoops i'm updating size here no this code suffers from the idea that get lines just returning the capacity the buffer it's not is returning the number of bytes read from the stream which is different from the capacity the capacity should be larger right so i actually need a new type here and double s for signed size and let's give it a better name like bites red ok and will change that to the address of my variable came looking good and now we want to just call exec well that's not how use exec exec see we're using the lp version which means that it's going to look up on the path and it also means i have to terminate my arguments with a character pointer with value zero in other words another point right so what do you think about that is that any good what will it do ok let's try it ok	address	432
ok is zero right the next issue is whoops i'm updating size here no this code suffers from the idea that get lines just returning the capacity the buffer it's not is returning the number of bytes read from the stream which is different from the capacity the capacity should be larger right so i actually need a new type here and double s for signed size and let's give it a better name like bites red ok and will change that to the address of my variable came looking good and now we want to just call exec well that's not how use exec exec see we're using the lp version which means that it's going to look up on the path and it also means i have to terminate my arguments with a character pointer with value zero in other words another point right so what do you think about that is that any good what will it do ok let's try it ok	pointer	691
ok so how can we discover what's wrong are you ready let's run it and this time will type in	type	85
k i want this string and i'm going to give it my little line pointer there we go ok	string	14
k i want this string and i'm going to give it my little line pointer there we go ok	pointer	61
right and we know we type cat and it says we're about to run cat great but then it says exact failed now then	type	21
there's actually two errors in this code can you see what they are the first one hopefully alarm bells should is just gone off and said hold on a moment actually when you want to exact and change what this process is doing we need to specify the program named twice firstly fur the actual thing on the disk that we want to find secondly as the zero th argument to the process the main going to see it needs to program names so actually we should have used line twice firstly for the program to final disk secondly as the process name ok so if we do that will it work and the answer is no it does failed now then why was that	code	36
let's see if i put a quote here in a quote here i think this would have given it away what do you think let's try this now case so run it ok i'll type something in which would get line will get so i'll type cat and it says we have a better one	type	146
flush standard out to say please please please send everything else lady make sure you've got nothing inside your internal buffers make sure that you call right and everything goes ok so let's run it once more and will type cat and we see ok this time we run cat	type	219
but cat contains a newline yes are gotcha here was that get line is giving us back everything it's writing into memory c a t and a new line and there is no program called c a t with a new line we needed to strip that newline ok so let's do that right	memory	112
and let's see will that be the end almost actually minus one if there is equal to a new line then i know i should remove it ok well seasons where every moving something don't make a new string just put just truncate it by putting a zero in there so let's do that right hey line let's change bright reds at want to now be the null byte which is our market to say there's nothing else after this point key	string	186
so and if we did get a valid thing let's actually try to run it ok so now let's compile this have to go right and will type cat	type	119
we will never have a chance to say and what would you like to do next but this is the basis of bash this is the basis of making our our systems interactive so we actually start to type things in and make them work for us kind of in real time and do what we want to do while than always having to write and compile and run programs now i can actually have at the start of a command line and this is actually going to be the start of an assignment	type	180
we will never have a chance to say and what would you like to do next but this is the basis of bash this is the basis of making our our systems interactive so we actually start to type things in and make them work for us kind of in real time and do what we want to do while than always having to write and compile and run programs now i can actually have at the start of a command line and this is actually going to be the start of an assignment	system	136
hi ok so a couple quick questions for you so i can thread access heap memory i think the answer right now you should know is yes they can so we're actually passing in some heap memory in our our previous code right so we said ok let's start or run method and you can see it's got the right signature to be given to p thread create<br> create and we passed in pointer there it is initialized a stack variable which is going to be individual to each thread unique to each thread but what are we passing in here remember we're passing in that memory that we malloc'd on the main thread so if we went back to	heap memory	65
hi ok so a couple quick questions for you so i can thread access heap memory i think the answer right now you should know is yes they can so we're actually passing in some heap memory in our our previous code right so we said ok let's start or run method and you can see it's got the right signature to be given to p thread create<br> create and we passed in pointer there it is initialized a stack variable which is going to be individual to each thread unique to each thread but what are we passing in here remember we're passing in that memory that we malloc'd on the main thread so if we went back to	memory	70
hi ok so a couple quick questions for you so i can thread access heap memory i think the answer right now you should know is yes they can so we're actually passing in some heap memory in our our previous code right so we said ok let's start or run method and you can see it's got the right signature to be given to p thread create<br> create and we passed in pointer there it is initialized a stack variable which is going to be individual to each thread unique to each thread but what are we passing in here remember we're passing in that memory that we malloc'd on the main thread so if we went back to	code	204
hi ok so a couple quick questions for you so i can thread access heap memory i think the answer right now you should know is yes they can so we're actually passing in some heap memory in our our previous code right so we said ok let's start or run method and you can see it's got the right signature to be given to p thread create<br> create and we passed in pointer there it is initialized a stack variable which is going to be individual to each thread unique to each thread but what are we passing in here remember we're passing in that memory that we malloc'd on the main thread so if we went back to	thread	51
hi ok so a couple quick questions for you so i can thread access heap memory i think the answer right now you should know is yes they can so we're actually passing in some heap memory in our our previous code right so we said ok let's start or run method and you can see it's got the right signature to be given to p thread create<br> create and we passed in pointer there it is initialized a stack variable which is going to be individual to each thread unique to each thread but what are we passing in here remember we're passing in that memory that we malloc'd on the main thread so if we went back to	pointer	359
original code over here right we first of all we malloc'd<br> that memory and then later when we called our runners	memory	67
original code over here right we first of all we malloc'd<br> that memory and then later when we called our runners	code	9
we were passing in a pointer to that memory so yes of course they can access heap memory and you could even create that heap memory on a different thread there's nothing special about the main thread other than the fact that if it returns then we exit the whole process so keep it to be shared i could have written malloc inside a different a different function all the things that i could do is i my main thread i could also do inside the other threads we notice like i even did right here i could have done printf here as well	heap memory	77
we were passing in a pointer to that memory so yes of course they can access heap memory and you could even create that heap memory on a different thread there's nothing special about the main thread other than the fact that if it returns then we exit the whole process so keep it to be shared i could have written malloc inside a different a different function all the things that i could do is i my main thread i could also do inside the other threads we notice like i even did right here i could have done printf here as well	memory	37
we were passing in a pointer to that memory so yes of course they can access heap memory and you could even create that heap memory on a different thread there's nothing special about the main thread other than the fact that if it returns then we exit the whole process so keep it to be shared i could have written malloc inside a different a different function all the things that i could do is i my main thread i could also do inside the other threads we notice like i even did right here i could have done printf here as well	printf	509
we were passing in a pointer to that memory so yes of course they can access heap memory and you could even create that heap memory on a different thread there's nothing special about the main thread other than the fact that if it returns then we exit the whole process so keep it to be shared i could have written malloc inside a different a different function all the things that i could do is i my main thread i could also do inside the other threads we notice like i even did right here i could have done printf here as well	thread	147
we were passing in a pointer to that memory so yes of course they can access heap memory and you could even create that heap memory on a different thread there's nothing special about the main thread other than the fact that if it returns then we exit the whole process so keep it to be shared i could have written malloc inside a different a different function all the things that i could do is i my main thread i could also do inside the other threads we notice like i even did right here i could have done printf here as well	pointer	21
so anything that you can do normally through many trades you can do with the other threads a quick comment here however is that many applications with a user interface put all of their ui code into a single thread required if you kind of modify the data structure that represents the ui interface you do it inside one thread so android does this qt and other frameworks do this the reason is for performance that if we kept on having to lock that data structure last potentially other threads would modify it then are you i would actually have worse performance so if you want to update the ui from a different thread you end up creating a message which you then have to synchronize and send to the user interaction thread took to process	the data structure	245
so anything that you can do normally through many trades you can do with the other threads a quick comment here however is that many applications with a user interface put all of their ui code into a single thread required if you kind of modify the data structure that represents the ui interface you do it inside one thread so android does this qt and other frameworks do this the reason is for performance that if we kept on having to lock that data structure last potentially other threads would modify it then are you i would actually have worse performance so if you want to update the ui from a different thread you end up creating a message which you then have to synchronize and send to the user interaction thread took to process	a struct	252
so anything that you can do normally through many trades you can do with the other threads a quick comment here however is that many applications with a user interface put all of their ui code into a single thread required if you kind of modify the data structure that represents the ui interface you do it inside one thread so android does this qt and other frameworks do this the reason is for performance that if we kept on having to lock that data structure last potentially other threads would modify it then are you i would actually have worse performance so if you want to update the ui from a different thread you end up creating a message which you then have to synchronize and send to the user interaction thread took to process	code	188
so anything that you can do normally through many trades you can do with the other threads a quick comment here however is that many applications with a user interface put all of their ui code into a single thread required if you kind of modify the data structure that represents the ui interface you do it inside one thread so android does this qt and other frameworks do this the reason is for performance that if we kept on having to lock that data structure last potentially other threads would modify it then are you i would actually have worse performance so if you want to update the ui from a different thread you end up creating a message which you then have to synchronize and send to the user interaction thread took to process	thread	83
ok so we talked about this yeah that one thread can call malik and another thread can call free that's fine just remember to pass in minus p thread when you compile it to make sure that the compiler knows you're using threads	thread	41
right and let's talk about static variables and where do they live so do static variables live on the heap course the answer is no well do they live on the stack no ok so static variables are special you can think of them as basically global variables they live for the lifetime of the program so they where you declare them changes the scope meaning whether you can actually use their name or not so let's have a quick play with this let's let's go and modify our matrix code here suppose k i want to go back to ok there we go so suppose we made a variable static here so let's make the	the heap	98
right and let's talk about static variables and where do they live so do static variables live on the heap course the answer is no well do they live on the stack no ok so static variables are special you can think of them as basically global variables they live for the lifetime of the program so they where you declare them changes the scope meaning whether you can actually use their name or not so let's have a quick play with this let's let's go and modify our matrix code here suppose k i want to go back to ok there we go so suppose we made a variable static here so let's make the	code	472
the character see a static variable so between you and me i can tell you that static means that this only going to exist once that were going when our program is loaded and becomes a process some memory will be set aside for that variable now i've declared it inside the function but actually that would be just as equivalent to declaring it outside the function with one exception so if i	memory	196
the character see a static variable so between you and me i can tell you that static means that this only going to exist once that were going when our program is loaded and becomes a process some memory will be set aside for that variable now i've declared it inside the function but actually that would be just as equivalent to declaring it outside the function with one exception so if i	a process	181
put before it as i could have kind of global out here then you could tell me that this variable see can't be bound can be seen by any other compilation units so another compilation it could have another variable would see and that would still compile fight so we've limited the scope to this whole combination unit but i didn't write it there i put it inside a function which means that the c the actual letter see the actual symbol c is only bound to that specific piece of memory when we inside this function anyway so i've i've declared this variable static here let me go back to the original code now and you can tell me what it's going to do case so here we go right got my static variable here and off we go so late clear this make this is not a compile time constant yeah yeah ok so i'll change it to that	memory	475
put before it as i could have kind of global out here then you could tell me that this variable see can't be bound can be seen by any other compilation units so another compilation it could have another variable would see and that would still compile fight so we've limited the scope to this whole combination unit but i didn't write it there i put it inside a function which means that the c the actual letter see the actual symbol c is only bound to that specific piece of memory when we inside this function anyway so i've i've declared this variable static here let me go back to the original code now and you can tell me what it's going to do case so here we go right got my static variable here and off we go so late clear this make this is not a compile time constant yeah yeah ok so i'll change it to that	code	597
between between function calls so for example if i had a ticket to ticket provider like a little ticket system let's make it and then with static variables i can do something like the following i can say have little counter here and then i can say return plus plus counter	the following	180
between between function calls so for example if i had a ticket to ticket provider like a little ticket system let's make it and then with static variables i can do something like the following i can say have little counter here and then i can say return plus plus counter	system	104
and so this count available because it's static will remember its value from one quart of next so the first time i call ticket i would get the value on the second time i called ticket i would get the value two three four and so on and so on and so on so static variables have their place but realize and remember that there's only one of them and they do not live on the stack and they do not live on the heap ok with that i will see you in the next video bye	the heap	401
ok so let's talk start talking about how we can store items on a disk and in particular how we might actually represent the data what features we might want in our file system so we're going to start by just a bit of a brainstorming exercise by saying if money was no object if i can get you the best software engineers	system	169
what features would you like to add to your file system so let's not try to be too constrained by the limitations of the file system on your laptop or what you've seen in virtual machine so far this act you think about what we need ok so this is kind of real let's start with the white board and will start to write down some features ok so what would make a great file system right so let's come up with a few ideas and then all kind of see how well we did and compare it to some other kind of brainstorm exercises i've done in the past right so what would you like first well maybe you want some access control right so we want the idea that look many people are going to be using this file system and perhaps i want to make sure that some people can't read all of my files or perhaps i want to make sure that some files are only read only or perhaps i want to make sure that only a limited set of files should be executed so if you give me a a file i can't just easily turn that turn around and say ok bash run this or ok cpu load this as a program	system	49
so i want to define some sort of security about our mike files maybe we want to write a file system created file system that even tracks who is accessing the	system	93
files so maybe the sort of auditing and logging auditing and logging perhaps if i'm going to get my file system to the nsa i want to know which analysts have opened which files so perhaps i've got some kind of logging i want to keep track of the number of files have been created each week probably want to keep track of the latest files so there's some meta information that we want as well so we've got things like when was the last file access when with file opened and who by how large is a file in terms of bytes or other information	system	105
it recorded so we might want to have more than just lump sum bites if we care about multiple versions perhaps off our system should innately support that so for example if you overate a file	system	118
perhaps your system 's been compromised and it's trying to lock up all of your files in order for you to pay some bit going to get them unlocked it would be nice if my file system rather than just delete the old version actually kept a prior versions around so i could go back in time and pull out the previous version all version before that so maybe we want some versioning as well ok	system	13
now on a typical file system it's not unusual for the same piece of data to be found in multiple places there's certainly going to be true of course with versioning but you and i might have a same copy over text file same copy of a c file so if i shared some music with you for example or video file and we're storing it on the same disk it seems a bit of a waste of space to actually store those bites multiple times on the disk surface so perhaps we want our file system to support deduplication	system	22
case so we like our file systems to be nice and fast	system	25
and of course we want to do this we use in the minimum over cpu time because i want to use my cpu for other things so what else might we need here right k so if i'm storing say text information that text could easily be compressed so maybe my file system should support compression as well so for some files for example suppose i'm storing all of the linux kernel	system	248
that's just a lot of c code and i could store that in a very much more space on my disk and if i can decompress it quickly i might even be able to load these files in and use on the fly decompression and actually get better performance from my file system so we want compression potential potentially for performance if i can decompose quickly but also of course i want to maximize the amount of things i can store on my file system	code	23
that's just a lot of c code and i could store that in a very much more space on my disk and if i can decompress it quickly i might even be able to load these files in and use on the fly decompression and actually get better performance from my file system so we want compression potential potentially for performance if i can decompose quickly but also of course i want to maximize the amount of things i can store on my file system	system	249
right what else ok so we could go through and keep talking about kind of more features like this but i want to remind you that so far we've been thinking very much like software engineers we've forgotten that real filesystems live on real devices and so	system	218
a big thing that we've missed out here i have not thought about is that we want our file system to be robust so perhaps there's going to be an error on the disk surface because the bit was never written correctly perhaps	system	89
stray cosmic ray 's modified one bit inside my ssd it would be unfortunate if my file system suddenly made all of my files unreadable just because one bit was flipped simile if i dropped my hard disk my physical spinning hard disk i'd like to think there's a fair chance that haven't suddenly lost all of my files so there's robustness in terms of what damage and how likely is it that i'm unable to recover anything there's also	system	86
inefficient and quite timely it takes a long period of time if i want to scan through all of my files to see which ones have changed which ones have been created it would be great if my file system could actually tell me which files have been created or modified since the last backup so we need some features to support that how are we going to do that right i kind of want to mention that one fun thing about all these features is that they are not required of course with all applications but they also are difficult to implement together for example compression may or may not hurt performance deduplication requires ability to scan files and may take additional cpu time additional memory and so may actually actually affect negatively the performance of your whole system	memory	687
inefficient and quite timely it takes a long period of time if i want to scan through all of my files to see which ones have changed which ones have been created it would be great if my file system could actually tell me which files have been created or modified since the last backup so we need some features to support that how are we going to do that right i kind of want to mention that one fun thing about all these features is that they are not required of course with all applications but they also are difficult to implement together for example compression may or may not hurt performance deduplication requires ability to scan files and may take additional cpu time additional memory and so may actually actually affect negatively the performance of your whole system	system	191
ok it's it's writing it's kind of sympathetic with the kind of hardware constraints and features so for example if i'm waiting on a spinning disc there's actual physical constraints about how quickly that can spin how often a particular sector is actually readable if i'm writing to an ssd then portions of that electrical system can only be written a number of times before it starts to become likely that i won't be able to correctly read that bit again in the future so i wanted to make sure that how i represent my files on my disk how implement these features and how i talk to the hardware respects the kind of natural physical constraints and features of the hardware that is used underneath ok so we came up with a kind of a good list not bad for a quick brainstorming session let's have another look at novel list i made see how close we got so what did we what did we miss so here's his another kind of incomplete	system	323
kind of dust on his disc surface but things like what happens if a prior to my disk i didn't complete maybe because there was a power los how likely is it that i'm able to detect that or recover from that in some way or have i just lost the entire disk have i just lost all of my files or in the future what i read back of file and not even realize it's incorrect here's some other features we didn't think about is accounting and quota ideas so do i want to allow anyone user just completely fill up the storage system or do i want to be able to limit the number of files on the amount of disk space that they're writing too	system	513
we didn't talk about indexing and searching so if tomorrow i want to find all files by a particular artist or if i want to be able to kind of find the moment in a video file that though the word camel was spoken then perhaps my file system should support that in interesting ways	system	233
ok right so that was a pretty good listen i hope you get to see why actually implementing a file system is hard and many file systems today are surprisingly old it's actually some of the oldest code you'll find inside the kernel why because writing code without bugs to satisfy all of these kind of design ideas and design goals is really really really hard and this is one area of the system where we do not want bugs we do not want our file system to suddenly start misbehaving when their disk becomes full for example we want all file system to work with all sorts of edge cases for example when a particular sector on a disk goes bad or if we want to start a shufflings information around in our disk for better performance in the future these little use cases are all tricky and take a long time to kind of get right both in terms of correctness and performance on our expectations of this part of the of this part of the kernel working robustly again and again and again even if we're writing large numbers of lights at ten to twelve or greater number of bytes is very very high so we tend to find that this code is extremely old and mature and extremely well tested	code	194
ok right so that was a pretty good listen i hope you get to see why actually implementing a file system is hard and many file systems today are surprisingly old it's actually some of the oldest code you'll find inside the kernel why because writing code without bugs to satisfy all of these kind of design ideas and design goals is really really really hard and this is one area of the system where we do not want bugs we do not want our file system to suddenly start misbehaving when their disk becomes full for example we want all file system to work with all sorts of edge cases for example when a particular sector on a disk goes bad or if we want to start a shufflings information around in our disk for better performance in the future these little use cases are all tricky and take a long time to kind of get right both in terms of correctness and performance on our expectations of this part of the of this part of the kernel working robustly again and again and again even if we're writing large numbers of lights at ten to twelve or greater number of bytes is very very high so we tend to find that this code is extremely old and mature and extremely well tested	system	97
ok so that's kind of a fun little game perhaps you'd like to think about your own features if tomorrow you decided to have a new startup to make a new file system will return to this little game in the future when we look at some newer file systems like zfs and also btrfs and what else we got ok so another nonlinear systems you'll find xfs as well where where these newer fire systems actually	system	156
support whole load of features of much more than a much more complex than our model file system that we're going to study insights this site this course	system	89
'cause we are going to turn our attention to model of e x t two which is sufficient for us to think about how we can represent different sized files on a file system and what constraints and limitations and performance impacts our choices have that's it for this video i'll see you in the next bye	system	159
off that process goes none the wiser than it was actually paused for many many seconds so we could do this if we say needed temporary stop a process if sending too much data or we wanted to pause it once we got a debugger ready to attach to it so actually this little technique is going really really powerful	a process	139
that it find it oh that's a little program finished ok there we go so let's try i forgot the negative for foot ok kill signet and off you go and also don't do that so if i had multiple programs called dot writer running they would all print don't do that let's try that ok so how can i run something in the background of bash this shorter answers put an ampersand at the end ok so now i've got would mean i don't have dot later	background	307
oh yeah ok so be helpful if i put a dot four slash dot forced operator ampersand i've now got two daughters going but i'm running that one in the back in the background so it's happily going so if i now do my kill all oh it's hard to type because it's typing at the same time so kill all space miners sig int and then any processes which have the word i can't type this kill or minus	type	234
oh yeah ok so be helpful if i put a dot four slash dot forced operator ampersand i've now got two daughters going but i'm running that one in the back in the background so it's happily going so if i now do my kill all oh it's hard to type because it's typing at the same time so kill all space miners sig int and then any processes which have the word i can't type this kill or minus	background	158
hi ok so let's jump to a different level let's jump back into the c library perhaps you wanna write some very portable code it doesn't require on requires to think about these low level posix interface is we just want to write code that works say in windows as well maybe you kind of other operating systems that support the c library and which is kind of everything so let's have a look at how we can kind of jump around	code	119
hi ok so let's jump to a different level let's jump back into the c library perhaps you wanna write some very portable code it doesn't require on requires to think about these low level posix interface is we just want to write code that works say in windows as well maybe you kind of other operating systems that support the c library and which is kind of everything so let's have a look at how we can kind of jump around	system	300
the beginning of the first video stream go to this file offset or if you want to find the first frame go to this other offset so there's lots of examples where i need a random access to a file so if my files on a disk or network disk then great i can start jumping around my file so that's what i'm going to be able to do with this fseek and ftell so ftell tells me my current position so that's useful if you want to kind of come back to where you were an f seek allows me to seek to a new position	ftell	342
the trick is to know what is this this whence an what does rewind do ok so we'll get to rewind and a little in a little moment notice it doesn't take any parameters but i'll let you kind of guess what that might do in a moment ok so let's talk about how this fc quirks right so we're going to pass in a a filestream that c based in the fast ring if you try to use this on standard io	parameter	154
and i want to reserve some space for might my file so i'd like to know how big it is now one way you may have seen already is simply to use stat stat tells me all sorts of great things about a file its size which file system is on the number of hard links we haven't talked about yet modification times and all that good stuff but let's just stay within the c library today for the most portable code and figure out how big the file	code	396
and i want to reserve some space for might my file so i'd like to know how big it is now one way you may have seen already is simply to use stat stat tells me all sorts of great things about a file its size which file system is on the number of hard links we haven't talked about yet modification times and all that good stuff but let's just stay within the c library today for the most portable code and figure out how big the file	system	218
right tell on the file k so that tells me my current position so that also tells me then the number of bytes that i would need so i can do things like if i want to have some space on the heap i could say ok malloc	the heap	183
give me that number of bytes now for brevity i'm skipping a whole load of error checking but i just want to kind of sketch out the code so great i've now got a some space and now i can read everything into their ok so how can i start reading my bites well i can use something called fread but i'm not going to do that today instead i'm going to concentrate on this this little problem in here which is	code	131
ok so we've got a concept of i nodes let's actually design our own file system so we're going to base our little design on the x two file system which has been around for a long time but it was the parent of the third generation x t three which came out in two thousand and one which added journaling so journaling is very useful if you want to support file system crashes when the file	system	72
ok so we can we can we can sort of say support power failures so this idea that i can resurrect my file system back to a good well known state where all of the data and the links inside my file system is correct and all the blocks that i refer to as being currently unused is correct that they're not kind of dual purpose for anything and i do that by keeping a journal of what actions i have been completed and then today your laptop your linux laptop is probably using e x t four and that added a lot of performance and also support for large files increased from sixteen terabytes which should have been big enough for everybody up to today four now supports want eat a bite of storage so that should be big enough for everybody we are not	block	224
ok so we can we can we can sort of say support power failures so this idea that i can resurrect my file system back to a good well known state where all of the data and the links inside my file system is correct and all the blocks that i refer to as being currently unused is correct that they're not kind of dual purpose for anything and i do that by keeping a journal of what actions i have been completed and then today your laptop your linux laptop is probably using e x t four and that added a lot of performance and also support for large files increased from sixteen terabytes which should have been big enough for everybody up to today four now supports want eat a bite of storage so that should be big enough for everybody we are not	system	104
going to look in detail at at e x t three weeks to four we're going to concentrate on this simpler model of e x t two right so here's our plan remember my disk drive has a lot of spinning parts or if it's an ssd will have a three dimensional geometry and i want to ignore all of that geometry for now because i would have a very abstract view of my disk namely that i can read and white blocks	block	387
that's my hardware is going to support the idea of saying please read this block one or please write this block two and that's all i need is a very very simple kind of block read or block right and i'd like random access if possible please ok so how should we do use all of these disk blocks ok so we will take the zero block here and will declare that as super block there it is so that is going to hold some meta information	block	75
so that's going to hold some meta information about how we've decided to organize the the rest of the disk so before we can actually start talking about that i notes and where the actual data is going to be stored we better read superblock ok but after that super lock we're going to use the rest of this place here to store the i know so it's just a simple linear way so i can easily calculate where our particular i know it is in relation to a particular this block	block	234
and i know it themselves are going to be pretty small let's think about what we need to store inside them so we have things like not the filename we're not going to store that inside and i note instead we have things like who is the owner read write execute permissions where on the disk will find some of the blocks to do the size of the total file in bytes and maybe a few other things but typically i know is going to be of the order of one hundred and twenty eight bytes or sixty four bytes a pretty small so we can actually fit a lot of them in per desktop for kb chunk ok so they're actually very very small here right so we'll set aside some space for all of these i notes in my very very simple model of a file system here will say that you get one opportunity to decide how many i know you would like to be able to store on this disk so you make that choice when you format it when you say right this is going to be the layout of my disk i'm going to set aside sony dis blocks for the i nodes here we go and the remainder will be used for all of the data that i want to store so that's my initial very simple model it's not very accurate in the sense that modern file systems allow me to have more than one area of memory set aside for on it but it's a good representation of how we started with early file systems ok so make that choice when you when you first formatted an will store that your choice inside the super block let's hope you don't under estimate about the number of files that you intend to store because then you'll run out of i know dentaries	memory	1224
and i know it themselves are going to be pretty small let's think about what we need to store inside them so we have things like not the filename we're not going to store that inside and i note instead we have things like who is the owner read write execute permissions where on the disk will find some of the blocks to do the size of the total file in bytes and maybe a few other things but typically i know is going to be of the order of one hundred and twenty eight bytes or sixty four bytes a pretty small so we can actually fit a lot of them in per desktop for kb chunk ok so they're actually very very small here right so we'll set aside some space for all of these i notes in my very very simple model of a file system here will say that you get one opportunity to decide how many i know you would like to be able to store on this disk so you make that choice when you format it when you say right this is going to be the layout of my disk i'm going to set aside sony dis blocks for the i nodes here we go and the remainder will be used for all of the data that i want to store so that's my initial very simple model it's not very accurate in the sense that modern file systems allow me to have more than one area of memory set aside for on it but it's a good representation of how we started with early file systems ok so make that choice when you when you first formatted an will store that your choice inside the super block let's hope you don't under estimate about the number of files that you intend to store because then you'll run out of i know dentaries	block	310
and i know it themselves are going to be pretty small let's think about what we need to store inside them so we have things like not the filename we're not going to store that inside and i note instead we have things like who is the owner read write execute permissions where on the disk will find some of the blocks to do the size of the total file in bytes and maybe a few other things but typically i know is going to be of the order of one hundred and twenty eight bytes or sixty four bytes a pretty small so we can actually fit a lot of them in per desktop for kb chunk ok so they're actually very very small here right so we'll set aside some space for all of these i notes in my very very simple model of a file system here will say that you get one opportunity to decide how many i know you would like to be able to store on this disk so you make that choice when you format it when you say right this is going to be the layout of my disk i'm going to set aside sony dis blocks for the i nodes here we go and the remainder will be used for all of the data that i want to store so that's my initial very simple model it's not very accurate in the sense that modern file systems allow me to have more than one area of memory set aside for on it but it's a good representation of how we started with early file systems ok so make that choice when you when you first formatted an will store that your choice inside the super block let's hope you don't under estimate about the number of files that you intend to store because then you'll run out of i know dentaries	system	719
ok and the rest of the space we're going to actually use to store the contents of my cat pictures ok so the first block of cat dot jpeg will be here if it's of a detailed jpeg picture then i'm going to need some other blocks ok and so for performance i probably put out try to use blocks which are contiguous which are next to each other but if my disk becomes very fragmented because i keep changing my mind about the kinds of cat pictures that i want to store its overtime i might say that ok so now anouk picture uses these three blocks but also i had to put the fourth block way over here and so let's come back right so if this is a spinning disk it might take quite awhile for the physical part of the disk to read these blocks and then jump over here to read these blocks ok so we might want to make sure that if possible we keep our disk blocks together so we can quickly load my cat picture	block	114
ok so one thing that you might notice right now is that what would happen if a dis block got slightly corrupted so for example let's say that some dust or for some reason the surface here got corrupted i was unable to read these bites so right now you know you've lost a particular cat picture or maybe the cap that particular cat picture won't display exactly correct now what about if we	block	83
actually instead had some damage over here and are super block ok so now this potentially renders the whole disk unusable because inside the super block we said where does the number of inodes kind of finished and which blocks are going to use for the data so in practice the super block is actually often replicated multiple times throughout the disk surface so that you save it scratched or some other awful thing happens with disk there's a good chance that i can find a valid copy elsewhere on the disk right so what we haven't talked about yet is how we actually reference the blocks we need to actually read my cat so right now	block	57
you'll see that say the cat is using say block seventeen eighteen nineteen twenty twenty one maybe it's using these ones of over well so maybe this is like nine hundred forty three and nine hundred forty four where am i going to store these numbers so for that let's actually look at a model of how we can do that and i'll start tell you at that in the next video bye	block	41
hi so what's wrong with the following code let's have a look at this spot the errors problem a little bit more complicated than we've seen before here some code is actually going to use some heat memory to initialize some floating point values for 's case so what we do well we're taking some n value and then we're trying to ask malloc for some memory were trying to a calculation on the number of bytes that we see right but we've got a problem here that the actual number of bytes we see	the following	24
hi so what's wrong with the following code let's have a look at this spot the errors problem a little bit more complicated than we've seen before here some code is actually going to use some heat memory to initialize some floating point values for 's case so what we do well we're taking some n value and then we're trying to ask malloc for some memory were trying to a calculation on the number of bytes that we see right but we've got a problem here that the actual number of bytes we see	memory	196
hi so what's wrong with the following code let's have a look at this spot the errors problem a little bit more complicated than we've seen before here some code is actually going to use some heat memory to initialize some floating point values for 's case so what we do well we're taking some n value and then we're trying to ask malloc for some memory were trying to a calculation on the number of bytes that we see right but we've got a problem here that the actual number of bytes we see	code	38
is an incorrect calculation here yes we have an items but the size of each of those items is not a double pointer who knows what that could be maybe on a thirty two bit system are points would only be four bytes instead we actually want the size of a double now we tend to write this kind of error simply because we put double here on the left to say i want to point to a double but the size of each element is not that so the fix is	system	169
is an incorrect calculation here yes we have an items but the size of each of those items is not a double pointer who knows what that could be maybe on a thirty two bit system are points would only be four bytes instead we actually want the size of a double now we tend to write this kind of error simply because we put double here on the left to say i want to point to a double but the size of each element is not that so the fix is	pointer	106
are often found around these kinds of calls we don't think carefully enough about our memory allocation ok so and just avoid the kind of the symmetry that oh yes i'm having a pointer that points to devils but my actual thing that i'm storing is only over double right so now i've got a pointer to a double in other words malaga said great i put aside some memory for you here's the very first byte of the memory that i'm going to give you so let's store that inside are available here and we're giving into the compiler then that	memory	86
are often found around these kinds of calls we don't think carefully enough about our memory allocation ok so and just avoid the kind of the symmetry that oh yes i'm having a pointer that points to devils but my actual thing that i'm storing is only over double right so now i've got a pointer to a double in other words malaga said great i put aside some memory for you here's the very first byte of the memory that i'm going to give you so let's store that inside are available here and we're giving into the compiler then that	memory allocation	86
are often found around these kinds of calls we don't think carefully enough about our memory allocation ok so and just avoid the kind of the symmetry that oh yes i'm having a pointer that points to devils but my actual thing that i'm storing is only over double right so now i've got a pointer to a double in other words malaga said great i put aside some memory for you here's the very first byte of the memory that i'm going to give you so let's store that inside are available here and we're giving into the compiler then that	pointer	175
we want to treat this memory as a place that we can store	memory	22
double valued floating point values in so now we can initialize this memory and that's what this next line attempts to do so while is i is less than n let's run through this treating it as an array and initialize each of these entries to twelve point three ok so this code appears to work but there's a couple of kind of very dangerous and exciting things about it the most important dangerous and exciting thing about it is the fact that we never initialize the value of i so this is not java in java great everything gets initialized but in see this is a stack variable and stack variables are not initialized so the big rule of thumb here is that stack variables and memory you get back from malloc is not initialized right so what is the value of i who knows today it might start off with zero but it doesn't have to in fact it will be whatever bit pattern happens to be in the stack memory that is assigned to i when we call this function so that's kind of the most glaring problem here there's two other problems that could have mentioned which is that there's no error checking here with with our	memory	69
double valued floating point values in so now we can initialize this memory and that's what this next line attempts to do so while is i is less than n let's run through this treating it as an array and initialize each of these entries to twelve point three ok so this code appears to work but there's a couple of kind of very dangerous and exciting things about it the most important dangerous and exciting thing about it is the fact that we never initialize the value of i so this is not java in java great everything gets initialized but in see this is a stack variable and stack variables are not initialized so the big rule of thumb here is that stack variables and memory you get back from malloc is not initialized right so what is the value of i who knows today it might start off with zero but it doesn't have to in fact it will be whatever bit pattern happens to be in the stack memory that is assigned to i when we call this function so that's kind of the most glaring problem here there's two other problems that could have mentioned which is that there's no error checking here with with our	code	268
multiplication if n was huge we could actually possibly have numerical overflow here secondly malloc itself could fail so more of a bus code would actually check to see if we were given a valid value a lot of value piece of memory or not and then in terms of a designer perspective i wouldn't use integer to request number of items because because 'cause en could be negative it doesn't make sense here so i'd either change this type to something else or at least check their end was non negative value before continuing alright see you in the next video bye	memory	224
multiplication if n was huge we could actually possibly have numerical overflow here secondly malloc itself could fail so more of a bus code would actually check to see if we were given a valid value a lot of value piece of memory or not and then in terms of a designer perspective i wouldn't use integer to request number of items because because 'cause en could be negative it doesn't make sense here so i'd either change this type to something else or at least check their end was non negative value before continuing alright see you in the next video bye	type	429
multiplication if n was huge we could actually possibly have numerical overflow here secondly malloc itself could fail so more of a bus code would actually check to see if we were given a valid value a lot of value piece of memory or not and then in terms of a designer perspective i wouldn't use integer to request number of items because because 'cause en could be negative it doesn't make sense here so i'd either change this type to something else or at least check their end was non negative value before continuing alright see you in the next video bye	code	136
ok, so we've got some code maybe some stuff we've written say inside cs two twenty five or an internship or we've got our own startup, and now we want to make it faster	code	22
so we want to make it so that actually multiple threads can use this code at the same time. okay, so let's start by just looking at simple typical kind of linked list code. perhaps you're going to write it in c++	code	69
so we want to make it so that actually multiple threads can use this code at the same time. okay, so let's start by just looking at simple typical kind of linked list code. perhaps you're going to write it in c++	thread	48
,uh... perhaps you're going to write it in c, perhaps you're going to write it in some other language. it doesn't matter. it doesn't matter. the idea is all the same. ok so here's the goal. we're going to try to modify this code to be what's called 'thread safe' in other words i can actually use it with multiple threads so along the way we're going to fix some errors as well. ok so what do we got. we've got a pointer that corresponds to the start of my linked list. uhm, in more complicated examples this might be in a separate data structure but this is good enough for a little example here. ok, and then i've got two methods to	a struct	535
,uh... perhaps you're going to write it in c, perhaps you're going to write it in some other language. it doesn't matter. it doesn't matter. the idea is all the same. ok so here's the goal. we're going to try to modify this code to be what's called 'thread safe' in other words i can actually use it with multiple threads so along the way we're going to fix some errors as well. ok so what do we got. we've got a pointer that corresponds to the start of my linked list. uhm, in more complicated examples this might be in a separate data structure but this is good enough for a little example here. ok, and then i've got two methods to	code	224
,uh... perhaps you're going to write it in c, perhaps you're going to write it in some other language. it doesn't matter. it doesn't matter. the idea is all the same. ok so here's the goal. we're going to try to modify this code to be what's called 'thread safe' in other words i can actually use it with multiple threads so along the way we're going to fix some errors as well. ok so what do we got. we've got a pointer that corresponds to the start of my linked list. uhm, in more complicated examples this might be in a separate data structure but this is good enough for a little example here. ok, and then i've got two methods to	thread	250
,uh... perhaps you're going to write it in c, perhaps you're going to write it in some other language. it doesn't matter. it doesn't matter. the idea is all the same. ok so here's the goal. we're going to try to modify this code to be what's called 'thread safe' in other words i can actually use it with multiple threads so along the way we're going to fix some errors as well. ok so what do we got. we've got a pointer that corresponds to the start of my linked list. uhm, in more complicated examples this might be in a separate data structure but this is good enough for a little example here. ok, and then i've got two methods to	pointer	413
add and remove things so either i want to append or remove from the front of my link list. ok, right, so let's see what do we do now. can we spot any errors in this code ok i can see one already. i'm attuned to this one this looks exactly like this. this is not a good sign. ok so the goal of this prepend method is to be able to create a new link with this value. so how do we create a link well, first of all, we better get some memory. the easiest way to get some memory that is not going to be immediately deallocated when we return from this "function is, of course, to use malloc. ""hey malloc! i need enough" space to hold my link structure right so the error here is that we actually wanted the size of the struct not the size of a pointer to the struct. so get rid of that point in there. right, so great! we've now got enough space hold it and now we can set up the values of our memory item here. and internally now, we want to consider that piece of memory as having a 'value' and a 'next'. so all the arrow "does is to say ""right, use the pointer that you've given" me, like link, and i'm going to dereference it but i'm not going to dereference it right at the beginning... i'm going to have some offset into that structure which "represents the value of the 'next' pointer."" okay, so"	memory	431
add and remove things so either i want to append or remove from the front of my link list. ok, right, so let's see what do we do now. can we spot any errors in this code ok i can see one already. i'm attuned to this one this looks exactly like this. this is not a good sign. ok so the goal of this prepend method is to be able to create a new link with this value. so how do we create a link well, first of all, we better get some memory. the easiest way to get some memory that is not going to be immediately deallocated when we return from this "function is, of course, to use malloc. ""hey malloc! i need enough" space to hold my link structure right so the error here is that we actually wanted the size of the struct not the size of a pointer to the struct. so get rid of that point in there. right, so great! we've now got enough space hold it and now we can set up the values of our memory item here. and internally now, we want to consider that piece of memory as having a 'value' and a 'next'. so all the arrow "does is to say ""right, use the pointer that you've given" me, like link, and i'm going to dereference it but i'm not going to dereference it right at the beginning... i'm going to have some offset into that structure which "represents the value of the 'next' pointer."" okay, so"	code	165
add and remove things so either i want to append or remove from the front of my link list. ok, right, so let's see what do we do now. can we spot any errors in this code ok i can see one already. i'm attuned to this one this looks exactly like this. this is not a good sign. ok so the goal of this prepend method is to be able to create a new link with this value. so how do we create a link well, first of all, we better get some memory. the easiest way to get some memory that is not going to be immediately deallocated when we return from this "function is, of course, to use malloc. ""hey malloc! i need enough" space to hold my link structure right so the error here is that we actually wanted the size of the struct not the size of a pointer to the struct. so get rid of that point in there. right, so great! we've now got enough space hold it and now we can set up the values of our memory item here. and internally now, we want to consider that piece of memory as having a 'value' and a 'next'. so all the arrow "does is to say ""right, use the pointer that you've given" me, like link, and i'm going to dereference it but i'm not going to dereference it right at the beginning... i'm going to have some offset into that structure which "represents the value of the 'next' pointer."" okay, so"	pointer	740
great! we're setting up the value. we're setting up its 'next' to be equal to the current head our global variable and then the last thing we change is 'head equal to link' "so, providing we fix the ""size of"" bug, this would work!" with a single thread! alright, so you can imagine 'head' is holding the address of some link. here it is. and this is gotta 'next' and a 'value' so let's imagine the next is pointing is holding the value of another little link object there. and what if we just done well we made a new link here we said its value and then we "said ""ok, 'next value', you need to point to the same thing that head" "does."" so you're pointing at the original top" of the link. there it is. and then finally change head	thread	248
great! we're setting up the value. we're setting up its 'next' to be equal to the current head our global variable and then the last thing we change is 'head equal to link' "so, providing we fix the ""size of"" bug, this would work!" with a single thread! alright, so you can imagine 'head' is holding the address of some link. here it is. and this is gotta 'next' and a 'value' so let's imagine the next is pointing is holding the value of another little link object there. and what if we just done well we made a new link here we said its value and then we "said ""ok, 'next value', you need to point to the same thing that head" "does."" so you're pointing at the original top" of the link. there it is. and then finally change head	address	306
so that it's looking at a new link. ok so we've made at entry we preprinted it. right let's have a look at the remove version of this. what are we doing so we want to grab a pointer we're going to make a pointer that is looking at whatever head is looking at. so, if head is looking at this entry here, now we've got this other variable this link variable they're also looking at the same memory structure and then we extract its value. ok, and then we say right head	memory	389
so that it's looking at a new link. ok so we've made at entry we preprinted it. right let's have a look at the remove version of this. what are we doing so we want to grab a pointer we're going to make a pointer that is looking at whatever head is looking at. so, if head is looking at this entry here, now we've got this other variable this link variable they're also looking at the same memory structure and then we extract its value. ok, and then we say right head	pointer	174
"change to be equal to 'link' next."" in other words whatever" this link is pointing to (which might be null), that is how we're going to change here. so we're now going to point to the same thing. right, so in doing so we skipped over our friend here and they are no longer apart of the linked list but they're still taking up some memory "so we better remember to tell the heap, ""oh! by the way"	memory	333
"change to be equal to 'link' next."" in other words whatever" this link is pointing to (which might be null), that is how we're going to change here. so we're now going to point to the same thing. right, so in doing so we skipped over our friend here and they are no longer apart of the linked list but they're still taking up some memory "so we better remember to tell the heap, ""oh! by the way"	the heap	371
"you're done."" ok we don't want you" right so the observant among you might say ok well "this always work?"" one concern, of course, is that what" if there was nothing in my linked list. what if head for example, pointed to nothing to null so then our code would crash and here's where it would crash. it would crash when we try to dereference this pointer. so we've got a null pointer pointing at address zero and then "we say, ""ok, let's try and read some offset from that."" so"	code	253
"you're done."" ok we don't want you" right so the observant among you might say ok well "this always work?"" one concern, of course, is that what" if there was nothing in my linked list. what if head for example, pointed to nothing to null so then our code would crash and here's where it would crash. it would crash when we try to dereference this pointer. so we've got a null pointer pointing at address zero and then "we say, ""ok, let's try and read some offset from that."" so"	address	399
"you're done."" ok we don't want you" right so the observant among you might say ok well "this always work?"" one concern, of course, is that what" if there was nothing in my linked list. what if head for example, pointed to nothing to null so then our code would crash and here's where it would crash. it would crash when we try to dereference this pointer. so we've got a null pointer pointing at address zero and then "we say, ""ok, let's try and read some offset from that."" so"	pointer	350
maybe offset 0 or offset 4.. so we end up trying to read address 4 or some low value and that course is going to crash ok, but what i do like about this code is that we don't free	code	153
maybe offset 0 or offset 4.. so we end up trying to read address 4 or some low value and that course is going to crash ok, but what i do like about this code is that we don't free	address	57
pulled out, for example, its value. i've seen plenty of badly written linked list code where you free it "first and then you say ""ok old link that doesn't exist," "tell me about your next pointer."" that might work if" you're lucky, but is actually undefined behavior.	code	82
pulled out, for example, its value. i've seen plenty of badly written linked list code where you free it "first and then you say ""ok old link that doesn't exist," "tell me about your next pointer."" that might work if" you're lucky, but is actually undefined behavior.	pointer	189
how to make this code 'threadsafe'. right, so we need to identify the critical section: 'where is it that we only need one thread at a time to be running and	code	17
how to make this code 'threadsafe'. right, so we need to identify the critical section: 'where is it that we only need one thread at a time to be running and	section	79
how to make this code 'threadsafe'. right, so we need to identify the critical section: 'where is it that we only need one thread at a time to be running and	thread	23
so we know that malloc is threadsafe. it is perfect ok for multiple threads to call malloc	thread	26
so if list_prepend was told in two threads at the same time that would be ok. each thread has its own stack and inside each stack it would have its own link variables be pointing to different pieces of memory life gets exciting! not when you try to use a parameter value, but when you try to use the actual data structure. it's this moment here when you read 'head', that we might run into problems. so you could imagine for example	memory	202
so if list_prepend was told in two threads at the same time that would be ok. each thread has its own stack and inside each stack it would have its own link variables be pointing to different pieces of memory life gets exciting! not when you try to use a parameter value, but when you try to use the actual data structure. it's this moment here when you read 'head', that we might run into problems. so you could imagine for example	parameter	255
so if list_prepend was told in two threads at the same time that would be ok. each thread has its own stack and inside each stack it would have its own link variables be pointing to different pieces of memory life gets exciting! not when you try to use a parameter value, but when you try to use the actual data structure. it's this moment here when you read 'head', that we might run into problems. so you could imagine for example	a struct	310
so if list_prepend was told in two threads at the same time that would be ok. each thread has its own stack and inside each stack it would have its own link variables be pointing to different pieces of memory life gets exciting! not when you try to use a parameter value, but when you try to use the actual data structure. it's this moment here when you read 'head', that we might run into problems. so you could imagine for example	thread	35
i've got head here looking at an existing block meanwhile i've got one thread that were setting up a new link and i've got another thread that were setting up a new link) and if life was fine and happy we would end up with these in some order. it doesn't really matter which order, just depends upon which what happens to be called first. but if list prepared was called at the same time you could imagine that both of them would read the old value of head here. in other words, they would both end up with the next pointer that points to	block	42
i've got head here looking at an existing block meanwhile i've got one thread that were setting up a new link and i've got another thread that were setting up a new link) and if life was fine and happy we would end up with these in some order. it doesn't really matter which order, just depends upon which what happens to be called first. but if list prepared was called at the same time you could imagine that both of them would read the old value of head here. in other words, they would both end up with the next pointer that points to	thread	71
i've got head here looking at an existing block meanwhile i've got one thread that were setting up a new link and i've got another thread that were setting up a new link) and if life was fine and happy we would end up with these in some order. it doesn't really matter which order, just depends upon which what happens to be called first. but if list prepared was called at the same time you could imagine that both of them would read the old value of head here. in other words, they would both end up with the next pointer that points to	pointer	516
another link that's being created at the same time so for example, i want to i don't want to first set head to be equal to a new one and then another thread immediately say, """aww, don't look at that one" "look at me instead."" and we skip over one of those created" links. ok so that's the piece of code that is a critical section in this first part of the code, that absolutely we can't have two threads running these two lines at the same time. we would like those two lines to be 'atomic' meaning that they should behave as if they happen in just one go and they can't be interrupted and no other thread can actually run those two lines at the same time. ok so how do we do that ok easy let's use mutex locks. so just before doing that we call pthread	code	301
another link that's being created at the same time so for example, i want to i don't want to first set head to be equal to a new one and then another thread immediately say, """aww, don't look at that one" "look at me instead."" and we skip over one of those created" links. ok so that's the piece of code that is a critical section in this first part of the code, that absolutely we can't have two threads running these two lines at the same time. we would like those two lines to be 'atomic' meaning that they should behave as if they happen in just one go and they can't be interrupted and no other thread can actually run those two lines at the same time. ok so how do we do that ok easy let's use mutex locks. so just before doing that we call pthread	section	325
another link that's being created at the same time so for example, i want to i don't want to first set head to be equal to a new one and then another thread immediately say, """aww, don't look at that one" "look at me instead."" and we skip over one of those created" links. ok so that's the piece of code that is a critical section in this first part of the code, that absolutely we can't have two threads running these two lines at the same time. we would like those two lines to be 'atomic' meaning that they should behave as if they happen in just one go and they can't be interrupted and no other thread can actually run those two lines at the same time. ok so how do we do that ok easy let's use mutex locks. so just before doing that we call pthread	thread	150
and is it ok for pre pend and remove front to be called at the same time? for example, one thread might be calling list_prepend() and another thread might be calling remove front uh oh! that's not safe. we don't want these two functions from changing the value of head at the same time. we don't.....	thread	91
so let's make sure that we define the critical section correctly in here as well. alright so when we're removing things, we read the value of head and at that moment, we'd like to make sure that nothing else changes, that this still corresponds to the beginning of the linked list. and we want to freeze everybody else until the moment that we have finished changing the value of head. ok so these lines are	section	47
before executing any of that i will call pthread_mutex_lock ok,	thread	42
ok so notice that i'm not freeing it till later and in fact all of my free operations could happen at the same time if we had lots of threads calling this but if i really did have lots and lots of threads trying to remove lots and lots of links, they would each get a different link, because each bit of this code here does not happen in parallel. ok, we've actually brought order to the madness it's like we have a thousand people running crazy saying... ok i wouldn't use that movie reference but at some point we turn him into a nice order dinner "queue and say ""ok you go first and then if you want to eat then" "you have to get in line"" and just one person at a time" gets to use a salad bar or something. ok so is this what this code work as i've written it? yeah.. kind of. well yes it will, but i want to mention couple of things first of all you might be worried about what happens if i call list_remove_front() too many times? yes, that's a problem. our code does not check to see for underflow does not check to see if you try to remove things from the list and there's nothing left in other words if head is null and it does not check to see if malloc succeeded and we actually hold on to the link a bit longer than we need to because this line in here where we extract the value of the link that could be done afterwards that could be done when we return but before we free it so we could give back the duck and that's an important idea that you want to minimize the contention of of your logs so your program runs past so there's only small parts of your code in terms of the total time that it takes to run where you need to hold onto a lock and say ok nobody else can do a critical	code	309
ok so notice that i'm not freeing it till later and in fact all of my free operations could happen at the same time if we had lots of threads calling this but if i really did have lots and lots of threads trying to remove lots and lots of links, they would each get a different link, because each bit of this code here does not happen in parallel. ok, we've actually brought order to the madness it's like we have a thousand people running crazy saying... ok i wouldn't use that movie reference but at some point we turn him into a nice order dinner "queue and say ""ok you go first and then if you want to eat then" "you have to get in line"" and just one person at a time" gets to use a salad bar or something. ok so is this what this code work as i've written it? yeah.. kind of. well yes it will, but i want to mention couple of things first of all you might be worried about what happens if i call list_remove_front() too many times? yes, that's a problem. our code does not check to see for underflow does not check to see if you try to remove things from the list and there's nothing left in other words if head is null and it does not check to see if malloc succeeded and we actually hold on to the link a bit longer than we need to because this line in here where we extract the value of the link that could be done afterwards that could be done when we return but before we free it so we could give back the duck and that's an important idea that you want to minimize the contention of of your logs so your program runs past so there's only small parts of your code in terms of the total time that it takes to run where you need to hold onto a lock and say ok nobody else can do a critical	thread	134
critical section because i'm holding the lock lock so so we'll keep those pieces of code to a minimum and so this idea that you lock you did a tiny bit of work on a data structure and then you unlock it that is very common to see inside multithreaded code	a struct	168
critical section because i'm holding the lock lock so so we'll keep those pieces of code to a minimum and so this idea that you lock you did a tiny bit of work on a data structure and then you unlock it that is very common to see inside multithreaded code	code	84
critical section because i'm holding the lock lock so so we'll keep those pieces of code to a minimum and so this idea that you lock you did a tiny bit of work on a data structure and then you unlock it that is very common to see inside multithreaded code	section	9
critical section because i'm holding the lock lock so so we'll keep those pieces of code to a minimum and so this idea that you lock you did a tiny bit of work on a data structure and then you unlock it that is very common to see inside multithreaded code	thread	242
ok right so i hope that made sense it's a lot of new ideas here feel free to discuss this on the course form because now we've got another one to do we've just worked on linked lists now i've got a push and pop functions so i've now got more like a stack type operation to look at so take a look at this code and decide what is wrong and then we will also make it thread safe are you ready go	type	255
ok right so i hope that made sense it's a lot of new ideas here feel free to discuss this on the course form because now we've got another one to do we've just worked on linked lists now i've got a push and pop functions so i've now got more like a stack type operation to look at so take a look at this code and decide what is wrong and then we will also make it thread safe are you ready go	code	304
ok right so i hope that made sense it's a lot of new ideas here feel free to discuss this on the course form because now we've got another one to do we've just worked on linked lists now i've got a push and pop functions so i've now got more like a stack type operation to look at so take a look at this code and decide what is wrong and then we will also make it thread safe are you ready go	thread	364
hi ok so here's a challenge we want to implement a barrier now to make it easy we're going to implement just a single use barrier and in fact usually is one of the cs two forty one assignments we ask you to think about how to generalize this into a multiple use barrier and one of the complexities of implementing a multiple use barrier is you can imagine right i've got my threads they've all arrived at holding gate here right so they're all kind of getting stuck inside	thread	374
getting blocked inside the little weight call here right and then after the eighth wonder ways so it's five six thread calls weight seven thread calls weight ok and then finally the eighth red calls weight and so we can say ok daytona five hundred off you go and we open the gate right and they all start rushing out	block	8
getting blocked inside the little weight call here right and then after the eighth wonder ways so it's five six thread calls weight seven thread calls weight ok and then finally the eighth red calls weight and so we can say ok daytona five hundred off you go and we open the gate right and they all start rushing out	thread	112
you could imagine that one thread completes its work really quickly and so actually calls p thread sorry of course the weight on your barry again who and we want that thread to actually be blocked to be wait to wait and it might actually even do that before this laggard thread over here is even managed to wake up and exit your barriers so somehow you need a way to ensure that this eighth this really fast thread this wiley coyote thread actually still blocks here even if it even if it does that before the eighth readers left so you need a way to disambiguate the first block the first barrier use form the second barriers from the third barriers from the fourth barriers and i'll let you figure out how to do that is actually multiple ways to do it ok	block	189
you could imagine that one thread completes its work really quickly and so actually calls p thread sorry of course the weight on your barry again who and we want that thread to actually be blocked to be wait to wait and it might actually even do that before this laggard thread over here is even managed to wake up and exit your barriers so somehow you need a way to ensure that this eighth this really fast thread this wiley coyote thread actually still blocks here even if it even if it does that before the eighth readers left so you need a way to disambiguate the first block the first barrier use form the second barriers from the third barriers from the fourth barriers and i'll let you figure out how to do that is actually multiple ways to do it ok	thread	27
right so here's what i'm going to do i'm going to keep track of the number of threads that have	thread	78
an multiple threads are going to call power so let's keep track of the total number of threads that have been there called this so we'll have a little counter in every time a new thread calls this i'm going to implement	thread	12
my counter right now then what if two threads called this is exactly the same time this is not thread safe so i will actually need some kind of lock here so i'll have a p thread mutex lock k	thread	38
try again and will hold on a moment we should be using condition variables for this so let's have a condition variable here to say ok please block inside here and release the mutex lock ok	block	141
to see if the counter value is got to eight but to initially the first seven threads that called this that all going to see counter values which are less than eight	thread	77
but what should we do to make sure that we wake up all about threads ok so i can say look if i am the eighth red so if my counter value has reached eight then i know that it's time to wake up all of the other threads so how should i do that should i call p three conditions signal no that's only going to wake up one of them i want to wake up all of the threads which are inside this wait call here so let's call	thread	61
they will now wake up of course they can't immediately continue why not because i'm holding the mutex lock but there are live and ready to go ok so what will the eight thread do it will call broadcaster ringing the fire alarm and then we a scape we call unlock an out we go ok so now i've got seven threads that are working up inside inside here inside my condition variable	thread	168
ok each one now tries to obtain the mutex lock one of them will win so it escapes and imagery unlocks the mutex lock and so the next red inside here is able to acquire the mutex lock so it's called period new text log succeeds and what's it do it immediately comes out and unlock the mutex lock so then one after another all of my threads can finally escape so that's our barrier so we've implemented this using open mutex lock just to kind of quick ideas suppose last i had six threads come in so my counters now six and now i have two threads which immediately called barrier at the same time what would happen ok so again we have the mutex lock to the rescue that this will ensure that one of the threads will acquire the lock and the other one gets blocked so there can only be one winner like two toddlers fighting over a toy eventually one of them says that the lock is mine	block	753
ok each one now tries to obtain the mutex lock one of them will win so it escapes and imagery unlocks the mutex lock and so the next red inside here is able to acquire the mutex lock so it's called period new text log succeeds and what's it do it immediately comes out and unlock the mutex lock so then one after another all of my threads can finally escape so that's our barrier so we've implemented this using open mutex lock just to kind of quick ideas suppose last i had six threads come in so my counters now six and now i have two threads which immediately called barrier at the same time what would happen ok so again we have the mutex lock to the rescue that this will ensure that one of the threads will acquire the lock and the other one gets blocked so there can only be one winner like two toddlers fighting over a toy eventually one of them says that the lock is mine	thread	331
i'm holding it i have the duck and so that thread will see a value of six it implements the counter and then we're going to sleep in sleeping on the one thing here and so get out here right that would see a value of six	thread	43
which is implemented to seven so it then it would go to sleep so now finally that release mutex lock and finally our last dead but the most important thread of all is able to acquire the metrics lock then call broadcast and off we go and we release all the locks ok so that's my single use lock one challenge will be to figure out how can you generalize this into a multiple use barrier so how can you deal with the special problem of threads which might complete very quickly and recall the barrier method before the seven other threads have managed to escape so how you going to implement that ok right the last thing automation is	thread	150
ok so let's complete the following to return one if the given c string contains an at symbol or not otherwise return zero so let's write this little bit of code	the following	21
ok so let's complete the following to return one if the given c string contains an at symbol or not otherwise return zero so let's write this little bit of code	code	156
ok so let's complete the following to return one if the given c string contains an at symbol or not otherwise return zero so let's write this little bit of code	string	64
so first of all take a look at this it's going to be given the address of a character so we can read this backwards my variable ptr is appointed otherwise it's going to hold an address of something and the type is a hint of the compiler to say	type	206
so first of all take a look at this it's going to be given the address of a character so we can read this backwards my variable ptr is appointed otherwise it's going to hold an address of something and the type is a hint of the compiler to say	address	63
how much maybe we should read or write when we actually use this pointer are we going to read or write four bytes for example for an integer or but no in this case it's just characters in other words we want to read or write just a single byte whenever we actually use this pointer and that's what we want to do most of the time most of the time we don't care about where the pointer is actually want to use its value we know the pointer points to some memory so let's go and read or write things at that memory ok so let's have a go at writing this function k so i will start my right favorite debugging in a favorite development environment perhaps you've got your favorite ide minus cat let's see how far we can get like what is cat will by default if you just one cat and you say hello it just sends a line back to you so we can keep doing this but let's not you could also ask app to print out some files so please print out the contents of a particular file for example	memory	453
how much maybe we should read or write when we actually use this pointer are we going to read or write four bytes for example for an integer or but no in this case it's just characters in other words we want to read or write just a single byte whenever we actually use this pointer and that's what we want to do most of the time most of the time we don't care about where the pointer is actually want to use its value we know the pointer points to some memory so let's go and read or write things at that memory ok so let's have a go at writing this function k so i will start my right favorite debugging in a favorite development environment perhaps you've got your favorite ide minus cat let's see how far we can get like what is cat will by default if you just one cat and you say hello it just sends a line back to you so we can keep doing this but let's not you could also ask app to print out some files so please print out the contents of a particular file for example	pointer	65
but today what we want to do is actually take the output of cat and instead of just saying putting it back to us i want to redirect their output to a file so let me call this file contains at right so now whatever i type will be sent to that file right so what i need inside here well i will be doing some possible input and output so let me include standard io dot h so i can use things like printf and now let me start the might start my program ok so main int argc and arg v right ok so how will i use my contains function well for example i want to be able to say result and then i'll call contains a lot of c code actually the style is to use underscore so let's do that and will say contains out and we expect if we call it with a test one	type	216
but today what we want to do is actually take the output of cat and instead of just saying putting it back to us i want to redirect their output to a file so let me call this file contains at right so now whatever i type will be sent to that file right so what i need inside here well i will be doing some possible input and output so let me include standard io dot h so i can use things like printf and now let me start the might start my program ok so main int argc and arg v right ok so how will i use my contains function well for example i want to be able to say result and then i'll call contains a lot of c code actually the style is to use underscore so let's do that and will say contains out and we expect if we call it with a test one	code	614
but today what we want to do is actually take the output of cat and instead of just saying putting it back to us i want to redirect their output to a file so let me call this file contains at right so now whatever i type will be sent to that file right so what i need inside here well i will be doing some possible input and output so let me include standard io dot h so i can use things like printf and now let me start the might start my program ok so main int argc and arg v right ok so how will i use my contains function well for example i want to be able to say result and then i'll call contains a lot of c code actually the style is to use underscore so let's do that and will say contains out and we expect if we call it with a test one	printf	393
that if we pass in a string with an app side we expect that to be equal to one ok so we can talk about the certain little bit but for now let's just decide what it prints out so i print out results so if it's all is one then then that we evaluate to true and we can print out something and we can say contains that right and otherwise we will say no app found ok	string	21
but this is not the best of code we probably should put those braces around those single statements for the year from the else but in the interest of time let's keep going ok so we've got ourselves on main	code	28
takes a character pointer so what are we doing here we actually giving it the address of the beginning of the string and we're going to walk through the string one at a time	string	110
takes a character pointer so what are we doing here we actually giving it the address of the beginning of the string and we're going to walk through the string one at a time	address	78
takes a character pointer so what are we doing here we actually giving it the address of the beginning of the string and we're going to walk through the string one at a time	pointer	18
so in our example code above where we called it with test one actually what's going to happen is that when we started programming and create a process that string literal along with the code that we've written here will be loaded into memory and so we know the very first bite of this little particular string here and so that's somewhere in memory so that's why she going to get to this function is the very first bite of that string ok so we need a way to walk through the string looking for each character ok so let me think about how to write this right now i'm just going to keep going around forever looking at each character in terms so i will just put a wild one here and we'll come back to this ok and let's have a look at the current character so i don't care about the actual address that we my variable holds i care about what's at that address i needed the cpus are full of the money to follow that pointer so i can do reference that pointer with an asterix so notice the aspects actually means two different things if it's in a declaration it means this is appointed to something	memory	235
so in our example code above where we called it with test one actually what's going to happen is that when we started programming and create a process that string literal along with the code that we've written here will be loaded into memory and so we know the very first bite of this little particular string here and so that's somewhere in memory so that's why she going to get to this function is the very first bite of that string ok so we need a way to walk through the string looking for each character ok so let me think about how to write this right now i'm just going to keep going around forever looking at each character in terms so i will just put a wild one here and we'll come back to this ok and let's have a look at the current character so i don't care about the actual address that we my variable holds i care about what's at that address i needed the cpus are full of the money to follow that pointer so i can do reference that pointer with an asterix so notice the aspects actually means two different things if it's in a declaration it means this is appointed to something	code	18
so in our example code above where we called it with test one actually what's going to happen is that when we started programming and create a process that string literal along with the code that we've written here will be loaded into memory and so we know the very first bite of this little particular string here and so that's somewhere in memory so that's why she going to get to this function is the very first bite of that string ok so we need a way to walk through the string looking for each character ok so let me think about how to write this right now i'm just going to keep going around forever looking at each character in terms so i will just put a wild one here and we'll come back to this ok and let's have a look at the current character so i don't care about the actual address that we my variable holds i care about what's at that address i needed the cpus are full of the money to follow that pointer so i can do reference that pointer with an asterix so notice the aspects actually means two different things if it's in a declaration it means this is appointed to something	a process	141
so in our example code above where we called it with test one actually what's going to happen is that when we started programming and create a process that string literal along with the code that we've written here will be loaded into memory and so we know the very first bite of this little particular string here and so that's somewhere in memory so that's why she going to get to this function is the very first bite of that string ok so we need a way to walk through the string looking for each character ok so let me think about how to write this right now i'm just going to keep going around forever looking at each character in terms so i will just put a wild one here and we'll come back to this ok and let's have a look at the current character so i don't care about the actual address that we my variable holds i care about what's at that address i needed the cpus are full of the money to follow that pointer so i can do reference that pointer with an asterix so notice the aspects actually means two different things if it's in a declaration it means this is appointed to something	string	156
so in our example code above where we called it with test one actually what's going to happen is that when we started programming and create a process that string literal along with the code that we've written here will be loaded into memory and so we know the very first bite of this little particular string here and so that's somewhere in memory so that's why she going to get to this function is the very first bite of that string ok so we need a way to walk through the string looking for each character ok so let me think about how to write this right now i'm just going to keep going around forever looking at each character in terms so i will just put a wild one here and we'll come back to this ok and let's have a look at the current character so i don't care about the actual address that we my variable holds i care about what's at that address i needed the cpus are full of the money to follow that pointer so i can do reference that pointer with an asterix so notice the aspects actually means two different things if it's in a declaration it means this is appointed to something	address	787
so in our example code above where we called it with test one actually what's going to happen is that when we started programming and create a process that string literal along with the code that we've written here will be loaded into memory and so we know the very first bite of this little particular string here and so that's somewhere in memory so that's why she going to get to this function is the very first bite of that string ok so we need a way to walk through the string looking for each character ok so let me think about how to write this right now i'm just going to keep going around forever looking at each character in terms so i will just put a wild one here and we'll come back to this ok and let's have a look at the current character so i don't care about the actual address that we my variable holds i care about what's at that address i needed the cpus are full of the money to follow that pointer so i can do reference that pointer with an asterix so notice the aspects actually means two different things if it's in a declaration it means this is appointed to something	pointer	912
we read it kind of backwards so inside out from the variable if you use it inside an expression you're saying hey follow the money right now you're looking at an address so go and use the type to go and actually read what's at that address is an interview for bites or eight whatever it is if its character just read that one bite right so we can read what's there and we want to know is what do we find ok so we really one character so i'd like to check to see if i found it at how can i do that well perhaps i'm an ascii geek and i know happen to know that that is sixty value sixty four but that code is not very readable it maybe it's better to use oh no that's not right because that's actually a c string and so that would just give me an address instead what i need is a single quotes to say here's an here's an ascii character please convert that into an ascii value for me right so if that's found great we can stop looping around so now we can actually return one to mean success ok otherwise we want to go on a loop ok so next time i loop i actually want to look at the next	type	188
we read it kind of backwards so inside out from the variable if you use it inside an expression you're saying hey follow the money right now you're looking at an address so go and use the type to go and actually read what's at that address is an interview for bites or eight whatever it is if its character just read that one bite right so we can read what's there and we want to know is what do we find ok so we really one character so i'd like to check to see if i found it at how can i do that well perhaps i'm an ascii geek and i know happen to know that that is sixty value sixty four but that code is not very readable it maybe it's better to use oh no that's not right because that's actually a c string and so that would just give me an address instead what i need is a single quotes to say here's an here's an ascii character please convert that into an ascii value for me right so if that's found great we can stop looping around so now we can actually return one to mean success ok otherwise we want to go on a loop ok so next time i loop i actually want to look at the next	code	599
we read it kind of backwards so inside out from the variable if you use it inside an expression you're saying hey follow the money right now you're looking at an address so go and use the type to go and actually read what's at that address is an interview for bites or eight whatever it is if its character just read that one bite right so we can read what's there and we want to know is what do we find ok so we really one character so i'd like to check to see if i found it at how can i do that well perhaps i'm an ascii geek and i know happen to know that that is sixty value sixty four but that code is not very readable it maybe it's better to use oh no that's not right because that's actually a c string and so that would just give me an address instead what i need is a single quotes to say here's an here's an ascii character please convert that into an ascii value for me right so if that's found great we can stop looping around so now we can actually return one to mean success ok otherwise we want to go on a loop ok so next time i loop i actually want to look at the next	string	704
we read it kind of backwards so inside out from the variable if you use it inside an expression you're saying hey follow the money right now you're looking at an address so go and use the type to go and actually read what's at that address is an interview for bites or eight whatever it is if its character just read that one bite right so we can read what's there and we want to know is what do we find ok so we really one character so i'd like to check to see if i found it at how can i do that well perhaps i'm an ascii geek and i know happen to know that that is sixty value sixty four but that code is not very readable it maybe it's better to use oh no that's not right because that's actually a c string and so that would just give me an address instead what i need is a single quotes to say here's an here's an ascii character please convert that into an ascii value for me right so if that's found great we can stop looping around so now we can actually return one to mean success ok otherwise we want to go on a loop ok so next time i loop i actually want to look at the next	address	162
nextbit how do i do that i could say pointer equals pointer plus one or for shorter how shorthand i can just say plus plus ok now the important thing though about c is that when you start doing point two arithmetic actually the compiler makes use of the pointer type and in this case the pointer points to characters so to look at the next character it actually needs to advance by one byte if we were looking at integer pointers then it would advance by four bytes or eight bytes or whatever ok so we've got a little program little function here and if we don't find it we should return something to mean zero sorry to mean false and in see if you evaluate an integer expression that are nonzero value means true and a zero value means false ok that's pretty good but right now we're going to keep looking forever right so we actually need	type	262
nextbit how do i do that i could say pointer equals pointer plus one or for shorter how shorthand i can just say plus plus ok now the important thing though about c is that when you start doing point two arithmetic actually the compiler makes use of the pointer type and in this case the pointer points to characters so to look at the next character it actually needs to advance by one byte if we were looking at integer pointers then it would advance by four bytes or eight bytes or whatever ok so we've got a little program little function here and if we don't find it we should return something to mean zero sorry to mean false and in see if you evaluate an integer expression that are nonzero value means true and a zero value means false ok that's pretty good but right now we're going to keep looking forever right so we actually need	pointer	37
to stop if we get to the very end of the seas of the string so how can we do that let's go now edit or program i like vim which is ver device so let's up my program here ok right	string	53
so we want to fix this ok so somehow i need to wait to say hey i've reached the end of the string now see strings don't have any idea about length all they asked us to sequence until the day we reached a very character which says hey no more and at that moment we've read the actual ascii value is zero so the value zero is not printable character it means this is the end of the c string ok so i could write	string	91
hey let's read the value up memory and surface zero but there's no point i can just read the value and if that zero great we know that we found everything right just delete word delete word ok so let's take this and try to compile it ok it contains at and we have a	memory	28
main it is amazing about function contains that so it kind of makes a guess as to where this function might be and what it looks like ok so we should fix this let's run a command called v so now i'm asking my shell to find the command that i last run that start with a v here it is of course it's vim so here's our problem we're using contains that and the compiler hasn't even seen it yet so at this point maybe i want to put a declaration insider dot h file or i could just declare what it looks like here so i'm going to tell the compiler that hey there's going to be a function called contains out that takes a character pointer and i'm not going to tell you anything more about it today i'm not going to tell you anything more about what how it's implemented just that it exists ok right so now let's compile k all we've got that one other issue to fix which is our main we didn't actually get the type here correct pointed to appointed or character white 'cause it's an array of strings so now let's try again ok great it compiles we could even try to compile with all early warnings enabled great compiled so what do we got inside the current directory i've got this thing called a door out that's the default name of my compilation let me make it something else for example i could call it contains demo and now i'll see contains demo inside my account directory when i ls it if i want to look at more details i can find out when things were created how big they are and all that good stuff ok so i want to run it i can't just type contains demo because my shell doesn't look for the current directory as uh doesn't consider the current directory as a place of executable programs so i have to be more explicit and force it to say hey look inside the current directory and they will find contains demo and great look it worked it said it found found it at we didn't put a newline so also along the same line i got my standard kind of regular prompt ok so what do you think will happen if rather than sending test one that says delete two double quotes there what happens if	type	903
main it is amazing about function contains that so it kind of makes a guess as to where this function might be and what it looks like ok so we should fix this let's run a command called v so now i'm asking my shell to find the command that i last run that start with a v here it is of course it's vim so here's our problem we're using contains that and the compiler hasn't even seen it yet so at this point maybe i want to put a declaration insider dot h file or i could just declare what it looks like here so i'm going to tell the compiler that hey there's going to be a function called contains out that takes a character pointer and i'm not going to tell you anything more about it today i'm not going to tell you anything more about what how it's implemented just that it exists ok right so now let's compile k all we've got that one other issue to fix which is our main we didn't actually get the type here correct pointed to appointed or character white 'cause it's an array of strings so now let's try again ok great it compiles we could even try to compile with all early warnings enabled great compiled so what do we got inside the current directory i've got this thing called a door out that's the default name of my compilation let me make it something else for example i could call it contains demo and now i'll see contains demo inside my account directory when i ls it if i want to look at more details i can find out when things were created how big they are and all that good stuff ok so i want to run it i can't just type contains demo because my shell doesn't look for the current directory as uh doesn't consider the current directory as a place of executable programs so i have to be more explicit and force it to say hey look inside the current directory and they will find contains demo and great look it worked it said it found found it at we didn't put a newline so also along the same line i got my standard kind of regular prompt ok so what do you think will happen if rather than sending test one that says delete two double quotes there what happens if	string	985
main it is amazing about function contains that so it kind of makes a guess as to where this function might be and what it looks like ok so we should fix this let's run a command called v so now i'm asking my shell to find the command that i last run that start with a v here it is of course it's vim so here's our problem we're using contains that and the compiler hasn't even seen it yet so at this point maybe i want to put a declaration insider dot h file or i could just declare what it looks like here so i'm going to tell the compiler that hey there's going to be a function called contains out that takes a character pointer and i'm not going to tell you anything more about it today i'm not going to tell you anything more about what how it's implemented just that it exists ok right so now let's compile k all we've got that one other issue to fix which is our main we didn't actually get the type here correct pointed to appointed or character white 'cause it's an array of strings so now let's try again ok great it compiles we could even try to compile with all early warnings enabled great compiled so what do we got inside the current directory i've got this thing called a door out that's the default name of my compilation let me make it something else for example i could call it contains demo and now i'll see contains demo inside my account directory when i ls it if i want to look at more details i can find out when things were created how big they are and all that good stuff ok so i want to run it i can't just type contains demo because my shell doesn't look for the current directory as uh doesn't consider the current directory as a place of executable programs so i have to be more explicit and force it to say hey look inside the current directory and they will find contains demo and great look it worked it said it found found it at we didn't put a newline so also along the same line i got my standard kind of regular prompt ok so what do you think will happen if rather than sending test one that says delete two double quotes there what happens if	pointer	625
we instead passing nothing what happens if we pass in address zero so we need null know that this is equivalent to memory address zero what are things going to happen so the exciting thing here is that actually when our process runs our memories divided into different segments some parts of it is read only so for example the actual code and the string literals in the other constants that we might declare inside our function i have to be loaded into the process but that is put inside read only memory and if you try to write to that memory you can't your process will actually actually stop with the segmentation fault other parts of memory just simply do not exist yet we can have large areas of memory dresses which are not mapped to physical ram other parts of memory will be mapped to the stack and other parts that will see later on the course ok so let's try this and see what happens ok right	memory	115
we instead passing nothing what happens if we pass in address zero so we need null know that this is equivalent to memory address zero what are things going to happen so the exciting thing here is that actually when our process runs our memories divided into different segments some parts of it is read only so for example the actual code and the string literals in the other constants that we might declare inside our function i have to be loaded into the process but that is put inside read only memory and if you try to write to that memory you can't your process will actually actually stop with the segmentation fault other parts of memory just simply do not exist yet we can have large areas of memory dresses which are not mapped to physical ram other parts of memory will be mapped to the stack and other parts that will see later on the course ok so let's try this and see what happens ok right	code	334
we instead passing nothing what happens if we pass in address zero so we need null know that this is equivalent to memory address zero what are things going to happen so the exciting thing here is that actually when our process runs our memories divided into different segments some parts of it is read only so for example the actual code and the string literals in the other constants that we might declare inside our function i have to be loaded into the process but that is put inside read only memory and if you try to write to that memory you can't your process will actually actually stop with the segmentation fault other parts of memory just simply do not exist yet we can have large areas of memory dresses which are not mapped to physical ram other parts of memory will be mapped to the stack and other parts that will see later on the course ok so let's try this and see what happens ok right	string	347
we instead passing nothing what happens if we pass in address zero so we need null know that this is equivalent to memory address zero what are things going to happen so the exciting thing here is that actually when our process runs our memories divided into different segments some parts of it is read only so for example the actual code and the string literals in the other constants that we might declare inside our function i have to be loaded into the process but that is put inside read only memory and if you try to write to that memory you can't your process will actually actually stop with the segmentation fault other parts of memory just simply do not exist yet we can have large areas of memory dresses which are not mapped to physical ram other parts of memory will be mapped to the stack and other parts that will see later on the course ok so let's try this and see what happens ok right	address	54
process has stopped with what's called a segmentation fault why because we tried to read some memory that is invalid it doesn't correspond to a valid segment or area of memory so my question to you is	memory	94
where did it crash which line do you think actually cause that error so we could use a debugger but right now i'd like you to actually try to figure out where did our crash occur which line in the following code so i'll give you five seconds to have a look ready go	the following	193
where did it crash which line do you think actually cause that error so we could use a debugger but right now i'd like you to actually try to figure out where did our crash occur which line in the following code so i'll give you five seconds to have a look ready go	code	207
ok right so the very first time we try to access this memory is actually when we test it inside the while loop it's perfectly fine to pass a value of null to new variable that just means that we bought a variable holds the value zero for the zoo with memory location it's only when we try to read from that memory location will our process crash so we could have also found that out using the debugger	memory	54
ok hi right so we've got memory there we go right we've got memory virtual memory working using a page table and we've just invented a two level page table but now we actually want to think about getting recovering that performance because right now with output to level page table it takes three memory accesses in order to actually read or write the bite that we care about inside our heap or stack or whatever it wasn't part of our process ok so here's the plan then let's talk about a useful bit of hardware there's also part of the memory management unit so it's part of the cpu and it is the tlb or the translation lookaside buffer so what is this tlb the translation lookaside buffer	a page	96
ok hi right so we've got memory there we go right we've got memory virtual memory working using a page table and we've just invented a two level page table but now we actually want to think about getting recovering that performance because right now with output to level page table it takes three memory accesses in order to actually read or write the bite that we care about inside our heap or stack or whatever it wasn't part of our process ok so here's the plan then let's talk about a useful bit of hardware there's also part of the memory management unit so it's part of the cpu and it is the tlb or the translation lookaside buffer so what is this tlb the translation lookaside buffer	memory	25
ok hi right so we've got memory there we go right we've got memory virtual memory working using a page table and we've just invented a two level page table but now we actually want to think about getting recovering that performance because right now with output to level page table it takes three memory accesses in order to actually read or write the bite that we care about inside our heap or stack or whatever it wasn't part of our process ok so here's the plan then let's talk about a useful bit of hardware there's also part of the memory management unit so it's part of the cpu and it is the tlb or the translation lookaside buffer so what is this tlb the translation lookaside buffer	a page table	96
then we can skip the memory reads that we needed to translate a virtual address into a physical address	memory	21
then we can skip the memory reads that we needed to translate a virtual address into a physical address	address	72
so this is a cache it's got a limited size we can't remember what kind of all of oil look up 's and what we're basically doing is saying hey i've got a virtual memory address except that i don't need to store a look up for a particular address instead actually i'm going to store this with a page	a page	290
so this is a cache it's got a limited size we can't remember what kind of all of oil look up 's and what we're basically doing is saying hey i've got a virtual memory address except that i don't need to store a look up for a particular address instead actually i'm going to store this with a page	memory	160
so this is a cache it's got a limited size we can't remember what kind of all of oil look up 's and what we're basically doing is saying hey i've got a virtual memory address except that i don't need to store a look up for a particular address instead actually i'm going to store this with a page	address	167
the page number and i want to go from a page number to the physical frame number so let's go to the frame number	a page	38
which date we did using our multi level page tables but what if we actually had a very fast piece of memory to do this as part of the cpu and this has to be extremely quickly has to be much faster than going to actually main memory and we're going to need this every time we actually want to kind of go back to main memory every time we want to you want to calculate and physical frame so the speed of this implementation it is critical and in fact it's gotta look aside because the cpu starts going down both these paths at the same time this is where ns count even tense of nanoseconds count so let's start asking the tlb as we fire up the machinery to talk to main memory to walk through the page tables but hopefully we won't need to complete that task because the tlb will say uh huh i have the answer for you i can tell you the physical frame for what you need now why is the tlb in practice so useful	memory	101
means that if you've just recently accessed particular piece of memory so low cal make sure i can spell this locality so for example if you've just read byte a zero zero zero seven then there's a good chance that in the near future you're going to be accessing neighboring bites as well so for example zero zero eight right or something within the same page so the fact that we are	memory	64
look up within the same page great we already have that information so that special locality the idea that neighboring address is going to be used in the near future and then there's temporal locality as well which is just that if you access one location you're likely to access the same location again in the future	address	119
ok so hey i've just initialized my variable say some location here or i've just read this code and i'm probably going to be writing into this same location again in the future because my code is going down to loop for example or because i have a counter or total and i keep writing into that ok so it's these two aspects of the programs that we write which make the tlb so useful	code	90
kind of as a quick sketch you realize that the page numbers were talking about our virtual memory addresses process specific so the mappings that we do always of course per process if we fork we make a child that is going to have a different mapping to different physical memory so when we do a context switch from one process to another we need to make sure that we don't use the old mappings because they were	memory	91
kind of as a quick sketch you realize that the page numbers were talking about our virtual memory addresses process specific so the mappings that we do always of course per process if we fork we make a child that is going to have a different mapping to different physical memory so when we do a context switch from one process to another we need to make sure that we don't use the old mappings because they were	address	98
with four eight different process right so all the page numbers all of our virtual addresses only makes sense in terms of the current process so you could look over time to say after i switched to a new process how likely is it that i've actually got the results that i need inside the tlb and so initially say it might be zero percent but overtime hopefully it's going to get close to say ninety nine percent or depending on the start of the project it may not get to that number if my code is has lots of branching and it's very difficult to predict where it's going to go but let's let's sketch up time that exponentially	code	487
with four eight different process right so all the page numbers all of our virtual addresses only makes sense in terms of the current process so you could look over time to say after i switched to a new process how likely is it that i've actually got the results that i need inside the tlb and so initially say it might be zero percent but overtime hopefully it's going to get close to say ninety nine percent or depending on the start of the project it may not get to that number if my code is has lots of branching and it's very difficult to predict where it's going to go but let's let's sketch up time that exponentially	address	83
the likelihood of a cache hit my tlb is going to head towards some asymptotic bound hopefully close to a hundred percent but we can't guarantee that so that means that overtime my program will actually get a little bit faster because now i no longer need to walk the page tables and my memory accesses direct	memory	286
so let's see if we can break into it ok let's see if we can hack the address a i mean you still used to hacking us i think we should go the other way around right ok so here we go to make it a little bit more of a challenge i'm going to make sure that you've only got four seconds to	address	69
as a type if we want to handle this actually is missing the second a but what we're going to do is rather than	type	5
so that's what this alarm function does it says hey colonel please generate a cig alarm for me in exactly four seconds time or close to four seconds time alright so my first challenge to you is what is the secret password that we need to enter so quickly read this code see if you can read this c code see if you can workout what each part is doing because you've only got four seconds to escape this little while loop to get the password right if you do get it correct then what happens next well so we do port s alright so let's continue line so presumably that's probably going to be flushed out if we just in line buffering mode and then we call exec and we're going to ssh ok so we wanna find ssh that's precious name and then we're going to say hey ssh your argument is an essay backdoor dot net let's connect to that and finally of course no pointed yet	code	265
ok so what do we do in this right in this little loop it asked you to guess the password and then we call f get s which we pass in standard in and we say here's the size of my result we better check to see that's an array and yes it's an array of twenty characters so we're saying to africa this hey please fill in this memory don't give me a string greater than twenty characters if it succeeds then forget it will return non null result ok so and his bed we wanted to write into ok so right can you tell me the password is let's try it ok so i'll compile it and run it	memory	320
ok so what do we do in this right in this little loop it asked you to guess the password and then we call f get s which we pass in standard in and we say here's the size of my result we better check to see that's an array and yes it's an array of twenty characters so we're saying to africa this hey please fill in this memory don't give me a string greater than twenty characters if it succeeds then forget it will return non null result ok so and his bed we wanted to write into ok so right can you tell me the password is let's try it ok so i'll compile it and run it	string	343
why are you ok so we have gcs es alarm dot c just to prove that you're kind of the code that we're looking at ok so great	code	83
right and it says your four seconds password or click what is it too slow and look bash printed out a little helpful commands to say hey hope i can tell from the weight pid values and those macros that the alarm clock was the alarm signal was responsible for killing that process ok so let's try again hopefully by now you've figured out that this code is saying that the very first bite of my result has to be a hash character ok or pound characters seem to be calling in american so let's try this let's put in a hash and fantastic we're connected the l s a o	code	348
wait did you notice something here that alarm clock still went off so even though we managed to ssh into the nsa server we didn't have a chance to download any files because in four seconds time that colonel sent the alarm clock to the very same process remember we had when you call exec you do not actually create a new process you give your existing processor head transplant and ask it to load in all of the new code and start with a new he put a fresh stack and all that good stuff	code	416
ok so why was it that any password worked less can actually look at that code and see if we could improve it ok so we	code	73
here's here's what the little change here is that you possibly read that as weird as result equal and classified available put whitespace around it you might have notice this area as well so you assume that code said hey does it result equal to hash	code	207
instead they said ok dereference result and change that into a hash right so this modifies some memory one bite of memory and then uses it as a result and the result of the hash or pound symbol there is a non zero value and non zero value inside if means success so we do end up break breaking out of this so it doesn't matter what we type we will always break out of that loop	memory	96
instead they said ok dereference result and change that into a hash right so this modifies some memory one bite of memory and then uses it as a result and the result of the hash or pound symbol there is a non zero value and non zero value inside if means success so we do end up break breaking out of this so it doesn't matter what we type we will always break out of that loop	type	335
so you might have said well why is it that i didn't see any warnings when you compile the code ok so let me run this one more time case so we have nsa alarm	code	90
ok now i'm seeing some warnings here that the compiler modern c compilers spot this is a common mistake so they spot this and give us a warning it still compiles so i can still run this but in my first little demo to you i deliberately suppress that warning by putting an extra pair or parentheses around this because sometimes doing an assignment inside an if statement or while statement statement is exactly what you want to do so that's how i got away with that that's neat little trick the last thing we might change in this code is we could we might say it doesn't seem right to return zero if our ssh fail and we could we could change this code so that we could install a single arm so that it starts getting testy with start saying giving us some warning that hey you're running out of time to enter your password that kind of thing but that's kind of cute little demo and finally how was it that i was able to log into the nsa nsa perhaps i purchased this domain name well i could have done but actually not quite here was a trick is that with my ssh i can define an ssh config	code	530
hi welcome to like twenty four we're going to start with a quick code review let's see look at this attempted waiting a fixed sized ring buffer and we'll see if we can figure out how it might go wrong ok so some of the things that we want to ask are is deadlock possible in other words could get stuck so that's never able to continue is underflow possible in other words could it be that we attempt to write so attempt to read some data that's not actually inside the ring buffer so will just be reading back some garbage information or perhaps overflow as possible which means that we're able to put more data into my buffer then it can actually hold so presumably we were going to corrupt something possibly value that we have not yet written out so what do we got here we have	code	65
two counting semaphores and will see the s one is initialized to two hundred and fifty six so this smells to me like some kind of capacity counting thing which is going to go down as we started add things and as two is initialized to zero so s two sounds to me like it's going to be counting the number of items in ok let's touch you have a look at the code then for my enqueue and dequeue or nq and deck so i see i'm going to move text lock ok so that's good so that only one thread at the time can be actually inside this code and in fact for this particular implementation is chosen to use the same mutex lock for both the nq in the dequeue ok but i do notice inside this implementation is that normally what do we do normally send post so the same way it happens first and we normally only have the mutex lock that wraps the buffer call as well so yeah	code	353
two counting semaphores and will see the s one is initialized to two hundred and fifty six so this smells to me like some kind of capacity counting thing which is going to go down as we started add things and as two is initialized to zero so s two sounds to me like it's going to be counting the number of items in ok let's touch you have a look at the code then for my enqueue and dequeue or nq and deck so i see i'm going to move text lock ok so that's good so that only one thread at the time can be actually inside this code and in fact for this particular implementation is chosen to use the same mutex lock for both the nq in the dequeue ok but i do notice inside this implementation is that normally what do we do normally send post so the same way it happens first and we normally only have the mutex lock that wraps the buffer call as well so yeah	thread	477
right hi so here's three world known synchronization problems there are well known because they occur all the time and they are generally useful for all kinds of applications as i explain them i think you'll see why in fact i encourage you to think about applications where might this might be useful so the first idea is i want to make a barrier in other words i've got a whole load of thread switch off doing their things independently queso this one might be downloading something this one might be loading some code this one might be talking to the sound processor there might be talking to the gpu off they go and we're not quite sure when they're going to finish but what i do want to make sure is that they all arrive at some temporary stopping point here and we get to choose when to open the gate case so we get for example to say when all of these threads arrive at this point then will let order them continue so that's the idea of a barrier common example might be say i've got a big numerical matrix and i'm going to divide the problem up so that each thread works on portion of this and only after each thread has finished working what we do the next stage now we've got say a matrix which we've inverted or matrix which we've rotated so now we've got a complete answer we can continue to do the next thing	code	515
right hi so here's three world known synchronization problems there are well known because they occur all the time and they are generally useful for all kinds of applications as i explain them i think you'll see why in fact i encourage you to think about applications where might this might be useful so the first idea is i want to make a barrier in other words i've got a whole load of thread switch off doing their things independently queso this one might be downloading something this one might be loading some code this one might be talking to the sound processor there might be talking to the gpu off they go and we're not quite sure when they're going to finish but what i do want to make sure is that they all arrive at some temporary stopping point here and we get to choose when to open the gate case so we get for example to say when all of these threads arrive at this point then will let order them continue so that's the idea of a barrier common example might be say i've got a big numerical matrix and i'm going to divide the problem up so that each thread works on portion of this and only after each thread has finished working what we do the next stage now we've got say a matrix which we've inverted or matrix which we've rotated so now we've got a complete answer we can continue to do the next thing	thread	387
p three condition wait there's one variant of barrier we can call it a one shot or even a repeatable barrier so you can imagine that i've got say a whole load of threads here they come out to their barrier point we're not going to exit these threads are just going to be temporarily paused then when finally the final thread, this laggard is finally gotten finished as well will let them all go so off they go again and then when they all finally have reached the next waiting point that's when we let them all go so off we will release them all so you can see now i've got a barrier which i can use repeatedly right so that's a barrier now let's talk about a producer consumer or there let's not we've already talked about the idea of a producer consumer the idea is a producer and i might have more than one of them is putting things into some kind of queue or data structure maybe a file store but there is some idea that i've got some kind of data structure inside here which represents a collecting point and then i've got a consumer which consumes things out of there and i need to correctly synchronize these things so that i never accidentally gave invalid data to the consumer or i never let the producer overfill my data structure and we've seen an implementation of that using a fixed sized ring buffer and we used some counterexample force	a struct	866
p three condition wait there's one variant of barrier we can call it a one shot or even a repeatable barrier so you can imagine that i've got say a whole load of threads here they come out to their barrier point we're not going to exit these threads are just going to be temporarily paused then when finally the final thread, this laggard is finally gotten finished as well will let them all go so off they go again and then when they all finally have reached the next waiting point that's when we let them all go so off we will release them all so you can see now i've got a barrier which i can use repeatedly right so that's a barrier now let's talk about a producer consumer or there let's not we've already talked about the idea of a producer consumer the idea is a producer and i might have more than one of them is putting things into some kind of queue or data structure maybe a file store but there is some idea that i've got some kind of data structure inside here which represents a collecting point and then i've got a consumer which consumes things out of there and i need to correctly synchronize these things so that i never accidentally gave invalid data to the consumer or i never let the producer overfill my data structure and we've seen an implementation of that using a fixed sized ring buffer and we used some counterexample force	thread	162
to temporarily block the producer or the consumer ok so that's the classic producer consumer problem and then the last one we're going to look at inside cs two forty one is so-called reader writer problem ok so now you could imagine i've got a data structure where	block	15
to temporarily block the producer or the consumer ok so that's the classic producer consumer problem and then the last one we're going to look at inside cs two forty one is so-called reader writer problem ok so now you could imagine i've got a data structure where	a struct	247
i which might be say on disk and and in memory so it could be a kind of quite complicated device but i can have multiple readers now that want to be able to access this thing so lots of little reader threads say doing look up diction you look up 's file openings maybe for database table doing a big search for this kind of thing but occasionally i have a writer	memory	40
i which might be say on disk and and in memory so it could be a kind of quite complicated device but i can have multiple readers now that want to be able to access this thing so lots of little reader threads say doing look up diction you look up 's file openings maybe for database table doing a big search for this kind of thing but occasionally i have a writer	thread	200
that wants to change it and when i change my data structure i need to temporarily say ok writers	a struct	48
cape i need you to be blocked right now so that's really weird this toy digger red color ok so writers get your hands off my data structure right now i'm making changes to it i'm updating a linked list i'm copying over my	block	22
cape i need you to be blocked right now so that's really weird this toy digger red color ok so writers get your hands off my data structure right now i'm making changes to it i'm updating a linked list i'm copying over my	a struct	128
hash dictionary to a larger piece of memory that kind of thing so i'm running to allow one writer to actually modify it and a writer also has to wait whilst as any active readers so if there's a really currently working through a link list let's wait until they finish before the writer say starts modifying that linked list and in fact if i've got an active writer modifying this data structure then if another way to appears then they have to wait as well so that is a classic reader wait a problem that i can have multiple readers but only one active writer	memory	37
hash dictionary to a larger piece of memory that kind of thing so i'm running to allow one writer to actually modify it and a writer also has to wait whilst as any active readers so if there's a really currently working through a link list let's wait until they finish before the writer say starts modifying that linked list and in fact if i've got an active writer modifying this data structure then if another way to appears then they have to wait as well so that is a classic reader wait a problem that i can have multiple readers but only one active writer	a struct	384
and when i have an active writer everybody else has to get their grubby hands off the data structure other writers can't right	the data structure	82
and when i have an active writer everybody else has to get their grubby hands off the data structure other writers can't right	a struct	89
readers can't beat ok so we had to figure out how to implement that alright that's all three classic problems you should be able to explain these and also write code to implement them by	code	161
there we go you might desire your ssd to look a bit like this whole load of flash memory	memory	82
but anyways so we have a little processor inside there and this job is to use this flash memory not only efficiently but given that it wears out we want to make sure that we push our rights in their different the physical areas of the flash memory overtime so this is called wear leveling so that whole device degrades overtime as opposed to say one particular area suddenly stops working ok inside our device we also need some ram because we're going to receive piece of information to write and yet our flash may not be ready to store that so we need a temporary some temporary buffer space similar we may choose if we can detect the pattern of read requests we may choose to read ahead so that we have the next block of data ready to go when the host asked for it so again we need some some storage space and buffer space and finally we may decide to reorganize how we're storing data on our flash so again i need some some more ram for my processor ok the other thing we have here is the host interface logic so too common interfaces today are saturn	memory	89
but anyways so we have a little processor inside there and this job is to use this flash memory not only efficiently but given that it wears out we want to make sure that we push our rights in their different the physical areas of the flash memory overtime so this is called wear leveling so that whole device degrades overtime as opposed to say one particular area suddenly stops working ok inside our device we also need some ram because we're going to receive piece of information to write and yet our flash may not be ready to store that so we need a temporary some temporary buffer space similar we may choose if we can detect the pattern of read requests we may choose to read ahead so that we have the next block of data ready to go when the host asked for it so again we need some some storage space and buffer space and finally we may decide to reorganize how we're storing data on our flash so again i need some some more ram for my processor ok the other thing we have here is the host interface logic so too common interfaces today are saturn	block	714
which is you'll find this serial ata you'll find this in kind of older storage devices and probably you're you're spinning disk today is using a satta type interface	type	151
this is an interface designed specifically for storage mechanisms but it's a little slow today it was fine we had spinning disks but today's solid state storage is so fast were actually hitting the constraints of the satur interface so saturday today is slightly cheaper than the other alternative switch today you can find an m v e gently remember these initials but these basically connect directly to the pci bus or pci express bus so ssd chip can talk directly to the cpu so it's much faster to be able to shuffle information from the ssd into main memory or even directly into the gpu as well so this does come important if you're ever decided to upgrade your pc or building your own pc pay attention to the actual physical or electrical connections that your device will support	memory	553
overtime we might discover parts of our storage are no longer function correctly for example we are no longer able to write to a particular block so rather than simply declared the whole device as dead we can use what's called bad block mapping or sometimes bad block remapping where we delivery section off parts of the physical storage and so that they don't appear inside are kind of abstracted version of what the story actually looks like circle secondly we may use error correcting code	block	140
overtime we might discover parts of our storage are no longer function correctly for example we are no longer able to write to a particular block so rather than simply declared the whole device as dead we can use what's called bad block mapping or sometimes bad block remapping where we delivery section off parts of the physical storage and so that they don't appear inside are kind of abstracted version of what the story actually looks like circle secondly we may use error correcting code	code	488
overtime we might discover parts of our storage are no longer function correctly for example we are no longer able to write to a particular block so rather than simply declared the whole device as dead we can use what's called bad block mapping or sometimes bad block remapping where we delivery section off parts of the physical storage and so that they don't appear inside are kind of abstracted version of what the story actually looks like circle secondly we may use error correcting code	section	296
we talked a little bit about this with google 's case and the idea that we want to be able to cope occassion with errors when you start having devices that can store ten to the twelve bits it's not that unlikely to start to see very a small errors and if we used an error correcting code for example a simple paraty code or better a reed solomon code then we can actually detect and correct single bit errors ok i think some other things i want to do is do things like block erasing when i finish with the block i don't want to have to erase each individual byte instead i want to erase say four thousand ninety six bytes all in one go we've already talked about wear leveling we want to make sure that we're using we're writing to the whole storage area as a whole so that we don't excessively wear out one particular area of it we want to do some reading white cashing we want the fastest	block	469
we talked a little bit about this with google 's case and the idea that we want to be able to cope occassion with errors when you start having devices that can store ten to the twelve bits it's not that unlikely to start to see very a small errors and if we used an error correcting code for example a simple paraty code or better a reed solomon code then we can actually detect and correct single bit errors ok i think some other things i want to do is do things like block erasing when i finish with the block i don't want to have to erase each individual byte instead i want to erase say four thousand ninety six bytes all in one go we've already talked about wear leveling we want to make sure that we're using we're writing to the whole storage area as a whole so that we don't excessively wear out one particular area of it we want to do some reading white cashing we want the fastest	code	283
device as possible and typically the device read write patterns fall into either a synchronous read so imagine you're pulling all the bytes for a video file i just want to get in say four gigabytes of data as quickly as possible or for example you're starting up the operating system or you are loading an application you just want to move in as many bytes as possible one after another or random so you have random read write access patterns where now you want to jump to jump around a file or jump between many different files and now the amount of data you want per request is relatively small but now you have thousands of requests per second	system	277
but they want to handle is garbage collection so what do we do when we declare that particular block is available	block	95
ok today in the quest for more bits per dollar today we can actually pack more than one actual bit per cell that we can store on this so in the beginning you'll still find some memory delight this today each cell	memory	177
each part that could receive a single bit of information was used literally to store one piece of information and if you do this you can rewrite that particular cell a large number of times a hundred thousand times now in fact you don't just rewrite that particular cell in fact the way that that ssd 's work is you erase an entire block so if i've got say block let's say four thousand ninety six bytes but it could actually be a different size and you decided to change one bit	block	332
then that whole block is now invalid i'm going to have to actually	block	16
to write the entire block again with that single bit changed and later on my processor inside the ssd the little controller can mark this single piece of area single block as available again and can electrically reset that entire set of cells	block	20
ok notice that we have kind of what's called write amplification happening here which is the the user program just set one bit but we had to actually write more than four thousand ninety six bytes or however big the blocksize happened to be on the device which is much larger than one bit but anyway so if i have the single bit purcell then empirically i can do about a hundred thousand lights for sale before that sell doesn't accept anymore writes ok today however in the quest to make of memory cheaper more bytes per per dollar we actually don't write a single bit per cell on a typical especially commodity devices you'll see that instead there's what's called multi level cells where now we can store two bits or even triple level cells and as of two thousand and nineteen there's now quad level cells as well ok where we store four bits	memory	491
ok notice that we have kind of what's called write amplification happening here which is the the user program just set one bit but we had to actually write more than four thousand ninety six bytes or however big the blocksize happened to be on the device which is much larger than one bit but anyway so if i have the single bit purcell then empirically i can do about a hundred thousand lights for sale before that sell doesn't accept anymore writes ok today however in the quest to make of memory cheaper more bytes per per dollar we actually don't write a single bit per cell on a typical especially commodity devices you'll see that instead there's what's called multi level cells where now we can store two bits or even triple level cells and as of two thousand and nineteen there's now quad level cells as well ok where we store four bits	block	216
ok so today that's where we are with quad the widely chases however is that you can buy more storage per dollar alright so there's very brief introduction to ssds the i guess the last thing i'll just mention is that that today when you buy one not only do you look for whether you won't see any us satyr or pci type interface	type	311
hi ok so let's talk about when we can generate bus signals an memory alignment issues supposed i told you i've got some memory for an integer k so here we go you can have a little pointer to my memory there we go i'll give you an address and then you said ok great and now i want to use that i'm going to store an integer there so let me right into that piece of memory and i'll write some value like seven ok wait so you and i know that the number of bytes written there gonna be saved four bytes if my integers on a particular platform for bites ok now what if i had given you an interesting address suppose i'd said something like here haven't address like our core malloc i'll get myself some bites so i'll get four thousand bytes or so and then i'm going	memory	62
hi ok so let's talk about when we can generate bus signals an memory alignment issues supposed i told you i've got some memory for an integer k so here we go you can have a little pointer to my memory there we go i'll give you an address and then you said ok great and now i want to use that i'm going to store an integer there so let me right into that piece of memory and i'll write some value like seven ok wait so you and i know that the number of bytes written there gonna be saved four bytes if my integers on a particular platform for bites ok now what if i had given you an interesting address suppose i'd said something like here haven't address like our core malloc i'll get myself some bites so i'll get four thousand bytes or so and then i'm going	address	230
hi ok so let's talk about when we can generate bus signals an memory alignment issues supposed i told you i've got some memory for an integer k so here we go you can have a little pointer to my memory there we go i'll give you an address and then you said ok great and now i want to use that i'm going to store an integer there so let me right into that piece of memory and i'll write some value like seven ok wait so you and i know that the number of bytes written there gonna be saved four bytes if my integers on a particular platform for bites ok now what if i had given you an interesting address suppose i'd said something like here haven't address like our core malloc i'll get myself some bites so i'll get four thousand bytes or so and then i'm going	pointer	180
to add three to that to give you an odd numbered address who or perhaps i explicitly calculating address which was odd what do you think is going to happen well on some systems the code would still work it would still the cpu would still be able to store the bit pattern common spending to seven and you'd be lucky it would work however is performance might not be as fast on early chips there was actually quite a significant performance penalty that it would take twice as long	code	181
to add three to that to give you an odd numbered address who or perhaps i explicitly calculating address which was odd what do you think is going to happen well on some systems the code would still work it would still the cpu would still be able to store the bit pattern common spending to seven and you'd be lucky it would work however is performance might not be as fast on early chips there was actually quite a significant performance penalty that it would take twice as long	address	49
to add three to that to give you an odd numbered address who or perhaps i explicitly calculating address which was odd what do you think is going to happen well on some systems the code would still work it would still the cpu would still be able to store the bit pattern common spending to seven and you'd be lucky it would work however is performance might not be as fast on early chips there was actually quite a significant performance penalty that it would take twice as long	system	169
actions over the memory bust in order to store or read that value so congratulations you just made your program is twice as slow but on other systems it would be worse it would crash the cpu would refuse to memory	memory	17
actions over the memory bust in order to store or read that value so congratulations you just made your program is twice as slow but on other systems it would be worse it would crash the cpu would refuse to memory	system	142
system would refuse to store a four byte value at such an evil location i'm not storing four byte values starting with an odd address and in fact therefore we need to actually think about this idea of natural alignment and the idea is very simple that if i've got a primitive such as an int which is four bytes that i should store it on a four byte boundary in other words dear dress that i'm using should be zero modulo four and if i've got something which is say takes eight bytes like double or a pointer on a sixty four bit system	address	126
system would refuse to store a four byte value at such an evil location i'm not storing four byte values starting with an odd address and in fact therefore we need to actually think about this idea of natural alignment and the idea is very simple that if i've got a primitive such as an int which is four bytes that i should store it on a four byte boundary in other words dear dress that i'm using should be zero modulo four and if i've got something which is say takes eight bytes like double or a pointer on a sixty four bit system	system	0
system would refuse to store a four byte value at such an evil location i'm not storing four byte values starting with an odd address and in fact therefore we need to actually think about this idea of natural alignment and the idea is very simple that if i've got a primitive such as an int which is four bytes that i should store it on a four byte boundary in other words dear dress that i'm using should be zero modulo four and if i've got something which is say takes eight bytes like double or a pointer on a sixty four bit system	pointer	500
then i need to store that on an address which is an eight byte boundary so the alignment requirements depend upon the size of the actual type the thing that i'm trying to store if i'm just storing characters there you can store them in any any possible bite if i'm storing shorts to bite shorts then i need to make sure they are stored and even address for example ok so that's a great idea about natural alignment	type	137
then i need to store that on an address which is an eight byte boundary so the alignment requirements depend upon the size of the actual type the thing that i'm trying to store if i'm just storing characters there you can store them in any any possible bite if i'm storing shorts to bite shorts then i need to make sure they are stored and even address for example ok so that's a great idea about natural alignment	address	32
and ignore it at your peril so this means that any addresses that we return for malloc better be aligned to a sixteen byte boundary case so with that in mind then what will do is when we write our malloc we're actually going to round up all of our allocations to sixteen bytes and in fact this is what the c library does on a sixty four bit system	address	51
and ignore it at your peril so this means that any addresses that we return for malloc better be aligned to a sixteen byte boundary case so with that in mind then what will do is when we write our malloc we're actually going to round up all of our allocations to sixteen bytes and in fact this is what the c library does on a sixty four bit system	system	341
so if we do this if all of our allocations are always conceptually in sixteen byte blocks then will ensure that will always be returning addresses which are	block	83
so if we do this if all of our allocations are always conceptually in sixteen byte blocks then will ensure that will always be returning addresses which are	address	137
aligned to sixteen bytes and if they were lined to sixteen bytes that should be a good enough nearly all primitives so intent short double etc etc so it turns out that a modern cpu does have a couple of native types which are larger than sixteen bytes but we won't worry about that for our memory allocator today alright so we've got	memory	290
aligned to sixteen bytes and if they were lined to sixteen bytes that should be a good enough nearly all primitives so intent short double etc etc so it turns out that a modern cpu does have a couple of native types which are larger than sixteen bytes but we won't worry about that for our memory allocator today alright so we've got	type	210
we've got this challenge was saying how she ran up to sixteen bytes here's our basic plan let's calculator size inside our malloc code ok to say this is the actual request that you're going to do so you want the size in bytes but here's what i'm going to do i'm going to add fifteen to this	code	130
for you ask me for any value between sixteen and thirty one i am going to assume that really you wanted just thirty two bites but you'll notice i didn't actually then multiply back up by sixteen no in fact i'm going to write my my lock code now always with regards to these sixteen byte boundaries so conceptually now i'm going to stop thinking about my my	code	236
my memory in terms of bytes for the rest of my malloc code i want to think about it now as all of my distances and spaces are actually going to be conceptually sixteen bytes so now when i do any point arithmetic	memory	3
my memory in terms of bytes for the rest of my malloc code i want to think about it now as all of my distances and spaces are actually going to be conceptually sixteen bytes so now when i do any point arithmetic	code	54
or talk about sizes i'm going to talk about it anymore i'm just going to actually think about it in terms of these blocks where each block is sixteen bytes wide and if i kind of keep that convention then it starts to make my my lock code	block	115
or talk about sizes i'm going to talk about it anymore i'm just going to actually think about it in terms of these blocks where each block is sixteen bytes wide and if i kind of keep that convention then it starts to make my my lock code	code	233
about it when i'm doing internal memory pointers if i just say this is always how i'm going to treat my code or my pointers etc are going to be this type or my editions will be based on this ok so what do we lose well we lose a little bit of flexibility were potentially over allocating bites so in fact we might need to a small amount of wasted space	memory	33
about it when i'm doing internal memory pointers if i just say this is always how i'm going to treat my code or my pointers etc are going to be this type or my editions will be based on this ok so what do we lose well we lose a little bit of flexibility were potentially over allocating bites so in fact we might need to a small amount of wasted space	type	149
about it when i'm doing internal memory pointers if i just say this is always how i'm going to treat my code or my pointers etc are going to be this type or my editions will be based on this ok so what do we lose well we lose a little bit of flexibility were potentially over allocating bites so in fact we might need to a small amount of wasted space	code	104
about it when i'm doing internal memory pointers if i just say this is always how i'm going to treat my code or my pointers etc are going to be this type or my editions will be based on this ok so what do we lose well we lose a little bit of flexibility were potentially over allocating bites so in fact we might need to a small amount of wasted space	pointer	40
hi welcome to let your nineteen so we can develop what's called the reader writer implementation in fact we're going to develop something called writers priority implementation before we jump into any code there's actually think less sketch out what we'd like to see ok so for this looks good blank piece alright so what do we got let's give ourselves a data structure ok so right now there's no one munching on our data structure that one visiting it but will say this just lives in the center there we go	a struct	357
hi welcome to let your nineteen so we can develop what's called the reader writer implementation in fact we're going to develop something called writers priority implementation before we jump into any code there's actually think less sketch out what we'd like to see ok so for this looks good blank piece alright so what do we got let's give ourselves a data structure ok so right now there's no one munching on our data structure that one visiting it but will say this just lives in the center there we go	code	201
and occasionally i have readers come along so here's a reader right there not interacting with the data structure yet but if we let them ok they can jump inside the data structure so maybe it'll open some files go through a linked list that kind of thing and so right	the data structure	95
and occasionally i have readers come along so here's a reader right there not interacting with the data structure yet but if we let them ok they can jump inside the data structure so maybe it'll open some files go through a linked list that kind of thing and so right	a struct	102
now they are in there going through that data structure eventually they'll find what they want and they can leave and of course i could have multiple readers so here's another reader that's coming along well let him go through and we can have more than one reader at a time so he's doing it's thing over there and then	a struct	44
reader coming in here and she needs to find some information ok right so you can see that i've got a very active set of readers always trying to use my data structure here ok so occasionally we have a writer so now it's time to change our data structure ok so here's the writer on the scene but they're going to have to wait why because i've got a whole load of readers which are currently inside that data structure so it's only when these reader threads actually leave the data structure	the data structure	471
reader coming in here and she needs to find some information ok right so you can see that i've got a very active set of readers always trying to use my data structure here ok so occasionally we have a writer so now it's time to change our data structure ok so here's the writer on the scene but they're going to have to wait why because i've got a whole load of readers which are currently inside that data structure so it's only when these reader threads actually leave the data structure	a struct	155
reader coming in here and she needs to find some information ok right so you can see that i've got a very active set of readers always trying to use my data structure here ok so occasionally we have a writer so now it's time to change our data structure ok so here's the writer on the scene but they're going to have to wait why because i've got a whole load of readers which are currently inside that data structure so it's only when these reader threads actually leave the data structure	thread	448
meaning that we don't have anybody that actually inside there will we let our read writer change so ok right and now you can go into the data structure	the data structure	133
meaning that we don't have anybody that actually inside there will we let our read writer change so ok right and now you can go into the data structure	a struct	140
now i've got the writer in there let's clean this up a little bit to purdue purdue purdue right just get into my old readers if any new readers are wife key i guess we better put up data structure back here it is right if any new readers arrive then they have to wait	a struct	185
it allowed to actually enter the building until we've finished changing it ok so well swim changing the maze around or maze runners have to wait ok so there's stuck outside i'm going to let them out once this particular writer finishes so if you want to do ok there we go right only when this righteous come out when we let anybody else into the data structure ok and simply if another right appears on the scene they would have to wait until no one else is updating it so once that is once it is available they get to go in ok so that's the sketch of the logic that we need notice that there's several kind of moments that we might need to block things so here's our first block we need to block readers if there's any writers around right we want to stop the hoard if we don't stop the horde then we run into a problem called vita starvation where because there's always a new reader going to be arriving there's never a good time to actually update the data structure there's always at least one read it in there	block	641
it allowed to actually enter the building until we've finished changing it ok so well swim changing the maze around or maze runners have to wait ok so there's stuck outside i'm going to let them out once this particular writer finishes so if you want to do ok there we go right only when this righteous come out when we let anybody else into the data structure ok and simply if another right appears on the scene they would have to wait until no one else is updating it so once that is once it is available they get to go in ok so that's the sketch of the logic that we need notice that there's several kind of moments that we might need to block things so here's our first block we need to block readers if there's any writers around right we want to stop the hoard if we don't stop the horde then we run into a problem called vita starvation where because there's always a new reader going to be arriving there's never a good time to actually update the data structure there's always at least one read it in there	the data structure	342
it allowed to actually enter the building until we've finished changing it ok so well swim changing the maze around or maze runners have to wait ok so there's stuck outside i'm going to let them out once this particular writer finishes so if you want to do ok there we go right only when this righteous come out when we let anybody else into the data structure ok and simply if another right appears on the scene they would have to wait until no one else is updating it so once that is once it is available they get to go in ok so that's the sketch of the logic that we need notice that there's several kind of moments that we might need to block things so here's our first block we need to block readers if there's any writers around right we want to stop the hoard if we don't stop the horde then we run into a problem called vita starvation where because there's always a new reader going to be arriving there's never a good time to actually update the data structure there's always at least one read it in there	a struct	349
anybody new arriving so that's our first block the second block we talked about was for the readers	block	41
so for the rights is that writer has to be blocked if there's any existing readers in there so whilst i've got old reader working through this data structure i have to block any writers that want to scene and we're going to let him go once that the existing readers have left the writers themselves were going to make sure the only one at a time is released in order to go into the data structure so we got a lot of logic to think about	block	43
so for the rights is that writer has to be blocked if there's any existing readers in there so whilst i've got old reader working through this data structure i have to block any writers that want to scene and we're going to let him go once that the existing readers have left the writers themselves were going to make sure the only one at a time is released in order to go into the data structure so we got a lot of logic to think about	the data structure	378
so for the rights is that writer has to be blocked if there's any existing readers in there so whilst i've got old reader working through this data structure i have to block any writers that want to scene and we're going to let him go once that the existing readers have left the writers themselves were going to make sure the only one at a time is released in order to go into the data structure so we got a lot of logic to think about	a struct	146
and the way we're going to do this is to keep track of several things here we're going to have the number of actual readers that would like to read so here they are is all my reader threads that are either waiting to read or currently reading and then a subset of those are actually in the data structure right now and so we will call this the number of active readers	the data structure	286
and the way we're going to do this is to keep track of several things here we're going to have the number of actual readers that would like to read so here they are is all my reader threads that are either waiting to read or currently reading and then a subset of those are actually in the data structure right now and so we will call this the number of active readers	a struct	293
and the way we're going to do this is to keep track of several things here we're going to have the number of actual readers that would like to read so here they are is all my reader threads that are either waiting to read or currently reading and then a subset of those are actually in the data structure right now and so we will call this the number of active readers	thread	182
there we do and i might have the case where new readers are blocked because a writer has just appeared similar lesser by symmetry also keep track of the number of writers	block	60
and we could also count the number of active writers though if we've implemented it correctly the number of active writers can only ever be either zero or one ok we're not going to support multiple writers changing our data structure so that's going to be our four variables and now we need to implement blocking code to ensure that we correctly implement the read lock and the right lock so let's go to have a go at doing that right so	block	304
and we could also count the number of active writers though if we've implemented it correctly the number of active writers can only ever be either zero or one ok we're not going to support multiple writers changing our data structure so that's going to be our four variables and now we need to implement blocking code to ensure that we correctly implement the read lock and the right lock so let's go to have a go at doing that right so	a struct	222
and we could also count the number of active writers though if we've implemented it correctly the number of active writers can only ever be either zero or one ok we're not going to support multiple writers changing our data structure so that's going to be our four variables and now we need to implement blocking code to ensure that we correctly implement the read lock and the right lock so let's go to have a go at doing that right so	code	313
be actually performing writing currently i've got the number of readers currently accessing the data structure so whilst that is non zero my writers are going to have to wait and also the number of readers they would like or want to be reading so this may be larger than the number of readers actually reading ok so with that in mind it's actually kind of see how we've sketched this out ok obviously we have some mutex locks to ensure that we update these variables atomically but the very first thing we're going to do then for each of these sections is to is to either call preferred mutex lock or unlock so for a few microseconds we hold onto a log but that's only for us to do some accounting either we will immediately a scape can have through this code or we will end up calling peter condition way in which case we release the mutex anyway	the data structure	92
be actually performing writing currently i've got the number of readers currently accessing the data structure so whilst that is non zero my writers are going to have to wait and also the number of readers they would like or want to be reading so this may be larger than the number of readers actually reading ok so with that in mind it's actually kind of see how we've sketched this out ok obviously we have some mutex locks to ensure that we update these variables atomically but the very first thing we're going to do then for each of these sections is to is to either call preferred mutex lock or unlock so for a few microseconds we hold onto a log but that's only for us to do some accounting either we will immediately a scape can have through this code or we will end up calling peter condition way in which case we release the mutex anyway	a struct	99
be actually performing writing currently i've got the number of readers currently accessing the data structure so whilst that is non zero my writers are going to have to wait and also the number of readers they would like or want to be reading so this may be larger than the number of readers actually reading ok so with that in mind it's actually kind of see how we've sketched this out ok obviously we have some mutex locks to ensure that we update these variables atomically but the very first thing we're going to do then for each of these sections is to is to either call preferred mutex lock or unlock so for a few microseconds we hold onto a log but that's only for us to do some accounting either we will immediately a scape can have through this code or we will end up calling peter condition way in which case we release the mutex anyway	code	755
be actually performing writing currently i've got the number of readers currently accessing the data structure so whilst that is non zero my writers are going to have to wait and also the number of readers they would like or want to be reading so this may be larger than the number of readers actually reading ok so with that in mind it's actually kind of see how we've sketched this out ok obviously we have some mutex locks to ensure that we update these variables atomically but the very first thing we're going to do then for each of these sections is to is to either call preferred mutex lock or unlock so for a few microseconds we hold onto a log but that's only for us to do some accounting either we will immediately a scape can have through this code or we will end up calling peter condition way in which case we release the mutex anyway	section	544
so let's reacquire the mutex lock so that we know for sure that we're currently only one thread running when we are changing our variables we're going to think about who we want to wake up here and then will unlock the mutex so yes there are parts of my code where only one thread can truly be running at a time but that'd be for a very very short period just for a few microseconds for example and most of the time in this is actually going to be when we actually reading the data structure so for example consider a linked list or map or maybe something on disk actual reading and writing is going to be a lot heavier than take more time than the actual code that we've written here for our locks	the data structure	473
so let's reacquire the mutex lock so that we know for sure that we're currently only one thread running when we are changing our variables we're going to think about who we want to wake up here and then will unlock the mutex so yes there are parts of my code where only one thread can truly be running at a time but that'd be for a very very short period just for a few microseconds for example and most of the time in this is actually going to be when we actually reading the data structure so for example consider a linked list or map or maybe something on disk actual reading and writing is going to be a lot heavier than take more time than the actual code that we've written here for our locks	a struct	480
so let's reacquire the mutex lock so that we know for sure that we're currently only one thread running when we are changing our variables we're going to think about who we want to wake up here and then will unlock the mutex so yes there are parts of my code where only one thread can truly be running at a time but that'd be for a very very short period just for a few microseconds for example and most of the time in this is actually going to be when we actually reading the data structure so for example consider a linked list or map or maybe something on disk actual reading and writing is going to be a lot heavier than take more time than the actual code that we've written here for our locks	code	254
so let's reacquire the mutex lock so that we know for sure that we're currently only one thread running when we are changing our variables we're going to think about who we want to wake up here and then will unlock the mutex so yes there are parts of my code where only one thread can truly be running at a time but that'd be for a very very short period just for a few microseconds for example and most of the time in this is actually going to be when we actually reading the data structure so for example consider a linked list or map or maybe something on disk actual reading and writing is going to be a lot heavier than take more time than the actual code that we've written here for our locks	thread	89
waiting for a writer to be actually doing the surgery on the data structure no is just mere presence of wanting to write means new readers have to wait ok so we've done that	the data structure	57
waiting for a writer to be actually doing the surgery on the data structure no is just mere presence of wanting to write means new readers have to wait ok so we've done that	a struct	64
so notice that i'm using the reading not the reader this is critically important because what have i done over here is if there's a reader that has arrived i'm right descent into sleep and so we don't want our writer to be waiting on on those people because there waiting on us so instead we're only going to wait for the ones which actually inside the data structure	the data structure	349
so notice that i'm using the reading not the reader this is critically important because what have i done over here is if there's a reader that has arrived i'm right descent into sleep and so we don't want our writer to be waiting on on those people because there waiting on us so instead we're only going to wait for the ones which actually inside the data structure	a struct	356
and like i said many many times before remember that because of this mutex lock actually only one thread time can be running the code that we're writing here so we could make strong reasoning strong inferences about the state of each thread	code	129
and like i said many many times before remember that because of this mutex lock actually only one thread time can be running the code that we're writing here so we could make strong reasoning strong inferences about the state of each thread	thread	98
we can say this either kind of waiting to enter this code because of the mutex log and i currently have to slog or that it's inside a condition wait either way it does not have the mutex locks so so that's our first condition can you guess what the other one is so either reading is non zero so let's just be explicit there today	code	53
ok so hopefully you worked out that the other reason is if there is another writer actively writing so if there is another writer modifying the data structure in here then we need to send this new writer to sleep so that's	the data structure	140
ok so hopefully you worked out that the other reason is if there is another writer actively writing so if there is another writer modifying the data structure in here then we need to send this new writer to sleep so that's	a struct	147
loop excuse me will be when there's no one left actually using the data structure for either reading all writing ok otherwise my new thread goes into this p threat condition wait ok so knew writers yes they're going to get priority as students we have arrived on the scene the reed has to wait but only only one of them is going to be able to continue to see why remember that each time a thread is working up outside condition wait remember is holding the mutex locks only one thread is running and so the very first writer that that has evaluation of false here gets to continue so what do they do they update writing from zero to one so now when they unlock and then proceed to change the data structure if another writer evaluates this condition so imagine we work them up in three p three condition wait or they've just arrived they will see an expression here that is true and so they will go into p three condition wait so that we can be sure that this condition must be false in order for us to continue ok so eventually that right oh will finish changing the data structure and then we get down here again so we wait to acquire the mutex lock hopefully as a very just a few nanoseconds maybe a microsecond and then we can say great we're out of here right so let's decrement the number of threads writing let's talk about the number of writers and then exit but before we exit maybe it's time to wake some people up ok so the most loud code would be to call peter condition broadcast on both the both condition variables so notice i've got a condition variable here for writers so we're going to send all the writers to some coffee shop and	the data structure	63
loop excuse me will be when there's no one left actually using the data structure for either reading all writing ok otherwise my new thread goes into this p threat condition wait ok so knew writers yes they're going to get priority as students we have arrived on the scene the reed has to wait but only only one of them is going to be able to continue to see why remember that each time a thread is working up outside condition wait remember is holding the mutex locks only one thread is running and so the very first writer that that has evaluation of false here gets to continue so what do they do they update writing from zero to one so now when they unlock and then proceed to change the data structure if another writer evaluates this condition so imagine we work them up in three p three condition wait or they've just arrived they will see an expression here that is true and so they will go into p three condition wait so that we can be sure that this condition must be false in order for us to continue ok so eventually that right oh will finish changing the data structure and then we get down here again so we wait to acquire the mutex lock hopefully as a very just a few nanoseconds maybe a microsecond and then we can say great we're out of here right so let's decrement the number of threads writing let's talk about the number of writers and then exit but before we exit maybe it's time to wake some people up ok so the most loud code would be to call peter condition broadcast on both the both condition variables so notice i've got a condition variable here for writers so we're going to send all the writers to some coffee shop and	a struct	70
loop excuse me will be when there's no one left actually using the data structure for either reading all writing ok otherwise my new thread goes into this p threat condition wait ok so knew writers yes they're going to get priority as students we have arrived on the scene the reed has to wait but only only one of them is going to be able to continue to see why remember that each time a thread is working up outside condition wait remember is holding the mutex locks only one thread is running and so the very first writer that that has evaluation of false here gets to continue so what do they do they update writing from zero to one so now when they unlock and then proceed to change the data structure if another writer evaluates this condition so imagine we work them up in three p three condition wait or they've just arrived they will see an expression here that is true and so they will go into p three condition wait so that we can be sure that this condition must be false in order for us to continue ok so eventually that right oh will finish changing the data structure and then we get down here again so we wait to acquire the mutex lock hopefully as a very just a few nanoseconds maybe a microsecond and then we can say great we're out of here right so let's decrement the number of threads writing let's talk about the number of writers and then exit but before we exit maybe it's time to wake some people up ok so the most loud code would be to call peter condition broadcast on both the both condition variables so notice i've got a condition variable here for writers so we're going to send all the writers to some coffee shop and	code	1445
loop excuse me will be when there's no one left actually using the data structure for either reading all writing ok otherwise my new thread goes into this p threat condition wait ok so knew writers yes they're going to get priority as students we have arrived on the scene the reed has to wait but only only one of them is going to be able to continue to see why remember that each time a thread is working up outside condition wait remember is holding the mutex locks only one thread is running and so the very first writer that that has evaluation of false here gets to continue so what do they do they update writing from zero to one so now when they unlock and then proceed to change the data structure if another writer evaluates this condition so imagine we work them up in three p three condition wait or they've just arrived they will see an expression here that is true and so they will go into p three condition wait so that we can be sure that this condition must be false in order for us to continue ok so eventually that right oh will finish changing the data structure and then we get down here again so we wait to acquire the mutex lock hopefully as a very just a few nanoseconds maybe a microsecond and then we can say great we're out of here right so let's decrement the number of threads writing let's talk about the number of writers and then exit but before we exit maybe it's time to wake some people up ok so the most loud code would be to call peter condition broadcast on both the both condition variables so notice i've got a condition variable here for writers so we're going to send all the writers to some coffee shop and	a thread	387
loop excuse me will be when there's no one left actually using the data structure for either reading all writing ok otherwise my new thread goes into this p threat condition wait ok so knew writers yes they're going to get priority as students we have arrived on the scene the reed has to wait but only only one of them is going to be able to continue to see why remember that each time a thread is working up outside condition wait remember is holding the mutex locks only one thread is running and so the very first writer that that has evaluation of false here gets to continue so what do they do they update writing from zero to one so now when they unlock and then proceed to change the data structure if another writer evaluates this condition so imagine we work them up in three p three condition wait or they've just arrived they will see an expression here that is true and so they will go into p three condition wait so that we can be sure that this condition must be false in order for us to continue ok so eventually that right oh will finish changing the data structure and then we get down here again so we wait to acquire the mutex lock hopefully as a very just a few nanoseconds maybe a microsecond and then we can say great we're out of here right so let's decrement the number of threads writing let's talk about the number of writers and then exit but before we exit maybe it's time to wake some people up ok so the most loud code would be to call peter condition broadcast on both the both condition variables so notice i've got a condition variable here for writers so we're going to send all the writers to some coffee shop and	thread	133
now we could do that but if we only wake up one writer i better make sure that when i write code down here that uh this code also wakes up those writers so yes i could do this just wake up a single writer by calling p three conditions signal but suppose there are two rights in the coffee shop then i've only woken up one here and i'd have to make sure then that when that first writer exits they end up also calling the writer so so that's i could do that	code	92
but if i wanted to not think so hard and just make my code tiny bit less efficient i just could call p thread conditioned broadcast on all other writers so let's wake up all of those and one of those	code	54
but if i wanted to not think so hard and just make my code tiny bit less efficient i just could call p thread conditioned broadcast on all other writers so let's wake up all of those and one of those	thread	103
vitus will win and continue and the others will wake up but then they will see that the somebody writing so they will go back to sleep ok so this is the most performant code but we're pretty confident that we released we always always going to wake up all the writers once we've we've got the active readers out of here so let's type i think about the writers again i could just wake up everybody the code will certainly function like that but the cost but there's a cost there's actually pay for the cost twice because now you're asking this system to signal many many many readers of writers and secondly i think about what all those threads are going to do you've woken them up but they're all going to test their conditions for example is although no writers around and then they just might go back to sleep and so we just wasted cpu time evaluating something that we could have reasoned must be zero	type	329
vitus will win and continue and the others will wake up but then they will see that the somebody writing so they will go back to sleep ok so this is the most performant code but we're pretty confident that we released we always always going to wake up all the writers once we've we've got the active readers out of here so let's type i think about the writers again i could just wake up everybody the code will certainly function like that but the cost but there's a cost there's actually pay for the cost twice because now you're asking this system to signal many many many readers of writers and secondly i think about what all those threads are going to do you've woken them up but they're all going to test their conditions for example is although no writers around and then they just might go back to sleep and so we just wasted cpu time evaluating something that we could have reasoned must be zero	code	169
vitus will win and continue and the others will wake up but then they will see that the somebody writing so they will go back to sleep ok so this is the most performant code but we're pretty confident that we released we always always going to wake up all the writers once we've we've got the active readers out of here so let's type i think about the writers again i could just wake up everybody the code will certainly function like that but the cost but there's a cost there's actually pay for the cost twice because now you're asking this system to signal many many many readers of writers and secondly i think about what all those threads are going to do you've woken them up but they're all going to test their conditions for example is although no writers around and then they just might go back to sleep and so we just wasted cpu time evaluating something that we could have reasoned must be zero	thread	636
vitus will win and continue and the others will wake up but then they will see that the somebody writing so they will go back to sleep ok so this is the most performant code but we're pretty confident that we released we always always going to wake up all the writers once we've we've got the active readers out of here so let's type i think about the writers again i could just wake up everybody the code will certainly function like that but the cost but there's a cost there's actually pay for the cost twice because now you're asking this system to signal many many many readers of writers and secondly i think about what all those threads are going to do you've woken them up but they're all going to test their conditions for example is although no writers around and then they just might go back to sleep and so we just wasted cpu time evaluating something that we could have reasoned must be zero	system	543
ok otherwise if there is a writer that still around let me wake up just one writer ok so let me call p threat conditions signal and they can then continue and change the data structure so here is the coffee shop there working at waiting app so the writer condition available ok and i can see that there's going to be like a domino cascading effect that every writer that leaves is going to wake up another writer until the very last writer in which case we call up all other readers and say ok you time to wake up and so now we've actually written the right implementation we see that actually we can go back here and make our code a little bit more efficient we only actually need to wake up one writer	the data structure	166
ok otherwise if there is a writer that still around let me wake up just one writer ok so let me call p threat conditions signal and they can then continue and change the data structure so here is the coffee shop there working at waiting app so the writer condition available ok and i can see that there's going to be like a domino cascading effect that every writer that leaves is going to wake up another writer until the very last writer in which case we call up all other readers and say ok you time to wake up and so now we've actually written the right implementation we see that actually we can go back here and make our code a little bit more efficient we only actually need to wake up one writer	a struct	173
ok otherwise if there is a writer that still around let me wake up just one writer ok so let me call p threat conditions signal and they can then continue and change the data structure so here is the coffee shop there working at waiting app so the writer condition available ok and i can see that there's going to be like a domino cascading effect that every writer that leaves is going to wake up another writer until the very last writer in which case we call up all other readers and say ok you time to wake up and so now we've actually written the right implementation we see that actually we can go back here and make our code a little bit more efficient we only actually need to wake up one writer	code	627
allows writers to have priority when there on the scene all new readers will get stopped but is it possible to have other kinds of starvation we're sure you could have a little bit of thought you could see that if my used of this data structure changes if i've now have always have writers then then my poor readers will never get a chance to continue so we've made a data structure which is great in the case that there's many many many more readers an is only occasional writers so we tend to read more than we right ok so that is our implementation for cs two forty one and as i hope you can see is that we've now we've actually got along way from when we first talked about a kind of a simple synchronization ideas of using p thread mutex lock and unlock ok so my advice to you is see if you can write this implementation from scratch starting with a blank piece of paper if you can congratulations i think you're really all along way into actually truly understanding synchronization at a kind of cs 241 level and this is kind of the underpinnings of caches and databases and all that great stuff ok bye for now	a struct	233
allows writers to have priority when there on the scene all new readers will get stopped but is it possible to have other kinds of starvation we're sure you could have a little bit of thought you could see that if my used of this data structure changes if i've now have always have writers then then my poor readers will never get a chance to continue so we've made a data structure which is great in the case that there's many many many more readers an is only occasional writers so we tend to read more than we right ok so that is our implementation for cs two forty one and as i hope you can see is that we've now we've actually got along way from when we first talked about a kind of a simple synchronization ideas of using p thread mutex lock and unlock ok so my advice to you is see if you can write this implementation from scratch starting with a blank piece of paper if you can congratulations i think you're really all along way into actually truly understanding synchronization at a kind of cs 241 level and this is kind of the underpinnings of caches and databases and all that great stuff ok bye for now	thread	730
maybe i want to divide my internet up into say look here's all of my customers and i'm not going to allow any packets between these between these peers so instead i'm only going to allow packets which go to say bona fide external hosts which i know are serving any bit torrent traffic so but if i see any packets for example appear to go between two bit torrent clients i'm going to drop that packet ok so this again is filtering and now it's based on the actual address so this is ip filtering and of course we could talk more specifically for example we could talk about maybe i'm going to implement my filter just for ip six packets or just for ip four four packets	address	463
and this effectively makes all of the are the clients all of the other peers here invisible there's no way that i can easily determine their existence because all i can do is directly communicate to service that are outside of this pool of machines so there's lots of ways then internet provider can block traffic the last thing that it could do is actually something quite exciting is called deep packet inspection	block	300
here you can use all of the buffer this time ok i don't care about turning that into a null terminated string. let's print out the number of bytes read ok so why it's read ok and i can only percent dior alright i could use to type that's correct for this machine so that's	type	226
here you can use all of the buffer this time ok i don't care about turning that into a null terminated string. let's print out the number of bytes read ok so why it's read ok and i can only percent dior alright i could use to type that's correct for this machine so that's	string	103
ok right so.. right now we run this program it was simply block on read(), so what i'm going to do actually is closed the write end so let's say there's no more bites that we want to write into this file descriptor into this pipe right so that means we're done what do you think will happen when we get to this read call ok let's	block	58
hi that's going to be two bites and another one will say ok how 'bout hi there which is going to be safe i bites have a case we've sent those let's hope they don't block i'm pretty confident vote on this particular machine 'cause it's less than my experiment earlier of sixty four kb and then will close it ok so send this bytes and then after that we're going to start reading from the pipe. ok, so off we go	block	164
of it in one go there were only limit here is going to be the buffer that i've put in here and i said i could i prepared to accept up to four thousand and ninety six bytes in one go ok so don't just assume that each read is going to become one so one right is beginning to come one read it doesn't have to write it just like you have a ring buffer we've put stuff in there and then we're going to want to read the most of bytes as possible when we call reed	a ring buffer	334
right so let's do that and now program hopefully a programmer block so compile that and hard right we've recovered our functionality again	block	62
ok so that's the kind of our second gotcher of using pipes the first gotcha i'm thinking about is don't just assume that if you're sending data that if you if you put a slash end at the end of it that sufficient no you need to flush the stream if you're going to use the c library fprintf type calls right so we've done reading from a pipe what about if we try to write to a closed pipe ok so how can the writer discover that things have gone wrong let's have a new program for this case so	type	289
ok so that's the kind of our second gotcher of using pipes the first gotcha i'm thinking about is don't just assume that if you're sending data that if you if you put a slash end at the end of it that sufficient no you need to flush the stream if you're going to use the c library fprintf type calls right so we've done reading from a pipe what about if we try to write to a closed pipe ok so how can the writer discover that things have gone wrong let's have a new program for this case so	printf	282
ok so if you try to write to a pipe that's not going to accept anymore bites because the readers closed actually the moment you try to do that our program is going to get a little signal and it's the sigpipe so let's prove that we can send something like will say printf write bytes sent k percent you	printf	265
right i need to include a string or as yeah let's do that so hash include string	string	26
if it was if a simple integer or less service print it out as a is a pointer ok also i'm surprised i didn't see negative kind of worn down here ok so	pointer	69
ok so printf() failed	printf	6
ok i'm going to finish with the challenge for you something you can discuss on piazza etc if you wish so it's the following it's the kind of typical have exam question where we put in a whole lot of concepts together and the nice thing about this one is that it's easy to write and easy to test as well ok so but it shows it demonstrates that you understand file descriptors and exact all this good stuff right so here's what we want to do we want to use forks so we have a child and a parent process	the following	110
twice i hope you can remember why we do this and it's important to pass in a null pointer at the end here to say ok i'm done with the arguments right so if you could make this work then it means you can actually start sending a script of commands to bash and actually see them being executed so your file input dot text can have things like ls echo word count etc and you should be able to send these all too a little bash program and see them run but this file itself can be very long but you're not loaded all at one time into memory know you're only going to try to copy four kb at a time just think something to watch out for is is remember that read and write can return well read can return zero when it's done and also you don't want to necessarily send four kb instead you should be paying attention to what read returns so if read returns oh yes i correctly well matched and we'd say one thousand two hundred and seventy five bytes even though i said you could read four thousand ninety six bytes then this is the number of bytes that you should be writing to the	memory	529
twice i hope you can remember why we do this and it's important to pass in a null pointer at the end here to say ok i'm done with the arguments right so if you could make this work then it means you can actually start sending a script of commands to bash and actually see them being executed so your file input dot text can have things like ls echo word count etc and you should be able to send these all too a little bash program and see them run but this file itself can be very long but you're not loaded all at one time into memory know you're only going to try to copy four kb at a time just think something to watch out for is is remember that read and write can return well read can return zero when it's done and also you don't want to necessarily send four kb instead you should be paying attention to what read returns so if read returns oh yes i correctly well matched and we'd say one thousand two hundred and seventy five bytes even though i said you could read four thousand ninety six bytes then this is the number of bytes that you should be writing to the	pointer	82
ok question for you does the i know contain the file name for ten to the ten to the ten points right so hopefully you say no ok the i know does not contain the file name the file name is just a way to organize our files in terms of her directory listing and that's it ok that's the kind of big idea right so can we have the same file appear in two different places inside of file system yes absolutely ok let's do that alright so right now the story so far	system	380
reducer is the reference count of my entry by one and if that gets down to zero then we know that i node is not useful anymore and so the disk blocks that i required	block	143
it's got a reference count of three but if i was to remove it so let's remove what i call it like another dot c o k that my reference count has gone down to two so we still need it so that's why we need reference counting just keep track of the number of entries that it appears so you might see how when we do forensic analysis on disks we can look for i knowed entries which have been deleted but which still don't appear inside anyways like my file system but we still might contain all of the meta information so for example it might be i did deleted i knowed entry can still point to the disk blocks that	block	598
it's got a reference count of three but if i was to remove it so let's remove what i call it like another dot c o k that my reference count has gone down to two so we still need it so that's why we need reference counting just keep track of the number of entries that it appears so you might see how when we do forensic analysis on disks we can look for i knowed entries which have been deleted but which still don't appear inside anyways like my file system but we still might contain all of the meta information so for example it might be i did deleted i knowed entry can still point to the disk blocks that	system	452
section two it is ok so you'll find lincoln or some systems link at as well where you can say right start with his existing directory so existing file and	section	0
section two it is ok so you'll find lincoln or some systems link at as well where you can say right start with his existing directory so existing file and	system	52
make a new entry there's only one thing you can't do with hard links and that is to create a hard link to a directory you can only do this for files perhaps you should think about why and i'll give that comment in a future lecture oh and another thing you can't do is create links across two different filesystems again perhaps you could think why that is true so making hardlinks only works for regular files you cannot do this for directories	system	306
hi welcome to lecture twenty four we're going to start with a quick code review let's see look at this attempted waiting a fixed sized ring buffer and we'll see if we can figure out how it might go wrong ok so some of the things that we want to ask are is deadlock possible in other words could it get stuck so that's never able to continue is underflow possible in other words could it be that we attempt to write so attempt to read some data that's not actually inside the ring buffer so will just be reading back some garbage information or perhaps overflow as possible which means that we're able to put more data into my buffer then it can actually hold so presumably we were going to corrupt something possibly a value that we have not yet written out so what do we got here we have	code	68
two counting semaphores and we'll see the s one is initialized to two hundred and fifty six so this smells to me like some kind of capacity counting thing which is going to go down as we started add things and s two is initialized to zero so s two sounds to me like it's going to be counting the number of items in ok let's actually have a look at the code then for my enqueue and dequeue or nq and deck so i see i've got a mutex lock ok so that's good so that only one thread at the time can be actually inside this code and in fact for this particular implementation it has chosen to use the same mutex lock for both the nq and the dequeue ok but i do notice inside this implementation is that normally what do we do normally sem post so the sem wait happens first and we normally only have the mutex lock that wraps the buffer call as well so yeah	code	352
two counting semaphores and we'll see the s one is initialized to two hundred and fifty six so this smells to me like some kind of capacity counting thing which is going to go down as we started add things and s two is initialized to zero so s two sounds to me like it's going to be counting the number of items in ok let's actually have a look at the code then for my enqueue and dequeue or nq and deck so i see i've got a mutex lock ok so that's good so that only one thread at the time can be actually inside this code and in fact for this particular implementation it has chosen to use the same mutex lock for both the nq and the dequeue ok but i do notice inside this implementation is that normally what do we do normally sem post so the sem wait happens first and we normally only have the mutex lock that wraps the buffer call as well so yeah	a mutex	422
two counting semaphores and we'll see the s one is initialized to two hundred and fifty six so this smells to me like some kind of capacity counting thing which is going to go down as we started add things and s two is initialized to zero so s two sounds to me like it's going to be counting the number of items in ok let's actually have a look at the code then for my enqueue and dequeue or nq and deck so i see i've got a mutex lock ok so that's good so that only one thread at the time can be actually inside this code and in fact for this particular implementation it has chosen to use the same mutex lock for both the nq and the dequeue ok but i do notice inside this implementation is that normally what do we do normally sem post so the sem wait happens first and we normally only have the mutex lock that wraps the buffer call as well so yeah	thread	470
in your spare time next time you're having drifting off to sleep chatting with friends and an algorithm or an idea pops into your head think about oh how would i apply what i'm learning inside cs two forty one to make that run faster to make it actually run concurrently so as a worked example remember some of the sorting algorithms you might have seen before like merge sort has suppose you wanted to make your merge sort run faster how would you implement that in parallel ok so kind of let's do this as a little worse example but again there my suggestion to you is is think about your css life and start thinking about well how can i use multiple threads to make this or how can i use multiple processes ok so remember how merge sort works we say if i've got say an array of data here	thread	652
ok so think of like to parcel cards so this number is smaller great i'll take this now we build the next number ok so now this number is not as small as the number might from my right hand pile so i'll take that and repeat and eventually we managed to merge these altogether and notice i relied on the recursion fairy to do most of the work so of course this happens at all levels so if i've started with nice big block of data say mb of data then first of all we call recursion ok and so on and so on and that has to be cursively run these ok so how can i now	block	414
and my calls here wouldn't be able to continue until say these two have completed and then i can start doing the merge simile this merge can happen once these two have finished so it's kind of fun to sketch out how you might actually implement this so how would you use condition way to how to use p threaded barrier to make your code run nice and fast	code	330
and my calls here wouldn't be able to continue until say these two have completed and then i can start doing the merge simile this merge can happen once these two have finished so it's kind of fun to sketch out how you might actually implement this so how would you use condition way to how to use p threaded barrier to make your code run nice and fast	thread	300
let's see what else has changed secondly is because i'm not going to try to go out to connect to remote machine when i call get address info i don't need to specify a remote address i'm not passing in illinois dot edu here	address	128
listing on a particular port for particular socket type ok so if this succeeds we've got everything we now need to create a socket but here's a here's the new call that we're going to need now which is this bind call so bind says right so far what have we done you've made an abstract socket and we did that much earlier at the top of the code here we said i need just an ip for tcp style socket thank you very much now we actually want to make that be on a particular port number on a particular network card on our local machine and that's the purpose of mind right so you can pink handcuffs or whatever to say hey we're going to actually combined abstract socket to actual port number an actual end point on my machine	type	51
listing on a particular port for particular socket type ok so if this succeeds we've got everything we now need to create a socket but here's a here's the new call that we're going to need now which is this bind call so bind says right so far what have we done you've made an abstract socket and we did that much earlier at the top of the code here we said i need just an ip for tcp style socket thank you very much now we actually want to make that be on a particular port number on a particular network card on our local machine and that's the purpose of mind right so you can pink handcuffs or whatever to say hey we're going to actually combined abstract socket to actual port number an actual end point on my machine	code	339
if we wanted to write a high performance server perhaps i want a backlog of up to a hundred connections but realize of course that all of this is going to take some resources to build again handle those one hundred conversations	resources	165
ok so so far none of these calls will block but we have now set up a valid server if i've got this far then calling netcat on this connection or calling telnet or calling using firefox or chrome etc will make a valid connection and then i'll start to want to it's not to send back to us so we better actually start processing our clients ok so how do we do that and the answer is with accept ok so accept means please block untill there's a customer for me to serve ok and of course we pass in our source server socket now the big important idea here is that now is that that server socket is the front door to your shop but it's not actually going to be the way that you talk to your clients instead when accept returns you get a new file descriptor one for each customer which is the private communication channel between you and that client so with this new file descriptor that's how we're going to be calling read and write	block	38
so accept will return immediately if there's customers which have completed their handshake and waiting to talk to you or it will block if there's no new customers ready to talk so you might for example write code where we'll put this accept insider loop and will process one customer at a time and there is exactly what we're doing here perhaps in the future will write a multithreaded version where as soon as we get a valid return from except we know we can start say a threat just a process that particular customer	block	130
so accept will return immediately if there's customers which have completed their handshake and waiting to talk to you or it will block if there's no new customers ready to talk so you might for example write code where we'll put this accept insider loop and will process one customer at a time and there is exactly what we're doing here perhaps in the future will write a multithreaded version where as soon as we get a valid return from except we know we can start say a threat just a process that particular customer	code	209
so accept will return immediately if there's customers which have completed their handshake and waiting to talk to you or it will block if there's no new customers ready to talk so you might for example write code where we'll put this accept insider loop and will process one customer at a time and there is exactly what we're doing here perhaps in the future will write a multithreaded version where as soon as we get a valid return from except we know we can start say a threat just a process that particular customer	a process	485
so accept will return immediately if there's customers which have completed their handshake and waiting to talk to you or it will block if there's no new customers ready to talk so you might for example write code where we'll put this accept insider loop and will process one customer at a time and there is exactly what we're doing here perhaps in the future will write a multithreaded version where as soon as we get a valid return from except we know we can start say a threat just a process that particular customer	thread	378
ok so let me read up to nine hundred and ninety nine bytes and if they give me something valid then ardesta printed out but remember what i get is not a c string it's up to me to terminate what what we received with the zoomer bite ok and will put it up and then i can say something back to them ok so let me now use either right aldi printf ok and so i can only say hello i could if i wanted to say something fancy with equal if i can use formatted strings	printf	335
ok so let me read up to nine hundred and ninety nine bytes and if they give me something valid then ardesta printed out but remember what i get is not a c string it's up to me to terminate what what we received with the zoomer bite ok and will put it up and then i can say something back to them ok so let me now use either right aldi printf ok and so i can only say hello i could if i wanted to say something fancy with equal if i can use formatted strings	string	155
so let's edit my code to say we're all done with this connection but the file descriptors still exists so that's taking up unnecessary resources so now actually let me kind of reset that ok alright so now i've got my little server finished	code	17
so let's edit my code to say we're all done with this connection but the file descriptors still exists so that's taking up unnecessary resources so now actually let me kind of reset that ok alright so now i've got my little server finished	resources	135
returning web web content not something that's a real web page ok and it's not actually truly talking http instead so let's modify it just use kind of deep printf and talk about some other things that this thing is doing as well	printf	156
if i break out this point in trying to run it again i'll be in for a bit of a nasty shock here that my bind called failed that i get an address already in use oh what's gone wrong with my code did i make an error let me try running again and it's still failing ok so let me look at my code figure out why bind it might be failing here ok so this is actually why it's useful to check every	code	188
if i break out this point in trying to run it again i'll be in for a bit of a nasty shock here that my bind called failed that i get an address already in use oh what's gone wrong with my code did i make an error let me try running again and it's still failing ok so let me look at my code figure out why bind it might be failing here ok so this is actually why it's useful to check every	address	136
things fail and in fact my code is correct the problem however is that even after my process has finished passively listing or one two three four there's a timeout there's a grace period of about two minutes where we can't make a new passive socket on the same port number that was actually previously used so if we a little bit longer they go see now it's actually working again i didn't even touch the code ok so that's one kind of fun surprised it will have with networking will talk about how we can reduce that timeout period to zero seconds in future lecture but realize that that time out is deliberate it's actually there for security purpose so more about that in the future so anyway we've got a little thing working here we should now try to connect to it let me now try using say netcat so netcat which is netcat or sometimes or some systems is just nc it's a netcat i wanted to talk to my localhost did it to do ok and i'm now on port one two three four ok right so i can say let's say	code	27
things fail and in fact my code is correct the problem however is that even after my process has finished passively listing or one two three four there's a timeout there's a grace period of about two minutes where we can't make a new passive socket on the same port number that was actually previously used so if we a little bit longer they go see now it's actually working again i didn't even touch the code ok so that's one kind of fun surprised it will have with networking will talk about how we can reduce that timeout period to zero seconds in future lecture but realize that that time out is deliberate it's actually there for security purpose so more about that in the future so anyway we've got a little thing working here we should now try to connect to it let me now try using say netcat so netcat which is netcat or sometimes or some systems is just nc it's a netcat i wanted to talk to my localhost did it to do ok and i'm now on port one two three four ok right so i can say let's say	system	846
hello right and you'll see that my server got the hello there and complete with a new line and it sent back this server code was written in year two thousand and eighteen tour it's a whole year old ok right	code	120
which is the following which is this end to hs calls so let's talk about that in the next video ok so i'm going to reset my code to a valid number explicit number like one two three four and we'll see how this code	the following	9
which is the following which is this end to hs calls so let's talk about that in the next video ok so i'm going to reset my code to a valid number explicit number like one two three four and we'll see how this code	code	124
ok. hi right so question three we've got a lot of different pieces of memory inside our process each time it runs we need some memory to hold of global variables are stack variables so that's actually look at that in action right so here is some crazy code that we wrote this is actually going to illustrate some of these ideas right so what do we have ok do i have a little pointer thingy ok great so the first thing is i've got a little variable up here called global do i have i'm in text mode ok let's go to squiggly line mode ok ok	memory	70
ok. hi right so question three we've got a lot of different pieces of memory inside our process each time it runs we need some memory to hold of global variables are stack variables so that's actually look at that in action right so here is some crazy code that we wrote this is actually going to illustrate some of these ideas right so what do we have ok do i have a little pointer thingy ok great so the first thing is i've got a little variable up here called global do i have i'm in text mode ok let's go to squiggly line mode ok ok	code	252
ok. hi right so question three we've got a lot of different pieces of memory inside our process each time it runs we need some memory to hold of global variables are stack variables so that's actually look at that in action right so here is some crazy code that we wrote this is actually going to illustrate some of these ideas right so what do we have ok do i have a little pointer thingy ok great so the first thing is i've got a little variable up here called global do i have i'm in text mode ok let's go to squiggly line mode ok ok	pointer	375
ok alright good alright so i got a variable here called global now globals are dangerous and great at the same time in the sense that once you declare a global you can use it anywhere else in the code below so they really have global scope so that's not great engineering we want to make all of our variables global in scope it means that our code becomes very very kind of complex and fragile but it's not unusual to have say one or two global variables which might represents a debug flag or something like that and you'll see the lot in very simple and small programs ok so global variable exists for the lifetime of the	code	196
process it's not in the heap it's not in the stack it's inside his own kind of memory segment and they can either have an initial value of zero or if we wish inside our code we can of course initialize them to a value right so the next thing to look at is	memory	79
process it's not in the heap it's not in the stack it's inside his own kind of memory segment and they can either have an initial value of zero or if we wish inside our code we can of course initialize them to a value right so the next thing to look at is	the heap	20
process it's not in the heap it's not in the stack it's inside his own kind of memory segment and they can either have an initial value of zero or if we wish inside our code we can of course initialize them to a value right so the next thing to look at is	code	169
what about all constants here and the code right so also in our process we have something called the text segment and that's going to hold	code	38
the code itself so the instructions required for this cpu all those bytes to the cpu is going to interpret	code	4
as instructions in terms of changing registers reading writing from memory branches conditionals etc etc etc etc all that has to live inside the process somewhere all of that has a memory address and that's all take segment and that is read only you try to write to that memory good luck trying you won't be able to on a modern cpu memory texture will kick in and your process will be kicked out ok so here's some examples of things which can be stored inside the tech segment and if we use the insider program and what do we get well actually what you get here is	memory	68
as instructions in terms of changing registers reading writing from memory branches conditionals etc etc etc etc all that has to live inside the process somewhere all of that has a memory address and that's all take segment and that is read only you try to write to that memory good luck trying you won't be able to on a modern cpu memory texture will kick in and your process will be kicked out ok so here's some examples of things which can be stored inside the tech segment and if we use the insider program and what do we get well actually what you get here is	address	188
is when you use it inside an expression you get the memory address of the very first item ok so when we use these inside	memory	52
is when you use it inside an expression you get the memory address of the very first item ok so when we use these inside	address	59
inside a little code here then a couple of things going to happen first of all let's have a look at t one t one is stored on the stack why it's an automatic variable that only exists whilst we are inside and running code inside test so we need a place in memory just a temporary hold	memory	255
inside a little code here then a couple of things going to happen first of all let's have a look at t one t one is stored on the stack why it's an automatic variable that only exists whilst we are inside and running code inside test so we need a place in memory just a temporary hold	code	16
all automatic variables are little stack variables here and that includes parameters as well ok so what does t what is t one and what's it doing well t one what is its type is a pointer to a character and otherwise it's going to hold a memory address and add that memory address we expect to find characters right but we're giving it this string so actually a t one is going to hold the memory address of that h it's going to point directly into the text segment it's going to hold that memory address which between you and me is going to be a low value the text document is is it near the beginning of the processes memory ok now this is a price however with t two t two is not a pointer is actually an array we didn't bother to specify the size because the compiler can work that out itself and the surprise here is actually the compiler is going to write some extra code for us here because rather than just looking at that that string literal in memory when we call this function it's actually going to copy those bites it's going to copy the one two three four five six seven eight nine bites including that zero bye to the end into the stack memory forwards so if i was to stop my process an actually use a debugger to have a look around i would find the original abcdefg h and then i'd find a copy of that inside the stack and the difference between the two of course is that the stack version we can modify as minutes mutable because it's just stack memory	memory	236
all automatic variables are little stack variables here and that includes parameters as well ok so what does t what is t one and what's it doing well t one what is its type is a pointer to a character and otherwise it's going to hold a memory address and add that memory address we expect to find characters right but we're giving it this string so actually a t one is going to hold the memory address of that h it's going to point directly into the text segment it's going to hold that memory address which between you and me is going to be a low value the text document is is it near the beginning of the processes memory ok now this is a price however with t two t two is not a pointer is actually an array we didn't bother to specify the size because the compiler can work that out itself and the surprise here is actually the compiler is going to write some extra code for us here because rather than just looking at that that string literal in memory when we call this function it's actually going to copy those bites it's going to copy the one two three four five six seven eight nine bites including that zero bye to the end into the stack memory forwards so if i was to stop my process an actually use a debugger to have a look around i would find the original abcdefg h and then i'd find a copy of that inside the stack and the difference between the two of course is that the stack version we can modify as minutes mutable because it's just stack memory	type	168
all automatic variables are little stack variables here and that includes parameters as well ok so what does t what is t one and what's it doing well t one what is its type is a pointer to a character and otherwise it's going to hold a memory address and add that memory address we expect to find characters right but we're giving it this string so actually a t one is going to hold the memory address of that h it's going to point directly into the text segment it's going to hold that memory address which between you and me is going to be a low value the text document is is it near the beginning of the processes memory ok now this is a price however with t two t two is not a pointer is actually an array we didn't bother to specify the size because the compiler can work that out itself and the surprise here is actually the compiler is going to write some extra code for us here because rather than just looking at that that string literal in memory when we call this function it's actually going to copy those bites it's going to copy the one two three four five six seven eight nine bites including that zero bye to the end into the stack memory forwards so if i was to stop my process an actually use a debugger to have a look around i would find the original abcdefg h and then i'd find a copy of that inside the stack and the difference between the two of course is that the stack version we can modify as minutes mutable because it's just stack memory	parameter	74
all automatic variables are little stack variables here and that includes parameters as well ok so what does t what is t one and what's it doing well t one what is its type is a pointer to a character and otherwise it's going to hold a memory address and add that memory address we expect to find characters right but we're giving it this string so actually a t one is going to hold the memory address of that h it's going to point directly into the text segment it's going to hold that memory address which between you and me is going to be a low value the text document is is it near the beginning of the processes memory ok now this is a price however with t two t two is not a pointer is actually an array we didn't bother to specify the size because the compiler can work that out itself and the surprise here is actually the compiler is going to write some extra code for us here because rather than just looking at that that string literal in memory when we call this function it's actually going to copy those bites it's going to copy the one two three four five six seven eight nine bites including that zero bye to the end into the stack memory forwards so if i was to stop my process an actually use a debugger to have a look around i would find the original abcdefg h and then i'd find a copy of that inside the stack and the difference between the two of course is that the stack version we can modify as minutes mutable because it's just stack memory	code	869
all automatic variables are little stack variables here and that includes parameters as well ok so what does t what is t one and what's it doing well t one what is its type is a pointer to a character and otherwise it's going to hold a memory address and add that memory address we expect to find characters right but we're giving it this string so actually a t one is going to hold the memory address of that h it's going to point directly into the text segment it's going to hold that memory address which between you and me is going to be a low value the text document is is it near the beginning of the processes memory ok now this is a price however with t two t two is not a pointer is actually an array we didn't bother to specify the size because the compiler can work that out itself and the surprise here is actually the compiler is going to write some extra code for us here because rather than just looking at that that string literal in memory when we call this function it's actually going to copy those bites it's going to copy the one two three four five six seven eight nine bites including that zero bye to the end into the stack memory forwards so if i was to stop my process an actually use a debugger to have a look around i would find the original abcdefg h and then i'd find a copy of that inside the stack and the difference between the two of course is that the stack version we can modify as minutes mutable because it's just stack memory	string	339
all automatic variables are little stack variables here and that includes parameters as well ok so what does t what is t one and what's it doing well t one what is its type is a pointer to a character and otherwise it's going to hold a memory address and add that memory address we expect to find characters right but we're giving it this string so actually a t one is going to hold the memory address of that h it's going to point directly into the text segment it's going to hold that memory address which between you and me is going to be a low value the text document is is it near the beginning of the processes memory ok now this is a price however with t two t two is not a pointer is actually an array we didn't bother to specify the size because the compiler can work that out itself and the surprise here is actually the compiler is going to write some extra code for us here because rather than just looking at that that string literal in memory when we call this function it's actually going to copy those bites it's going to copy the one two three four five six seven eight nine bites including that zero bye to the end into the stack memory forwards so if i was to stop my process an actually use a debugger to have a look around i would find the original abcdefg h and then i'd find a copy of that inside the stack and the difference between the two of course is that the stack version we can modify as minutes mutable because it's just stack memory	address	243
all automatic variables are little stack variables here and that includes parameters as well ok so what does t what is t one and what's it doing well t one what is its type is a pointer to a character and otherwise it's going to hold a memory address and add that memory address we expect to find characters right but we're giving it this string so actually a t one is going to hold the memory address of that h it's going to point directly into the text segment it's going to hold that memory address which between you and me is going to be a low value the text document is is it near the beginning of the processes memory ok now this is a price however with t two t two is not a pointer is actually an array we didn't bother to specify the size because the compiler can work that out itself and the surprise here is actually the compiler is going to write some extra code for us here because rather than just looking at that that string literal in memory when we call this function it's actually going to copy those bites it's going to copy the one two three four five six seven eight nine bites including that zero bye to the end into the stack memory forwards so if i was to stop my process an actually use a debugger to have a look around i would find the original abcdefg h and then i'd find a copy of that inside the stack and the difference between the two of course is that the stack version we can modify as minutes mutable because it's just stack memory	pointer	178
so let's see what happens next right ok so the online seven we used to but it looks like we're using as a pointer this is ok array variables behave a bit like pointers if you use them in a pointer context like this then	pointer	106
the variable behave as if it's talking about the very first address of the array in other words we're looking at the very first element of the array in the stack itself	address	60
four bytes ok so t one would hold the address of this first bite here and	address	38
so the difference between these is subtle but important that t one doesn't hold the string high instead it's a pointer and this my little world here i'm working on a thirty two bit machine as you can see i used four bytes to hold the address of of t one so you've got to follow the money if you like you've got to actually go to that other address if you actually want to see those bytes h and i it's not going to be found directly inside the stack versus t two actually has abc carpet into it ok and so on and so on and so on ok up to h and then one last bite for the zero at the end and you'll notice i put my address is of the highest at the top and the lowest at the bottom of the page ok so	string	84
so the difference between these is subtle but important that t one doesn't hold the string high instead it's a pointer and this my little world here i'm working on a thirty two bit machine as you can see i used four bytes to hold the address of of t one so you've got to follow the money if you like you've got to actually go to that other address if you actually want to see those bytes h and i it's not going to be found directly inside the stack versus t two actually has abc carpet into it ok and so on and so on and so on ok up to h and then one last bite for the zero at the end and you'll notice i put my address is of the highest at the top and the lowest at the bottom of the page ok so	address	234
so the difference between these is subtle but important that t one doesn't hold the string high instead it's a pointer and this my little world here i'm working on a thirty two bit machine as you can see i used four bytes to hold the address of of t one so you've got to follow the money if you like you've got to actually go to that other address if you actually want to see those bytes h and i it's not going to be found directly inside the stack versus t two actually has abc carpet into it ok and so on and so on and so on ok up to h and then one last bite for the zero at the end and you'll notice i put my address is of the highest at the top and the lowest at the bottom of the page ok so	pointer	111
hello line seven we are going to change that first element of the array so i'm actually changing by stack memory directly here and then line eight we do a calculation that says take two two so treat it as as an address add one to it and then dereference is full of the money see the aspects here actually use that address so in other words changed a lowercase b that we put in there into an uppercase b line nine actually does the same thing so these two lines are equivalent is just different syntax as you can see it a little bit nicer to use square brackets and remember the square brackets means also right right to those locations just as a fun thing actually if you want to confuse your cs two twenty five friends you could write this equivalently by swapping the two sites so you could also write one square bracket t two and that would compile as well so you could	memory	106
hello line seven we are going to change that first element of the array so i'm actually changing by stack memory directly here and then line eight we do a calculation that says take two two so treat it as as an address add one to it and then dereference is full of the money see the aspects here actually use that address so in other words changed a lowercase b that we put in there into an uppercase b line nine actually does the same thing so these two lines are equivalent is just different syntax as you can see it a little bit nicer to use square brackets and remember the square brackets means also right right to those locations just as a fun thing actually if you want to confuse your cs two twenty five friends you could write this equivalently by swapping the two sites so you could also write one square bracket t two and that would compile as well so you could	address	211
swap these around if you so in client wouldn't do that for real production code but it's great fun for confusing confusing people right now let's look at line tent line ten says ok take the address the t one holds and use it change was there but hold on you say t one doesn't actually have their contents or so we are going to be a very unhappy here	code	75
swap these around if you so in client wouldn't do that for real production code but it's great fun for confusing confusing people right now let's look at line tent line ten says ok take the address the t one holds and use it change was there but hold on you say t one doesn't actually have their contents or so we are going to be a very unhappy here	address	190
put my little fun smiley face because will try to follow the address that we stored inside t one which you pointing to some read only memory	memory	134
put my little fun smiley face because will try to follow the address that we stored inside t one which you pointing to some read only memory	address	61
how to change that so the moment that you actually try to dereference this memory actually right to it the cpu will notice and say hold on let's stop program anymore get a segmentation fault the last line here says if we actually got to this last this last line is last line hey malloc i need some heap memory and this is the number of bytes i'd like i'd like a hundred and twenty three and i promise not to write a extra bite after that point and i promise not to try to write any bites before they start	heap memory	298
how to change that so the moment that you actually try to dereference this memory actually right to it the cpu will notice and say hold on let's stop program anymore get a segmentation fault the last line here says if we actually got to this last this last line is last line hey malloc i need some heap memory and this is the number of bytes i'd like i'd like a hundred and twenty three and i promise not to write a extra bite after that point and i promise not to try to write any bites before they start	memory	75
start of the place you give me so if it succeeds is actually going to turn an address and we can use that that particular address that address up to one hundred and twenty two for whatever we want to do maybe want to store some integers in there maybe one store that a little picture whatever we want to do maybe once too long string i don't know malloc doesn't care or black noses it's assigned a given us that memory and it promises not to give anybody else that same piece of memory until the day that we say ok i'm done with this and how do i say i'm done with this	memory	412
start of the place you give me so if it succeeds is actually going to turn an address and we can use that that particular address that address up to one hundred and twenty two for whatever we want to do maybe want to store some integers in there maybe one store that a little picture whatever we want to do maybe once too long string i don't know malloc doesn't care or black noses it's assigned a given us that memory and it promises not to give anybody else that same piece of memory until the day that we say ok i'm done with this and how do i say i'm done with this	string	327
start of the place you give me so if it succeeds is actually going to turn an address and we can use that that particular address that address up to one hundred and twenty two for whatever we want to do maybe want to store some integers in there maybe one store that a little picture whatever we want to do maybe once too long string i don't know malloc doesn't care or black noses it's assigned a given us that memory and it promises not to give anybody else that same piece of memory until the day that we say ok i'm done with this and how do i say i'm done with this	address	78
well let's stop drawing right past back the same the same address that we got originally from malloc so i call free with t one	address	58
ok so our code will fail at line ten the only way that we could stop this code from failing at line ten would be if we swapped lines ten eleven because this is what we can do with pointers with pointers you can say hey pointer point to something else and so if we swap those two lines around by calling malloc first we would have changed t one to now point to some brand new memory to some some heap memory and we could have set that very first bite to an h but we would not have created a string because the h of to be a c string would have to also have a zero bite after it and doesn't guarantee as anything about the memory that we actually get ok with that i'll see you next video for further next question by	heap memory	395
ok so our code will fail at line ten the only way that we could stop this code from failing at line ten would be if we swapped lines ten eleven because this is what we can do with pointers with pointers you can say hey pointer point to something else and so if we swap those two lines around by calling malloc first we would have changed t one to now point to some brand new memory to some some heap memory and we could have set that very first bite to an h but we would not have created a string because the h of to be a c string would have to also have a zero bite after it and doesn't guarantee as anything about the memory that we actually get ok with that i'll see you next video for further next question by	memory	375
ok so our code will fail at line ten the only way that we could stop this code from failing at line ten would be if we swapped lines ten eleven because this is what we can do with pointers with pointers you can say hey pointer point to something else and so if we swap those two lines around by calling malloc first we would have changed t one to now point to some brand new memory to some some heap memory and we could have set that very first bite to an h but we would not have created a string because the h of to be a c string would have to also have a zero bite after it and doesn't guarantee as anything about the memory that we actually get ok with that i'll see you next video for further next question by	code	10
ok so our code will fail at line ten the only way that we could stop this code from failing at line ten would be if we swapped lines ten eleven because this is what we can do with pointers with pointers you can say hey pointer point to something else and so if we swap those two lines around by calling malloc first we would have changed t one to now point to some brand new memory to some some heap memory and we could have set that very first bite to an h but we would not have created a string because the h of to be a c string would have to also have a zero bite after it and doesn't guarantee as anything about the memory that we actually get ok with that i'll see you next video for further next question by	string	490
ok so our code will fail at line ten the only way that we could stop this code from failing at line ten would be if we swapped lines ten eleven because this is what we can do with pointers with pointers you can say hey pointer point to something else and so if we swap those two lines around by calling malloc first we would have changed t one to now point to some brand new memory to some some heap memory and we could have set that very first bite to an h but we would not have created a string because the h of to be a c string would have to also have a zero bite after it and doesn't guarantee as anything about the memory that we actually get ok with that i'll see you next video for further next question by	pointer	180
examples and problems from the second lecture here the cc crash ok so let's have a look at our first little first little problem here we've got here is ok so we want to know about the pre the pre processor let me pull it in here ok so what kind of three examples of common examples first of all what is the c preprocessor is that it is a text replacement tool that runs before we actually compile this c code and we can think of is very simple and fairly dump tool that only stands a few understand a few limited commands so one thing i can do is that it can we can include additional files so for example if i say ok my utility functions then that moment inside our compilation file we're going to replace that line with the contents of another file in this case my little file called my utils dot h and that better be somewhere inside our project perhaps i want to include some system files for example standard i o dot h because i want to use things like printf and	code	404
examples and problems from the second lecture here the cc crash ok so let's have a look at our first little first little problem here we've got here is ok so we want to know about the pre the pre processor let me pull it in here ok so what kind of three examples of common examples first of all what is the c preprocessor is that it is a text replacement tool that runs before we actually compile this c code and we can think of is very simple and fairly dump tool that only stands a few understand a few limited commands so one thing i can do is that it can we can include additional files so for example if i say ok my utility functions then that moment inside our compilation file we're going to replace that line with the contents of another file in this case my little file called my utils dot h and that better be somewhere inside our project perhaps i want to include some system files for example standard i o dot h because i want to use things like printf and	printf	958
examples and problems from the second lecture here the cc crash ok so let's have a look at our first little first little problem here we've got here is ok so we want to know about the pre the pre processor let me pull it in here ok so what kind of three examples of common examples first of all what is the c preprocessor is that it is a text replacement tool that runs before we actually compile this c code and we can think of is very simple and fairly dump tool that only stands a few understand a few limited commands so one thing i can do is that it can we can include additional files so for example if i say ok my utility functions then that moment inside our compilation file we're going to replace that line with the contents of another file in this case my little file called my utils dot h and that better be somewhere inside our project perhaps i want to include some system files for example standard i o dot h because i want to use things like printf and	system	880
put s another kind of standard ways to do input and output inside my c file and the angle brackets here are just a hint to say this is not part of my project instead you look inside the standard include paths of the c library and my system ok so that's the first thing is just a weekend it easy music for includes	system	233
the second thing we will see is we can define macros so for example we can define the fact that if you see life then you should replace that with the value forty two ok so now if i type if life what the compiler is actually going to compile is going to see if forty two i didn't see any non zero integer is considered a truthful value so this would be true ok in fact you can define macros which take parameters as well so for example i can disable if you see my macro then expect two parameters and then we could do some things with that so for example we could	type	181
the second thing we will see is we can define macros so for example we can define the fact that if you see life then you should replace that with the value forty two ok so now if i type if life what the compiler is actually going to compile is going to see if forty two i didn't see any non zero integer is considered a truthful value so this would be true ok in fact you can define macros which take parameters as well so for example i can disable if you see my macro then expect two parameters and then we could do some things with that so for example we could	parameter	401
function like this we could say a b for example and realized then if you type my macro and you then put something in here like some quotes have a string and something else it literally will take those and replace that so now the compiler would see two strings and number and if we change our macro to say have commas then the compiler would later see values with commerce so it's a very simple text searching replacer	type	73
function like this we could say a b for example and realized then if you type my macro and you then put something in here like some quotes have a string and something else it literally will take those and replace that so now the compiler would see two strings and number and if we change our macro to say have commas then the compiler would later see values with commerce so it's a very simple text searching replacer	string	146
and the last thing that the professor is commonly useful is weak and conditionally define parts of our code so i can rap parts of my code with hash if and how shifting fine so for example i could say if life now life itself is going to be expanded to the value forty two so that would conditionally reply include all of the code then i put between that issue if an end if	code	103
you could also test to see whether even a macro over these symbols has been defined or not so for example you might say look if i have compiling on a system that's already compliant declared the simple unix or declared say debug for example then do this extra code and where would this process a symbol come from well maybe you've defined it earlier or maybe actually as part of your compilation when you go to compile this inside your make file you might specify some flags so for example you might say ok gcc please compile my code but ensure that i'll just call debug is set to something is at least defined and possibly set to something as well ok so that's quick very quick introduction to the people verse we use it to include things we use it to define macros and symbols which can be simply replaced and then we use it to conditionally	code	260
you could also test to see whether even a macro over these symbols has been defined or not so for example you might say look if i have compiling on a system that's already compliant declared the simple unix or declared say debug for example then do this extra code and where would this process a symbol come from well maybe you've defined it earlier or maybe actually as part of your compilation when you go to compile this inside your make file you might specify some flags so for example you might say ok gcc please compile my code but ensure that i'll just call debug is set to something is at least defined and possibly set to something as well ok so that's quick very quick introduction to the people verse we use it to include things we use it to define macros and symbols which can be simply replaced and then we use it to conditionally	system	150
compile parts of our code	code	21
alright let's get back to the next part right so also on the compilation step we have this wonderful thing called size of now size of it is evaluated at compile time let me say that again at compile time so if i say size of int the compiler says look on this platform i know that an inch is four bytes or eight bytes so that actually becomes a number eight four oh eight if i give it a variable like counter then it will depend upon the type that variable so if a counter isn't it again this would evaluate to save four on a particular platform possibly even two on a small embedded cpu ok so it tells us the number of bytes required to store that value if i have a pointer so let me make it a point to type so here is a pointer to an int ok so on a thirty two bit system there were thirty two wires which represents the address all my addressable memory ok so if i want to talk about a particular address being able to read or write a particular bite i need thirty two bits also known as four bytes so on that particular machine i would need for bytes to hold a pointer to a particular integer on a modern processor probably you're looking at me right now using a sixty four bit processor sixty four bits is going to require a sixty four bits to hold an address in other words it's going to take eight bytes to hold that address so so size of can be very useful now when i care about how big something is	memory	848
alright let's get back to the next part right so also on the compilation step we have this wonderful thing called size of now size of it is evaluated at compile time let me say that again at compile time so if i say size of int the compiler says look on this platform i know that an inch is four bytes or eight bytes so that actually becomes a number eight four oh eight if i give it a variable like counter then it will depend upon the type that variable so if a counter isn't it again this would evaluate to save four on a particular platform possibly even two on a small embedded cpu ok so it tells us the number of bytes required to store that value if i have a pointer so let me make it a point to type so here is a pointer to an int ok so on a thirty two bit system there were thirty two wires which represents the address all my addressable memory ok so if i want to talk about a particular address being able to read or write a particular bite i need thirty two bits also known as four bytes so on that particular machine i would need for bytes to hold a pointer to a particular integer on a modern processor probably you're looking at me right now using a sixty four bit processor sixty four bits is going to require a sixty four bits to hold an address in other words it's going to take eight bytes to hold that address so so size of can be very useful now when i care about how big something is	type	437
alright let's get back to the next part right so also on the compilation step we have this wonderful thing called size of now size of it is evaluated at compile time let me say that again at compile time so if i say size of int the compiler says look on this platform i know that an inch is four bytes or eight bytes so that actually becomes a number eight four oh eight if i give it a variable like counter then it will depend upon the type that variable so if a counter isn't it again this would evaluate to save four on a particular platform possibly even two on a small embedded cpu ok so it tells us the number of bytes required to store that value if i have a pointer so let me make it a point to type so here is a pointer to an int ok so on a thirty two bit system there were thirty two wires which represents the address all my addressable memory ok so if i want to talk about a particular address being able to read or write a particular bite i need thirty two bits also known as four bytes so on that particular machine i would need for bytes to hold a pointer to a particular integer on a modern processor probably you're looking at me right now using a sixty four bit processor sixty four bits is going to require a sixty four bits to hold an address in other words it's going to take eight bytes to hold that address so so size of can be very useful now when i care about how big something is	address	821
alright let's get back to the next part right so also on the compilation step we have this wonderful thing called size of now size of it is evaluated at compile time let me say that again at compile time so if i say size of int the compiler says look on this platform i know that an inch is four bytes or eight bytes so that actually becomes a number eight four oh eight if i give it a variable like counter then it will depend upon the type that variable so if a counter isn't it again this would evaluate to save four on a particular platform possibly even two on a small embedded cpu ok so it tells us the number of bytes required to store that value if i have a pointer so let me make it a point to type so here is a pointer to an int ok so on a thirty two bit system there were thirty two wires which represents the address all my addressable memory ok so if i want to talk about a particular address being able to read or write a particular bite i need thirty two bits also known as four bytes so on that particular machine i would need for bytes to hold a pointer to a particular integer on a modern processor probably you're looking at me right now using a sixty four bit processor sixty four bits is going to require a sixty four bits to hold an address in other words it's going to take eight bytes to hold that address so so size of can be very useful now when i care about how big something is	system	765
alright let's get back to the next part right so also on the compilation step we have this wonderful thing called size of now size of it is evaluated at compile time let me say that again at compile time so if i say size of int the compiler says look on this platform i know that an inch is four bytes or eight bytes so that actually becomes a number eight four oh eight if i give it a variable like counter then it will depend upon the type that variable so if a counter isn't it again this would evaluate to save four on a particular platform possibly even two on a small embedded cpu ok so it tells us the number of bytes required to store that value if i have a pointer so let me make it a point to type so here is a pointer to an int ok so on a thirty two bit system there were thirty two wires which represents the address all my addressable memory ok so if i want to talk about a particular address being able to read or write a particular bite i need thirty two bits also known as four bytes so on that particular machine i would need for bytes to hold a pointer to a particular integer on a modern processor probably you're looking at me right now using a sixty four bit processor sixty four bits is going to require a sixty four bits to hold an address in other words it's going to take eight bytes to hold that address so so size of can be very useful now when i care about how big something is	pointer	666
right so let's actually use it what do you think about the following he's a very strange use of the two ideas we've just put this put together right so they define size of a divided by size of a back is zero right and we're going to use this as a macro so what do you think this doesn't count to five was you have to think about it are you ready go	the following	55
give the compiler the following would say size of x divided by size of x of zero ok so what how can we make use of this size of x then is going to be the total amount of memory required to hold x right so if is it for bias great but then we say ok x squared bracket zero	the following	18
give the compiler the following would say size of x divided by size of x of zero ok so what how can we make use of this size of x then is going to be the total amount of memory required to hold x right so if is it for bias great but then we say ok x squared bracket zero	memory	170
arrays not with pointers and we'll see why in a little bit ok that's it for question one i'll see you in the next video for question two	pointer	16
ok so we've kind of talked a little bit about this idea before so it could i implement p thread mutex lock just by disabling interrupts on on the cpu so the idea here is that if my code is running on the cpu if i disable interrupts then i cannot be stopped become agent smith out of the matrix that now i own the cpu so no one else can can take it for me so one of the limitations of this first of all that yes we can ensure that we're the only ones going into the critical section if one there is only one cpu	code	181
ok so we've kind of talked a little bit about this idea before so it could i implement p thread mutex lock just by disabling interrupts on on the cpu so the idea here is that if my code is running on the cpu if i disable interrupts then i cannot be stopped become agent smith out of the matrix that now i own the cpu so no one else can can take it for me so one of the limitations of this first of all that yes we can ensure that we're the only ones going into the critical section if one there is only one cpu	section	474
ok so we've kind of talked a little bit about this idea before so it could i implement p thread mutex lock just by disabling interrupts on on the cpu so the idea here is that if my code is running on the cpu if i disable interrupts then i cannot be stopped become agent smith out of the matrix that now i own the cpu so no one else can can take it for me so one of the limitations of this first of all that yes we can ensure that we're the only ones going into the critical section if one there is only one cpu	thread	89
ok so if i control the one and only cpu and i cannot be interrupted then i get to do everything inside the critical section until i give up the cpu ok so providing i don't make any system calls providing i'm just updating my data structure no one can stop me because i disabled into apps	a struct	228
ok so if i control the one and only cpu and i cannot be interrupted then i get to do everything inside the critical section until i give up the cpu ok so providing i don't make any system calls providing i'm just updating my data structure no one can stop me because i disabled into apps	section	116
ok so if i control the one and only cpu and i cannot be interrupted then i get to do everything inside the critical section until i give up the cpu ok so providing i don't make any system calls providing i'm just updating my data structure no one can stop me because i disabled into apps	system	181
ok the second is that i require an here's a big problem here is that actually require sufficient privileges to disable the interrupts and because this is such a powerful operation by default that is disabled for normal user programs we need interrupts in order to make a cpu stop running one thread and start running another in order to handle hardware interrupt you too do to devices iot devices being ready to either take data from the system or give data from the system for example the network card might report that her new packages arrived and here's some data or a disk or solid state disk might report hey i've now finally got the data you can now read this into memory or gpu might ask for more memory more data so there's lots	memory	671
ok the second is that i require an here's a big problem here is that actually require sufficient privileges to disable the interrupts and because this is such a powerful operation by default that is disabled for normal user programs we need interrupts in order to make a cpu stop running one thread and start running another in order to handle hardware interrupt you too do to devices iot devices being ready to either take data from the system or give data from the system for example the network card might report that her new packages arrived and here's some data or a disk or solid state disk might report hey i've now finally got the data you can now read this into memory or gpu might ask for more memory more data so there's lots	thread	292
ok the second is that i require an here's a big problem here is that actually require sufficient privileges to disable the interrupts and because this is such a powerful operation by default that is disabled for normal user programs we need interrupts in order to make a cpu stop running one thread and start running another in order to handle hardware interrupt you too do to devices iot devices being ready to either take data from the system or give data from the system for example the network card might report that her new packages arrived and here's some data or a disk or solid state disk might report hey i've now finally got the data you can now read this into memory or gpu might ask for more memory more data so there's lots	system	438
of reasons why we in over a normal complex system we cannot just disable disable interrupts ok so this	system	43
is one solution to the critical section but like i said it's not a generally useful solution to the critical section we need to find a way to be able to kind of implement these correctly and will talk about some algorithmic concerns about that in the future instead now is what i've got a real challenge for you which is i want to implement a barrier in fact i'm going to give you all the code that you need here it is i just want to implement a barrier that will wait until five threads call this method called this function and i've got to keep track of how many there we go and all i'm going to give you is the following code which uses a counting semaphore so you get to choose how what you would like to implement what you'd like to to initialize is counting semaphore with and all you have to do is rearrange these lines enter the correct order so that's my challenge to you pause this video and see if you can work it out i'll give you the solution next video but before you do that make some brain new brain cell connections and actually think about how you're going to rearrange this code to the actually works by	the following	610
is one solution to the critical section but like i said it's not a generally useful solution to the critical section we need to find a way to be able to kind of implement these correctly and will talk about some algorithmic concerns about that in the future instead now is what i've got a real challenge for you which is i want to implement a barrier in fact i'm going to give you all the code that you need here it is i just want to implement a barrier that will wait until five threads call this method called this function and i've got to keep track of how many there we go and all i'm going to give you is the following code which uses a counting semaphore so you get to choose how what you would like to implement what you'd like to to initialize is counting semaphore with and all you have to do is rearrange these lines enter the correct order so that's my challenge to you pause this video and see if you can work it out i'll give you the solution next video but before you do that make some brain new brain cell connections and actually think about how you're going to rearrange this code to the actually works by	code	389
is one solution to the critical section but like i said it's not a generally useful solution to the critical section we need to find a way to be able to kind of implement these correctly and will talk about some algorithmic concerns about that in the future instead now is what i've got a real challenge for you which is i want to implement a barrier in fact i'm going to give you all the code that you need here it is i just want to implement a barrier that will wait until five threads call this method called this function and i've got to keep track of how many there we go and all i'm going to give you is the following code which uses a counting semaphore so you get to choose how what you would like to implement what you'd like to to initialize is counting semaphore with and all you have to do is rearrange these lines enter the correct order so that's my challenge to you pause this video and see if you can work it out i'll give you the solution next video but before you do that make some brain new brain cell connections and actually think about how you're going to rearrange this code to the actually works by	section	32
is one solution to the critical section but like i said it's not a generally useful solution to the critical section we need to find a way to be able to kind of implement these correctly and will talk about some algorithmic concerns about that in the future instead now is what i've got a real challenge for you which is i want to implement a barrier in fact i'm going to give you all the code that you need here it is i just want to implement a barrier that will wait until five threads call this method called this function and i've got to keep track of how many there we go and all i'm going to give you is the following code which uses a counting semaphore so you get to choose how what you would like to implement what you'd like to to initialize is counting semaphore with and all you have to do is rearrange these lines enter the correct order so that's my challenge to you pause this video and see if you can work it out i'll give you the solution next video but before you do that make some brain new brain cell connections and actually think about how you're going to rearrange this code to the actually works by	thread	480
hi welcome to let your nine so we're going to start looking at how to build a memory allocator in other words we want to implement malloc and calloc and realloc so let's get started and think how we're going to do that right so here's the game plan we're going to need a data structure to keep track of the pieces of memory that we've currently allocated plus later when they are freed we want to keep track of those for items so that we can provide them for future allocations so the bedrock of our implementation is going to be this little memory structure in here so let's take a look at this right so what are we got well today we're talking about a struct which is a way for us to put a whole lot of information together in this case we're going to have a pointer for the users area of this particular application how large it is and whether this particular entry represents some memory that is currently in use another words malloc has been called in the users using it or is available for future allocations in other words free has been called on this block of memory and we should consider it for future allocations right now a couple of quick point about this is that i don't have to keep writing struct metadata entry each time every time i want to talk about this piece of this piece of this structure i have to when i'm talking about a link list so here is my linked list so that i can chain these together but for other times i don't want to have to keep writing the word stripe let's be lazy and for that we're going to use the c word called typedef typedef you can think of is just an	memory	78
hi welcome to let your nine so we're going to start looking at how to build a memory allocator in other words we want to implement malloc and calloc and realloc so let's get started and think how we're going to do that right so here's the game plan we're going to need a data structure to keep track of the pieces of memory that we've currently allocated plus later when they are freed we want to keep track of those for items so that we can provide them for future allocations so the bedrock of our implementation is going to be this little memory structure in here so let's take a look at this right so what are we got well today we're talking about a struct which is a way for us to put a whole lot of information together in this case we're going to have a pointer for the users area of this particular application how large it is and whether this particular entry represents some memory that is currently in use another words malloc has been called in the users using it or is available for future allocations in other words free has been called on this block of memory and we should consider it for future allocations right now a couple of quick point about this is that i don't have to keep writing struct metadata entry each time every time i want to talk about this piece of this piece of this structure i have to when i'm talking about a link list so here is my linked list so that i can chain these together but for other times i don't want to have to keep writing the word stripe let's be lazy and for that we're going to use the c word called typedef typedef you can think of is just an	block	1059
hi welcome to let your nine so we're going to start looking at how to build a memory allocator in other words we want to implement malloc and calloc and realloc so let's get started and think how we're going to do that right so here's the game plan we're going to need a data structure to keep track of the pieces of memory that we've currently allocated plus later when they are freed we want to keep track of those for items so that we can provide them for future allocations so the bedrock of our implementation is going to be this little memory structure in here so let's take a look at this right so what are we got well today we're talking about a struct which is a way for us to put a whole lot of information together in this case we're going to have a pointer for the users area of this particular application how large it is and whether this particular entry represents some memory that is currently in use another words malloc has been called in the users using it or is available for future allocations in other words free has been called on this block of memory and we should consider it for future allocations right now a couple of quick point about this is that i don't have to keep writing struct metadata entry each time every time i want to talk about this piece of this piece of this structure i have to when i'm talking about a link list so here is my linked list so that i can chain these together but for other times i don't want to have to keep writing the word stripe let's be lazy and for that we're going to use the c word called typedef typedef you can think of is just an	type	1556
hi welcome to let your nine so we're going to start looking at how to build a memory allocator in other words we want to implement malloc and calloc and realloc so let's get started and think how we're going to do that right so here's the game plan we're going to need a data structure to keep track of the pieces of memory that we've currently allocated plus later when they are freed we want to keep track of those for items so that we can provide them for future allocations so the bedrock of our implementation is going to be this little memory structure in here so let's take a look at this right so what are we got well today we're talking about a struct which is a way for us to put a whole lot of information together in this case we're going to have a pointer for the users area of this particular application how large it is and whether this particular entry represents some memory that is currently in use another words malloc has been called in the users using it or is available for future allocations in other words free has been called on this block of memory and we should consider it for future allocations right now a couple of quick point about this is that i don't have to keep writing struct metadata entry each time every time i want to talk about this piece of this piece of this structure i have to when i'm talking about a link list so here is my linked list so that i can chain these together but for other times i don't want to have to keep writing the word stripe let's be lazy and for that we're going to use the c word called typedef typedef you can think of is just an	a struct	274
hi welcome to let your nine so we're going to start looking at how to build a memory allocator in other words we want to implement malloc and calloc and realloc so let's get started and think how we're going to do that right so here's the game plan we're going to need a data structure to keep track of the pieces of memory that we've currently allocated plus later when they are freed we want to keep track of those for items so that we can provide them for future allocations so the bedrock of our implementation is going to be this little memory structure in here so let's take a look at this right so what are we got well today we're talking about a struct which is a way for us to put a whole lot of information together in this case we're going to have a pointer for the users area of this particular application how large it is and whether this particular entry represents some memory that is currently in use another words malloc has been called in the users using it or is available for future allocations in other words free has been called on this block of memory and we should consider it for future allocations right now a couple of quick point about this is that i don't have to keep writing struct metadata entry each time every time i want to talk about this piece of this piece of this structure i have to when i'm talking about a link list so here is my linked list so that i can chain these together but for other times i don't want to have to keep writing the word stripe let's be lazy and for that we're going to use the c word called typedef typedef you can think of is just an	pointer	761
alias for example you could typedef float to say number and then later you might change your mind and say typedef a double to your number type so it think of it it's just a simple simple alias which means that later on in my code i can just use the following type and it's a convention in c to use underscore t when when working with your own types like this	the following	245
alias for example you could typedef float to say number and then later you might change your mind and say typedef a double to your number type so it think of it it's just a simple simple alias which means that later on in my code i can just use the following type and it's a convention in c to use underscore t when when working with your own types like this	type	28
alias for example you could typedef float to say number and then later you might change your mind and say typedef a double to your number type so it think of it it's just a simple simple alias which means that later on in my code i can just use the following type and it's a convention in c to use underscore t when when working with your own types like this	code	225
ok so so great now we've got this type we can have pointers to memory and also got appointed a memory i can talk about the entries at that memory in particular my point my pointer to some boy to memory that the user can use and how large it is ok alright so here's the game plan then is that we will have these little entries my little metadata entry and when i allocate some memory i will make a note of that i will set the pointer to point to some memory and say hey you go there's some maybe on the hit that you wanted but as you can see that i've also have a next pointer which would point to my next entry	memory	63
ok so so great now we've got this type we can have pointers to memory and also got appointed a memory i can talk about the entries at that memory in particular my point my pointer to some boy to memory that the user can use and how large it is ok alright so here's the game plan then is that we will have these little entries my little metadata entry and when i allocate some memory i will make a note of that i will set the pointer to point to some memory and say hey you go there's some maybe on the hit that you wanted but as you can see that i've also have a next pointer which would point to my next entry	type	34
ok so so great now we've got this type we can have pointers to memory and also got appointed a memory i can talk about the entries at that memory in particular my point my pointer to some boy to memory that the user can use and how large it is ok alright so here's the game plan then is that we will have these little entries my little metadata entry and when i allocate some memory i will make a note of that i will set the pointer to point to some memory and say hey you go there's some maybe on the hit that you wanted but as you can see that i've also have a next pointer which would point to my next entry	pointer	51
so we won't decide where to put these yet so let's just kind of keep this conceptually as a separate from the actual heap memory that the user sees an that will have another piece of memory that the user is using or not etc etc so great using little next point is going to build a linked list and then when the user program calls malloc i can walk through this link list looking for available entries and hopefully we've got one which is of sufficient in size and available	heap memory	117
so we won't decide where to put these yet so let's just kind of keep this conceptually as a separate from the actual heap memory that the user sees an that will have another piece of memory that the user is using or not etc etc so great using little next point is going to build a linked list and then when the user program calls malloc i can walk through this link list looking for available entries and hopefully we've got one which is of sufficient in size and available	memory	122
wait so will need to check our flags for size and free etc to see if it's going to be sufficient for the malloc request and at some point we'll get to the end of this and the next pointer work pointer nothing will just set it equal to null which is kind of a standard system program way to indicate that we got to the end of a linked list ok alright what else to talk about this i think that's going to be it we can make some conventions about how to insert and remove from this	system	268
wait so will need to check our flags for size and free etc to see if it's going to be sufficient for the malloc request and at some point we'll get to the end of this and the next pointer work pointer nothing will just set it equal to null which is kind of a standard system program way to indicate that we got to the end of a linked list ok alright what else to talk about this i think that's going to be it we can make some conventions about how to insert and remove from this	pointer	180
obviously only the head pointer that points to the beginning of my link list so if i want to insert into my link list inserting at the very front it's going to be in order on operation all i need to do is find some memory to hold my new	memory	215
obviously only the head pointer that points to the beginning of my link list so if i want to insert into my link list inserting at the very front it's going to be in order on operation all i need to do is find some memory to hold my new	pointer	24
k so here it is it behaves a lot like right we give it a file descriptor as usual we give it a buffer as usual and the number of bytes we want to write but we also give it an offset in other words we don't care about the current position in a file we just want to explicitly say where to write these bites by the way there's a similar call called pread() as well so where this becomes uh it useful is where i have say a whole load of threads which are generating output suppose for example that you run a competition against students from another university and all you have to do is sort some sort of numbers or i want a better color than that here we go and write as quickly as possible	thread	434
ok so maybe you know about threats so great you are able to chunk up the work into different jobs so that each thread is responsible for the output of the total result and so you need each thread to work independently great you say i remember those two forty one p right to the rescue that now i can tell my first thread to explicitly write its results into the first part of the file meanwhile the second thread over here is starting to generate results as well and so it can start writing bits of data over here and we can explicitly say where in the file we want that to go so yep there's pwrite and there's also pread which does a similar thing that you can read from a certain part of the file and directly specify an offset into the file so they are very useful when you want to to do random access and random reads into file but also later inside cs two forty one we're going to learn how to memory mapped files directly into memory where we no longer even need to call read and write but we can actually look at the file as if it is actually part of our address space so that's coming up later inside cs two forty one and it's the most one of the most far and most powerful features of posix and system programming that you'll see in this course so the will do what's a named pipe ok how do i make a named pipe for this you can actually make pipes on your file system you can just say make vivo because they behave as a little first in first out queue so let's call it say my queue kate and now if you look on the current directory you will see there's something called my queue so here it is looks a bit like a file right now but let's find out some more information about it ok and you'll see i've got a magic letter over here that actually it's a queue so i can put stuff into it let's say helico hello pipe that into my queue	memory	899
ok so maybe you know about threats so great you are able to chunk up the work into different jobs so that each thread is responsible for the output of the total result and so you need each thread to work independently great you say i remember those two forty one p right to the rescue that now i can tell my first thread to explicitly write its results into the first part of the file meanwhile the second thread over here is starting to generate results as well and so it can start writing bits of data over here and we can explicitly say where in the file we want that to go so yep there's pwrite and there's also pread which does a similar thing that you can read from a certain part of the file and directly specify an offset into the file so they are very useful when you want to to do random access and random reads into file but also later inside cs two forty one we're going to learn how to memory mapped files directly into memory where we no longer even need to call read and write but we can actually look at the file as if it is actually part of our address space so that's coming up later inside cs two forty one and it's the most one of the most far and most powerful features of posix and system programming that you'll see in this course so the will do what's a named pipe ok how do i make a named pipe for this you can actually make pipes on your file system you can just say make vivo because they behave as a little first in first out queue so let's call it say my queue kate and now if you look on the current directory you will see there's something called my queue so here it is looks a bit like a file right now but let's find out some more information about it ok and you'll see i've got a magic letter over here that actually it's a queue so i can put stuff into it let's say helico hello pipe that into my queue	thread	111
ok so maybe you know about threats so great you are able to chunk up the work into different jobs so that each thread is responsible for the output of the total result and so you need each thread to work independently great you say i remember those two forty one p right to the rescue that now i can tell my first thread to explicitly write its results into the first part of the file meanwhile the second thread over here is starting to generate results as well and so it can start writing bits of data over here and we can explicitly say where in the file we want that to go so yep there's pwrite and there's also pread which does a similar thing that you can read from a certain part of the file and directly specify an offset into the file so they are very useful when you want to to do random access and random reads into file but also later inside cs two forty one we're going to learn how to memory mapped files directly into memory where we no longer even need to call read and write but we can actually look at the file as if it is actually part of our address space so that's coming up later inside cs two forty one and it's the most one of the most far and most powerful features of posix and system programming that you'll see in this course so the will do what's a named pipe ok how do i make a named pipe for this you can actually make pipes on your file system you can just say make vivo because they behave as a little first in first out queue so let's call it say my queue kate and now if you look on the current directory you will see there's something called my queue so here it is looks a bit like a file right now but let's find out some more information about it ok and you'll see i've got a magic letter over here that actually it's a queue so i can put stuff into it let's say helico hello pipe that into my queue	address	1062
ok so maybe you know about threats so great you are able to chunk up the work into different jobs so that each thread is responsible for the output of the total result and so you need each thread to work independently great you say i remember those two forty one p right to the rescue that now i can tell my first thread to explicitly write its results into the first part of the file meanwhile the second thread over here is starting to generate results as well and so it can start writing bits of data over here and we can explicitly say where in the file we want that to go so yep there's pwrite and there's also pread which does a similar thing that you can read from a certain part of the file and directly specify an offset into the file so they are very useful when you want to to do random access and random reads into file but also later inside cs two forty one we're going to learn how to memory mapped files directly into memory where we no longer even need to call read and write but we can actually look at the file as if it is actually part of our address space so that's coming up later inside cs two forty one and it's the most one of the most far and most powerful features of posix and system programming that you'll see in this course so the will do what's a named pipe ok how do i make a named pipe for this you can actually make pipes on your file system you can just say make vivo because they behave as a little first in first out queue so let's call it say my queue kate and now if you look on the current directory you will see there's something called my queue so here it is looks a bit like a file right now but let's find out some more information about it ok and you'll see i've got a magic letter over here that actually it's a queue so i can put stuff into it let's say helico hello pipe that into my queue	system	1204
oh that's right into my queue there we go ok that is now waiting to invite those bites it's blocked why because no one is currently reading from that so to be able to read from the this fifa i better set up a new process that can read from this so i will start a new buffer let me get out of that because i want to the current directory so let me grab all that ok run it again and now let's start a new window and we will cd into that directory case so	block	92
my process is and how do i get rid of them you can just type rm so goodbye my queue right so there's a very quick introduction to refocus and they exist on the inside inside that directory ok so we've talked about these we talked about these	type	56
hi welcome to let your fifteen actually jump in and learn a third synchronization primitive and this one is one of the most powerful things that you're learning this course it's actually a bedrock for how you can implement other things as well so in the future when you want to say implement a barrier or complicated condition of when a thread is allowed to continue condition variables will come to the rescue so let's get started you can imagine lots of examples in life where you need to temporarily stop, like you cannot leave the house until you have your keys and something else, or you cannot say get a ticket from the train until you know which train and where you're going. so let's let's look at how condition variables can emulate this process, emulate this idea, and in particular what condition variables allow us to do is to pause a thread, to say stop, right, do not continue and then later we can wake up that specific thread all we can wake up a whole bunch of threats when some condition has changed so when the weather is warmer we want to run outside in just a t shirt great will wake up all last sleeping threads right so excuse me	a thread	335
hi welcome to let your fifteen actually jump in and learn a third synchronization primitive and this one is one of the most powerful things that you're learning this course it's actually a bedrock for how you can implement other things as well so in the future when you want to say implement a barrier or complicated condition of when a thread is allowed to continue condition variables will come to the rescue so let's get started you can imagine lots of examples in life where you need to temporarily stop, like you cannot leave the house until you have your keys and something else, or you cannot say get a ticket from the train until you know which train and where you're going. so let's let's look at how condition variables can emulate this process, emulate this idea, and in particular what condition variables allow us to do is to pause a thread, to say stop, right, do not continue and then later we can wake up that specific thread all we can wake up a whole bunch of threats when some condition has changed so when the weather is warmer we want to run outside in just a t shirt great will wake up all last sleeping threads right so excuse me	thread	337
let's talk about the basic idea than about threads so first thing is how do i send a threat to sleep easy you needed condition variable so it will create one of those a little bit but after you've got one or or you need to do is your thread should call p thread p for short p thread condition wait	thread	43
we're going to skip on some details that make it a little bit more complicated but i'm going to write it just like this for now there's pass in the address of my condition variable and so again this is a bit like file handles that yes i have a variable in my code but actually refers to something else the actual object is not the variable so will write it like that and i'm going to skip over the fact that i'm going to act you need a little bit more than that but for now we can think of it as our condition variable represents a place where our thread goes for a little nap ok so please go into this little hotel room here for it in an hour long will nap and will wake you up when life is improved by life is better when it's warmer outside when you've got your cash when you've got your keys and we're ready to go ok so we're sending our slept a thread to sleep like a quick hypnotic trance off you go so it do not do not pass go do not continue	code	259
we're going to skip on some details that make it a little bit more complicated but i'm going to write it just like this for now there's pass in the address of my condition variable and so again this is a bit like file handles that yes i have a variable in my code but actually refers to something else the actual object is not the variable so will write it like that and i'm going to skip over the fact that i'm going to act you need a little bit more than that but for now we can think of it as our condition variable represents a place where our thread goes for a little nap ok so please go into this little hotel room here for it in an hour long will nap and will wake you up when life is improved by life is better when it's warmer outside when you've got your cash when you've got your keys and we're ready to go ok so we're sending our slept a thread to sleep like a quick hypnotic trance off you go so it do not do not pass go do not continue	a thread	848
we're going to skip on some details that make it a little bit more complicated but i'm going to write it just like this for now there's pass in the address of my condition variable and so again this is a bit like file handles that yes i have a variable in my code but actually refers to something else the actual object is not the variable so will write it like that and i'm going to skip over the fact that i'm going to act you need a little bit more than that but for now we can think of it as our condition variable represents a place where our thread goes for a little nap ok so please go into this little hotel room here for it in an hour long will nap and will wake you up when life is improved by life is better when it's warmer outside when you've got your cash when you've got your keys and we're ready to go ok so we're sending our slept a thread to sleep like a quick hypnotic trance off you go so it do not do not pass go do not continue	thread	548
we're going to skip on some details that make it a little bit more complicated but i'm going to write it just like this for now there's pass in the address of my condition variable and so again this is a bit like file handles that yes i have a variable in my code but actually refers to something else the actual object is not the variable so will write it like that and i'm going to skip over the fact that i'm going to act you need a little bit more than that but for now we can think of it as our condition variable represents a place where our thread goes for a little nap ok so please go into this little hotel room here for it in an hour long will nap and will wake you up when life is improved by life is better when it's warmer outside when you've got your cash when you've got your keys and we're ready to go ok so we're sending our slept a thread to sleep like a quick hypnotic trance off you go so it do not do not pass go do not continue	address	148
full practical purposes then we my thread is going to be sleeping it's going to be blocked inside this function ok right so in the next video will talk about how to wake them up are you already ok bye	block	83
full practical purposes then we my thread is going to be sleeping it's going to be blocked inside this function ok right so in the next video will talk about how to wake them up are you already ok bye	thread	35
and his mind type and its status code of two hundred except it's everything 's ok now on the same tcp connection you can image it to say oh great thank you i've looked at the html and i've decided that i want to now request cat dot jpeg and we can get that as well so great we've made our pages significantly faster now requesting a new resource can happen every ten milliseconds if they're small resources so now in this little cat example we've reduced the time down to thirty milliseconds ok and we can continue to keep this connection alive in fact this protocol flag to do this is called keep alive	type	13
and his mind type and its status code of two hundred except it's everything 's ok now on the same tcp connection you can image it to say oh great thank you i've looked at the html and i've decided that i want to now request cat dot jpeg and we can get that as well so great we've made our pages significantly faster now requesting a new resource can happen every ten milliseconds if they're small resources so now in this little cat example we've reduced the time down to thirty milliseconds ok and we can continue to keep this connection alive in fact this protocol flag to do this is called keep alive	code	33
and his mind type and its status code of two hundred except it's everything 's ok now on the same tcp connection you can image it to say oh great thank you i've looked at the html and i've decided that i want to now request cat dot jpeg and we can get that as well so great we've made our pages significantly faster now requesting a new resource can happen every ten milliseconds if they're small resources so now in this little cat example we've reduced the time down to thirty milliseconds ok and we can continue to keep this connection alive in fact this protocol flag to do this is called keep alive	resources	397
i could actually now have a web hosting business where the same ip address and the same server listing on the ip address could be pretend to be multiple things so for example maybe i could serve the web pages for chocolate dot edu or document dot com and start selling favorite candy bars i could have another website that says sells go carts so i guess i'm listening all kind of my favorite things at this point and the same web server on the same ip address can pretend to be these different servers so as part of the http request you could now send a header the says please respond as if your host name is something in particular so i can specify a name like please behave as if you are go karts dot com for example so that kind of became an integral part of the spec and there was integrated with https as well right so we still have some problems however	address	67
ok so think about a typical kind of local call how much work do you have to do so for this we extend the stack ok we put on return address onto the stack so this is the old pc value the program counter this is where we want to go back to after we return we're going to put potentially some parameters on here though for efficiently see today because we can because silicon today is so cheap we may not put all all of the calling parameters onto the stack instead we can pass them directly through registers and that's obviously much faster than writing to to memory in order to store some parameters and we need to change the stack pointer to say hey old stack was just here this other stuff up here and now we've moved down so that if there's local variables we can	memory	559
ok so think about a typical kind of local call how much work do you have to do so for this we extend the stack ok we put on return address onto the stack so this is the old pc value the program counter this is where we want to go back to after we return we're going to put potentially some parameters on here though for efficiently see today because we can because silicon today is so cheap we may not put all all of the calling parameters onto the stack instead we can pass them directly through registers and that's obviously much faster than writing to to memory in order to store some parameters and we need to change the stack pointer to say hey old stack was just here this other stuff up here and now we've moved down so that if there's local variables we can	parameter	290
ok so think about a typical kind of local call how much work do you have to do so for this we extend the stack ok we put on return address onto the stack so this is the old pc value the program counter this is where we want to go back to after we return we're going to put potentially some parameters on here though for efficiently see today because we can because silicon today is so cheap we may not put all all of the calling parameters onto the stack instead we can pass them directly through registers and that's obviously much faster than writing to to memory in order to store some parameters and we need to change the stack pointer to say hey old stack was just here this other stuff up here and now we've moved down so that if there's local variables we can	address	131
ok so think about a typical kind of local call how much work do you have to do so for this we extend the stack ok we put on return address onto the stack so this is the old pc value the program counter this is where we want to go back to after we return we're going to put potentially some parameters on here though for efficiently see today because we can because silicon today is so cheap we may not put all all of the calling parameters onto the stack instead we can pass them directly through registers and that's obviously much faster than writing to to memory in order to store some parameters and we need to change the stack pointer to say hey old stack was just here this other stuff up here and now we've moved down so that if there's local variables we can	pointer	632
versus rpc what have we seen we've got things like marshalling and that can unmark sling and that can include changing bit representations marshall link there so we've got modifying representations we've got pausing we've got oh yes we've we've got we got to traverse data structures and which potentially involves many cache lines or what you're reading or writing to main memory we've also got ever handling as well so even if we don't take those branches there's a lot of branching code including in this we've got potentially authentication an authorization authorization to do as well so this is authentication authorization session handling so if we discovered that the remote connection is no longer good we might automatically reconnect as well so the complexity of our curls is about a hundred to a thousand lines of code at least compared to a simple local call which is perhaps one expert and i forgot one more thing as heat memory as well we might need to do some memory allocation and deallocation so	memory	374
versus rpc what have we seen we've got things like marshalling and that can unmark sling and that can include changing bit representations marshall link there so we've got modifying representations we've got pausing we've got oh yes we've we've got we got to traverse data structures and which potentially involves many cache lines or what you're reading or writing to main memory we've also got ever handling as well so even if we don't take those branches there's a lot of branching code including in this we've got potentially authentication an authorization authorization to do as well so this is authentication authorization session handling so if we discovered that the remote connection is no longer good we might automatically reconnect as well so the complexity of our curls is about a hundred to a thousand lines of code at least compared to a simple local call which is perhaps one expert and i forgot one more thing as heat memory as well we might need to do some memory allocation and deallocation so	memory allocation	976
versus rpc what have we seen we've got things like marshalling and that can unmark sling and that can include changing bit representations marshall link there so we've got modifying representations we've got pausing we've got oh yes we've we've got we got to traverse data structures and which potentially involves many cache lines or what you're reading or writing to main memory we've also got ever handling as well so even if we don't take those branches there's a lot of branching code including in this we've got potentially authentication an authorization authorization to do as well so this is authentication authorization session handling so if we discovered that the remote connection is no longer good we might automatically reconnect as well so the complexity of our curls is about a hundred to a thousand lines of code at least compared to a simple local call which is perhaps one expert and i forgot one more thing as heat memory as well we might need to do some memory allocation and deallocation so	a struct	271
versus rpc what have we seen we've got things like marshalling and that can unmark sling and that can include changing bit representations marshall link there so we've got modifying representations we've got pausing we've got oh yes we've we've got we got to traverse data structures and which potentially involves many cache lines or what you're reading or writing to main memory we've also got ever handling as well so even if we don't take those branches there's a lot of branching code including in this we've got potentially authentication an authorization authorization to do as well so this is authentication authorization session handling so if we discovered that the remote connection is no longer good we might automatically reconnect as well so the complexity of our curls is about a hundred to a thousand lines of code at least compared to a simple local call which is perhaps one expert and i forgot one more thing as heat memory as well we might need to do some memory allocation and deallocation so	code	485
is any surprise then the rpc can be at least a thousand times slower than local courts and in fact it can often be ten thousand or even up to one hundred thousand times times slower so there can be a great cost to using rpc however why do we then still use it answer because sometimes it's really useful to be able to run code remotely for example perhaps you have a what's called a thin client meaning that your compute power close to the user can be very small because most of the actual work happens on the remote end so for example you might want to automatically modify video files audio files on a remote heavy due to server that has thousands of cores and lots gpu resources and now you can do all of that heavy computational work directly from your much lighter weight local front end	code	322
is any surprise then the rpc can be at least a thousand times slower than local courts and in fact it can often be ten thousand or even up to one hundred thousand times times slower so there can be a great cost to using rpc however why do we then still use it answer because sometimes it's really useful to be able to run code remotely for example perhaps you have a what's called a thin client meaning that your compute power close to the user can be very small because most of the actual work happens on the remote end so for example you might want to automatically modify video files audio files on a remote heavy due to server that has thousands of cores and lots gpu resources and now you can do all of that heavy computational work directly from your much lighter weight local front end	resources	672
right so that's kind of feel for pc and the other thing we mentioned the other advantage of course is the security advantage of i can have a different process is with different security models and different amounts of trust an access to different resources	resources	247
ok so in the next video let's talk about different ways to kind of represent more structured data so let's move beyond just thinking about an integer or string and what about actually really want to work with more complicated data models and for this actually have a look that's how we can transfer data over a network using either jason or xml or google 's protocol buffers	string	153
ok so in the next video let's talk about different ways to kind of represent more structured data so let's move beyond just thinking about an integer or string and what about actually really want to work with more complicated data models and for this actually have a look that's how we can transfer data over a network using either jason or xml or google 's protocol buffers	protocol buffers	358
hi welcome to lecture twenty so let's have a code review where we're going to talk about a little bit of code that uses condition variables are you ready ok so my little application is very simple it's just got two threads one thread some point is going to modify this value of x and then call signal another thread is waiting for x d b positive so we can think of this basically like a latch and only after it's become positive do we continue right so what do we think about this code	code	45
hi welcome to lecture twenty so let's have a code review where we're going to talk about a little bit of code that uses condition variables are you ready ok so my little application is very simple it's just got two threads one thread some point is going to modify this value of x and then call signal another thread is waiting for x d b positive so we can think of this basically like a latch and only after it's become positive do we continue right so what do we think about this code	thread	215
right so what do we notice first of all that my code over here on the right really does need a mutex lock before we change value of x and we signal ok let's see why the problem occurs is when we call change at the same time that our second thread is actually called in this wait for positive x let's see where the problem could occur	code	48
right so what do we notice first of all that my code over here on the right really does need a mutex lock before we change value of x and we signal ok let's see why the problem occurs is when we call change at the same time that our second thread is actually called in this wait for positive x let's see where the problem could occur	a mutex	93
right so what do we notice first of all that my code over here on the right really does need a mutex lock before we change value of x and we signal ok let's see why the problem occurs is when we call change at the same time that our second thread is actually called in this wait for positive x let's see where the problem could occur	thread	240
we've got this test here and then later maybe a few nanoseconds later but it might be a bit longer eventually by calling peter condition wait my thread is going to block so here's the problem scenario what if we had an interleaving of these operations such that changing the value of x here happens after this test	block	164
we've got this test here and then later maybe a few nanoseconds later but it might be a bit longer eventually by calling peter condition wait my thread is going to block so here's the problem scenario what if we had an interleaving of these operations such that changing the value of x here happens after this test	thread	145
and calling peter condition signal happens before the thread blocks and waits for signals ok so now what's happened our second thread is going to deadlock it's now waiting for a signal that is never going to happen	block	61
and calling peter condition signal happens before the thread blocks and waits for signals ok so now what's happened our second thread is going to deadlock it's now waiting for a signal that is never going to happen	thread	54
so right now yes we have a small opportunity a chance that our second thread will deadlock how do we fix it by locking on the same mutex because then the only way that you can continue is after the threat has acquired the mutex so another thread will have to wait so now if we do that it becomes impossible to be executing these two lines of code at the same time that these two lines are being executed	code	342
so right now yes we have a small opportunity a chance that our second thread will deadlock how do we fix it by locking on the same mutex because then the only way that you can continue is after the threat has acquired the mutex so another thread will have to wait so now if we do that it becomes impossible to be executing these two lines of code at the same time that these two lines are being executed	thread	70
right the second thing that we'd like to change is this if inside here so in practice this can bite you in two different ways first of all maybe in other applications you have multiple threads calling this and we really just want to ensure their x really is positive before we continue and other things may change value x the second problem with this code is the actual deep condition wait is occasionally may suffer from what's called a spurious wake up it never truly went to sleep ok right so why does that occur well let's let's go back and talk about the implications for how conditioned weight is actually implemented right so we've just seen this problem of change in value of x and then signaling too early before they thread is actually blocking and waiting for that signal to arrive so in practice what does this mean it means that unlocking the mutex	block	746
right the second thing that we'd like to change is this if inside here so in practice this can bite you in two different ways first of all maybe in other applications you have multiple threads calling this and we really just want to ensure their x really is positive before we continue and other things may change value x the second problem with this code is the actual deep condition wait is occasionally may suffer from what's called a spurious wake up it never truly went to sleep ok right so why does that occur well let's let's go back and talk about the implications for how conditioned weight is actually implemented right so we've just seen this problem of change in value of x and then signaling too early before they thread is actually blocking and waiting for that signal to arrive so in practice what does this mean it means that unlocking the mutex	code	351
right the second thing that we'd like to change is this if inside here so in practice this can bite you in two different ways first of all maybe in other applications you have multiple threads calling this and we really just want to ensure their x really is positive before we continue and other things may change value x the second problem with this code is the actual deep condition wait is occasionally may suffer from what's called a spurious wake up it never truly went to sleep ok right so why does that occur well let's let's go back and talk about the implications for how conditioned weight is actually implemented right so we've just seen this problem of change in value of x and then signaling too early before they thread is actually blocking and waiting for that signal to arrive so in practice what does this mean it means that unlocking the mutex	thread	185
blocking a waiting for that signal has to be it has to behave as if it is an a single atomic operation in other words there is no clock cycle no moment in time between between these two events otherwise the very same argument that we just gave hear about these two operations happening just within that now window would apply to all of our cause to p three condition wait ok so we have to ensure that these behave can instantaneously together now in practice that may be impossible there could be a very narrow window between when we unlock the window unlock the mutex and block so in practice if that may occur for example because i really do have multiple cpus running on different pieces of silicon then what will happen is rather than blocking forever rp threat condition variable instead will suffer a spurious wake up to say i'm sorry maybe i missed a single maybe it just happened so that is why we always need to write this using a while so that	block	0
we can only continue if condition is met in this case the taxes become positive ok right so that's it for code review in next video let's talk about livelock bye	code	106
ok so let's talk about why the nation part of the operating system here that is ass break now if we were to look at the manpage of s break you'd read something like the following s break increases the process is data segment by end bites so when you call s break you can give it a number and you can say hey i'd like ten more bytes please alright so what does that actually mean	the following	165
ok so let's talk about why the nation part of the operating system here that is ass break now if we were to look at the manpage of s break you'd read something like the following s break increases the process is data segment by end bites so when you call s break you can give it a number and you can say hey i'd like ten more bytes please alright so what does that actually mean	system	60
ok so between you and me as big is not actually used anymore instead we're going to use some virtual memory tricks of all the slide this did modern c library uses some virtual memory tricks that we haven't learned yet so s breakers are simply mechanism but we will use it for cs two forty one to implement a simple memory allocator ok so remember how i said that the bottom of the memory i've got the text segment which is the program code and string literals and any other constants we've put in here and	memory	101
ok so between you and me as big is not actually used anymore instead we're going to use some virtual memory tricks of all the slide this did modern c library uses some virtual memory tricks that we haven't learned yet so s breakers are simply mechanism but we will use it for cs two forty one to implement a simple memory allocator ok so remember how i said that the bottom of the memory i've got the text segment which is the program code and string literals and any other constants we've put in here and	code	435
ok so between you and me as big is not actually used anymore instead we're going to use some virtual memory tricks of all the slide this did modern c library uses some virtual memory tricks that we haven't learned yet so s breakers are simply mechanism but we will use it for cs two forty one to implement a simple memory allocator ok so remember how i said that the bottom of the memory i've got the text segment which is the program code and string literals and any other constants we've put in here and	string	444
ok we can put any data we like inside there and by default the total amount of memory allocated to this is g asked sufficient for what we need ok but what about the day you call malloc and say hey my malloc i need another four thousand and ninety six bytes please this point we need need to go back to the operating system to the kernel and beg for some more van back for some more real addresses we don't want to talk to the oblivion we don't want to avoid we actually need those memory addresses now to refer to some actual memory and that's the purpose of s break is to say yes i know i've got my heap possibly say zero bytes at the beginning but that's not enough now i need to extend it so i please i'd like to move this watermark upwards say by two hundred fifty six bytes so that now i've got some more addresses i can play with i can use to hold some data so that's one less pack gives you an ability to turn on like a tap some more some more dresses which are valid ok we just keep extending this space here and we can use that then to implement possibly the world 's worst but simplest allocator so let's have a look in a moment then how we could actually use this to implement malloc are you ready are slow you in the next video bye	memory	79
ok we can put any data we like inside there and by default the total amount of memory allocated to this is g asked sufficient for what we need ok but what about the day you call malloc and say hey my malloc i need another four thousand and ninety six bytes please this point we need need to go back to the operating system to the kernel and beg for some more van back for some more real addresses we don't want to talk to the oblivion we don't want to avoid we actually need those memory addresses now to refer to some actual memory and that's the purpose of s break is to say yes i know i've got my heap possibly say zero bytes at the beginning but that's not enough now i need to extend it so i please i'd like to move this watermark upwards say by two hundred fifty six bytes so that now i've got some more addresses i can play with i can use to hold some data so that's one less pack gives you an ability to turn on like a tap some more some more dresses which are valid ok we just keep extending this space here and we can use that then to implement possibly the world 's worst but simplest allocator so let's have a look in a moment then how we could actually use this to implement malloc are you ready are slow you in the next video bye	address	387
ok we can put any data we like inside there and by default the total amount of memory allocated to this is g asked sufficient for what we need ok but what about the day you call malloc and say hey my malloc i need another four thousand and ninety six bytes please this point we need need to go back to the operating system to the kernel and beg for some more van back for some more real addresses we don't want to talk to the oblivion we don't want to avoid we actually need those memory addresses now to refer to some actual memory and that's the purpose of s break is to say yes i know i've got my heap possibly say zero bytes at the beginning but that's not enough now i need to extend it so i please i'd like to move this watermark upwards say by two hundred fifty six bytes so that now i've got some more addresses i can play with i can use to hold some data so that's one less pack gives you an ability to turn on like a tap some more some more dresses which are valid ok we just keep extending this space here and we can use that then to implement possibly the world 's worst but simplest allocator so let's have a look in a moment then how we could actually use this to implement malloc are you ready are slow you in the next video bye	system	316
ok right so this one again is sometimes couple set up in the interviews and sometimes cups comes up in exams let's have a look at thinking about what happens here with the kernel when we do something like the following so here's a kind of typical piece of c code where we're going to make a file pointer there it is and we are opening up this particular file so we're going to open up for read	the following	205
ok right so this one again is sometimes couple set up in the interviews and sometimes cups comes up in exams let's have a look at thinking about what happens here with the kernel when we do something like the following so here's a kind of typical piece of c code where we're going to make a file pointer there it is and we are opening up this particular file so we're going to open up for read	code	258
ok right so this one again is sometimes couple set up in the interviews and sometimes cups comes up in exams let's have a look at thinking about what happens here with the kernel when we do something like the following so here's a kind of typical piece of c code where we're going to make a file pointer there it is and we are opening up this particular file so we're going to open up for read	pointer	296
ok so of course we could write that kind of code in c but we could also write it in another language like python or rust or go etc java doesn't really matter what we care about is what's going out with going on with the system at this point	code	44
ok so of course we could write that kind of code in c but we could also write it in another language like python or rust or go etc java doesn't really matter what we care about is what's going out with going on with the system at this point	system	220
ok so we need to think about how we traverse different i nodes in order to kind of traverse through different directories in sub directories ok so it was the first thing that happens we have a file system mounted at route so we'll assume there isn't a file system mounted inside dtc instead were mounting the file system	system	198
uh so we've we've got as far as reading the the file and we want to know how many disk blocks in total have been read again what's assumption assumption the only mounted directory is through directory and	block	87
all i know data is cached but directory listings are not cached ok so all the words we got them right so the first directory aside the first disk access is when we actually say ok give me the contents of slash and that it gives our first mapping save et c to one two three in the others cape and we don't go out there is out again that's all our first read and then we read e t c o k so inside et see what if i got all i got a file called hosts and it's i know numbers two three four i've got some directory blah blah blah it's night number of something else baba blah so that's all second directly block weed and then we actually read the contents of the hosts file and so if i just read one block of that will be my third discreet discrete so it takes me three discrete different places in the disk to actually get the get the contents of the initial contents of the file and notice i excluded the disk reads to actually do the stat information of each i knowed assume that we've already got those cashed	block	599
next time we talk about is the critical section problem	section	40
our hints i'm sending it to zero i want to do everything where i just done by by paper and maybe i want to connect locally or maybe i want to connect to illinois ok so first of all let's try let's try it annoys see what it says if we do this ok so pick an address right so how about cs ok	address	256
right i remember that the port number must be in double quotes for passing a string ok and we're taking the address of my hints tractor in the address of the pointer	string	77
right i remember that the port number must be in double quotes for passing a string ok and we're taking the address of my hints tractor in the address of the pointer	address	108
right i remember that the port number must be in double quotes for passing a string ok and we're taking the address of my hints tractor in the address of the pointer	pointer	158
so if it fails let's just exit after printing out to the an error ok and here's where we're just going to only look at the very first entry so i make a socket with the wright family and the right socket type and	type	203
then i'm going to connect and connect all that needs is the socket file descriptor key and the address and the length of of that struct ok so let's compile this then we talk about the remainder of the code key right so	code	201
then i'm going to connect and connect all that needs is the socket file descriptor key and the address and the length of of that struct ok so let's compile this then we talk about the remainder of the code key right so	address	95
wait who it connected a k and what it gave us it told us to go to a different page ok so please refresh this and go to this other web page fine so i'd write a web server web client now which actually kind of understands this text and follow that link right but we'll see that fundamentally our request was ok and it gave us back a hundred and sixty three bites of actual content and the content gavers was a web page ok that's the mind type text slash html so let's have a brief look at the remainder of the code to see how it works	type	436
wait who it connected a k and what it gave us it told us to go to a different page ok so please refresh this and go to this other web page fine so i'd write a web server web client now which actually kind of understands this text and follow that link right but we'll see that fundamentally our request was ok and it gave us back a hundred and sixty three bites of actual content and the content gavers was a web page ok that's the mind type text slash html so let's have a brief look at the remainder of the code to see how it works	code	508
first of all i'm defining my request here just using a macro so this time rather than just requesting a resource i'm also telling the server that i wanted to behave as if i connect as if it was this other address this other host name illinois to edu here's why today we can have multiple hostnames which resolve to the same ip address and so our web server doesn't know which actual host that you would like it to pretend to be unless you tell it so perhaps if i told it that we wanted to connect to behave as ww dot c s dot illinois dot you it might give us a different response hey let's just try that for a moment ok so will compile it ok and will run the client again	address	205
ok ok nope that's still telling us to go to a different web page ok but you might notice something surprising here which is that i'm using this call i haven't talked about it before called d printf ok so d print f is this very strange call is not truly part of the posix standard but it makes our life a lot easier what it does is it	printf	191
and start passing in additional parameters ok so if you've got strings and integer numbers do you want to send to your socket remember d printf can be a useful tool here rather than using right directly and then i'm going to start reading back what the service says so i need a little buffer and i've got my little read loop in here and every time i get some bites back i'm going to write them out to standard out i'm going to finish if it	parameter	32
and start passing in additional parameters ok so if you've got strings and integer numbers do you want to send to your socket remember d printf can be a useful tool here rather than using right directly and then i'm going to start reading back what the service says so i need a little buffer and i've got my little read loop in here and every time i get some bites back i'm going to write them out to standard out i'm going to finish if it	printf	137
and start passing in additional parameters ok so if you've got strings and integer numbers do you want to send to your socket remember d printf can be a useful tool here rather than using right directly and then i'm going to start reading back what the service says so i need a little buffer and i've got my little read loop in here and every time i get some bites back i'm going to write them out to standard out i'm going to finish if it	string	63
ever fails so if either i read back zero meaning ok there's no more bites for us then i want to stop also if read return to negative one then we're not going to read anymore so this is the simplest kind of code right but it's not complete i'm not yet handling the case that we got we got interrupted i'm also not handling	code	206
ok the last thing that we're not doing in his code is gracefully shutting down tcp connection so really we should be using shut down	code	46
and also we should polite code should also call clothes on the file descriptor so we should also call socket close on the file descriptor socket	code	26
to say hey let's free up this socket but as this is very simple and short demo code that's going to happen automatically when the process shuts down ok so that's the beginnings about tcp client let's see in the next video let's talk about how to make a tcp server are you ready let's go	code	79
and if you want to use it from code then there's the equivalent system call here again we use a path but this time you actually to specify the mode numbers as well there are symbolic numbers in here or you can write your own octal number in here ok so but there is not this kind of second form you can't do this from	code	31
and if you want to use it from code then there's the equivalent system call here again we use a path but this time you actually to specify the mode numbers as well there are symbolic numbers in here or you can write your own octal number in here ok so but there is not this kind of second form you can't do this from	system	64
code ok you have to specify a number now it turns out that the mode bits also have two other kind of secret bits that most programmers don't know about so these two other bits are what's called the set uid bits and here's the idea normally when i run a program like say ls or little out just going to run it as the user that's logged in there has called fork 's called exec and we're going to run under that users privileges ok but what about a special program like sudo so sudo as you know will run as a different allows you to run as a different user allows you to have great privileges right you can potentially do things as the administrator as root for example so clearly the program sudo itself needs some extra	code	0
when you run it when you execute it you're not only given permission to execute it but on my system sudo will actually run as root not as you right so that's the effective user id little bit there's also one for the group but let's not worry about that today	system	93
hi ok right so let's have another go implementing a mutex lock but this time we've got a useful little	a mutex	50
x cpu instruction called exchange and here's what it's defined to do it's going to swap two values at two addresses as an atomic operation music sell uranium powered or thorium powered know what do we mean by atomic is it's an indivisible uninterruptible operation	exchange	25
x cpu instruction called exchange and here's what it's defined to do it's going to swap two values at two addresses as an atomic operation music sell uranium powered or thorium powered know what do we mean by atomic is it's an indivisible uninterruptible operation	address	106
rather than write assembly code will imagine that i've got a function here codex exchange that behaves as if it's some assembly code ok so let's mock out this code here's how we're going to write it then so	code	27
rather than write assembly code will imagine that i've got a function here codex exchange that behaves as if it's some assembly code ok so let's mock out this code here's how we're going to write it then so	exchange	81
call this exchange assembly instruction there all these people pretend that this is ok and we will say here's the address of q here's the	exchange	10
call this exchange assembly instruction there all these people pretend that this is ok and we will say here's the address of q here's the	address	114
address of upside i need that scroll set up	address	0
as n ok so swap the contents of q and the address of n ok right so why do we do that so let's think about what we're doing we've got this hot potato that we want to put into mutex which don't tell anybody but we're going to just treat as an integer and then we're going to keep going around this loop when we read the value of one so when the first thread calls mutex lock here's what's going to happen it's going to swap its value of one here with a value of zero so	thread	349
as n ok so swap the contents of q and the address of n ok right so why do we do that so let's think about what we're doing we've got this hot potato that we want to put into mutex which don't tell anybody but we're going to just treat as an integer and then we're going to keep going around this loop when we read the value of one so when the first thread calls mutex lock here's what's going to happen it's going to swap its value of one here with a value of zero so	address	42
over here here's my mutex lock it's now got one in but the value that q it now has is zero so it escapes out of this loop and can continue so that first they can go into his critical section meanwhile as second thread calls mutex lock ok what happens to it well its own value of q is one and then it calls exchange right but it's just going to exchange a value of one with one because that's what's already inside the mutex log so now it reads a value of what again so what's it doing it goes around the loop again continuously trying to get rid of this hot potato right so it's like i've got a one oh what do i do i'm going to keep calling exchange i'm going to keep trying to push it into the mutex lock	the loop	500
over here here's my mutex lock it's now got one in but the value that q it now has is zero so it escapes out of this loop and can continue so that first they can go into his critical section meanwhile as second thread calls mutex lock ok what happens to it well its own value of q is one and then it calls exchange right but it's just going to exchange a value of one with one because that's what's already inside the mutex log so now it reads a value of what again so what's it doing it goes around the loop again continuously trying to get rid of this hot potato right so it's like i've got a one oh what do i do i'm going to keep calling exchange i'm going to keep trying to push it into the mutex lock	section	183
over here here's my mutex lock it's now got one in but the value that q it now has is zero so it escapes out of this loop and can continue so that first they can go into his critical section meanwhile as second thread calls mutex lock ok what happens to it well its own value of q is one and then it calls exchange right but it's just going to exchange a value of one with one because that's what's already inside the mutex log so now it reads a value of what again so what's it doing it goes around the loop again continuously trying to get rid of this hot potato right so it's like i've got a one oh what do i do i'm going to keep calling exchange i'm going to keep trying to push it into the mutex lock	thread	211
over here here's my mutex lock it's now got one in but the value that q it now has is zero so it escapes out of this loop and can continue so that first they can go into his critical section meanwhile as second thread calls mutex lock ok what happens to it well its own value of q is one and then it calls exchange right but it's just going to exchange a value of one with one because that's what's already inside the mutex log so now it reads a value of what again so what's it doing it goes around the loop again continuously trying to get rid of this hot potato right so it's like i've got a one oh what do i do i'm going to keep calling exchange i'm going to keep trying to push it into the mutex lock	exchange	306
ok so we've only get to escape out of that loop when filing is able to get back a value of zero so where does that happen after the first read has finished with this critical section and writes back a value of zero ok so there we get so with this implementation then thank you hardware people were now able to ensure that are critical section is more sophisticated solution today will go to sleep for example if we can't do this within ten thousand nanoseconds in fact rather than just directly calling atomic operations today period mutex locks actually does a lot more than this it uses a kernel resource called a spinlock and also we have to ensure that our eddie information inside our caches are correctly pushed back out to main memory so if the actual implementation of preferred mutex lock is a little bit more complicated than this it includes memory barriers and performance characteristics but i hope you see how ultimately we need hardware support to ensure that our preferred mutex lock is atomic	memory	735
ok so we've only get to escape out of that loop when filing is able to get back a value of zero so where does that happen after the first read has finished with this critical section and writes back a value of zero ok so there we get so with this implementation then thank you hardware people were now able to ensure that are critical section is more sophisticated solution today will go to sleep for example if we can't do this within ten thousand nanoseconds in fact rather than just directly calling atomic operations today period mutex locks actually does a lot more than this it uses a kernel resource called a spinlock and also we have to ensure that our eddie information inside our caches are correctly pushed back out to main memory so if the actual implementation of preferred mutex lock is a little bit more complicated than this it includes memory barriers and performance characteristics but i hope you see how ultimately we need hardware support to ensure that our preferred mutex lock is atomic	section	175
last thing will will mention today for this today's lecture video is the idea that what we're actually talking about is this basic problem of how do i implement a critical section and	section	172
and we want to find ways to ensure the only one thread enter the critical section at a time so this is actually a classic operating system problem because critical sections occur all over the place inside the kernel because there's so much concurrency going on and can we kind of find a way to write code to ensure that	code	300
and we want to find ways to ensure the only one thread enter the critical section at a time so this is actually a classic operating system problem because critical sections occur all over the place inside the kernel because there's so much concurrency going on and can we kind of find a way to write code to ensure that	section	74
and we want to find ways to ensure the only one thread enter the critical section at a time so this is actually a classic operating system problem because critical sections occur all over the place inside the kernel because there's so much concurrency going on and can we kind of find a way to write code to ensure that	thread	48
and we want to find ways to ensure the only one thread enter the critical section at a time so this is actually a classic operating system problem because critical sections occur all over the place inside the kernel because there's so much concurrency going on and can we kind of find a way to write code to ensure that	system	132
only one thread or process or algorithm can actually manipulate one resource two resources at a time ok so this is kind of the last similar sorry this is a future thing we're going to look at in a different lecture is how can we implement or how can we solve this critical section problem which we've today we solve using mutex locks but how can we solve this in a kind of algorithmic fashion	section	273
only one thread or process or algorithm can actually manipulate one resource two resources at a time ok so this is kind of the last similar sorry this is a future thing we're going to look at in a different lecture is how can we implement or how can we solve this critical section problem which we've today we solve using mutex locks but how can we solve this in a kind of algorithmic fashion	thread	9
only one thread or process or algorithm can actually manipulate one resource two resources at a time ok so this is kind of the last similar sorry this is a future thing we're going to look at in a different lecture is how can we implement or how can we solve this critical section problem which we've today we solve using mutex locks but how can we solve this in a kind of algorithmic fashion	resources	81
and at the steps were going to kind of concentrate on here is actually this very first step is to somehow we need a way to wait to enter the griddle section if another thread or process is inside the critical section and then we'll do something so there's a critical section code and then will lead to critical section so we need to do something after that and then most of the time off threads and processes doing other things so that's the problem we're going to solve this problem we're going to address is how do we how do we correctly deal with critical sections and we're going to look from this from a historical perspective and look at some examples which don't work alright that's it for today that's it for days lecture video and i'll see you in the future bye	code	275
and at the steps were going to kind of concentrate on here is actually this very first step is to somehow we need a way to wait to enter the griddle section if another thread or process is inside the critical section and then we'll do something so there's a critical section code and then will lead to critical section so we need to do something after that and then most of the time off threads and processes doing other things so that's the problem we're going to solve this problem we're going to address is how do we how do we correctly deal with critical sections and we're going to look from this from a historical perspective and look at some examples which don't work alright that's it for today that's it for days lecture video and i'll see you in the future bye	section	149
and at the steps were going to kind of concentrate on here is actually this very first step is to somehow we need a way to wait to enter the griddle section if another thread or process is inside the critical section and then we'll do something so there's a critical section code and then will lead to critical section so we need to do something after that and then most of the time off threads and processes doing other things so that's the problem we're going to solve this problem we're going to address is how do we how do we correctly deal with critical sections and we're going to look from this from a historical perspective and look at some examples which don't work alright that's it for today that's it for days lecture video and i'll see you in the future bye	thread	168
and at the steps were going to kind of concentrate on here is actually this very first step is to somehow we need a way to wait to enter the griddle section if another thread or process is inside the critical section and then we'll do something so there's a critical section code and then will lead to critical section so we need to do something after that and then most of the time off threads and processes doing other things so that's the problem we're going to solve this problem we're going to address is how do we how do we correctly deal with critical sections and we're going to look from this from a historical perspective and look at some examples which don't work alright that's it for today that's it for days lecture video and i'll see you in the future bye	address	499
ok right sir i remember the next question is going to talk about and it's the following it's actually a typical kind of interview question where we look at something a power is simple and then say ok what actually happens what all the steps so let's take a look at the kind of typical question suppose you opened up a terminal and you ran the following so call http illinois dot edu and press return what happens next right so this is an opportunity to show off all of your operating system knowledge and system programming knowledge ok so first of all what is curl right so we better talk about that for a moment ok so curl actually is a bit like cat but rather than saying ok tammy cat about a file curl will connect to a website it understand several protocols including http and https and it will make a connection to a web server so great and then we can see we've connected to this and we've got back the kind of basic html document ok the actual body of the response we can probably ask it for more information maybe if we do kind of both it will tell us about how it's trying to connect what is trying to connect to and you'll see that uh this is what it's sent ok it's sent the following we actually can tell curl to send additional information as well if we wish and then here's the actual response headers we get back which is a standard http key by the way your web browser will can also kind of tell you some basic cool stuff as well	the following	74
ok right sir i remember the next question is going to talk about and it's the following it's actually a typical kind of interview question where we look at something a power is simple and then say ok what actually happens what all the steps so let's take a look at the kind of typical question suppose you opened up a terminal and you ran the following so call http illinois dot edu and press return what happens next right so this is an opportunity to show off all of your operating system knowledge and system programming knowledge ok so first of all what is curl right so we better talk about that for a moment ok so curl actually is a bit like cat but rather than saying ok tammy cat about a file curl will connect to a website it understand several protocols including http and https and it will make a connection to a web server so great and then we can see we've connected to this and we've got back the kind of basic html document ok the actual body of the response we can probably ask it for more information maybe if we do kind of both it will tell us about how it's trying to connect what is trying to connect to and you'll see that uh this is what it's sent ok it's sent the following we actually can tell curl to send additional information as well if we wish and then here's the actual response headers we get back which is a standard http key by the way your web browser will can also kind of tell you some basic cool stuff as well	a terminal	316
ok right sir i remember the next question is going to talk about and it's the following it's actually a typical kind of interview question where we look at something a power is simple and then say ok what actually happens what all the steps so let's take a look at the kind of typical question suppose you opened up a terminal and you ran the following so call http illinois dot edu and press return what happens next right so this is an opportunity to show off all of your operating system knowledge and system programming knowledge ok so first of all what is curl right so we better talk about that for a moment ok so curl actually is a bit like cat but rather than saying ok tammy cat about a file curl will connect to a website it understand several protocols including http and https and it will make a connection to a web server so great and then we can see we've connected to this and we've got back the kind of basic html document ok the actual body of the response we can probably ask it for more information maybe if we do kind of both it will tell us about how it's trying to connect what is trying to connect to and you'll see that uh this is what it's sent ok it's sent the following we actually can tell curl to send additional information as well if we wish and then here's the actual response headers we get back which is a standard http key by the way your web browser will can also kind of tell you some basic cool stuff as well	system	484
so for example his day the whale say demo that we saw and in fact it shows you on this web page how that well say image was created that's a system kind of dockerfile script that says ok start from a bun to run these unbuntu things to install a hollow door stuff and copy some basic stuff into the file system of that image and then finally this will be the default command if no one	system	141
i could send those as well etc etc etc ok so now if i run this and hit return it didn't return anything because in this case i've the information is already cached in fact if we did have both mode we would see that it's returning back to say hey actually you can just use your cash version that we haven't modified it on the server so just go ahead and use your local copy alright so let's go back to our original question and say how do we answer this how do we answer this kind of curl questions right so this is giving us an opportunity to talk about the fact that first of all we're inside a shell so inside the shell we have now got this string of letters curl space and blah blah blah and a new turn ok so now we can talk about the fact that our shell is in the middle of a reed call and waiting for the next line of content so the moment we press return that is when that's going to be given to our our process which what will it do next ok we've got	a shell	594
i could send those as well etc etc etc ok so now if i run this and hit return it didn't return anything because in this case i've the information is already cached in fact if we did have both mode we would see that it's returning back to say hey actually you can just use your cash version that we haven't modified it on the server so just go ahead and use your local copy alright so let's go back to our original question and say how do we answer this how do we answer this kind of curl questions right so this is giving us an opportunity to talk about the fact that first of all we're inside a shell so inside the shell we have now got this string of letters curl space and blah blah blah and a new turn ok so now we can talk about the fact that our shell is in the middle of a reed call and waiting for the next line of content so the moment we press return that is when that's going to be given to our our process which what will it do next ok we've got	string	643
this now inside some buffer maybe on the heap for example	the heap	37
of exact which will use the path because we're going to look for this command called curl somewhere on that set of directories ok so assuming we find it we're going to start this new process and pass in this as these as its argument ok so we can now talk about how cold works so the first we want to say is ok we're going to call exact so we're going to load in the bites of cult into memory remember we have a head transplant at this moment goodbye the shell whatever was going on side that side that process because now we're going to be calling the main function for curl and we're going to pass in the arguments ok so when it starts up kerbal purse passwords given to it and it's v r x y and you will see the string so now we can start talking about finally about some of the network stuff how we have to first of all identify a domain name so it's illinois dot edu so we're going to try to connect to that how does that work ok great now you have an opportunity to talk about dns we're going to turn that into some ip addresses by doing dns what is dns development done name name system how does that work ok so now you can talk about the fact that maybe you've got an entry locally inside your e t c hosts file	memory	385
of exact which will use the path because we're going to look for this command called curl somewhere on that set of directories ok so assuming we find it we're going to start this new process and pass in this as these as its argument ok so we can now talk about how cold works so the first we want to say is ok we're going to call exact so we're going to load in the bites of cult into memory remember we have a head transplant at this moment goodbye the shell whatever was going on side that side that process because now we're going to be calling the main function for curl and we're going to pass in the arguments ok so when it starts up kerbal purse passwords given to it and it's v r x y and you will see the string so now we can start talking about finally about some of the network stuff how we have to first of all identify a domain name so it's illinois dot edu so we're going to try to connect to that how does that work ok great now you have an opportunity to talk about dns we're going to turn that into some ip addresses by doing dns what is dns development done name name system how does that work ok so now you can talk about the fact that maybe you've got an entry locally inside your e t c hosts file	string	713
of exact which will use the path because we're going to look for this command called curl somewhere on that set of directories ok so assuming we find it we're going to start this new process and pass in this as these as its argument ok so we can now talk about how cold works so the first we want to say is ok we're going to call exact so we're going to load in the bites of cult into memory remember we have a head transplant at this moment goodbye the shell whatever was going on side that side that process because now we're going to be calling the main function for curl and we're going to pass in the arguments ok so when it starts up kerbal purse passwords given to it and it's v r x y and you will see the string so now we can start talking about finally about some of the network stuff how we have to first of all identify a domain name so it's illinois dot edu so we're going to try to connect to that how does that work ok great now you have an opportunity to talk about dns we're going to turn that into some ip addresses by doing dns what is dns development done name name system how does that work ok so now you can talk about the fact that maybe you've got an entry locally inside your e t c hosts file	address	1023
of exact which will use the path because we're going to look for this command called curl somewhere on that set of directories ok so assuming we find it we're going to start this new process and pass in this as these as its argument ok so we can now talk about how cold works so the first we want to say is ok we're going to call exact so we're going to load in the bites of cult into memory remember we have a head transplant at this moment goodbye the shell whatever was going on side that side that process because now we're going to be calling the main function for curl and we're going to pass in the arguments ok so when it starts up kerbal purse passwords given to it and it's v r x y and you will see the string so now we can start talking about finally about some of the network stuff how we have to first of all identify a domain name so it's illinois dot edu so we're going to try to connect to that how does that work ok great now you have an opportunity to talk about dns we're going to turn that into some ip addresses by doing dns what is dns development done name name system how does that work ok so now you can talk about the fact that maybe you've got an entry locally inside your e t c hosts file	system	1085
or maybe there's a cashed information because you've recently kind of connected to this website but if not we have to make an external request and dns simple dns today just uses udp packets so we send it out saying hey neighbors i'm looking for an ip address associated with this host name and whoever can tell me the answer the fastest wins that's what happens today tomorrow hopefully we're going to have more secure systems for example this current discussions about running dns over https so that it's more difficult to forge and not possible for internet providers to sniff all of your dns traffic	address	251
or maybe there's a cashed information because you've recently kind of connected to this website but if not we have to make an external request and dns simple dns today just uses udp packets so we send it out saying hey neighbors i'm looking for an ip address associated with this host name and whoever can tell me the answer the fastest wins that's what happens today tomorrow hopefully we're going to have more secure systems for example this current discussions about running dns over https so that it's more difficult to forge and not possible for internet providers to sniff all of your dns traffic	system	419
ok so finally we get back an ip address great so now we can try to make some different sockets like its ip six sockets so ip four sockets and then start making tcp connections to our web server we know that http runs on port eighty so we haven't specified reports we're going to use a default poor poor eighty so let's connect to the illinois edu server and then start talking this particular protocol so now we can talk about the fact that we're going to send to the server	address	32
our server is stuck now if you wanted to you could also talk about the network calls that you required to do this so you could talk about get address info to make your life easier you could talk about you created a socket you could talk about you've called connect in order to connect to the other side you could talk about then that gives you gotta far descriptor so you can do all the standard stuff like using right or deeper in tf etc etc etc right and then finally have are the other side returns and gives you back talk to you back in http and that will include a bunch of headers in the response headers and possibly some content as well which by default called this prints out who fantastic did i get the internship that i get the job but i hope you see how if you slow down in these kinds of interview questions rather than just kind of panicking and so it tells the network actually kind of start and took a very carefully about all the things that happened you actually have a lot to say and so this class c s two forty one can give you kind of a lot of ideas things to say in these kind of interview questions	address	142
and if you want to use it from code then there's the equivalent system call here again we use a path but this time you actually to specify the mode numbers as well there are symbolic numbers in here or you can write your own octal number in here ok so but there is not this kind of second form you can't do this from	code	31
and if you want to use it from code then there's the equivalent system call here again we use a path but this time you actually to specify the mode numbers as well there are symbolic numbers in here or you can write your own octal number in here ok so but there is not this kind of second form you can't do this from	system	64
code ok you have to specify a number now it turns out that the mode bits also have two other kind of secret bits that most programmers don't know about so these two other bits are what's called the set uid bits and here's the idea normally when i run a program like say ls or little out just going to run it as the user that's logged in there has called fork 's called exec and we're going to run under that users privileges ok but what about a special program like sue do so sue do as you know will run as a different allows you to run as a different user allows you to have great privileges right you can potentially do things as the administrator as root for example so clearly the program pseudo itself needs some extra	code	0
when you run it when you execute it you're not only given permission to execute it but on my system suit will actually run as root not as you right so that's the effective user id little bit there's also one for the group but let's not worry about that today	system	93
hi so let's start talking about the reader writer problem this occurs in all sorts of problems where i want to build a read things for many different processes and threads and occasionally update it so this for example might be a cash it might be your web cache perhaps you've heard today that many you have your web pages aren't served by a single server but instead we have hundreds or thousands of boxes set up around the globe already to cash your content and so that's how we can have an extremely responsive an fast that internet by caching the content close to the end user user so great most of the time we just want to do some kind of key based look up so ultimately we have this kind of algorithmically idea but occasionally we actually want to update values into that cash similar example is maybe you've got a sql database or no sql database and i need to do some kind of query on a table	thread	164
but occasionally i actually want to update that so now i want to say right let's say updater or update a particular entry inside my database and i need to make sure i can do this without destroying the validity of my look up 's and so this is a concurrency problem when it's happening all of the time is what powers are all of our modern applications so if you were to implement this today here's the good news are posix specification includes not only p threads not only condition variables but reader writer locks as well ok so	thread	455
that i make not just a mutex lock but a reader writer lock here it is	a mutex	21
doing either of these i can unlock it as well so for example if i want to i want to make sure my cash look up is thread safe before doing anything called the read lock do my stuff maybe opened file go to the white line of the file that kind of thing and then unlock it ok great so that's how we can do things outside of cs two forty one when you want to do your next	thread	113
ok great so let's start talking about mandelbrot sets so here's a great wonderful idea i wanted to choose something which was it was called embarrassingly parallel meaning that we can just set all cpus off calculating something and then we don't need to think about any communication between those cpus we don't need to think about them trying to update the same piece of memory at the same time so this is a very easy problem for us to parallelize into play with do understand how to use p threads before we move on to more complicated examples ok so we're going to put together a lot of ideas first of all let's talk about a little bit of math so here's the plan i want you to think of a number right now i'd like you to square that number	memory	372
ok great so let's start talking about mandelbrot sets so here's a great wonderful idea i wanted to choose something which was it was called embarrassingly parallel meaning that we can just set all cpus off calculating something and then we don't need to think about any communication between those cpus we don't need to think about them trying to update the same piece of memory at the same time so this is a very easy problem for us to parallelize into play with do understand how to use p threads before we move on to more complicated examples ok so we're going to put together a lot of ideas first of all let's talk about a little bit of math so here's the plan i want you to think of a number right now i'd like you to square that number	thread	491
going to stay around zero but for much larger numbers they're very quickly exponent get away because we are squaring our current number so that's why we're actually going to look at here this is our sdr code for calculating the manager set and it's something we can do very nicely on distant kind of ten lines of code here it is especially as see actually support sir complex numbers so you didn't think of a complex number or shame on you right so here we go for it we can we see so let's pass in a screen position so that will be of x and y and we will turn that into a complex number somewhere close to the origin somewhere close to zero so will convert are those into some real number and some imaginary component as well right so i've now i've got my constant but i'm going to keep adding around each time now i just want to play my think of a number game so will start off with a value of zero will tried playing this game for say like a thousand times also so we'll go around this little loop but will quit if my value of my complex number z here gets too large so once it's greater than two we know we're going to lose anyway we know we're on the path some exponentially large number ok so we're only gonna keep this plate keep playing this game then if we stay close to the origin and we haven't exhausted the number of maximum iterations were prepared to play this game so here's our game right so just update busy with squaring with z adding the complex number we first thought of wait so when we finished playing this game it would be nice to play this display this in a nice colorful way so here's what we've got if i manage to stay close to the origin i'm going to use a white color so my rg and b values are going to be large as possible otherwise i've got a fun little multiplication function here	code	203
and i want to store the results somewhere so let's get some memory let's use calloc right and this time	memory	60
i wanted to say how many bytes exactly i want ansi supports these wonderful things here where we actually say the number of bits we want so today i would like this unsigned buster you hear unsigned integer through two bits please so i know i'm definitely talking about a four byte integer and right so use that in my car lock as well to to declare that's a total number of bytes so i'm going to need per element right so that's my code the last thing will do is somewhere for loop here is don't forget to update the ui so after calculating sixteen rose we want to	code	431
update the ui somehow in other words take my array of pixels which is just a big block of memory inside the heap and displayed on the screen so how do i do that i do the following let's take a tape why mask it with the value fifteen so in other words i only care about the lowest four bits and if those lowest four bits are equal to fifteen then display the ui ok so providing my screen size is actually some multiple of sixteen then i'll make sure that i update this every sixteen rows and i also updated at the end if it's not some multiple of sixteen then i should call update gui a one more time before exiting or before finishing right so let's have a look at this this actually have a play with this ok so i've compiled already i've got a little make file here	the following	166
update the ui somehow in other words take my array of pixels which is just a big block of memory inside the heap and displayed on the screen so how do i do that i do the following let's take a tape why mask it with the value fifteen so in other words i only care about the lowest four bits and if those lowest four bits are equal to fifteen then display the ui ok so providing my screen size is actually some multiple of sixteen then i'll make sure that i update this every sixteen rows and i also updated at the end if it's not some multiple of sixteen then i should call update gui a one more time before exiting or before finishing right so let's have a look at this this actually have a play with this ok so i've compiled already i've got a little make file here	memory	90
update the ui somehow in other words take my array of pixels which is just a big block of memory inside the heap and displayed on the screen so how do i do that i do the following let's take a tape why mask it with the value fifteen so in other words i only care about the lowest four bits and if those lowest four bits are equal to fifteen then display the ui ok so providing my screen size is actually some multiple of sixteen then i'll make sure that i update this every sixteen rows and i also updated at the end if it's not some multiple of sixteen then i should call update gui a one more time before exiting or before finishing right so let's have a look at this this actually have a play with this ok so i've compiled already i've got a little make file here	the heap	104
update the ui somehow in other words take my array of pixels which is just a big block of memory inside the heap and displayed on the screen so how do i do that i do the following let's take a tape why mask it with the value fifteen so in other words i only care about the lowest four bits and if those lowest four bits are equal to fifteen then display the ui ok so providing my screen size is actually some multiple of sixteen then i'll make sure that i update this every sixteen rows and i also updated at the end if it's not some multiple of sixteen then i should call update gui a one more time before exiting or before finishing right so let's have a look at this this actually have a play with this ok so i've compiled already i've got a little make file here	block	81
k so we just look we look at the make fall you see i've got ok let's do my initial manda brought no thread	thread	100
ok right so let's design a way to do this mapping ok so here's our exciting problem we've got an address	address	97
that needs to be converted into a particular place or inside our actual physical memory ok who's doing this answer the memory management unit which is part of the cpu so this happens transparently every time that your code is running every time reading a variable every time it's wants to read the next operation for the the program counter ok so let's think about how we can do this our planet is for every page here to have an entry inside a large look up table ok so let's think a little bit about how big this look up table is going to be right so i'm on a thirty two bit machine and so i've got two to thirty two possible addresses but hold on a moment we said that the lowest twelve bits are going to be used on my page offset so actually i've only got thirty two minus twelve ie twenty why is left in other words i've got two to the twenty possible pages	memory	81
that needs to be converted into a particular place or inside our actual physical memory ok who's doing this answer the memory management unit which is part of the cpu so this happens transparently every time that your code is running every time reading a variable every time it's wants to read the next operation for the the program counter ok so let's think about how we can do this our planet is for every page here to have an entry inside a large look up table ok so let's think a little bit about how big this look up table is going to be right so i'm on a thirty two bit machine and so i've got two to thirty two possible addresses but hold on a moment we said that the lowest twelve bits are going to be used on my page offset so actually i've only got thirty two minus twelve ie twenty why is left in other words i've got two to the twenty possible pages	code	218
that needs to be converted into a particular place or inside our actual physical memory ok who's doing this answer the memory management unit which is part of the cpu so this happens transparently every time that your code is running every time reading a variable every time it's wants to read the next operation for the the program counter ok so let's think about how we can do this our planet is for every page here to have an entry inside a large look up table ok so let's think a little bit about how big this look up table is going to be right so i'm on a thirty two bit machine and so i've got two to thirty two possible addresses but hold on a moment we said that the lowest twelve bits are going to be used on my page offset so actually i've only got thirty two minus twelve ie twenty why is left in other words i've got two to the twenty possible pages	address	627
so did you follow that right so you could imagine you know i've got these thirty two wires do did did did did did did to do ok and we said we have a page offset which is nielaus twelve bits 'cause i'm divided everything to four thousand ninety six and so i've only got twenty bits left to actually describe my pages ok so that's number of pages	a page	147
and so there needs to be an entry for each page inside this big giant look up table you can imagine it is just say like an array except that we're not going to write code to actually talk to this array directly instead the silicon is going to be implemented to actually talk to this very directly	code	166
if our address space for physical memory is also thirty two bits you might say well it's two to the thirty two of them except we've divided things up into four thousand ninety six chunks so the same argument applies that after these thirty two bits we just discovered in the last twelve bits in other words this only twenty bits remaining so we've actually only got twenty bits to play with so we need to store twenty bits for each entry alright so we got two to twenty pages the number of entries and each one is going to be twenty bits ok so how big is twenty bits it's two and a half bites alright so are you suggesting that we make an array then where each the size of each entry is two and a half bites oh i don't like the sound of that let's run that up let's roll out up to three bytes ok hold on a moment i don't like doing arithmetic and primitives which can fall on odd by entries so i'm going to run that up to four bytes ok so now each entry is going to be four bytes as a little wasteful but it will make the hardware implementation simpler	memory	34
if our address space for physical memory is also thirty two bits you might say well it's two to the thirty two of them except we've divided things up into four thousand ninety six chunks so the same argument applies that after these thirty two bits we just discovered in the last twelve bits in other words this only twenty bits remaining so we've actually only got twenty bits to play with so we need to store twenty bits for each entry alright so we got two to twenty pages the number of entries and each one is going to be twenty bits ok so how big is twenty bits it's two and a half bites alright so are you suggesting that we make an array then where each the size of each entry is two and a half bites oh i don't like the sound of that let's run that up let's roll out up to three bytes ok hold on a moment i don't like doing arithmetic and primitives which can fall on odd by entries so i'm going to run that up to four bytes ok so now each entry is going to be four bytes as a little wasteful but it will make the hardware implementation simpler	address	7
ok so now i want you to imagine then somewhere stored inside my actual memory as well except you don't get to see it the hardware or uses giant look up table let's put it over here and so what's it look like just lots and lots of little entries where each entry is four bytes and so each entry holds a number and we use this by going to a particular entry for a particular page to read out the right physical frame	memory	71
let's imagine that we're trying to read some memory inside my program right now i want to change a bite in my heat for example ok so we convert their physical psychological address the virtual memory address and we see this in page six so let's go to page six one two three four let's imagine it's just here ok and we read this entry right ok page six i see that this corresponds to some frame number like let's imagine this is frame forty seven cases	memory	45
let's imagine that we're trying to read some memory inside my program right now i want to change a bite in my heat for example ok so we convert their physical psychological address the virtual memory address and we see this in page six so let's go to page six one two three four let's imagine it's just here ok and we read this entry right ok page six i see that this corresponds to some frame number like let's imagine this is frame forty seven cases	address	173
right so now when we actually want to read that bite inside the heap we go to this frame and we use the original offset that you had ok so here's the offset those lower twelve bits and literally those twelve wires will be we don't touch that we don't even need to think about that what does push them straight out towards our ram and so that we can now actually read the correct but ok so that's our plan but we've just invented is called a page table so we've got a single level page table and it's	a page	439
right so now when we actually want to read that bite inside the heap we go to this frame and we use the original offset that you had ok so here's the offset those lower twelve bits and literally those twelve wires will be we don't touch that we don't even need to think about that what does push them straight out towards our ram and so that we can now actually read the correct but ok so that's our plan but we've just invented is called a page table so we've got a single level page table and it's	the heap	60
right so now when we actually want to read that bite inside the heap we go to this frame and we use the original offset that you had ok so here's the offset those lower twelve bits and literally those twelve wires will be we don't touch that we don't even need to think about that what does push them straight out towards our ram and so that we can now actually read the correct but ok so that's our plan but we've just invented is called a page table so we've got a single level page table and it's	a page table	439
and it gives us the security of of each process now each process will have its own page table so we've just looked at the page table one particular process if another process starts to run will have to tell the cpu to use a different piece of memory for the page table and this page table will be maintained by the kernel so if you call s break if you load more libraries if you'll start gets bigger than this page table need to be updated as well right so anything we can do to improve this do we have any problems with this	memory	243
right so the first thing i want you to notice that we remember is that actually for most programs i've got lots and lots of addresses in here that are utterly unnecessary my thirty two bit program like four gigabytes of address space is the time i talk about inside my process most of them i'm never going to touch for example my stack might be small my heat might be small and yet i have entries inside my page table for these so maybe a future design can improve upon that a second problem we've got is that congratulations we just made our machine run twice as slow because now every time your program wants to use memory we've now made it actually required two accesses to memory so you need to read piece of the heap and it wasn't inside the cache congratulations what do we do well first of all we need to go to main memory to look up a frame number and then once we've got that finally we can actually go and read or write the byte that you cared about so now my machine is twice as slow oh we bet about think about ways to fix that right so those are going to be two problems we're going to solve in the near future right and i'm going to solve those problems in the future video bye	memory	618
right so the first thing i want you to notice that we remember is that actually for most programs i've got lots and lots of addresses in here that are utterly unnecessary my thirty two bit program like four gigabytes of address space is the time i talk about inside my process most of them i'm never going to touch for example my stack might be small my heat might be small and yet i have entries inside my page table for these so maybe a future design can improve upon that a second problem we've got is that congratulations we just made our machine run twice as slow because now every time your program wants to use memory we've now made it actually required two accesses to memory so you need to read piece of the heap and it wasn't inside the cache congratulations what do we do well first of all we need to go to main memory to look up a frame number and then once we've got that finally we can actually go and read or write the byte that you cared about so now my machine is twice as slow oh we bet about think about ways to fix that right so those are going to be two problems we're going to solve in the near future right and i'm going to solve those problems in the future video bye	the heap	713
right so the first thing i want you to notice that we remember is that actually for most programs i've got lots and lots of addresses in here that are utterly unnecessary my thirty two bit program like four gigabytes of address space is the time i talk about inside my process most of them i'm never going to touch for example my stack might be small my heat might be small and yet i have entries inside my page table for these so maybe a future design can improve upon that a second problem we've got is that congratulations we just made our machine run twice as slow because now every time your program wants to use memory we've now made it actually required two accesses to memory so you need to read piece of the heap and it wasn't inside the cache congratulations what do we do well first of all we need to go to main memory to look up a frame number and then once we've got that finally we can actually go and read or write the byte that you cared about so now my machine is twice as slow oh we bet about think about ways to fix that right so those are going to be two problems we're going to solve in the near future right and i'm going to solve those problems in the future video bye	address	124
we've got a case where my files use ten direct blocks and we have our dis block numbers	block	47
use thirty two bit numbers ok so the maximum number of disk blocks	block	60
which are addressable two to the thirty two and if	address	10
each disk block is four kb let's just work out how bigger disk we can actually use before we run out of addressable space here so what is two to the thirty two minutes at home ok so i can think of that as two to the ten times two to the ten times two to the ten times two to the two	block	10
each disk block is four kb let's just work out how bigger disk we can actually use before we run out of addressable space here so what is two to the thirty two minutes at home ok so i can think of that as two to the ten times two to the ten times two to the ten times two to the two	address	104
terabytes and so this scheme allows me to address up to sixteen terabytes worth of memory so today we're right at that limit that i can already easily by a say twelve terabyte disk	memory	83
terabytes and so this scheme allows me to address up to sixteen terabytes worth of memory so today we're right at that limit that i can already easily by a say twelve terabyte disk	address	42
right so in practice then ext2 actually provides actually has its limit based on choice of saying dis blocks must be represented using just thirty two bits and each disk block is exactly four kb	block	102
scheme here of actually how we reference a information about files and look at how many blocks and indirect blocks that we can reference here so for how many indirect blocks can be we reference we work this out by saying	block	88
so therefore i can have a thousand twenty four indirect blocks	block	56
because that's the size of my table that can fit inside one disk block	block	65
right so the next question is how large is the file in blocks of data if the indirect block index is half full	block	55
ten direct blocks k so	block	11
plus five hundred and twelve indirect blocks so in other words we have five hundred twenty two blocks is the size of my file	block	38
ok right and let's see what is question three what is the total number blocks used	block	71
in this example then we have five hundred and twenty two blocks worth of data but the actual storage space on the disk is going to be five hundred and twenty three why one extra because we have this overhead of actually storing the table and notice i didn't bother to consider the inode as as extra block we've already to set aside some space for the inode entries when we format it the disk	block	57
the largest file that we could have here was going to be let's see forty kilobytes for the direct blocks and then we had four megabytes for the indirect blocks and then we had four gigabytes for the double indirect blocks and then four terabytes for the triple indirect blocks so providing you don't need to make files much greater than four terabytes this scheme will work now of course in practice today were actually now i really do want to make files greater than four terabytes plus four gigabytes plus four megabytes plus forty kb so in practice today on a modern file system we're not going to use ext2	block	98
the largest file that we could have here was going to be let's see forty kilobytes for the direct blocks and then we had four megabytes for the indirect blocks and then we had four gigabytes for the double indirect blocks and then four terabytes for the triple indirect blocks so providing you don't need to make files much greater than four terabytes this scheme will work now of course in practice today were actually now i really do want to make files greater than four terabytes plus four gigabytes plus four megabytes plus forty kb so in practice today on a modern file system we're not going to use ext2	system	575
hi ok so initially we've just let's switch to that ok we have assumed that my whole process has been loaded into memory but there still may not be all possible addresses that map to physical ram we've seen this already when say you accidentally tried to read or write an invalid memory allocation for example page zero or maybe your programs malloc implementation there's a little bit crazy instead of trying to re divide into addresses which don't probably exist yet ok so when that happens what's happening is that we are going through our multi level page table system here and we get to an entry that says no i'm sorry i do not map to any one of my actual physical pieces of ram	memory	113
hi ok so initially we've just let's switch to that ok we have assumed that my whole process has been loaded into memory but there still may not be all possible addresses that map to physical ram we've seen this already when say you accidentally tried to read or write an invalid memory allocation for example page zero or maybe your programs malloc implementation there's a little bit crazy instead of trying to re divide into addresses which don't probably exist yet ok so when that happens what's happening is that we are going through our multi level page table system here and we get to an entry that says no i'm sorry i do not map to any one of my actual physical pieces of ram	memory allocation	279
hi ok so initially we've just let's switch to that ok we have assumed that my whole process has been loaded into memory but there still may not be all possible addresses that map to physical ram we've seen this already when say you accidentally tried to read or write an invalid memory allocation for example page zero or maybe your programs malloc implementation there's a little bit crazy instead of trying to re divide into addresses which don't probably exist yet ok so when that happens what's happening is that we are going through our multi level page table system here and we get to an entry that says no i'm sorry i do not map to any one of my actual physical pieces of ram	address	160
hi ok so initially we've just let's switch to that ok we have assumed that my whole process has been loaded into memory but there still may not be all possible addresses that map to physical ram we've seen this already when say you accidentally tried to read or write an invalid memory allocation for example page zero or maybe your programs malloc implementation there's a little bit crazy instead of trying to re divide into addresses which don't probably exist yet ok so when that happens what's happening is that we are going through our multi level page table system here and we get to an entry that says no i'm sorry i do not map to any one of my actual physical pieces of ram	system	565
so when that happens mmu the part that is reading this page table causes a page fault and a page fault is a hardware interrupt to tell the cpu that i'm sorry i cannot satisfy this	a page	73
read or write to request because it doesn't actually map to any memory so our first example then was when we were trying to actually read an invalid memory address but i wanted to realize that we can now stop playing tricks on our process is so for example for the longest time i've been looking at you and for the longest time my program has been running code inside	memory	64
read or write to request because it doesn't actually map to any memory so our first example then was when we were trying to actually read an invalid memory address but i wanted to realize that we can now stop playing tricks on our process is so for example for the longest time i've been looking at you and for the longest time my program has been running code inside	code	356
read or write to request because it doesn't actually map to any memory so our first example then was when we were trying to actually read an invalid memory address but i wanted to realize that we can now stop playing tricks on our process is so for example for the longest time i've been looking at you and for the longest time my program has been running code inside	address	156
defined inside this second page over here and it hasn't actually needed any of the code inside this	code	83
another page because that was all just set up code and maybe some code to kind of save the result at the end but right now it's stuck inside a deeply nested for loop and swim in cursive code busy executing all the stuff inside here	code	46
we use the page tables so we tracked through the page tables ok the upper ten bits tell me to use this table the middle ten bits time we choose this table and this is i'm sorry that doesn't correspond to any memory here's what we'll do we'll put the process on pause because we've just got a page fault and as i turn around look behind me will quickly fill in the background and so that i'll never know it was missing any pointers at this time and we're going to do the same thing in my process so what will do is will identify a piece of physical memory ok out of all of these let's choose this one this one doesn't seem to be doing much right now and we will say it's ok i know where the bytes are they are still on disk maybe it's on a network mount maybe it's on the local ssd but i have the contents of the program which i can load into memory so i will go to my i o systems say hey please can read me this page of memory four thousand ninety six bytes and will wait for that to complete so hopefully in just a few milliseconds time but it might take longer i'll actually have those bites now and now we can fix up our page table to say ok don't look at nothing anymore instead this entry is now going to be just here	a page	290
we use the page tables so we tracked through the page tables ok the upper ten bits tell me to use this table the middle ten bits time we choose this table and this is i'm sorry that doesn't correspond to any memory here's what we'll do we'll put the process on pause because we've just got a page fault and as i turn around look behind me will quickly fill in the background and so that i'll never know it was missing any pointers at this time and we're going to do the same thing in my process so what will do is will identify a piece of physical memory ok out of all of these let's choose this one this one doesn't seem to be doing much right now and we will say it's ok i know where the bytes are they are still on disk maybe it's on a network mount maybe it's on the local ssd but i have the contents of the program which i can load into memory so i will go to my i o systems say hey please can read me this page of memory four thousand ninety six bytes and will wait for that to complete so hopefully in just a few milliseconds time but it might take longer i'll actually have those bites now and now we can fix up our page table to say ok don't look at nothing anymore instead this entry is now going to be just here	memory	208
we use the page tables so we tracked through the page tables ok the upper ten bits tell me to use this table the middle ten bits time we choose this table and this is i'm sorry that doesn't correspond to any memory here's what we'll do we'll put the process on pause because we've just got a page fault and as i turn around look behind me will quickly fill in the background and so that i'll never know it was missing any pointers at this time and we're going to do the same thing in my process so what will do is will identify a piece of physical memory ok out of all of these let's choose this one this one doesn't seem to be doing much right now and we will say it's ok i know where the bytes are they are still on disk maybe it's on a network mount maybe it's on the local ssd but i have the contents of the program which i can load into memory so i will go to my i o systems say hey please can read me this page of memory four thousand ninety six bytes and will wait for that to complete so hopefully in just a few milliseconds time but it might take longer i'll actually have those bites now and now we can fix up our page table to say ok don't look at nothing anymore instead this entry is now going to be just here	background	364
we use the page tables so we tracked through the page tables ok the upper ten bits tell me to use this table the middle ten bits time we choose this table and this is i'm sorry that doesn't correspond to any memory here's what we'll do we'll put the process on pause because we've just got a page fault and as i turn around look behind me will quickly fill in the background and so that i'll never know it was missing any pointers at this time and we're going to do the same thing in my process so what will do is will identify a piece of physical memory ok out of all of these let's choose this one this one doesn't seem to be doing much right now and we will say it's ok i know where the bytes are they are still on disk maybe it's on a network mount maybe it's on the local ssd but i have the contents of the program which i can load into memory so i will go to my i o systems say hey please can read me this page of memory four thousand ninety six bytes and will wait for that to complete so hopefully in just a few milliseconds time but it might take longer i'll actually have those bites now and now we can fix up our page table to say ok don't look at nothing anymore instead this entry is now going to be just here	system	872
we use the page tables so we tracked through the page tables ok the upper ten bits tell me to use this table the middle ten bits time we choose this table and this is i'm sorry that doesn't correspond to any memory here's what we'll do we'll put the process on pause because we've just got a page fault and as i turn around look behind me will quickly fill in the background and so that i'll never know it was missing any pointers at this time and we're going to do the same thing in my process so what will do is will identify a piece of physical memory ok out of all of these let's choose this one this one doesn't seem to be doing much right now and we will say it's ok i know where the bytes are they are still on disk maybe it's on a network mount maybe it's on the local ssd but i have the contents of the program which i can load into memory so i will go to my i o systems say hey please can read me this page of memory four thousand ninety six bytes and will wait for that to complete so hopefully in just a few milliseconds time but it might take longer i'll actually have those bites now and now we can fix up our page table to say ok don't look at nothing anymore instead this entry is now going to be just here	pointer	422
great so now we fixed it up we can release process and let it continue and it would be a non the wiser we might notice that our program took a little bit longer to run at that moment but as far as it's concerned those bytes will always available there was never a moment when those bites were not acting in memory so that's kind of pretty cool trick so we've seen two kinds of page faults of page for when we access invalid memory and the page fault where we had lied to the process and we had to go and grab those bites from the disk so this process is called demand paging we pull things in on demand and in fact there's two parts to this there's a page in process this is the part we just described where we go back to disk to actually read those bytes in but let's think about this for a moment what this bikes were pulled probably being used for something	a page	649
great so now we fixed it up we can release process and let it continue and it would be a non the wiser we might notice that our program took a little bit longer to run at that moment but as far as it's concerned those bytes will always available there was never a moment when those bites were not acting in memory so that's kind of pretty cool trick so we've seen two kinds of page faults of page for when we access invalid memory and the page fault where we had lied to the process and we had to go and grab those bites from the disk so this process is called demand paging we pull things in on demand and in fact there's two parts to this there's a page in process this is the part we just described where we go back to disk to actually read those bytes in but let's think about this for a moment what this bikes were pulled probably being used for something	memory	307
now in linux if there's any spare memory by default lennox will use that actually as a buffer for io operations but it could be that other pages are actually used for the process is so we have to choose the best frame physical frame that we want to actually use to satisfy this page fault and	memory	34
it can be that some of these bytes yes might already exist on disk because they refer to say some program code but it could also be that they don't yet exist on disk in which point if we want to use this particular page we have to take the current contents and copy them out to disk and this is called the page app process so in the worst case we'd have to do both but obviously that takes even more time so hopefully we won't have to choose a page which requires a copy out to disk	a page	442
it can be that some of these bytes yes might already exist on disk because they refer to say some program code but it could also be that they don't yet exist on disk in which point if we want to use this particular page we have to take the current contents and copy them out to disk and this is called the page app process so in the worst case we'd have to do both but obviously that takes even more time so hopefully we won't have to choose a page which requires a copy out to disk	code	106
right so we talked about on demand paging paging paging out in page faults i hope you see look like a very cool mechanism and the last thing we're going to talk about will revisit this in the future is this i did that there's a set of pages that i need in order for my process to continue right now if i give them just the right number of amount of memory i'm not going to generate too many page faults for example right now my programs calculating a mandlebrot set it might be just that i need say my small bit of program code some heat memory where i'm going to store the result and maybe a little bit of stack memory and thats it so if i gave my process right now just one two three four five pages of memory that would be enough to continue it wouldn't constantly complain they wouldn't wouldn't constantly generate page faults and so this idea about how much memory is required is called the current working set and you can see that changes overtime depending on what a program is doing weight so we are lots of terms right now in the next video let's let's talk about how we can start thinking about pages by	memory	349
right so we talked about on demand paging paging paging out in page faults i hope you see look like a very cool mechanism and the last thing we're going to talk about will revisit this in the future is this i did that there's a set of pages that i need in order for my process to continue right now if i give them just the right number of amount of memory i'm not going to generate too many page faults for example right now my programs calculating a mandlebrot set it might be just that i need say my small bit of program code some heat memory where i'm going to store the result and maybe a little bit of stack memory and thats it so if i gave my process right now just one two three four five pages of memory that would be enough to continue it wouldn't constantly complain they wouldn't wouldn't constantly generate page faults and so this idea about how much memory is required is called the current working set and you can see that changes overtime depending on what a program is doing weight so we are lots of terms right now in the next video let's let's talk about how we can start thinking about pages by	code	523
let's choose a new color right sketch out how much time a process needs the cpu to actually continue	a process	56
the amount of cpu code the amount of code that inside your program that we need to execute is minimal we're always just waiting to read another block from the buffer or write it out ok so most of our time is actually spent waiting for io events ok so our cpu needs are minimal so in theory it should be fine if say someone else wants to run their fractal program right so here's my fractal program maybe it's calculating over mandel brot picture or maybe it's kind of mining coins but for whatever reason	block	144
the amount of cpu code the amount of code that inside your program that we need to execute is minimal we're always just waiting to read another block from the buffer or write it out ok so most of our time is actually spent waiting for io events ok so our cpu needs are minimal so in theory it should be fine if say someone else wants to run their fractal program right so here's my fractal program maybe it's calculating over mandel brot picture or maybe it's kind of mining coins but for whatever reason	code	18
ok and if you sketch it out in terms of thinking about how how we have to wait for a cpu even though you actually need only just a tiny amount of time you can see how this effect arises there's probably some analogy in terms of say you just need a moment of the bartenders time or the ushers time or their waiters time but because they're busy servicing other tables your needs happen or service only very occasionally so that's the convoy effect make sure you understand it it is a standard interview question that crops application exams that kind of things and it all comes down from this monopolization the cpu by a cpu bound job right and bia cpu bound as just a way to say that the performance of a job depends on how depends on cpu speed depends upon using as much cp resources as possible right that's it for this lecture "bye for now	resources	775
ok let's review this one what do you think the following code will print ok so	the following	43
ok let's review this one what do you think the following code will print ok so	code	57
how can we analyze this right so i've got a pizza it create an i'm storing somewhere the fed id 's and i'm going to say ok i want to thread that is going to start functioning and let's start function be and we're going to pass a void pointer the address of the string literals so the address of the capital a and address of the cadillacs to each one right so what will function be do function be then get this pointer and so we're giving it the address of xyz so when this runs and we're not quite sure when it will run it will print out xyz	string	261
how can we analyze this right so i've got a pizza it create an i'm storing somewhere the fed id 's and i'm going to say ok i want to thread that is going to start functioning and let's start function be and we're going to pass a void pointer the address of the string literals so the address of the capital a and address of the cadillacs to each one right so what will function be do function be then get this pointer and so we're giving it the address of xyz so when this runs and we're not quite sure when it will run it will print out xyz	thread	133
how can we analyze this right so i've got a pizza it create an i'm storing somewhere the fed id 's and i'm going to say ok i want to thread that is going to start functioning and let's start function be and we're going to pass a void pointer the address of the string literals so the address of the capital a and address of the cadillacs to each one right so what will function be do function be then get this pointer and so we're giving it the address of xyz so when this runs and we're not quite sure when it will run it will print out xyz	address	246
how can we analyze this right so i've got a pizza it create an i'm storing somewhere the fed id 's and i'm going to say ok i want to thread that is going to start functioning and let's start function be and we're going to pass a void pointer the address of the string literals so the address of the capital a and address of the cadillacs to each one right so what will function be do function be then get this pointer and so we're giving it the address of xyz so when this runs and we're not quite sure when it will run it will print out xyz	pointer	234
now what about function a so functionally when it runs let's see is given the address of abc ok but it doesn't do anything instead it just simply exits this thread and it returns an address so it takes the pointer that we gave it which was a pointer to the string in memory abc and a zero bite if it is	memory	267
now what about function a so functionally when it runs let's see is given the address of abc ok but it doesn't do anything instead it just simply exits this thread and it returns an address so it takes the pointer that we gave it which was a pointer to the string in memory abc and a zero bite if it is	string	257
now what about function a so functionally when it runs let's see is given the address of abc ok but it doesn't do anything instead it just simply exits this thread and it returns an address so it takes the pointer that we gave it which was a pointer to the string in memory abc and a zero bite if it is	thread	157
now what about function a so functionally when it runs let's see is given the address of abc ok but it doesn't do anything instead it just simply exits this thread and it returns an address so it takes the pointer that we gave it which was a pointer to the string in memory abc and a zero bite if it is	address	78
now what about function a so functionally when it runs let's see is given the address of abc ok but it doesn't do anything instead it just simply exits this thread and it returns an address so it takes the pointer that we gave it which was a pointer to the string in memory abc and a zero bite if it is	pointer	206
ok and we take that caster character add one in other words we just calculated a pointer that now points to the b ok an we return that so if and when these two threads run we know that the first first one returns a pointer to bc string and the second one prints are xyz right what is the rest of the code to write so equals p thread join on thread a and grab the result and so in stores that in there area code result ok so what what is going to be put inside this result so this line is going to wait is going to wait until it's able to join p thread so that means we wait until functionary has finished at which point we set this result variable to be a pointer and it's pointing to here we go do that be right there which we print out ok so this will print bc add a new line	code	300
ok and we take that caster character add one in other words we just calculated a pointer that now points to the b ok an we return that so if and when these two threads run we know that the first first one returns a pointer to bc string and the second one prints are xyz right what is the rest of the code to write so equals p thread join on thread a and grab the result and so in stores that in there area code result ok so what what is going to be put inside this result so this line is going to wait is going to wait until it's able to join p thread so that means we wait until functionary has finished at which point we set this result variable to be a pointer and it's pointing to here we go do that be right there which we print out ok so this will print bc add a new line	string	229
ok and we take that caster character add one in other words we just calculated a pointer that now points to the b ok an we return that so if and when these two threads run we know that the first first one returns a pointer to bc string and the second one prints are xyz right what is the rest of the code to write so equals p thread join on thread a and grab the result and so in stores that in there area code result ok so what what is going to be put inside this result so this line is going to wait is going to wait until it's able to join p thread so that means we wait until functionary has finished at which point we set this result variable to be a pointer and it's pointing to here we go do that be right there which we print out ok so this will print bc add a new line	thread	160
ok and we take that caster character add one in other words we just calculated a pointer that now points to the b ok an we return that so if and when these two threads run we know that the first first one returns a pointer to bc string and the second one prints are xyz right what is the rest of the code to write so equals p thread join on thread a and grab the result and so in stores that in there area code result ok so what what is going to be put inside this result so this line is going to wait is going to wait until it's able to join p thread so that means we wait until functionary has finished at which point we set this result variable to be a pointer and it's pointing to here we go do that be right there which we print out ok so this will print bc add a new line	pointer	81
ok right so now we hopefully you can conclude what this code is going to print right so if you said it's going to print bc or the new line then you'd be correct if you said it's going to print bc in a new line and xyz you'd be correct if you said is going to print xyz with a new line and bc you'd be correct yes so what code is actually indeterminate fethard create makes no promises about when these threads now going to stop maybe in a microsecond maybe in a millisecond time there's a very real chance that	code	56
ok right so now we hopefully you can conclude what this code is going to print right so if you said it's going to print bc or the new line then you'd be correct if you said it's going to print bc in a new line and xyz you'd be correct if you said is going to print xyz with a new line and bc you'd be correct yes so what code is actually indeterminate fethard create makes no promises about when these threads now going to stop maybe in a microsecond maybe in a millisecond time there's a very real chance that	thread	402
the first thread thread a could could start up exit and main thread could join on that we could print out an exit before thread b has a chance to start this would be particularly true on sale really busy system or a system that's only got one cpu core are poor threadbear it hasn't had a cpu scheduled yet and so our main thread is done before it another chance to start up ok right so all those those as possible if we modified our code so that we included p three exit on the main thread then you know that that means that because we are never returning from maine now our program is going to run until both those threads finish so now we expect both the bc to be printed and the xyz to be printed though we can't actually say definitively what order these two things can print we can make a guess as to which ones more likely but we haven't actually	code	433
the first thread thread a could could start up exit and main thread could join on that we could print out an exit before thread b has a chance to start this would be particularly true on sale really busy system or a system that's only got one cpu core are poor threadbear it hasn't had a cpu scheduled yet and so our main thread is done before it another chance to start up ok right so all those those as possible if we modified our code so that we included p three exit on the main thread then you know that that means that because we are never returning from maine now our program is going to run until both those threads finish so now we expect both the bc to be printed and the xyz to be printed though we can't actually say definitively what order these two things can print we can make a guess as to which ones more likely but we haven't actually	thread	10
the first thread thread a could could start up exit and main thread could join on that we could print out an exit before thread b has a chance to start this would be particularly true on sale really busy system or a system that's only got one cpu core are poor threadbear it hasn't had a cpu scheduled yet and so our main thread is done before it another chance to start up ok right so all those those as possible if we modified our code so that we included p three exit on the main thread then you know that that means that because we are never returning from maine now our program is going to run until both those threads finish so now we expect both the bc to be printed and the xyz to be printed though we can't actually say definitively what order these two things can print we can make a guess as to which ones more likely but we haven't actually	system	204
so fun stuff with threads fun stuff with thinking about interleaving and i hope you burn his mind as you write your own multithreaded programs	thread	18
ok so it wouldn't be fun if you could to any program say don't tell me about singing right now i just block those signals put them off don't even have a steel handler to print something out no we actually want to stop these things at the door don't let them be delivered ok let's see how we can do that right so we're going to play with a sig proc mask here it is and	block	102
what i'm going to do is first of all to say hey signal put mask tell me about the current signals which are currently blocked no practice there probably aren't any but here's one way to actually ask it with cig pop mask you can say optionally you can say here's the new master i care about all you can give it the address	block	118
what i'm going to do is first of all to say hey signal put mask tell me about the current signals which are currently blocked no practice there probably aren't any but here's one way to actually ask it with cig pop mask you can say optionally you can say here's the new master i care about all you can give it the address	address	314
so that you can actually determine the current set of signals which are blocked so basically we have a new and old here so great when this returns i've copied the comment mask the process mask into this little variable here this set off signals ok now i want to modify that set of signals by adding sigint to it so you can think of this set as just a set of kind of little bits and we happen to be modifying one bit ok now we've got a new signal set with that bit set let's go back to cig pop mask and say hey cig dot press let's replace your can't process mask where the one i'm going to give you so set mask to say ok i'm going to tell you all the signals that i care about being blocked which will be whatever we originally got plus sigint ok so now we've got our defense against the dark arts we're not going to allow cig in into our process so let's have a go with this summer play with this and i've got little program here that's going to countdown from from ten and will sleep for a second after each time but only after five seconds have elapsed well i change my process mask so once i get out of five here's what i'm going to do let me modify that set of bits ok that doesn't do anything that simply changes this variable which you can think of is just a little kind of opaque integer here but we've ensured that one particular bit of that entity value has been reset has been set to zero and now we can say ok sleep mask i'm going to give you the bit set here it is and i want you to use this as the new process mask so we're lowering our shields we're pulling down the drawbridge for sigint so at that point we should see that signal being delivered immediately so let's have a play play with this ok so i'll compile it	block	72
and nothing happens i can press ctrl c as many times as i want until the day that we change the mask and at that point great the signal gets delivered and it's default behavior of course is to to stop or program we could change this to to instead run a signal handler so let's do this so i want to say sigint	the mask	92
piece of asynchronous code that is going to be run	code	22
ok right there we go wait what do you notice did you notice that we only called our little signal handler once even though i press control c lots and lots and lots of times yeah so to remember that signals cannot be queued i can have a set of different signals waiting to be delivered but the actual specific signal itself is not queued here we just get that delivery of one once again event so let's do what we did we installed a signal handler here using signal all it does is print out three hash is ok but nothing happens initially because we blocked sigint by setting the process mask and we do this in kind of couple of stages first of all we work with a bit set but it's only call sig pop mask do we actually get to change the actual process is mask our first call up here didn't do anything 'cause we want setting the the new one instead we were simply using it to grab the existing process mask ok and later we modify the bit set that didn't do much we're just changing a number is only when we call secret masks do we actually modify the process mask so that i think that's enough fun for that for for now	block	547
hi ok so let's take a look at some code that i found on the internet that claims to solve their dining philosophers and we will analyze it and see what we think ok so here we go it uses all the good stuff that we now understand	code	35
we've got a little structure here called philosopher and you can see it's going to be typed deft so that we can just say philosopher later on inside that i'm going to have a pointer to the left fork and the right fork and of course a philosopher has a name	type	86
we've got a little structure here called philosopher and you can see it's going to be typed deft so that we can just say philosopher later on inside that i'm going to have a pointer to the left fork and the right fork and of course a philosopher has a name	pointer	174
and associated with it ap thread and some output variable say whether it failed or not ok we have a global variable to see whether this program should keep running or not ok and let's have a look see how things get initialized	thread	26
ok so we've got a new way of character pointers and that's just a name of five philosophers would like today we're going to have five mutex locks they're going to be our forks and five philosophers ok so	pointer	39
my philosophers so that's just a simple stack away it's ok to do this on inside the main threat because we'll see all of my threads which are going to run	thread	124
finish before we exit made right so great let's get myself a philosopher will get the i th one will initialize its name will initialize it left hand and right hand fork to be one of my five mutex locks look i'm using modulo arithmetic so that the fifth philosopher wraps around and gets to zero for kids game right after setting that all up let's start off threats will call preferred create will make a note of the thread id and will ask it to actually run some multithreaded code which will look at in a moment i learned the rest of my main thread doesn't do much it sleeps with forty seconds then changes running and now just wait for those five threats to finish	code	477
finish before we exit made right so great let's get myself a philosopher will get the i th one will initialize its name will initialize it left hand and right hand fork to be one of my five mutex locks look i'm using modulo arithmetic so that the fifth philosopher wraps around and gets to zero for kids game right after setting that all up let's start off threats will call preferred create will make a note of the thread id and will ask it to actually run some multithreaded code which will look at in a moment i learned the rest of my main thread doesn't do much it sleeps with forty seconds then changes running and now just wait for those five threats to finish	thread	416
otherwise will exit ok so that's my main threat now let's let's have a look at the code that we get that is run by each philosopher oh yes and here's my source	code	83
ok so each philosopher is going to be given a pointer to its little struct there ok so each plus is going to get its own unique name etc right so we also have some local stack variables which mirror what we find inside the the struct you'll see why in a moment so let's see what	pointer	46
my little threads going to do here so for forty seconds until that global variable is changed the first thing that my my philosophy does is sleep in other words thanks a bit so will print out his name then will sleep for and amount of time so in this case let's sleep for say some two one and eight seconds alright and then the philosopher goes to pick up the two folks	thread	10
let's see all chill at the moment ok so we're going to get out of there were going to take this check this after you run through this code once i know notice it is frayed i apologize the logic as given incorrect let's have a look see what it does first of all philosopher waist to pick up the fork on the left ok so that's only going to proceed once you get exclusive access to that particular fork alright and then it's going to change this local variable failed to based on on what happens when it tries to pick up the the fork on the right so notice that initial value of tries left is too so actually it's going to call this function called trilok which we haven't seen before trilok never blocks instead rather than blocking if it's unable to acquire this mutex	block	694
let's see all chill at the moment ok so we're going to get out of there were going to take this check this after you run through this code once i know notice it is frayed i apologize the logic as given incorrect let's have a look see what it does first of all philosopher waist to pick up the fork on the left ok so that's only going to proceed once you get exclusive access to that particular fork alright and then it's going to change this local variable failed to based on on what happens when it tries to pick up the the fork on the right so notice that initial value of tries left is too so actually it's going to call this function called trilok which we haven't seen before trilok never blocks instead rather than blocking if it's unable to acquire this mutex	code	134
it just returns an error numbers returns a non zero value so the very first time that we running this code with twice left equal to two if we caught acquire that second log we just say we failed so what do we do if we failed we immediately unlock the left hand thread	code	102
it just returns an error numbers returns a non zero value so the very first time that we running this code with twice left equal to two if we caught acquire that second log we just say we failed so what do we do if we failed we immediately unlock the left hand thread	thread	261
great you say this looks a lot like we're not going to implement holding wait we're not holding onto the fork on the left we are definitely releasing it so then what does this code do well it	code	176
and then we release both looks ok then we go round the loop we keep going until we've hdr forty seconds is up so what do you think about that is that code correct does	the loop	51
and then we release both looks ok then we go round the loop we keep going until we've hdr forty seconds is up so what do you think about that is that code correct does	code	150
for the fork on the right in other words they all get blocked so yes there is a chance that all my possibles will will deadlock because all waiting for resource it is never going to be released so oh dear this apparent code on the internet is not smart enough to solve this problem so yes ladies and gentlemen as a cs two forty one	block	54
for the fork on the right in other words they all get blocked so yes there is a chance that all my possibles will will deadlock because all waiting for resource it is never going to be released so oh dear this apparent code on the internet is not smart enough to solve this problem so yes ladies and gentlemen as a cs two forty one	code	219
student now smarter than the internet ok so we can prove we can show the circumstances in which deadlock is can occur this actually see if we can actually see that occur if we actually run this code in practice so here's here's the same code that i prepared earlier i wanted to get out of this and go to handouts but code	code	194
there we go right go to code	code	24
but i need cs two forty one lectures code right	code	37
p thread	thread	2
ok finally great let's ok off they go oh alright look at this we've run into deadlock where all five were hungry at exactly the same time so in practice causing this is actually actually difficult let me just run it one more time will see if we can generate it so you can see no expense spared on the graphics we've got five philosophers going through the states of either hungry eating or sleeping and yes we run into deadlock again this actually kind of take a look at this code because i want to show you that i actually had to work a little bit hard to make deadlock occur here so i want to reset my group right and let's	code	476
threads word acquire the left hand lock that was interesting is that right now i'm recording this so one of my cpu cores is busy capturing the lecture content the video content so i was actually surprised that so quickly run into deadlock the other thing that i did to try to make it more likely is i'm using micro sleeps too actually sure that we have an opportunity for deadlock many many many more times in the original provider coded only tested this with sleeps for eight seconds or so over forty second window so opportunity for deadlock is is only handful of times order of ten times or so we would like it to be much higher alright so yes i have i can run it in slow motion let's see how we do that	code	432
threads word acquire the left hand lock that was interesting is that right now i'm recording this so one of my cpu cores is busy capturing the lecture content the video content so i was actually surprised that so quickly run into deadlock the other thing that i did to try to make it more likely is i'm using micro sleeps too actually sure that we have an opportunity for deadlock many many many more times in the original provider coded only tested this with sleeps for eight seconds or so over forty second window so opportunity for deadlock is is only handful of times order of ten times or so we would like it to be much higher alright so yes i have i can run it in slow motion let's see how we do that	thread	0
hello welcome to lecture five do you know anybody that's had a head transplant because that's exactly what we're about to do to our programs here so let's imagine that we've got a running process it's perfectly fine it's having a great time but then we say hold on a moment think about this process think about all the memory we've got here we have of course the stack somewhere up here we've got our heap somewhere down here i've also got variable space my global variables underneath that i've got some read only memory to hold my program code for the cpu and all the constants as well that i defined what if we said right process stop doing this i want to remove all of this stuff and the memory and actually give you a completely new program to load and this is exactly what exec does so it doesn't create a new process know the existing process keeps on running but we give a head transplant to this process we rip out the color instructions that is executing and put some new ones in so all that stack memory all those malloc calls there are long gone that memory	memory	319
hello welcome to lecture five do you know anybody that's had a head transplant because that's exactly what we're about to do to our programs here so let's imagine that we've got a running process it's perfectly fine it's having a great time but then we say hold on a moment think about this process think about all the memory we've got here we have of course the stack somewhere up here we've got our heap somewhere down here i've also got variable space my global variables underneath that i've got some read only memory to hold my program code for the cpu and all the constants as well that i defined what if we said right process stop doing this i want to remove all of this stuff and the memory and actually give you a completely new program to load and this is exactly what exec does so it doesn't create a new process know the existing process keeps on running but we give a head transplant to this process we rip out the color instructions that is executing and put some new ones in so all that stack memory all those malloc calls there are long gone that memory	code	541
memory values no longer exist right so that is actually how we can do new things with our programs and actually exec has comes in several flavors we can specify the arguments for exec using a whole lot of parameters or we can give it in a way we can also say this is specifically the program that we want to load from disk or we can ask the system to search the path worse	memory	0
memory values no longer exist right so that is actually how we can do new things with our programs and actually exec has comes in several flavors we can specify the arguments for exec using a whole lot of parameters or we can give it in a way we can also say this is specifically the program that we want to load from disk or we can ask the system to search the path worse	parameter	205
memory values no longer exist right so that is actually how we can do new things with our programs and actually exec has comes in several flavors we can specify the arguments for exec using a whole lot of parameters or we can give it in a way we can also say this is specifically the program that we want to load from disk or we can ask the system to search the path worse	system	341
to find a matching program name so let's have a look at this alright so let's pull up all man page and will say ok man tell me about exact and the first information we get ashley is not very useful is actually a built in command for bash we didn't want that we actually wanted in section three will find exact	section	280
and you didn't say where in the file system catch that we found it will use your path environment variable to look for it also this version you just keep specifying parameters so you might say cat and then include save the file name that you want to print out all the versions with an array here you pass in	parameter	165
and you didn't say where in the file system catch that we found it will use your path environment variable to look for it also this version you just keep specifying parameters so you might say cat and then include save the file name that you want to print out all the versions with an array here you pass in	system	37
appointed to away now there's a couple of big gotchas to watch out for you here is the first one how can exact know when you're lovely parameter array has finished	parameter	135
so here's what you have to do if you're using the version where you just write out the parameters here as arguments the very last one is going to be a null pointer and in particular it's going to be a character null pointer ok so remember that zero is just another word for null in fact as exact one oh point who is and if you decide to create your own array or passing the pointer to a new way of string pointers the way last entry has to be null ok	parameter	87
so here's what you have to do if you're using the version where you just write out the parameters here as arguments the very last one is going to be a null pointer and in particular it's going to be a character null pointer ok so remember that zero is just another word for null in fact as exact one oh point who is and if you decide to create your own array or passing the pointer to a new way of string pointers the way last entry has to be null ok	string	398
so here's what you have to do if you're using the version where you just write out the parameters here as arguments the very last one is going to be a null pointer and in particular it's going to be a character null pointer ok so remember that zero is just another word for null in fact as exact one oh point who is and if you decide to create your own array or passing the pointer to a new way of string pointers the way last entry has to be null ok	pointer	156
great and we can kind of scroll down here so the exciting thing about exec is that it never returns if it's successful the next line of program code that you write will never be executed all that has disappeared like i said it is the head transplant they were going to give up or little process so it's only going to turn if an error code and a common error would be it couldn't find the program that was looking for so i think it's time to play with this so let's take let's get started on right on a little program here right so are colic exact demo dot c and	code	144
and i will use the version where we just write it out in full ok so not use the path so let's just start with exec and i think it's exact will find out in a moment ok so what should i look for i'm going to look for something that doesn't exist i'm going to call it cat right and what about its arguments now here's the second gotcher for using exec remember when we were printing out the arguments to the process to very zeroth won the first one will is actually the the process name so we better give it a name here what would we like to call our program well typically by convention it might be the same name of the file that we want to load but it doesn't have to be so i could have something called say alright ok and do i want to give some arguments no i'm done now so the very last thing member is let's have a point at the end which is another pointer ok so what do we want to start with that if it succeeds we'll never see this line but if it fails we will say so will say oops exact failed ok now if we actually want to print out more information about	pointer	851
why a system call failed we can use pierre and it will tell us about the last system called that didn't succeed so i can put a little little message in here and it will supplement that with whatever it finds out the last error occured right so will do that and then we can return all right so let's	a system call	4
why a system call failed we can use pierre and it will tell us about the last system called that didn't succeed so i can put a little little message in here and it will supplement that with whatever it finds out the last error occured right so will do that and then we can return all right so let's	system	6
i got pretty good to maine let's go back and check to see if we have we have uni standard ok that's going to see why we messed it up because i can't type that's why right so my want to cast that to a character let me jump forward two o'clock to that closing parentheses there we go and put my asterisk in there ok and this ass tricks can go alright much more reasonable case i will compile this way let's run it what do we see ok if it's that one then whoops exact failed nothing happened why i think it's time to fix this program don't you ok so let's now change this to a file that does exist so i happen to know that there is	type	149
k so will compile this we run it again and oh look it never printed anything more that's why because our process became that cap program the system loaded that process got program from the disk created it	system	141
image and then all of the memory inside that existing process and what do we do well no actually running the cap program which if you don't give any arguments simply echoes back what you say to its if i say hello it should say hello back to me right	memory	26
try again this export the path to be the old path and now if i run it then i have to put the start in the four slash in there to explicitly talk about my program and now it can find cat again and runs cat ok so and the other thing to point out is look here's the message to pierre are printed out for us the first part before the colone was it was the text i typed and after the cologne that came automatically from the particular error that happened most recently all right so we've seen a little bit of cat now i want you to think about the following there's a version of	the following	539
try again this export the path to be the old path and now if i run it then i have to put the start in the four slash in there to explicitly talk about my program and now it can find cat again and runs cat ok so and the other thing to point out is look here's the message to pierre are printed out for us the first part before the colone was it was the text i typed and after the cologne that came automatically from the particular error that happened most recently all right so we've seen a little bit of cat now i want you to think about the following there's a version of	type	359
so we've we've seen a version of exec that not just takes a list of arguments and i could put bullet point one here but aversion which actually takes an array of character pointers where else have you seen that and how can we put these together right let's do that in the next video bye	pointer	172
hi so let's look at how we can figure out who we are and who is our parent so it turns out there's two wonderful little calls it one is i want to know my own process id which will give me a small non negative integer adding practice for all programs and processes that so that we start it's going to be greater than one unless you're using dog but that's another story anyway so we're going to get a small little integer here from get pid but if i want to know my parents id then there's a similar called called get pid standing for get parents process id and between you and me i don't think this is actually great design as an api because it differs just by a single letter it would be very easy to going to miss type this and not notice that you would actually type pid or just pid so when you went the other one so now we can do this we can discover who we are and who are father is an hour or we've just given away the entire plot for the early	type	715
star wars movies never mind life is still fun right ok so instead i'd like you to workout what does the following code do it looks pretty tricky so we have a main method and it's written in a pretty obtuse and difficult way to read instead of rvr knoxy we just got this little counter then we have a while loop and look worse than that we got little semi colon here so the rest of the code isn't actually inside the wire loop but to try to make your head explode we're actually going to fork call inside a while loop so what is going on here right we've got uh not fork in other words that it's going to mean a fork 's return zero right so here's my challenge to you before playing the next video figure out what this code is going to do and why you ready<br> go	the following	100
star wars movies never mind life is still fun right ok so instead i'd like you to workout what does the following code do it looks pretty tricky so we have a main method and it's written in a pretty obtuse and difficult way to read instead of rvr knoxy we just got this little counter then we have a while loop and look worse than that we got little semi colon here so the rest of the code isn't actually inside the wire loop but to try to make your head explode we're actually going to fork call inside a while loop so what is going on here right we've got uh not fork in other words that it's going to mean a fork 's return zero right so here's my challenge to you before playing the next video figure out what this code is going to do and why you ready<br> go	code	114
ok write some things remember first of all we need what we need the peace red library so he p thread dot h and also remember when you compile it to set that flag as well so i'll need standard i oh ok right and i need my little run a method or case so let me have my little program called say shout right except it needs to be something that p thread can understand so let's make it a void pointer and	thread	94
ok write some things remember first of all we need what we need the peace red library so he p thread dot h and also remember when you compile it to set that flag as well so i'll need standard i oh ok right and i need my little run a method or case so let me have my little program called say shout right except it needs to be something that p thread can understand so let's make it a void pointer and	pointer	389
take a void pointer are right so what should we shout let's have this one prints whatever you said so actually we can shorten this code to just print percent s and then his arg let's and let's	code	131
take a void pointer are right so what should we shout let's have this one prints whatever you said so actually we can shorten this code to just print percent s and then his arg let's and let's	pointer	12
k let's do rather than having a new line let's flushed and it out today just to prove that we can do normal c code there's nothing special different inside these threads compared to the main thread for an important idea is that all the threads great equality there's not an idea of a parent and child relationship any any thread can join another thread any thread can create new threads its one big happy clan of threads ok so we've flushed something else and now will exit so what's use pthread_exit just practice ok so i've got something we can shout stuff out great now i need my main methods so let's not declare the arguments today will be a bit lazy and we want to call shelt so shout	code	110
k let's do rather than having a new line let's flushed and it out today just to prove that we can do normal c code there's nothing special different inside these threads compared to the main thread for an important idea is that all the threads great equality there's not an idea of a parent and child relationship any any thread can join another thread any thread can create new threads its one big happy clan of threads ok so we've flushed something else and now will exit so what's use pthread_exit just practice ok so i've got something we can shout stuff out great now i need my main methods so let's not declare the arguments today will be a bit lazy and we want to call shelt so shout	thread	162
world k what do you think of that let's run this or k so we will try it ok and i remember to say o p thread and we try it and it prints hello ann nothing else why not well then we actually only had the original main thread we actually didn't create any new threads so now we want to convert this into actually starting some new threat service a p thread create ok i need the address of a little variable but today i'm going to use a little away so i was pizza it hypes ok so i need tds	thread	101
world k what do you think of that let's run this or k so we will try it ok and i remember to say o p thread and we try it and it prints hello ann nothing else why not well then we actually only had the original main thread we actually didn't create any new threads so now we want to convert this into actually starting some new threat service a p thread create ok i need the address of a little variable but today i'm going to use a little away so i was pizza it hypes ok so i need tds	address	375
will have two of them so now here i can say something like i want the address of the first entry oh four code we can do better than that that of course is just the beginning of the arrays so we're just going to say tits and the attributes i don't need any ok what about the function or is that is that the right way round	code	105
will have two of them so now here i can say something like i want the address of the first entry oh four code we can do better than that that of course is just the beginning of the arrays so we're just going to say tits and the attributes i don't need any ok what about the function or is that is that the right way round	address	70
let's check to their men page we go pee thread create ok well we find k it's the thread then the attributes so yes that is correct so now and then we say shelt right but we don't just passing the argument there no we're going to say hey pthread hold on to this pointer for me and give it to that shelt function later when you actually find it get it get around to starting it ok so there's one and i want another one that's going to say world so the second id better go in the second slot so let's add one and address point arithmetic comes to the rescue rescue and i want to use that trick of just saying p thread exit here so i will never return from maine	thread	40
let's check to their men page we go pee thread create ok well we find k it's the thread then the attributes so yes that is correct so now and then we say shelt right but we don't just passing the argument there no we're going to say hey pthread hold on to this pointer for me and give it to that shelt function later when you actually find it get it get around to starting it ok so there's one and i want another one that's going to say world so the second id better go in the second slot so let's add one and address point arithmetic comes to the rescue rescue and i want to use that trick of just saying p thread exit here so i will never return from maine	address	510
let's check to their men page we go pee thread create ok well we find k it's the thread then the attributes so yes that is correct so now and then we say shelt right but we don't just passing the argument there no we're going to say hey pthread hold on to this pointer for me and give it to that shelt function later when you actually find it get it get around to starting it ok so there's one and i want another one that's going to say world so the second id better go in the second slot so let's add one and address point arithmetic comes to the rescue rescue and i want to use that trick of just saying p thread exit here so i will never return from maine	pointer	261
ok so put back around that to mean i'm talking about the c libraries exit ks so are we good let's try this right and then my two little threads are going to run that an exit her case so	thread	136
space and we've got now ok hello world thread style yes the one of these slowest versions are pretty hello world but we could make it slower if we used processes instead right so that's kind of a quick demo of doing our hello world and covering up most things you might say what happened to the exit value for example what what would happen if i put dead beef in here for example let's cast that or what would happen if i just return the argument well sure you can do these things remember all your doing is returning memory addresses petered itself is not little peek at that memory so it's perfectly reasonable to store to return sainul that that will be those values will be remembered until someone calls p thread join on that thread so right now i'm creating threads zombies as my two runners finished my two programs to cite two threads finish they exit but but we don't clean up no one ever cleans up after them	memory	518
space and we've got now ok hello world thread style yes the one of these slowest versions are pretty hello world but we could make it slower if we used processes instead right so that's kind of a quick demo of doing our hello world and covering up most things you might say what happened to the exit value for example what what would happen if i put dead beef in here for example let's cast that or what would happen if i just return the argument well sure you can do these things remember all your doing is returning memory addresses petered itself is not little peek at that memory so it's perfectly reasonable to store to return sainul that that will be those values will be remembered until someone calls p thread join on that thread so right now i'm creating threads zombies as my two runners finished my two programs to cite two threads finish they exit but but we don't clean up no one ever cleans up after them	thread	39
space and we've got now ok hello world thread style yes the one of these slowest versions are pretty hello world but we could make it slower if we used processes instead right so that's kind of a quick demo of doing our hello world and covering up most things you might say what happened to the exit value for example what what would happen if i put dead beef in here for example let's cast that or what would happen if i just return the argument well sure you can do these things remember all your doing is returning memory addresses petered itself is not little peek at that memory so it's perfectly reasonable to store to return sainul that that will be those values will be remembered until someone calls p thread join on that thread so right now i'm creating threads zombies as my two runners finished my two programs to cite two threads finish they exit but but we don't clean up no one ever cleans up after them	address	525
i've got two threads on this and inside that we make a note of the exit value for this little program it doesn't matter because in a moment we're going to finish all threads and at that point the whole process is going to like a black hole just disappear and so	thread	13
we don't care about the thread zombies anymore alright so that's my little hello world and in the next video	thread	24
we will talk about what happen if we called peace it create one hundred types are you ready let's get by	type	72
and inside our main method we're going to do we're going to create a whole load of pizza it's ok and make a note of their thread i ds pass in the firework function ok and then after we've done that we will set fireworks equal to one and then will call preconditions signals so we know that is going to wake up one thread	thread	122
now we want to wait for all threads to finish here so i could write a for loop to call p thread join on all of my thread i ds but i could also be lazy in to say ok pthread less exit the main thread	thread	28
so that we never returned from maine so i could call p thread exit here key	thread	55
right so great we've implemented that now actually let's have to think about how we can implement the firework right so what does r firework do k right well we acquire the mutex lock i might impede here just for for sure had so we've got we've got the mutex lock and all threads that run this code again to acquire the same lock	code	293
right so great we've implemented that now actually let's have to think about how we can implement the firework right so what does r firework do k right well we acquire the mutex lock i might impede here just for for sure had so we've got we've got the mutex lock and all threads that run this code again to acquire the same lock	thread	271
and then we say well while fireworks is zero corporate recognition weight in other words if my firework thread starts up here and it starts up early then we're just going to block it for but we're going to ask it to release the mutex lock and lock inside here so go back to the kind of first code remember we created all of the threads initially back when are fireworks variable with zero it's only after we've created all five	block	174
and then we say well while fireworks is zero corporate recognition weight in other words if my firework thread starts up here and it starts up early then we're just going to block it for but we're going to ask it to release the mutex lock and lock inside here so go back to the kind of first code remember we created all of the threads initially back when are fireworks variable with zero it's only after we've created all five	code	292
and then we say well while fireworks is zero corporate recognition weight in other words if my firework thread starts up here and it starts up early then we're just going to block it for but we're going to ask it to release the mutex lock and lock inside here so go back to the kind of first code remember we created all of the threads initially back when are fireworks variable with zero it's only after we've created all five	thread	104
ok so let's get down here ok right so what do we do after this point ok when we escape out of here where a scaping out of here because fireworks is no longer no longer zero and the very first thing we do is call p three condition broadcast in other words ring that fire bell wake everybody up in this might be sleeping inside this condition variable ok so now all five of my threads	thread	375
definitely working up ok so i implement increment the value of fireworks i print out oh and that value and then i decrement it ok so what's going to be the largest value this code will print one two three four five six what do you think so just as a reminder i've got five threads running this and the only way they can escape out of this code is after fireworks is no longer zero so what's the maximum possible value that we might see from this first to run this hundred or thousand to a million times what's the largest integer that would expect here ok so think about that pause this video and make your choice and then we'll see if you're correct ok so we think about this for five seconds and then we'll review the answers	code	175
definitely working up ok so i implement increment the value of fireworks i print out oh and that value and then i decrement it ok so what's going to be the largest value this code will print one two three four five six what do you think so just as a reminder i've got five threads running this and the only way they can escape out of this code is after fireworks is no longer zero so what's the maximum possible value that we might see from this first to run this hundred or thousand to a million times what's the largest integer that would expect here ok so think about that pause this video and make your choice and then we'll see if you're correct ok so we think about this for five seconds and then we'll review the answers	thread	273
ok wait times up so let's let's have a look at the key key detail here the key detail is a mutex lock our mutex lock allows us to reason strongly about the number of threads which are actually running in this code	code	209
ok wait times up so let's let's have a look at the key key detail here the key detail is a mutex lock our mutex lock allows us to reason strongly about the number of threads which are actually running in this code	a mutex	89
ok wait times up so let's let's have a look at the key key detail here the key detail is a mutex lock our mutex lock allows us to reason strongly about the number of threads which are actually running in this code	thread	166
because we've acquired mutex lock means that any other threads that want to run have to also require it so all of these lines of code can only be run by one thread at a time	code	129
because we've acquired mutex lock means that any other threads that want to run have to also require it so all of these lines of code can only be run by one thread at a time	thread	55
if the threads have gone to sleep inside p thread condition wait there only allowed to escape out of that after they reacquired the mutex log so that's the key idea that only one third of the time can be running this piece of code and it allows us to actually reason about this so we know that when we escape out of here the very first thread will see of fireworks value of one because we changed it upstairs in the main method so we implement so we increment it to two case of wig the first escapes out of here will	code	226
if the threads have gone to sleep inside p thread condition wait there only allowed to escape out of that after they reacquired the mutex log so that's the key idea that only one third of the time can be running this piece of code and it allows us to actually reason about this so we know that when we escape out of here the very first thread will see of fireworks value of one because we changed it upstairs in the main method so we implement so we increment it to two case of wig the first escapes out of here will	thread	7
will print out too and then we decrement it down to one again and then we unlock the mutex ok so the next step that comes out of here will only escape out of p three condition wait after we've unlock the mutex so it will also see a value of fireworks of one it also does a big forecast waking everybody up and most are too and so it will print out the value of two etc right and so on the next thread will come out check the condition for the while loop ok that is no longer true so it comes to an does the same thing increments it from one to two and then two to one and then unlocks the mutex which allows the next set to escape it checks the value and so on and so on so right so let's just kind of run this just to kind of prove it right so we have ok compiled it	thread	394
why is my machine slow ok there we go he got out all right and we see every firework every thread wanna see the value of two and we could do that through this strong reasoning thanks to the mutex log	thread	91
that these two lines of code here	code	24
between us deciding the value of fireworks is zero and then calling peter condition wait so if it happened right inside there if that just that moment in time then what's going to happen we've actually called preconditions signal but no thread was yet sleeping no thread was yet blocked inside condition wait ok so was to fix for that and the answer is to actually log on the same mutex here so if i call pete said mutex lock here	block	279
between us deciding the value of fireworks is zero and then calling peter condition wait so if it happened right inside there if that just that moment in time then what's going to happen we've actually called preconditions signal but no thread was yet sleeping no thread was yet blocked inside condition wait ok so was to fix for that and the answer is to actually log on the same mutex here so if i call pete said mutex lock here	thread	237
another thread is acquired mutex or after the all the threads have called pizza hut	thread	8
another thing this code is kind of highlights is that	code	19
that you can create threads but peter create doesn't wait for them to actually start so this this code is an attempt to say ok let's create all these threads and actually we're going to make our own barrier	code	98
that you can create threads but peter create doesn't wait for them to actually start so this this code is an attempt to say ok let's create all these threads and actually we're going to make our own barrier	thread	20
inside here so we won't let anybody go until we've actually created or five threads and also kind of starting up so but this line of actually changing the fireworks to one here could still actually technically occur before this five threads of actually started all we've just simply say is to say ok create them and at some point in the future please run alright so lots of interesting interleavings details there and as you can see this stuff is tricky	thread	76
so how do we get data into our processes maybe it's from a file maybe it's from what we type maybe assuming network and underneath all of those ideas is very simple and useful little	type	88
we got three to pick zero one or two and it happens to be that far descriptive zero corresponds to standard input and then we have to say where do we want this day to arrive so we need to give it a memory location a memory address now read doesn't care about a type we simply going to say hey start putting bites into this particular memory location and if i ask for more than one byte then use the success of the addresses after this location	memory	198
we got three to pick zero one or two and it happens to be that far descriptive zero corresponds to standard input and then we have to say where do we want this day to arrive so we need to give it a memory location a memory address now read doesn't care about a type we simply going to say hey start putting bites into this particular memory location and if i ask for more than one byte then use the success of the addresses after this location	type	261
we got three to pick zero one or two and it happens to be that far descriptive zero corresponds to standard input and then we have to say where do we want this day to arrive so we need to give it a memory location a memory address now read doesn't care about a type we simply going to say hey start putting bites into this particular memory location and if i ask for more than one byte then use the success of the addresses after this location	address	223
it is useful to say however how large are buffers we don't want it to overwrite all of our memory and start changing other variables so we're going to put an upper limit if you like the capacity that we're prepared to accept now this isn't necessarily the number of bytes it is going to be actually "written you'll notice that ""read"" has a return type" this s size underscore t the s size here the extra s here means it's a signed value because we might return negative one mean so i didn't give you anything but if it does return a positive value then we know that	memory	91
it is useful to say however how large are buffers we don't want it to overwrite all of our memory and start changing other variables so we're going to put an upper limit if you like the capacity that we're prepared to accept now this isn't necessarily the number of bytes it is going to be actually "written you'll notice that ""read"" has a return type" this s size underscore t the s size here the extra s here means it's a signed value because we might return negative one mean so i didn't give you anything but if it does return a positive value then we know that	type	349
you can test for that condition and then act accordingly "one thing you wouldn't do after that point of course is call more reads because there isn't anything else coming down now here's the second type type of thing about read which is perhaps surprising is that it can block so it's default behavior is to wait until there's some bites ready to give you in other words this call to read might wait forever was this waiting for it's not gonna use any other any cpu time we can give the cpu to other processes and other kernel tasks that need to run so realize that this read is what's called a blocking call that it doesn't return immediately when it returns you know that something is happening is time to process it	block	271
you can test for that condition and then act accordingly "one thing you wouldn't do after that point of course is call more reads because there isn't anything else coming down now here's the second type type of thing about read which is perhaps surprising is that it can block so it's default behavior is to wait until there's some bites ready to give you in other words this call to read might wait forever was this waiting for it's not gonna use any other any cpu time we can give the cpu to other processes and other kernel tasks that need to run so realize that this read is what's called a blocking call that it doesn't return immediately when it returns you know that something is happening is time to process it	type	198
we're not going to go into a full details have read today will wait until the end of the course but today we will remember that if it does return a negative value it's going to negative one and we're going to treat the street that is a kind of generic error condition to say hey something went wrong the usb key was pulled out my network connection was closed i couldn't read anymore bites into file whatever will treat that as a time to stop right so what kind of call exists as you might have guessed it is a system call that to do all of these things we need help from the kernel we need to escape from our process space and actually used us to the system so let's see how we can use it for this let's actually write some code	code	725
we're not going to go into a full details have read today will wait until the end of the course but today we will remember that if it does return a negative value it's going to negative one and we're going to treat the street that is a kind of generic error condition to say hey something went wrong the usb key was pulled out my network connection was closed i couldn't read anymore bites into file whatever will treat that as a time to stop right so what kind of call exists as you might have guessed it is a system call that to do all of these things we need help from the kernel we need to escape from our process space and actually used us to the system so let's see how we can use it for this let's actually write some code	a system call	509
we're not going to go into a full details have read today will wait until the end of the course but today we will remember that if it does return a negative value it's going to negative one and we're going to treat the street that is a kind of generic error condition to say hey something went wrong the usb key was pulled out my network connection was closed i couldn't read anymore bites into file whatever will treat that as a time to stop right so what kind of call exists as you might have guessed it is a system call that to do all of these things we need help from the kernel we need to escape from our process space and actually used us to the system so let's see how we can use it for this let's actually write some code	system	511
and i need to declare it i don't need to write that i can just i know that it's inside you <unistd.h> right so now we have a little main method high maine and you take the number of arguments and a pointer pointer rv fight ok so let's just read from standard input right now i need a place for that i need some bites well i could call malloc to get some bites on the heap i could have a global variable such as an array or i could have a stack variable read does not care or re cares about is hey give me an address and tell me how many bytes i can right there ok so let me have a little buffer space here pick a random number like four thousand ninety six ok so now you know that if i just use the variable buffer without pushing the square brackets then that is going to evaluate the very first bite of that away or the stack is not a pointer it's an away and arrays can't be changed to look at somewhere else so i can't say ok variable start looking at this other memory location you cannot do that but we can use it in a pointer context so let's do that let's call size t and will say result and say ok read now at this point i need that file descriptor	memory	967
and i need to declare it i don't need to write that i can just i know that it's inside you <unistd.h> right so now we have a little main method high maine and you take the number of arguments and a pointer pointer rv fight ok so let's just read from standard input right now i need a place for that i need some bites well i could call malloc to get some bites on the heap i could have a global variable such as an array or i could have a stack variable read does not care or re cares about is hey give me an address and tell me how many bytes i can right there ok so let me have a little buffer space here pick a random number like four thousand ninety six ok so now you know that if i just use the variable buffer without pushing the square brackets then that is going to evaluate the very first bite of that away or the stack is not a pointer it's an away and arrays can't be changed to look at somewhere else so i can't say ok variable start looking at this other memory location you cannot do that but we can use it in a pointer context so let's do that let's call size t and will say result and say ok read now at this point i need that file descriptor	the heap	363
and i need to declare it i don't need to write that i can just i know that it's inside you <unistd.h> right so now we have a little main method high maine and you take the number of arguments and a pointer pointer rv fight ok so let's just read from standard input right now i need a place for that i need some bites well i could call malloc to get some bites on the heap i could have a global variable such as an array or i could have a stack variable read does not care or re cares about is hey give me an address and tell me how many bytes i can right there ok so let me have a little buffer space here pick a random number like four thousand ninety six ok so now you know that if i just use the variable buffer without pushing the square brackets then that is going to evaluate the very first bite of that away or the stack is not a pointer it's an away and arrays can't be changed to look at somewhere else so i can't say ok variable start looking at this other memory location you cannot do that but we can use it in a pointer context so let's do that let's call size t and will say result and say ok read now at this point i need that file descriptor	address	508
and i need to declare it i don't need to write that i can just i know that it's inside you <unistd.h> right so now we have a little main method high maine and you take the number of arguments and a pointer pointer rv fight ok so let's just read from standard input right now i need a place for that i need some bites well i could call malloc to get some bites on the heap i could have a global variable such as an array or i could have a stack variable read does not care or re cares about is hey give me an address and tell me how many bytes i can right there ok so let me have a little buffer space here pick a random number like four thousand ninety six ok so now you know that if i just use the variable buffer without pushing the square brackets then that is going to evaluate the very first bite of that away or the stack is not a pointer it's an away and arrays can't be changed to look at somewhere else so i can't say ok variable start looking at this other memory location you cannot do that but we can use it in a pointer context so let's do that let's call size t and will say result and say ok read now at this point i need that file descriptor	pointer	198
when it finishes that's what should we do right so we print out the result of the return value of results so how can i do that i can say printf and then result is and we could treat it say as assigned simple integer right and for that i will cast it to a simple int because my result actually may be larger than it but today we just for demo purposes this will be sufficient	printf	137
let's see we've got some bites but we didn't necessarily get a c string what we got is just some bytes is not actually going to be null terminated so how could i actually	string	65
see those bytes well one way is to use every right to say give spit out those particular bites but let's start using as a c string how can i do that and the trick of course is to put a zero at the end so if i said buffer	string	124
at the number of bytes read that will definitely be one more by after the number of bytes we got and what i want to put in there i want to put in a null byte ok so this is now in dangerous territory i hope you can see why but now if i did actually get some bites i've terminated it so now i can use it as a c string so i can do things like put it in print f and i can say and	string	309
and you gave me write a little string here right now i need to say buffer and we know that printf when we ask it to predict string will start at my location	printf	91
and you gave me write a little string here right now i need to say buffer and we know that printf when we ask it to predict string will start at my location	string	31
we could also have used put s as well so that would do something similar and including new line as well ok right so let's return that we were successful and my little program ok so what did i call it read demo right so i'll compile it gcc read demo and we expect it to fail one reason is that i didn't actually declare what printf so let me go and fix that	printf	324
nothing it's waiting that read call has blocked my process is not consuming any cpu it's now frozen in time waiting to return from that kernel call ok so i think it's time we type something in like abc and press return	block	40
nothing it's waiting that read call has blocked my process is not consuming any cpu it's now frozen in time waiting to return from that kernel call ok so i think it's time we type something in like abc and press return	type	175
and ah look i recall is returned the kernel did the following for its first of all returned the value of four and also abc so why did we say return value for	the following	48
only typed in three letters well actually what we get is everything in this case it the result includes abc and that new line character which is why we're seeing all of this extra space in the output that my actual string is abc anna new line so of course it takes five bytes to hold that ok let's just try it once more and we will have some other fun with it let's uh this time	type	5
only typed in three letters well actually what we get is everything in this case it the result includes abc and that new line character which is why we're seeing all of this extra space in the output that my actual string is abc anna new line so of course it takes five bytes to hold that ok let's just try it once more and we will have some other fun with it let's uh this time	string	215
just press ctrl d immediately so that there is no input ok and now my result is zero so actually the string length of this is just an empty string	string	101
let's have a look at my little demo and say what do you think will happen if i didn't terminate the string so if i didn't put that that null byte in so take a moment to think about that i will compile it and run it ok off we go this time i'm going to type say	type	251
let's have a look at my little demo and say what do you think will happen if i didn't terminate the string so if i didn't put that that null byte in so take a moment to think about that i will compile it and run it ok off we go this time i'm going to type say	string	100
so the answer to this is that the contents of our buffer in the stack is just going to be the whatever happens to be in those stack memory locations and we didn't actually set any others to zero so when we asked to print it out as a string printf and put i said fine i'll do that i'm going to keep working until like happen to come of course is zero and in this case we were lucky there happened to be a zero just a few bytes later but of course there's no guarantee about where that zero bite will be	memory	132
so the answer to this is that the contents of our buffer in the stack is just going to be the whatever happens to be in those stack memory locations and we didn't actually set any others to zero so when we asked to print it out as a string printf and put i said fine i'll do that i'm going to keep working until like happen to come of course is zero and in this case we were lucky there happened to be a zero just a few bytes later but of course there's no guarantee about where that zero bite will be	printf	240
so the answer to this is that the contents of our buffer in the stack is just going to be the whatever happens to be in those stack memory locations and we didn't actually set any others to zero so when we asked to print it out as a string printf and put i said fine i'll do that i'm going to keep working until like happen to come of course is zero and in this case we were lucky there happened to be a zero just a few bytes later but of course there's no guarantee about where that zero bite will be	string	233
ok the other thing you might have noticed is a very subtle memory bug here let's take a look at how many bytes that we are prepared to accept we're prepared to accept four thousand and ninety six	memory	59
but in our original code how many bytes do we actually right well potentially if i typed in four thousand ninety six bytes putting in that zero byte would have gone past the end	type	83
but in our original code how many bytes do we actually right well potentially if i typed in four thousand ninety six bytes putting in that zero byte would have gone past the end	code	20
if that ever had occured what would what would you expect it to see where maybe that piece of memory that we were overwriting is being used for a different variable and so we might have seen a subtle error later on in our code because we change different variable or worse perhaps we changed a pointer in memory of the return address for something so now our code crashes or does something unexpected and exciting	memory	94
if that ever had occured what would what would you expect it to see where maybe that piece of memory that we were overwriting is being used for a different variable and so we might have seen a subtle error later on in our code because we change different variable or worse perhaps we changed a pointer in memory of the return address for something so now our code crashes or does something unexpected and exciting	code	222
if that ever had occured what would what would you expect it to see where maybe that piece of memory that we were overwriting is being used for a different variable and so we might have seen a subtle error later on in our code because we change different variable or worse perhaps we changed a pointer in memory of the return address for something so now our code crashes or does something unexpected and exciting	address	326
if that ever had occured what would what would you expect it to see where maybe that piece of memory that we were overwriting is being used for a different variable and so we might have seen a subtle error later on in our code because we change different variable or worse perhaps we changed a pointer in memory of the return address for something so now our code crashes or does something unexpected and exciting	pointer	294
ok so that's a little kind of demo with read every time i called read is going to wait for some new bites basically it's like going up to a service counter and saying ok please go to have some more food thank you very much and this is where to put it so if we are fully processed what we had in the buffer there's no need to keep getting more memory each time i can overwrite the contents of that that buffer and then have a very fast high performance program that can just continually use the same piece of piece of memory provided i don't care that the contents of my read is overwritten each time i call it right that's enough for me for now will do one last thing here which is let's make sure our code works if it does return negative one that if it did return an error then	memory	343
ok so that's a little kind of demo with read every time i called read is going to wait for some new bites basically it's like going up to a service counter and saying ok please go to have some more food thank you very much and this is where to put it so if we are fully processed what we had in the buffer there's no need to keep getting more memory each time i can overwrite the contents of that that buffer and then have a very fast high performance program that can just continually use the same piece of piece of memory provided i don't care that the contents of my read is overwritten each time i call it right that's enough for me for now will do one last thing here which is let's make sure our code works if it does return negative one that if it did return an error then	code	702
ok something which is a lot more useful is this little program called e n v you've probably already seen it as a way to modify environment variables and print them out but perhaps you've also seen it at the top of shell programs so if i give you a little script file to run as a python interpreter or to run say with bash i might put the following at the top another common one actually would be perl as well so let's change colors here right	the following	334
the whole line actually starts with a hash and a bang as well so what is the purpose of his usr bin end well the idea is that perhaps where you store pearl on your system is different from mine so rather than	system	164
with these shell programs explicitly putting in the path to say right please run this script using say user local my perl right it would just be great if the system could find the right version of perl and run it automatically	system	158
right ok some other quick things how do we make hidden files that are not that not listed by ls we talked about this before easy give a file name that starts with a dot so if you look in your home directory you'll discover there's lots of examples of this the windows files the windowing file system tends to make a lot of files and all the apps that you might run inside it also for example you might finda subdirectory cause dot ssh for the secure shell and there's useful things inside there for example you can set up a whole load of aliases inside config so that rather than having to do ssh and then a long name you can just have a nice short name you can do things like saying ok for this particular host connect on this unusual port number or forward these other ports as well so that i can say directly connect to a database that is listing on a port on my server and make it appear as if that databases	system	293
the next video let's talk about how we can actually have in our system multiple filesystems mounted	system	64
ok we going live ok great wait let's talk about the program arguments so let's suppose you wanted to write a compiler right do you say well you know what i need to pass in some arguments like one dot c and minus d for something ok how are we going to get these things which people add after the program name and where do they go right so to that we need to understand argv and argc so every time we start our program this "two important variables here called argc and argv. argc is the count of number of labels and argv actually tells us their values so look at this looks pretty scary a pointer to a pointer ok so before we panic here's what we start the first thing we see is just that working backwards like oh i have a pointer in other words all argv is is just holds a memory address and that's we could stop there and say ok points just something	memory	775
ok we going live ok great wait let's talk about the program arguments so let's suppose you wanted to write a compiler right do you say well you know what i need to pass in some arguments like one dot c and minus d for something ok how are we going to get these things which people add after the program name and where do they go right so to that we need to understand argv and argc so every time we start our program this "two important variables here called argc and argv. argc is the count of number of labels and argv actually tells us their values so look at this looks pretty scary a pointer to a pointer ok so before we panic here's what we start the first thing we see is just that working backwards like oh i have a pointer in other words all argv is is just holds a memory address and that's we could stop there and say ok points just something	address	782
ok we going live ok great wait let's talk about the program arguments so let's suppose you wanted to write a compiler right do you say well you know what i need to pass in some arguments like one dot c and minus d for something ok how are we going to get these things which people add after the program name and where do they go right so to that we need to understand argv and argc so every time we start our program this "two important variables here called argc and argv. argc is the count of number of labels and argv actually tells us their values so look at this looks pretty scary a pointer to a pointer ok so before we panic here's what we start the first thing we see is just that working backwards like oh i have a pointer in other words all argv is is just holds a memory address and that's we could stop there and say ok points just something	pointer	589
this actually think about what it now points do that actually points to pointers ok so let's sketch this out a little bit k so do i have a great i do ok so if here's my variable called argv	pointer	72
for value it holds the address of another pointer there it is but actually that's not the whole story ok so what does this pointer hold it actually points to a string just like we've had other variables so far that points districts and this one actually holds the name of the process is running so for example it might be gcc or a dot out but we have some other arguments as well so this i have another pointer which points to the second argument case and maybe i've got like well you know one here or something ok and then the next	string	160
for value it holds the address of another pointer there it is but actually that's not the whole story ok so what does this pointer hold it actually points to a string just like we've had other variables so far that points districts and this one actually holds the name of the process is running so for example it might be gcc or a dot out but we have some other arguments as well so this i have another pointer which points to the second argument case and maybe i've got like well you know one here or something ok and then the next	address	23
for value it holds the address of another pointer there it is but actually that's not the whole story ok so what does this pointer hold it actually points to a string just like we've had other variables so far that points districts and this one actually holds the name of the process is running so for example it might be gcc or a dot out but we have some other arguments as well so this i have another pointer which points to the second argument case and maybe i've got like well you know one here or something ok and then the next	pointer	42
but next to bites for bites or eight bytes will point to the next ring etc but there's one very special entry up here to tell us we finished and this pointer is a null pointer in other words it's address zero don't try to follow that because if you try to read or write to that location your program will crash with a segmentation fault right so now we can answer these questions about what special argc[0] is going to be the process name	address	196
but next to bites for bites or eight bytes will point to the next ring etc but there's one very special entry up here to tell us we finished and this pointer is a null pointer in other words it's address zero don't try to follow that because if you try to read or write to that location your program will crash with a segmentation fault right so now we can answer these questions about what special argc[0] is going to be the process name	pointer	150
so that's always there and argv[argc] will be the null entry as well so we don't expect to have to read that one either it can be useful if you want to write a little pointer loop a little	pointer	167
loop that uses pointers and when you get to that null value you know you can stop so let's have a go let's actually try that out ok so i will get out of that mode and grab my main here let's go and write a little program to print out all the arguments ok right so call it print args lights	pointer	15
so yes i will need printf so let me include standard io.h and that should be enough ok so we can do this in a couple of different ways let's do it just using a simple for to begin with ok so i would say for int (i = 0; i < argc; i++) going to go around a loop and look at each entry ok so we could do printf and then if i want the value of i and inside there i could print	printf	19
out what i find so i could use it as a pointer but i could also use it as a string so will actually do it two different ways ok so we want the value of i	string	76
out what i find so i could use it as a pointer but i could also use it as a string so will actually do it two different ways ok so we want the value of i	pointer	39
right so i want the value of pi and then let's find out what is inside arc v but we pretend it's an array so an array starting at the i think locally i th location so that is equivalent actually to saying oddly plus i remember we do pointer arithmetic so if we're adding one two or three well actually advance far enough to move on to the next pointer case so we get ourselves to another pointer but then we dereference it ok so	pointer	233
and then if i actually wanted to print out a string	string	45
i would say ok here's the same pointer except i just for fun let's mix up let's replace that with its equivalent expression which is just argv of i write and	pointer	31
we're going around let's return zero which means success are the values of the nonzero values are conventionally used to mean ok here's an error code right not bad i just want to make one little change here that the i like a new line at the end here ok so will compile this print args compiled run it and right now we have just a single augmon as you can see it's a pointer an inside this memory we have it'll help now let's try one two three ok an we get as you can see our different arguments and each one is separated by a space unless we put put it in quotes	memory	389
we're going around let's return zero which means success are the values of the nonzero values are conventionally used to mean ok here's an error code right not bad i just want to make one little change here that the i like a new line at the end here ok so will compile this print args compiled run it and right now we have just a single augmon as you can see it's a pointer an inside this memory we have it'll help now let's try one two three ok an we get as you can see our different arguments and each one is separated by a space unless we put put it in quotes	code	145
we're going around let's return zero which means success are the values of the nonzero values are conventionally used to mean ok here's an error code right not bad i just want to make one little change here that the i like a new line at the end here ok so will compile this print args compiled run it and right now we have just a single augmon as you can see it's a pointer an inside this memory we have it'll help now let's try one two three ok an we get as you can see our different arguments and each one is separated by a space unless we put put it in quotes	pointer	366
let's open this in something which little bit more viewable ok make it larger ok let's let's instead right will use arc preprocessor trick so if hash of zero don't compile this ok and instead let's use pointer arithmetic our case so while let's go and see what argv is looking at and if it's gone zero or pointed out so printf there's printed out as a string and we want that value and just at the end of the loop let's take argv and we need to move it forward once they stop looking at the old memory location move to the next one ok right so let's looks good i want a new line ok compile this again	the loop	405
let's open this in something which little bit more viewable ok make it larger ok let's let's instead right will use arc preprocessor trick so if hash of zero don't compile this ok and instead let's use pointer arithmetic our case so while let's go and see what argv is looking at and if it's gone zero or pointed out so printf there's printed out as a string and we want that value and just at the end of the loop let's take argv and we need to move it forward once they stop looking at the old memory location move to the next one ok right so let's looks good i want a new line ok compile this again	memory	495
let's open this in something which little bit more viewable ok make it larger ok let's let's instead right will use arc preprocessor trick so if hash of zero don't compile this ok and instead let's use pointer arithmetic our case so while let's go and see what argv is looking at and if it's gone zero or pointed out so printf there's printed out as a string and we want that value and just at the end of the loop let's take argv and we need to move it forward once they stop looking at the old memory location move to the next one ok right so let's looks good i want a new line ok compile this again	printf	320
let's open this in something which little bit more viewable ok make it larger ok let's let's instead right will use arc preprocessor trick so if hash of zero don't compile this ok and instead let's use pointer arithmetic our case so while let's go and see what argv is looking at and if it's gone zero or pointed out so printf there's printed out as a string and we want that value and just at the end of the loop let's take argv and we need to move it forward once they stop looking at the old memory location move to the next one ok right so let's looks good i want a new line ok compile this again	string	352
let's open this in something which little bit more viewable ok make it larger ok let's let's instead right will use arc preprocessor trick so if hash of zero don't compile this ok and instead let's use pointer arithmetic our case so while let's go and see what argv is looking at and if it's gone zero or pointed out so printf there's printed out as a string and we want that value and just at the end of the loop let's take argv and we need to move it forward once they stop looking at the old memory location move to the next one ok right so let's looks good i want a new line ok compile this again	pointer	202
ok an run it ok initially just one and then if i do ab and c i can also read those arguments and we keep going until we hit the null at the end so that was two different ways to work through argv argc i encourage you to think about how and why this code works the easiest way is to sketch out for yourself the layout of the pointers this is a great and simple example actually to really get you to think about what it means to have pointers and pointers to pointers and equipment could always gnarly stuff so work on this one until you feel you've battled that confusion away right goodbye	code	249
ok an run it ok initially just one and then if i do ab and c i can also read those arguments and we keep going until we hit the null at the end so that was two different ways to work through argv argc i encourage you to think about how and why this code works the easiest way is to sketch out for yourself the layout of the pointers this is a great and simple example actually to really get you to think about what it means to have pointers and pointers to pointers and equipment could always gnarly stuff so work on this one until you feel you've battled that confusion away right goodbye	pointer	324
ok so for ways that thread can be terminated right so what do we got so we might have that the thread calls p thread exit	thread	20
we might have that the thread	thread	23
so the other way is that a thread could be terminated as if we terminate the whole process so that might happen gracefully for example any thread it doesn't need to be the main thread any thread calls exit for example	a thread	25
so the other way is that a thread could be terminated as if we terminate the whole process so that might happen gracefully for example any thread it doesn't need to be the main thread any thread calls exit for example	thread	27
the main thread returns from maine	thread	9
the main thread it turns from maine	thread	9
ok anything else well how about a signal so if a signal terminates the program terminates the process then there is no process for my thread to run in so again my thread is terminated so the single terminates the process	thread	134
right so there's five ways we could also talk about p thread cancelled but like it like i said i prefer not to write so my next challenge to do is you seen me	thread	54
do a demo now it's your turn so before playing the next video have ago at creating a program that prints out hello world except the main thread doesn't print anything so get one third to print out hello and another thread to print out world are you ready go	thread	137
and inside our main method we're going to do we're going to create a whole load of pizza it's ok and make a note of their thread i ds pass in the firework function ok and then after we've done that we will set fireworks equal to one and then will call preconditions signals so we know that is going to wake up one thread	thread	122
now we want to wait for all threads to finish here so i could write a for loop to call p thread join on all of my thread i ds but i could also be lazy in to say ok pthread less exit the main thread	thread	28
so that we never returned from maine so i could call p thread exit here key	thread	55
right so great we've implemented that now actually let's have to think about how we can implement the firework right so what does r firework do k right well we acquire the mutex lock i might impede here just for for sure had so we've got we've got the mutex lock and all threads that run this code again to acquire the same lock	code	293
right so great we've implemented that now actually let's have to think about how we can implement the firework right so what does r firework do k right well we acquire the mutex lock i might impede here just for for sure had so we've got we've got the mutex lock and all threads that run this code again to acquire the same lock	thread	271
and then we say well while fireworks is zero corporate recognition weight in other words if my firework thread starts up here and it starts up early then we're just going to block it for but we're going to ask it to release the mutex lock and lock inside here so go back to the kind of first code remember we created all of the threads initially back when are fireworks variable with zero it's only after we've created all five	block	174
and then we say well while fireworks is zero corporate recognition weight in other words if my firework thread starts up here and it starts up early then we're just going to block it for but we're going to ask it to release the mutex lock and lock inside here so go back to the kind of first code remember we created all of the threads initially back when are fireworks variable with zero it's only after we've created all five	code	292
and then we say well while fireworks is zero corporate recognition weight in other words if my firework thread starts up here and it starts up early then we're just going to block it for but we're going to ask it to release the mutex lock and lock inside here so go back to the kind of first code remember we created all of the threads initially back when are fireworks variable with zero it's only after we've created all five	thread	104
ok so let's get down here ok right so what do we do after this point ok when we escape out of here where a scaping out of here because fireworks is no longer no longer zero and the very first thing we do is call p three condition broadcast in other words ring that fire bell wake everybody up in this might be sleeping inside this condition variable ok so now all five of my threads	thread	375
definitely working up ok so i implement increment the value of fireworks i print out oh and that value and then i decrement it ok so what's going to be the largest value this code will print one two three four five six what do you think so just as a reminder i've got five threads running this and the only way they can escape out of this code is after fireworks is no longer zero so what's the maximum possible value that we might see from this first to run this hundred or thousand to a million times what's the largest integer that would expect here ok so think about that pause this video and make your choice and then we'll see if you're correct ok so we think about this for five seconds and then we'll review the answers	code	175
definitely working up ok so i implement increment the value of fireworks i print out oh and that value and then i decrement it ok so what's going to be the largest value this code will print one two three four five six what do you think so just as a reminder i've got five threads running this and the only way they can escape out of this code is after fireworks is no longer zero so what's the maximum possible value that we might see from this first to run this hundred or thousand to a million times what's the largest integer that would expect here ok so think about that pause this video and make your choice and then we'll see if you're correct ok so we think about this for five seconds and then we'll review the answers	thread	273
ok wait times up so let's let's have a look at the key key detail here the key detail is a mutex lock our mutex lock allows us to reason strongly about the number of threads which are actually running in this code	code	209
ok wait times up so let's let's have a look at the key key detail here the key detail is a mutex lock our mutex lock allows us to reason strongly about the number of threads which are actually running in this code	a mutex	89
ok wait times up so let's let's have a look at the key key detail here the key detail is a mutex lock our mutex lock allows us to reason strongly about the number of threads which are actually running in this code	thread	166
because we've acquired mutex lock means that any other threads that want to run have to also require it so all of these lines of code can only be run by one thread at a time	code	129
because we've acquired mutex lock means that any other threads that want to run have to also require it so all of these lines of code can only be run by one thread at a time	thread	55
if the threads have gone to sleep inside p thread condition wait there only allowed to escape out of that after they reacquired the mutex log so that's the key idea that only one third of the time can be running this piece of code and it allows us to actually reason about this so we know that when we escape out of here the very first thread will see of fireworks value of one because we changed it upstairs in the main method so we implement so we increment it to two case of wig the first escapes out of here will	code	226
if the threads have gone to sleep inside p thread condition wait there only allowed to escape out of that after they reacquired the mutex log so that's the key idea that only one third of the time can be running this piece of code and it allows us to actually reason about this so we know that when we escape out of here the very first thread will see of fireworks value of one because we changed it upstairs in the main method so we implement so we increment it to two case of wig the first escapes out of here will	thread	7
will print out too and then we decrement it down to one again and then we unlock the mutex ok so the next step that comes out of here will only escape out of p three condition wait after we've unlock the mutex so it will also see a value of fireworks of one it also does a big forecast waking everybody up and most are too and so it will print out the value of two etc right and so on the next thread will come out check the condition for the while loop ok that is no longer true so it comes to an does the same thing increments it from one to two and then two to one and then unlocks the mutex which allows the next set to escape it checks the value and so on and so on so right so let's just kind of run this just to kind of prove it right so we have ok compiled it	thread	394
why is my machine slow ok there we go he got out all right and we see every firework every thread wanna see the value of two and we could do that through this strong reasoning thanks to the mutex log	thread	91
that these two lines of code here	code	24
between us deciding the value of fireworks is zero and then calling peter condition wait so if it happened right inside there if that just that moment in time then what's going to happen we've actually called preconditions signal but no thread was yet sleeping no thread was yet blocked inside condition wait ok so was to fix for that and the answer is to actually log on the same mutex here so if i call pete said mutex lock here	block	279
between us deciding the value of fireworks is zero and then calling peter condition wait so if it happened right inside there if that just that moment in time then what's going to happen we've actually called preconditions signal but no thread was yet sleeping no thread was yet blocked inside condition wait ok so was to fix for that and the answer is to actually log on the same mutex here so if i call pete said mutex lock here	thread	237
another thread is acquired mutex or after the all the threads have called pizza hut	thread	8
another thing this code is kind of highlights is that	code	19
that you can create threads but peter create doesn't wait for them to actually start so this this code is an attempt to say ok let's create all these threads and actually we're going to make our own barrier	code	98
that you can create threads but peter create doesn't wait for them to actually start so this this code is an attempt to say ok let's create all these threads and actually we're going to make our own barrier	thread	20
inside here so we won't let anybody go until we've actually created or five threads and also kind of starting up so but this line of actually changing the fireworks to one here could still actually technically occur before this five threads of actually started all we've just simply say is to say ok create them and at some point in the future please run alright so lots of interesting interleavings details there and as you can see this stuff is tricky	thread	76
ok we have some fun with this i did about you but isn't it annoying when we actually have to ask our program to be compiled suppose we actually wrote a program now that continuously tried to compile the code that i am writing and the moment that the compiler succeeds hey let's run it we can do all that today with everything we've learned from this system programming course so let's have a look at that let's look at the code that i've started and workout how to complete it ok so what do we got first of all let's define the compiler that would like to use i'm going to choose gcc but we could choose c lang or we can choose a different compiler and then decide our main method let's check to see if it's being used as we as we like so did you give me	code	203
ok we have some fun with this i did about you but isn't it annoying when we actually have to ask our program to be compiled suppose we actually wrote a program now that continuously tried to compile the code that i am writing and the moment that the compiler succeeds hey let's run it we can do all that today with everything we've learned from this system programming course so let's have a look at that let's look at the code that i've started and workout how to complete it ok so what do we got first of all let's define the compiler that would like to use i'm going to choose gcc but we could choose c lang or we can choose a different compiler and then decide our main method let's check to see if it's being used as we as we like so did you give me	system	350
right number of arguments and then if you didn't let's kind of suggest usage text like you should tell me that the source code that i should be attempting to compile	code	122
or the child also immediately jumps into the loop then you've got very quickly and infinite attempt to make an infinite number of processes that can bring down a system making impossible to log back in make it impossible to fix etc so let's make sure that we write this code very carefully so the point out where's particularly where that is important ok so will get the id back from fork and remember the catch phrase here is that if we return zero we know we are the child so if the child id we get back is zero then actually we are the child so if this is zero you could also write just exclamation point child so if that child to do it then great i'm the child now in the child then our plan is to invoke the compiler so stop being this program code and start being something else	the loop	41
or the child also immediately jumps into the loop then you've got very quickly and infinite attempt to make an infinite number of processes that can bring down a system making impossible to log back in make it impossible to fix etc so let's make sure that we write this code very carefully so the point out where's particularly where that is important ok so will get the id back from fork and remember the catch phrase here is that if we return zero we know we are the child so if the child id we get back is zero then actually we are the child so if this is zero you could also write just exclamation point child so if that child to do it then great i'm the child now in the child then our plan is to invoke the compiler so stop being this program code and start being something else	code	270
or the child also immediately jumps into the loop then you've got very quickly and infinite attempt to make an infinite number of processes that can bring down a system making impossible to log back in make it impossible to fix etc so let's make sure that we write this code very carefully so the point out where's particularly where that is important ok so will get the id back from fork and remember the catch phrase here is that if we return zero we know we are the child so if the child id we get back is zero then actually we are the child so if this is zero you could also write just exclamation point child so if that child to do it then great i'm the child now in the child then our plan is to invoke the compiler so stop being this program code and start being something else	system	162
and this is the moment where we have to pause and remember the exec lp can fail and if it does we don't want to immediately go round the loop trying to fork again because children work themselves we cried trying to create more processes instead don't go round the loop do not pass go instead	the loop	133
exit so if exact fails do not continue alright so how do we call exec what we have to remember here is that we're actually going to use the program named twice first of all as the thing we'd like to load from disk and secondly the string first string will be the	string	231
process id and here's the address of my little status variable to receive the result	address	26
on that ok and then the last thing we're going to do down here is we escape out of this payment process will now do something else it will actually run this so let's fill that code in for real now	code	176
to write this in we have our if i'm a child i'm going to call exec p to say please run the following compiler	the following	87
if we broken out of the loop we will print this running your program and if we're just running it on the terminal then this will automatically flush because it has a new line and so lastly let's change the apparent process to run it ok so without all in mind let's compile this gcc compiler and i'll call it i need to give it a name that's not a drought so have a auto compiler	the loop	20
and now look five seconds later the compiler has read my stock c file but can't actually run that program yet ok fine we can change this we can start writing things like hash include standard io dot h return i got saved to disk then will do say maine at what should we do here how 'bout will do print f and you can see it's giving me back useful error messages as i type so print half like	type	366
right great ok so unless some implement a stack and will implement stack but is bounded by two things first of all you'll see that i data store here my little array here can only handle ten items also we can't pull anything from the stack if my stack is empty so now push and pop methods need to block if they are unable to continue right so let's let's have a good figure out how we're going to implement this first of all let's just pretend that with i cs two twenty five or some other course right and right than on the single threaded version ok so what are we going to have we're going to have things like the push method will be take my data structure my ray and after i've used the value of n increment it and density equal to be ok right what else you want to do so for multithreaded code i need to make sure that i'm the only person using this value of end otherwise two threads might call this code at the same time and both right into the same slot the same entry inside the away so less using mutex lock for that so we're definitely going to need mutex lock	block	296
right great ok so unless some implement a stack and will implement stack but is bounded by two things first of all you'll see that i data store here my little array here can only handle ten items also we can't pull anything from the stack if my stack is empty so now push and pop methods need to block if they are unable to continue right so let's let's have a good figure out how we're going to implement this first of all let's just pretend that with i cs two twenty five or some other course right and right than on the single threaded version ok so what are we going to have we're going to have things like the push method will be take my data structure my ray and after i've used the value of n increment it and density equal to be ok right what else you want to do so for multithreaded code i need to make sure that i'm the only person using this value of end otherwise two threads might call this code at the same time and both right into the same slot the same entry inside the away so less using mutex lock for that so we're definitely going to need mutex lock	a struct	646
right great ok so unless some implement a stack and will implement stack but is bounded by two things first of all you'll see that i data store here my little array here can only handle ten items also we can't pull anything from the stack if my stack is empty so now push and pop methods need to block if they are unable to continue right so let's let's have a good figure out how we're going to implement this first of all let's just pretend that with i cs two twenty five or some other course right and right than on the single threaded version ok so what are we going to have we're going to have things like the push method will be take my data structure my ray and after i've used the value of n increment it and density equal to be ok right what else you want to do so for multithreaded code i need to make sure that i'm the only person using this value of end otherwise two threads might call this code at the same time and both right into the same slot the same entry inside the away so less using mutex lock for that so we're definitely going to need mutex lock	code	792
right great ok so unless some implement a stack and will implement stack but is bounded by two things first of all you'll see that i data store here my little array here can only handle ten items also we can't pull anything from the stack if my stack is empty so now push and pop methods need to block if they are unable to continue right so let's let's have a good figure out how we're going to implement this first of all let's just pretend that with i cs two twenty five or some other course right and right than on the single threaded version ok so what are we going to have we're going to have things like the push method will be take my data structure my ray and after i've used the value of n increment it and density equal to be ok right what else you want to do so for multithreaded code i need to make sure that i'm the only person using this value of end otherwise two threads might call this code at the same time and both right into the same slot the same entry inside the away so less using mutex lock for that so we're definitely going to need mutex lock	thread	530
soapy said mutex lock and as luck would have it i've already got my variables up here ready to go right so let me call peter mutex lock on my mutex there we go so that might block for a short while if someone else is currently acquired the lock which is why a later on we are going to release it	block	174
so now we've got code which where only one third of the time can push things what about if our array is full of what if i stack is full so remember stepping	code	17
busy checking this right so while while n is equal to the maximum number go round the loop now we know we could put a sleeping here if we wanted to we know that right now this is a terrible test because we're holding the lock if all of our code uses a lot no one else will be able to do this fortunately for us we're going to be using p thread condition wait	the loop	82
busy checking this right so while while n is equal to the maximum number go round the loop now we know we could put a sleeping here if we wanted to we know that right now this is a terrible test because we're holding the lock if all of our code uses a lot no one else will be able to do this fortunately for us we're going to be using p thread condition wait	code	240
busy checking this right so while while n is equal to the maximum number go round the loop now we know we could put a sleeping here if we wanted to we know that right now this is a terrible test because we're holding the lock if all of our code uses a lot no one else will be able to do this fortunately for us we're going to be using p thread condition wait	thread	337
and that will release the lock whilst it's blocking ok so here's our condition variable that were going to sleep in and watched was sleeping unlock that mutex and then before returning lock it again so the big idea here is that in all the code that we write let's do i make a highlighter well let's do it like like a yellow ok it all this code every single piece of this	block	43
and that will release the lock whilst it's blocking ok so here's our condition variable that were going to sleep in and watched was sleeping unlock that mutex and then before returning lock it again so the big idea here is that in all the code that we write let's do i make a highlighter well let's do it like like a yellow ok it all this code every single piece of this	code	239
that we are in the matrix log so we could reason that we are the only thread that continue to run so great i've got all these other threads running at the same time but my head doesn't need to explode thinking about the possible interleavings of all of these expressions from this thread and another third because we own the mutex lock right and anybody else has to wait until we finished so it simplifies reasoning about this back down to just simple single threaded code again alright so great we've got our push method to work	code	468
that we are in the matrix log so we could reason that we are the only thread that continue to run so great i've got all these other threads running at the same time but my head doesn't need to explode thinking about the possible interleavings of all of these expressions from this thread and another third because we own the mutex lock right and anybody else has to wait until we finished so it simplifies reasoning about this back down to just simple single threaded code again alright so great we've got our push method to work	thread	70
if anything else we need to do yeah well we're writing a method which both to push and pop can can block so if i just put something onto this onto my way it could be that there's another thread waiting to pop things from the data structure so after i've modified it i'm going to call p threat condition broadcast	block	99
if anything else we need to do yeah well we're writing a method which both to push and pop can can block so if i just put something onto this onto my way it could be that there's another thread waiting to pop things from the data structure so after i've modified it i'm going to call p threat condition broadcast	the data structure	221
if anything else we need to do yeah well we're writing a method which both to push and pop can can block so if i just put something onto this onto my way it could be that there's another thread waiting to pop things from the data structure so after i've modified it i'm going to call p threat condition broadcast	a struct	228
if anything else we need to do yeah well we're writing a method which both to push and pop can can block so if i just put something onto this onto my way it could be that there's another thread waiting to pop things from the data structure so after i've modified it i'm going to call p threat condition broadcast	thread	187
there we go so if there happens to be someone sleeping in on this condition variable because that waiting to pop then now they can wake up so we could for performance reasons a little bit more about this and say the only time we need to do this the only possible time that someone could be blocked while popping from this away would be if the value of n was zero so in other words we have just increased it up to one otherwise there's no way that anyone could be sleeping right now so we could weight using about that and we could also reason that we've just added one thing	block	290
then maybe we could call pizza hut conditions signal as well but i would have to be a lot more careful about reasoning about that so i'm going to use p thread condition broadcast just in case there were multiple threads gone to sleep we want to make sure that if we're only going to wake up in that transition that we work them all up so	thread	152
so the pop ok so what should my pop method look like ok so first of all let's write the code which is going to	code	88
k so we turned my v where does become from i'm going to have something like double v equals so i go to my way now i want to pre decrement my value of n there we go alright so what about the blocking all right so we need something like look if my value of n is zero then go to sleep ok right so i'm going to have my p thread conditioned wait ok did you do today and here is my condition variable i'd like to sleep in and don't forget that mutex lock ok what is the mutex lock code look like are right so we've seen this before that's just	block	190
k so we turned my v where does become from i'm going to have something like double v equals so i go to my way now i want to pre decrement my value of n there we go alright so what about the blocking all right so we need something like look if my value of n is zero then go to sleep ok right so i'm going to have my p thread conditioned wait ok did you do today and here is my condition variable i'd like to sleep in and don't forget that mutex lock ok what is the mutex lock code look like are right so we've seen this before that's just	code	475
k so we turned my v where does become from i'm going to have something like double v equals so i go to my way now i want to pre decrement my value of n there we go alright so what about the blocking all right so we need something like look if my value of n is zero then go to sleep ok right so i'm going to have my p thread conditioned wait ok did you do today and here is my condition variable i'd like to sleep in and don't forget that mutex lock ok what is the mutex lock code look like are right so we've seen this before that's just	thread	317
right are we done no we might need to wake up some threads so let's put that code in as well about this kind of	code	77
right are we done no we might need to wake up some threads so let's put that code in as well about this kind of	thread	51
dark published right so let's in here wake up any thread switch might be sleeping on the condition variable so p thread condition broadcast	thread	50
all right and again we could reason about this we could say if there's if there's any locks if there's any threads sleeping on this waiting to push the only time that that can occur is if the reached the maximum number so if any is equal to now nine then i know that	thread	107
time to broadcast however this is kind of a optimization it's very easy to get these wrong it's very tricky to start modeling thinking about this when you've got multiple threads which might call pop of multiple threads which might call push gets a little bit easier to think about if you've only got one thread of each kind so my advice is treat these optimizations with extreme caution you're introducing possible edge cases which not easy to discover or think about and so if in doubt	optimizations	353
time to broadcast however this is kind of a optimization it's very easy to get these wrong it's very tricky to start modeling thinking about this when you've got multiple threads which might call pop of multiple threads which might call push gets a little bit easier to think about if you've only got one thread of each kind so my advice is treat these optimizations with extreme caution you're introducing possible edge cases which not easy to discover or think about and so if in doubt	thread	171
if you don't care about absolute performance just called prefect ingram forecast that performance head is not that great ok so we've got some working code we think let's actually have a go at testing this	code	150
ok so here's my code	code	16
that is going to actually run this and i've got some testing code where my producer is going to call the	code	61
push say ten thousand times but we're actually going to do that with two threads and then i've got a consumer method that is going to call pop twenty thousand times is just one of those today so let's check that we actually get all values of all the double values that we pushed in so we know that we know that we're going to push in the	thread	73
help for help in the background ok great so we know we're going to push in the values zero up to nine hundred and ninety nine nine have enough ninth ok right and so if we're just going to some these so we have the sum of values from zero up to that number there ok but in fact we're having two threads actually push all those values in so	thread	294
help for help in the background ok great so we know we're going to push in the values zero up to nine hundred and ninety nine nine have enough ninth ok right and so if we're just going to some these so we have the sum of values from zero up to that number there ok but in fact we're having two threads actually push all those values in so	background	21
i'm going to sum up the integers and if you know i'm sure you've seen this inside once every three right or you can do it recursively you can do this inductively or you can do it with lego as well you know that the sum is equal to n times n plus one over two right so in other words we expect a total of that right by the way i said you could do it with lego blocks here's the reasoning with lego blocks if you still some lego blocks from your younger sibling	block	359
lego block proved there right so let's let's actually have a go at running this ok so do we have code right so we called it block and let's let's run this thing ok you'll notice that we only exit after we managed to join all three threats so will compile it stop the cake monster stop consuming cake	block	5
lego block proved there right so let's let's actually have a go at running this ok so do we have code right so we called it block and let's let's run this thing ok you'll notice that we only exit after we managed to join all three threats so will compile it stop the cake monster stop consuming cake	code	97
compile ok block right so let's do that	block	11
ok gcc minus p thread block	block	22
ok gcc minus p thread block	thread	15
alright and great we got the correct some who are so are we convinced that our code works or like i said we've firmed given it a fair shake we called the	code	79
push and pop in a tight loop and we called it for ten thousand times so empirically we've shown that maybe if there's a likelihood of it failing we've at least tested it to the kind of point one percent level but is that is that is that does that give me confidence to put this into production no i'd actually want to kind of actually do a code review and think carefully about how my code works so so in multithreaded code it's a very important we have strong understanding about how our code works and rather than just simple going to lightweight testing and say oh yeah great pistol work if we actually want to use this code and trust it on our game or driving a car or an aircraft or website which is going to make our livelihood we actually want to be confident that we've got this multithreaded coding correct ok that's it for now bye	code	340
push and pop in a tight loop and we called it for ten thousand times so empirically we've shown that maybe if there's a likelihood of it failing we've at least tested it to the kind of point one percent level but is that is that is that does that give me confidence to put this into production no i'd actually want to kind of actually do a code review and think carefully about how my code works so so in multithreaded code it's a very important we have strong understanding about how our code works and rather than just simple going to lightweight testing and say oh yeah great pistol work if we actually want to use this code and trust it on our game or driving a car or an aircraft or website which is going to make our livelihood we actually want to be confident that we've got this multithreaded coding correct ok that's it for now bye	thread	410
hi, so lets figure out how we can write a version of a strdup. this idea is to duplicate a string. perhaps you've got a string that's only read only, or perhaps you've got a string that is not going to be around for much longer - perhaps it is about to go out of scope, perhaps you don't control its lifetime - so we want to get a copy of that object ok so let's have a go at this there's been an attempt here, we've got some problems.	string	91
first of all that's not how we're going to calculate the size of a string. a size of source here is going to look at the type. and what is the type of src for source? it's a pointer to something and so pointers to things are going to be four bytes or eight bytes, so however many bits are required to actually talk about our addressable memory. so on a 64 bit machine, i need 64 bits, i.e. eight bytes. so that's not going to be helpful it might work in very simple testing of trying to create small strings, but that's not how we get the size. and we also need to get some memory that is going to outlive the lifetime of my function. and of that, of course we're going to need some heap memory. ok, so let's have a go at that. the last thing i notice is that this looks a bit suspicious to me. are these the right way around? turns out they're not. how can we confirm that? answer: use the man pages. so, if i use the man pages of strcpy, i would discover that the destination goes on the left. ok, so with that in mind let's write our own version of strdup. ok so we'll skip that and go to [indistinct]. right, so we'll write mystrdup	heap memory	683
first of all that's not how we're going to calculate the size of a string. a size of source here is going to look at the type. and what is the type of src for source? it's a pointer to something and so pointers to things are going to be four bytes or eight bytes, so however many bits are required to actually talk about our addressable memory. so on a 64 bit machine, i need 64 bits, i.e. eight bytes. so that's not going to be helpful it might work in very simple testing of trying to create small strings, but that's not how we get the size. and we also need to get some memory that is going to outlive the lifetime of my function. and of that, of course we're going to need some heap memory. ok, so let's have a go at that. the last thing i notice is that this looks a bit suspicious to me. are these the right way around? turns out they're not. how can we confirm that? answer: use the man pages. so, if i use the man pages of strcpy, i would discover that the destination goes on the left. ok, so with that in mind let's write our own version of strdup. ok so we'll skip that and go to [indistinct]. right, so we'll write mystrdup	memory	337
first of all that's not how we're going to calculate the size of a string. a size of source here is going to look at the type. and what is the type of src for source? it's a pointer to something and so pointers to things are going to be four bytes or eight bytes, so however many bits are required to actually talk about our addressable memory. so on a 64 bit machine, i need 64 bits, i.e. eight bytes. so that's not going to be helpful it might work in very simple testing of trying to create small strings, but that's not how we get the size. and we also need to get some memory that is going to outlive the lifetime of my function. and of that, of course we're going to need some heap memory. ok, so let's have a go at that. the last thing i notice is that this looks a bit suspicious to me. are these the right way around? turns out they're not. how can we confirm that? answer: use the man pages. so, if i use the man pages of strcpy, i would discover that the destination goes on the left. ok, so with that in mind let's write our own version of strdup. ok so we'll skip that and go to [indistinct]. right, so we'll write mystrdup	type	121
first of all that's not how we're going to calculate the size of a string. a size of source here is going to look at the type. and what is the type of src for source? it's a pointer to something and so pointers to things are going to be four bytes or eight bytes, so however many bits are required to actually talk about our addressable memory. so on a 64 bit machine, i need 64 bits, i.e. eight bytes. so that's not going to be helpful it might work in very simple testing of trying to create small strings, but that's not how we get the size. and we also need to get some memory that is going to outlive the lifetime of my function. and of that, of course we're going to need some heap memory. ok, so let's have a go at that. the last thing i notice is that this looks a bit suspicious to me. are these the right way around? turns out they're not. how can we confirm that? answer: use the man pages. so, if i use the man pages of strcpy, i would discover that the destination goes on the left. ok, so with that in mind let's write our own version of strdup. ok so we'll skip that and go to [indistinct]. right, so we'll write mystrdup	string	67
first of all that's not how we're going to calculate the size of a string. a size of source here is going to look at the type. and what is the type of src for source? it's a pointer to something and so pointers to things are going to be four bytes or eight bytes, so however many bits are required to actually talk about our addressable memory. so on a 64 bit machine, i need 64 bits, i.e. eight bytes. so that's not going to be helpful it might work in very simple testing of trying to create small strings, but that's not how we get the size. and we also need to get some memory that is going to outlive the lifetime of my function. and of that, of course we're going to need some heap memory. ok, so let's have a go at that. the last thing i notice is that this looks a bit suspicious to me. are these the right way around? turns out they're not. how can we confirm that? answer: use the man pages. so, if i use the man pages of strcpy, i would discover that the destination goes on the left. ok, so with that in mind let's write our own version of strdup. ok so we'll skip that and go to [indistinct]. right, so we'll write mystrdup	address	325
first of all that's not how we're going to calculate the size of a string. a size of source here is going to look at the type. and what is the type of src for source? it's a pointer to something and so pointers to things are going to be four bytes or eight bytes, so however many bits are required to actually talk about our addressable memory. so on a 64 bit machine, i need 64 bits, i.e. eight bytes. so that's not going to be helpful it might work in very simple testing of trying to create small strings, but that's not how we get the size. and we also need to get some memory that is going to outlive the lifetime of my function. and of that, of course we're going to need some heap memory. ok, so let's have a go at that. the last thing i notice is that this looks a bit suspicious to me. are these the right way around? turns out they're not. how can we confirm that? answer: use the man pages. so, if i use the man pages of strcpy, i would discover that the destination goes on the left. ok, so with that in mind let's write our own version of strdup. ok so we'll skip that and go to [indistinct]. right, so we'll write mystrdup	pointer	174
it can return a character pointer. ok, mystrdup and it's going to take a pointer to a constant character. i promise not to change that character or anything else using this pointer.	pointer	26
ok, so first of all let's figure out how many bytes we need, and we're going to go down memory form	memory	88
"ok, so i'm going to say, ""hey malloc, i need the following" number of bytes. i want strlen to count the length of my string, but remember, alarm bells should go off at this point. anytime we use	the following	47
"ok, so i'm going to say, ""hey malloc, i need the following" number of bytes. i want strlen to count the length of my string, but remember, alarm bells should go off at this point. anytime we use	string	119
malloc requesting memory, let's make sure very carefully that we actually get the right number of bytes. and in this case, we need one extra because we need space for that null byte at the end. right and now, i've got myself a pointer to the beginning of that memory allocation area, i can now copy things across so i'm going to call strcpy, and i want to go	memory	18
malloc requesting memory, let's make sure very carefully that we actually get the right number of bytes. and in this case, we need one extra because we need space for that null byte at the end. right and now, i've got myself a pointer to the beginning of that memory allocation area, i can now copy things across so i'm going to call strcpy, and i want to go	memory allocation	260
malloc requesting memory, let's make sure very carefully that we actually get the right number of bytes. and in this case, we need one extra because we need space for that null byte at the end. right and now, i've got myself a pointer to the beginning of that memory allocation area, i can now copy things across so i'm going to call strcpy, and i want to go	pointer	227
and finally, let's make sure we return the correct thing. i [only?actually?] want to return my newly minted string. i	string	108
don't want to return the source ok, so what do you think about that? well, it's going to work and would be sufficient providing we ignore the possibility of errors. so there's a chance for example, that malloc might fail. maybe there is no more memory left in our system, so how could we defend against that? well, for more production quality code, we "might actually check this. we might say, ""look, if the result" "failed,"" so if the result was null,"	memory	245
don't want to return the source ok, so what do you think about that? well, it's going to work and would be sufficient providing we ignore the possibility of errors. so there's a chance for example, that malloc might fail. maybe there is no more memory left in our system, so how could we defend against that? well, for more production quality code, we "might actually check this. we might say, ""look, if the result" "failed,"" so if the result was null,"	code	343
don't want to return the source ok, so what do you think about that? well, it's going to work and would be sufficient providing we ignore the possibility of errors. so there's a chance for example, that malloc might fail. maybe there is no more memory left in our system, so how could we defend against that? well, for more production quality code, we "might actually check this. we might say, ""look, if the result" "failed,"" so if the result was null,"	system	264
right, so that's our version of strdup. we could actually now go back to the man page of strdup to see how close we've actually met the requirements of this, but instead we are going to look at puzzle six. and i've got now a little puzzle for you to work out how to complete the following code. ok, bye.	the following	275
right, so that's our version of strdup. we could actually now go back to the man page of strdup to see how close we've actually met the requirements of this, but instead we are going to look at puzzle six. and i've got now a little puzzle for you to work out how to complete the following code. ok, bye.	code	289
so remember how to do that the trick of course with using get address info is first of all zero it all out throughout all the fields	address	62
will have a tcp ip four so we want address family inet so in other words that's going to be an ip four socket we want to use tcp so we'll have a stream based protocol please right there we go so that's going to tcp and	address	35
to make sure we have a server socket we want a passive socket here for the flags ok so we've settable or hints we could get it address info and right now i'm going to say please listen on port one thousand twenty four ok and just for fun i'd like you to think about what is a thousand twenty four look like in hexadecimal so remember port numbers two bites two octets so you can have any result from zero or zero zero zero if you wish up to ffff anyway so that's a little teaser because we'll see something interesting in a moment right	address	127
so let's do some error checking remember that it get addressing for fails will use its own little helper function to print an error but i'm also going to check the return values of all of my other network code as well and if something goes wrong with one of these calls we turns negative one i'm going to just quit so my quick function is very simple it just prints out the error no message together with my little message of what happened and they just exits so that's that's quick very come to civil program there simple simple function right so what do we do ok right so let's call socket	code	205
so let's do some error checking remember that it get addressing for fails will use its own little helper function to print an error but i'm also going to check the return values of all of my other network code as well and if something goes wrong with one of these calls we turns negative one i'm going to just quit so my quick function is very simple it just prints out the error no message together with my little message of what happened and they just exits so that's that's quick very come to civil program there simple simple function right so what do we do ok right so let's call socket	address	53
will use the result this time to say there's my family so expect that to be a fine it is the only one we wanted will have the socket type in there and will have a protocol which is actually usually just the value o of for our regular tcp ip type sockets right ok so we've made ourselves suck it will check to see if it worked if we got a valid file descriptor now let's bind that to an actual network port ok so this is when we actually start saying right i want to use a particular port ok so we've done that ok now it turns out that if you hadn't actually specified an explicit port in other words if you just ask for zero it would be nice to know which port it was actually bound to so we can do that the surprising thing is rather than being called get sort port is actually get socked name	a protocol	161
will use the result this time to say there's my family so expect that to be a fine it is the only one we wanted will have the socket type in there and will have a protocol which is actually usually just the value o of for our regular tcp ip type sockets right ok so we've made ourselves suck it will check to see if it worked if we got a valid file descriptor now let's bind that to an actual network port ok so this is when we actually start saying right i want to use a particular port ok so we've done that ok now it turns out that if you hadn't actually specified an explicit port in other words if you just ask for zero it would be nice to know which port it was actually bound to so we can do that the surprising thing is rather than being called get sort port is actually get socked name	type	133
that way this is not on the test but it is kind of useful code to know about getting information about your socket so here's what we'll do we have this little structure here called socket address in calling and because there could be different kinds of sockets you have to pass through these kinds of functions not only an address of your struct but how big it is as well so that's a little bit of code here it doesn't say ok i want to know the size of this	code	58
that way this is not on the test but it is kind of useful code to know about getting information about your socket so here's what we'll do we have this little structure here called socket address in calling and because there could be different kinds of sockets you have to pass through these kinds of functions not only an address of your struct but how big it is as well so that's a little bit of code here it doesn't say ok i want to know the size of this	address	188
and while the amusingly you pass in the address of this as well	address	40
cast there right so out of this one let's print out the actual port number ok which should be the same as the port number that we asked for which is a thousand twenty four the rest of the code doesn't do much will say that we are prepared to accept a backlog of up to one hundred one hundred connections from hundred clients in other words if i don't call accept at all the first hundred people are lucky but after that one hundred and first person it gets turned away ok so here's my little service loop here we're going to do is when someone connects great will have now a client file descriptor will print it out and we could immediately tell this socket hey by the way we refuse to read anymore i'm just not listening anymore to any bytes are going to arrive on this socket that will actually also give a hint to the client as well to say hey stop sending anymore bites then will say hi will write three bites which is nature nine in new line to the client and because we don't want to say anymore let's shut down now that client file descriptor for writing as well and then finally because we have done we can actually close it we can release the file descriptor so we can reuse it ok and then we'll go round again so let's compile this and run it a case so off we go like will run it and	code	188
gave me a father scripter and it went rather loop and decided to block again ok if i use instead of netcat if i use telnet	block	65
uh annoying in the current code where we actually explicitly put in thousand and twenty four but even bigger problem when we actually say you know what just find me any of freeport because i'm doing some development and i don't want to specify the port right now just find me a free one ok so now we have a bigger problem that if i run it this port number is completely wrong so if i try to connect it doesn't work right so what did we forget what did we miss what we missed is that this low level c structure that we are getting information about the socket beds it's information using the network representation of port numbers and ip addresses and all that good stuff so we can't just simply print out the port number like we're attempting to do here the bits that are inside this field of this structure are not in the correct order to represent the right integer we need to convert it how do you do that we need to say ok i want to go from network to host and ports or equivalent to sixteen bits of the words we want this short ok and let's convert that right and now it should give us the correct result so let's try that ok so we will recompile this run it again and ok now i've got a port number let's see if we believe it ok so we'll get back over here and will try to get to it and congratulations now it works now it's giving us the correct port number ok so that's kind of the big gotcha that realized that that these low level c structures are used port numbers etc in the network byte order and using network representation which may or may not be different from the way that your cpu represents integers ok in this case we wanted to go from network to host hence end to hs if you were setting up the c structures explicitly because he didn't want to get address info	code	27
uh annoying in the current code where we actually explicitly put in thousand and twenty four but even bigger problem when we actually say you know what just find me any of freeport because i'm doing some development and i don't want to specify the port right now just find me a free one ok so now we have a bigger problem that if i run it this port number is completely wrong so if i try to connect it doesn't work right so what did we forget what did we miss what we missed is that this low level c structure that we are getting information about the socket beds it's information using the network representation of port numbers and ip addresses and all that good stuff so we can't just simply print out the port number like we're attempting to do here the bits that are inside this field of this structure are not in the correct order to represent the right integer we need to convert it how do you do that we need to say ok i want to go from network to host and ports or equivalent to sixteen bits of the words we want this short ok and let's convert that right and now it should give us the correct result so let's try that ok so we will recompile this run it again and ok now i've got a port number let's see if we believe it ok so we'll get back over here and will try to get to it and congratulations now it works now it's giving us the correct port number ok so that's kind of the big gotcha that realized that that these low level c structures are used port numbers etc in the network byte order and using network representation which may or may not be different from the way that your cpu represents integers ok in this case we wanted to go from network to host hence end to hs if you were setting up the c structures explicitly because he didn't want to get address info	address	637
so i can now already so i can get there in time yeah connect right notice that i successfully connect to the host that's because we'd already called listen and so the colonel was willing to be the welcoming auto collapse in a restaurant that kind of welcomes you there right and then right please to meet you and shakes your hand right it does the protocol handshake so that's so that's listen in action we could have up to a hundred people arrived or reston before we call it call accept and now if i keep connecting your notice on the other side i'm starting to use up my file descriptors here let's connect again right and eventually i'm accept is going to fail because there's no spare file descriptors left my process has a limited number of file descriptors that it's able to use ok right and that's the security idea because we don't want one process using up all of the carnal resources	the protocol	344
so i can now already so i can get there in time yeah connect right notice that i successfully connect to the host that's because we'd already called listen and so the colonel was willing to be the welcoming auto collapse in a restaurant that kind of welcomes you there right and then right please to meet you and shakes your hand right it does the protocol handshake so that's so that's listen in action we could have up to a hundred people arrived or reston before we call it call accept and now if i keep connecting your notice on the other side i'm starting to use up my file descriptors here let's connect again right and eventually i'm accept is going to fail because there's no spare file descriptors left my process has a limited number of file descriptors that it's able to use ok right and that's the security idea because we don't want one process using up all of the carnal resources	resources	885
will sign off here because now we're going to start talking about files and file systems and how to represent files on a disk right bye for now	system	81
ok so we've got our struct now let's think about how we can use it when we're running the program we need to keep track of our little linked list so for that let's have a variable here called head here i can sort it right so we're going to see a reference to that and what is it it's a pointer to little struck that we just defined above we've also declared this variable to be static and what static does is it hides the variables so that only the code i write inside this compilation unit in other words inside the dot c file that i'm currently writing will actually see this variable so that's the safety measures just in case you decide to have a global variable called head as well then there actually referring to do different variables and it also ensures that my implementation details aren't going to leak out into the rest of the code right so i've got my global variable and initially of course i don't have anything allocated now let's think about how we want to implement malloc here's our plan malloc is going to do two things first of all let's walk through our apartment complex and see if we have any available apartments which are large enough and available to satisfy the request for the so many bytes that we need if that fails then we'll go back to the system and say timetable be some some more heap memory please and for that will use sbrk so will only happen in our plan b we going to go there if we cannot find useful piece of space to be allocated earlier that is now free ok so let's have a look at that	heap memory	1317
ok so we've got our struct now let's think about how we can use it when we're running the program we need to keep track of our little linked list so for that let's have a variable here called head here i can sort it right so we're going to see a reference to that and what is it it's a pointer to little struck that we just defined above we've also declared this variable to be static and what static does is it hides the variables so that only the code i write inside this compilation unit in other words inside the dot c file that i'm currently writing will actually see this variable so that's the safety measures just in case you decide to have a global variable called head as well then there actually referring to do different variables and it also ensures that my implementation details aren't going to leak out into the rest of the code right so i've got my global variable and initially of course i don't have anything allocated now let's think about how we want to implement malloc here's our plan malloc is going to do two things first of all let's walk through our apartment complex and see if we have any available apartments which are large enough and available to satisfy the request for the so many bytes that we need if that fails then we'll go back to the system and say timetable be some some more heap memory please and for that will use sbrk so will only happen in our plan b we going to go there if we cannot find useful piece of space to be allocated earlier that is now free ok so let's have a look at that	memory	1322
ok so we've got our struct now let's think about how we can use it when we're running the program we need to keep track of our little linked list so for that let's have a variable here called head here i can sort it right so we're going to see a reference to that and what is it it's a pointer to little struck that we just defined above we've also declared this variable to be static and what static does is it hides the variables so that only the code i write inside this compilation unit in other words inside the dot c file that i'm currently writing will actually see this variable so that's the safety measures just in case you decide to have a global variable called head as well then there actually referring to do different variables and it also ensures that my implementation details aren't going to leak out into the rest of the code right so i've got my global variable and initially of course i don't have anything allocated now let's think about how we want to implement malloc here's our plan malloc is going to do two things first of all let's walk through our apartment complex and see if we have any available apartments which are large enough and available to satisfy the request for the so many bytes that we need if that fails then we'll go back to the system and say timetable be some some more heap memory please and for that will use sbrk so will only happen in our plan b we going to go there if we cannot find useful piece of space to be allocated earlier that is now free ok so let's have a look at that	code	449
ok so we've got our struct now let's think about how we can use it when we're running the program we need to keep track of our little linked list so for that let's have a variable here called head here i can sort it right so we're going to see a reference to that and what is it it's a pointer to little struck that we just defined above we've also declared this variable to be static and what static does is it hides the variables so that only the code i write inside this compilation unit in other words inside the dot c file that i'm currently writing will actually see this variable so that's the safety measures just in case you decide to have a global variable called head as well then there actually referring to do different variables and it also ensures that my implementation details aren't going to leak out into the rest of the code right so i've got my global variable and initially of course i don't have anything allocated now let's think about how we want to implement malloc here's our plan malloc is going to do two things first of all let's walk through our apartment complex and see if we have any available apartments which are large enough and available to satisfy the request for the so many bytes that we need if that fails then we'll go back to the system and say timetable be some some more heap memory please and for that will use sbrk so will only happen in our plan b we going to go there if we cannot find useful piece of space to be allocated earlier that is now free ok so let's have a look at that	system	1274
ok so we've got our struct now let's think about how we can use it when we're running the program we need to keep track of our little linked list so for that let's have a variable here called head here i can sort it right so we're going to see a reference to that and what is it it's a pointer to little struck that we just defined above we've also declared this variable to be static and what static does is it hides the variables so that only the code i write inside this compilation unit in other words inside the dot c file that i'm currently writing will actually see this variable so that's the safety measures just in case you decide to have a global variable called head as well then there actually referring to do different variables and it also ensures that my implementation details aren't going to leak out into the rest of the code right so i've got my global variable and initially of course i don't have anything allocated now let's think about how we want to implement malloc here's our plan malloc is going to do two things first of all let's walk through our apartment complex and see if we have any available apartments which are large enough and available to satisfy the request for the so many bytes that we need if that fails then we'll go back to the system and say timetable be some some more heap memory please and for that will use sbrk so will only happen in our plan b we going to go there if we cannot find useful piece of space to be allocated earlier that is now free ok so let's have a look at that	pointer	286
ok so if we have a pointer to this type and this structure type which got a lot of information how do i pull out the individual parts of what's there in the memory remember we've got things like whether how big it is in other words the number of bytes that the user could actually store there well that's inside our size variable and whether this particular entry represents something which is available which is free or not ok so you'll notice i'm now using this little operator this kind of arrow thing which means hey go to some memory and don't treat it as just float or an integer instead i want you to use its type and inside that type there's an offset and so many bytes in order to be able to read this variable so when the compiler first saw this struct it needs to allocate offsets to each of these variables so for example it might be that the pointer start store at the very beginning of this struct area size might be saved four bytes eight bytes later free might be another say four bytes eight bytes later the compilers free to put some padding between variables so the alignment of each of these variables makes sense and realized that these entries just like member variables inside a c plus plus class or fields of a java object were going to coeur each time all we need to know is the base address of where that struct is going to start ok so right let's go have a look at this in so we need a little loop that says well so i'm looking at a valid entry in my linked list so keep going until i get to the end i need to consider the current apartment that i'm looking at is a good one so our first criteria and this is important of course is that it's currently free ok what else well we need to make sure that it's sufficiently large right so how can i write that ok let's get a little pen here right so we need to see if the	memory	157
ok so if we have a pointer to this type and this structure type which got a lot of information how do i pull out the individual parts of what's there in the memory remember we've got things like whether how big it is in other words the number of bytes that the user could actually store there well that's inside our size variable and whether this particular entry represents something which is available which is free or not ok so you'll notice i'm now using this little operator this kind of arrow thing which means hey go to some memory and don't treat it as just float or an integer instead i want you to use its type and inside that type there's an offset and so many bytes in order to be able to read this variable so when the compiler first saw this struct it needs to allocate offsets to each of these variables so for example it might be that the pointer start store at the very beginning of this struct area size might be saved four bytes eight bytes later free might be another say four bytes eight bytes later the compilers free to put some padding between variables so the alignment of each of these variables makes sense and realized that these entries just like member variables inside a c plus plus class or fields of a java object were going to coeur each time all we need to know is the base address of where that struct is going to start ok so right let's go have a look at this in so we need a little loop that says well so i'm looking at a valid entry in my linked list so keep going until i get to the end i need to consider the current apartment that i'm looking at is a good one so our first criteria and this is important of course is that it's currently free ok what else well we need to make sure that it's sufficiently large right so how can i write that ok let's get a little pen here right so we need to see if the	type	35
ok so if we have a pointer to this type and this structure type which got a lot of information how do i pull out the individual parts of what's there in the memory remember we've got things like whether how big it is in other words the number of bytes that the user could actually store there well that's inside our size variable and whether this particular entry represents something which is available which is free or not ok so you'll notice i'm now using this little operator this kind of arrow thing which means hey go to some memory and don't treat it as just float or an integer instead i want you to use its type and inside that type there's an offset and so many bytes in order to be able to read this variable so when the compiler first saw this struct it needs to allocate offsets to each of these variables so for example it might be that the pointer start store at the very beginning of this struct area size might be saved four bytes eight bytes later free might be another say four bytes eight bytes later the compilers free to put some padding between variables so the alignment of each of these variables makes sense and realized that these entries just like member variables inside a c plus plus class or fields of a java object were going to coeur each time all we need to know is the base address of where that struct is going to start ok so right let's go have a look at this in so we need a little loop that says well so i'm looking at a valid entry in my linked list so keep going until i get to the end i need to consider the current apartment that i'm looking at is a good one so our first criteria and this is important of course is that it's currently free ok what else well we need to make sure that it's sufficiently large right so how can i write that ok let's get a little pen here right so we need to see if the	address	1309
ok so if we have a pointer to this type and this structure type which got a lot of information how do i pull out the individual parts of what's there in the memory remember we've got things like whether how big it is in other words the number of bytes that the user could actually store there well that's inside our size variable and whether this particular entry represents something which is available which is free or not ok so you'll notice i'm now using this little operator this kind of arrow thing which means hey go to some memory and don't treat it as just float or an integer instead i want you to use its type and inside that type there's an offset and so many bytes in order to be able to read this variable so when the compiler first saw this struct it needs to allocate offsets to each of these variables so for example it might be that the pointer start store at the very beginning of this struct area size might be saved four bytes eight bytes later free might be another say four bytes eight bytes later the compilers free to put some padding between variables so the alignment of each of these variables makes sense and realized that these entries just like member variables inside a c plus plus class or fields of a java object were going to coeur each time all we need to know is the base address of where that struct is going to start ok so right let's go have a look at this in so we need a little loop that says well so i'm looking at a valid entry in my linked list so keep going until i get to the end i need to consider the current apartment that i'm looking at is a good one so our first criteria and this is important of course is that it's currently free ok what else well we need to make sure that it's sufficiently large right so how can i write that ok let's get a little pen here right so we need to see if the	pointer	19
so what do you think about the following ok so so decide what's that going to do and decide which placement algorithm operating while still doing that weird is going to keep going around the loop let's pull up that next pointer and keep iterating round	the following	27
so what do you think about the following ok so so decide what's that going to do and decide which placement algorithm operating while still doing that weird is going to keep going around the loop let's pull up that next pointer and keep iterating round	the loop	187
so what do you think about the following ok so so decide what's that going to do and decide which placement algorithm operating while still doing that weird is going to keep going around the loop let's pull up that next pointer and keep iterating round	pointer	220
we've changed chosen to no longer be null so it's a non zero value right so we don't need to do much there's one thing that's very important to do which is the following right do you remember to mop out apartment block as now that apartment has now taken otherwise you'll be telling other guests and to go and visit the same apartment and that would be a mistake so it's important to update our record here so that future calls to malloc skip over this entry all right now what should we return	the following	156
we've changed chosen to no longer be null so it's a non zero value right so we don't need to do much there's one thing that's very important to do which is the following right do you remember to mop out apartment block as now that apartment has now taken otherwise you'll be telling other guests and to go and visit the same apartment and that would be a mistake so it's important to update our record here so that future calls to malloc skip over this entry all right now what should we return	block	213
it would be an error just to return the actual pointer to our metadata 'cause then the code that is called us would overwrite our struct instead inside our struct we've got a pointer so let's use that let's return the value of pointers that will tell the caller exactly which piece of heap memory they can use so that's all of accounting that we're going to need for first part of malloc alright so let's go back to this line of code here and let's talk about what it's doing so we're saying let's look at the current size each time around this loop of this entry and see if it's less than	heap memory	285
it would be an error just to return the actual pointer to our metadata 'cause then the code that is called us would overwrite our struct instead inside our struct we've got a pointer so let's use that let's return the value of pointers that will tell the caller exactly which piece of heap memory they can use so that's all of accounting that we're going to need for first part of malloc alright so let's go back to this line of code here and let's talk about what it's doing so we're saying let's look at the current size each time around this loop of this entry and see if it's less than	memory	290
it would be an error just to return the actual pointer to our metadata 'cause then the code that is called us would overwrite our struct instead inside our struct we've got a pointer so let's use that let's return the value of pointers that will tell the caller exactly which piece of heap memory they can use so that's all of accounting that we're going to need for first part of malloc alright so let's go back to this line of code here and let's talk about what it's doing so we're saying let's look at the current size each time around this loop of this entry and see if it's less than	code	87
it would be an error just to return the actual pointer to our metadata 'cause then the code that is called us would overwrite our struct instead inside our struct we've got a pointer so let's use that let's return the value of pointers that will tell the caller exactly which piece of heap memory they can use so that's all of accounting that we're going to need for first part of malloc alright so let's go back to this line of code here and let's talk about what it's doing so we're saying let's look at the current size each time around this loop of this entry and see if it's less than	pointer	47
ok now we talk about this code is that first of all we've got an ore here so by short circuiting we're only going to evaluate the right hand side of this or if chosen is non null so actually this part of the code is chosen and and is superfluous that must be true trosa must be must be non null in order to get to the right hand side ok so when can the right hand side be true in other words when we update chosen with the current apartment ok it's when the one we're currently evaluating is smaller	code	26
right now let's have a look at the second part of our code	code	54
so if we get outta here then we didn't do the early return online twenty five instead where we've given up an had to kind of get some more space ok so actually turns out we need space for two things i need space excuse me to hold the actual metadata so let me allocate that on the heap here's some code that attempts to do that what do we think of this alright so let's take the size of my struct notice i didn't put an astrex in here that would be that would be mistaken if i put a pointer here	the heap	277
so if we get outta here then we didn't do the early return online twenty five instead where we've given up an had to kind of get some more space ok so actually turns out we need space for two things i need space excuse me to hold the actual metadata so let me allocate that on the heap here's some code that attempts to do that what do we think of this alright so let's take the size of my struct notice i didn't put an astrex in here that would be that would be mistaken if i put a pointer here	code	298
so if we get outta here then we didn't do the early return online twenty five instead where we've given up an had to kind of get some more space ok so actually turns out we need space for two things i need space excuse me to hold the actual metadata so let me allocate that on the heap here's some code that attempts to do that what do we think of this alright so let's take the size of my struct notice i didn't put an astrex in here that would be that would be mistaken if i put a pointer here	pointer	483
instead will actually evaluate this to be say that twenty four bytes or thirty bytes however big are little structures and then we're changing the size of our heap memory here by calling s brick and that is going to increment a high watermark serve this is the amount of heat member we've got so far in our hip we've just increased it by say thirty two bites and our metadata chosen is going to be pointing at the old value here ok right so now we can use those thirty two bytes to actually as a metadata	heap memory	159
instead will actually evaluate this to be say that twenty four bytes or thirty bytes however big are little structures and then we're changing the size of our heap memory here by calling s brick and that is going to increment a high watermark serve this is the amount of heat member we've got so far in our hip we've just increased it by say thirty two bites and our metadata chosen is going to be pointing at the old value here ok right so now we can use those thirty two bytes to actually as a metadata	memory	164
entry so sometimes it takes a bit of getting used to the idea that i can just talk about a memory address and then immediately say ok now put these filters filters over eyes and don't think of it as just bits and bytes actually think of it as a piece of a data structure or actually think of it as an int or a double or something else see doesn't care the compiler doesn't care the cpu doesn't care up to a point more about that in a bid you can say at this particular address i want you to treat it as if this particular object or primitive value so great we're going to use those bytes as a metadata entry right so there's a few things we need to do here we need to set up those fields we've got a pointer and a size and a free so let's make sure that we do the easy ones first here right so we've going to make a note of how many bytes this entry represents remember that's the actual number of bytes the user can use and it's important for us as well to set the fact that this entry in our linked list is going to be unavailable it represents some memory there's actually been taken	memory	91
entry so sometimes it takes a bit of getting used to the idea that i can just talk about a memory address and then immediately say ok now put these filters filters over eyes and don't think of it as just bits and bytes actually think of it as a piece of a data structure or actually think of it as an int or a double or something else see doesn't care the compiler doesn't care the cpu doesn't care up to a point more about that in a bid you can say at this particular address i want you to treat it as if this particular object or primitive value so great we're going to use those bytes as a metadata entry right so there's a few things we need to do here we need to set up those fields we've got a pointer and a size and a free so let's make sure that we do the easy ones first here right so we've going to make a note of how many bytes this entry represents remember that's the actual number of bytes the user can use and it's important for us as well to set the fact that this entry in our linked list is going to be unavailable it represents some memory there's actually been taken	a struct	259
entry so sometimes it takes a bit of getting used to the idea that i can just talk about a memory address and then immediately say ok now put these filters filters over eyes and don't think of it as just bits and bytes actually think of it as a piece of a data structure or actually think of it as an int or a double or something else see doesn't care the compiler doesn't care the cpu doesn't care up to a point more about that in a bid you can say at this particular address i want you to treat it as if this particular object or primitive value so great we're going to use those bytes as a metadata entry right so there's a few things we need to do here we need to set up those fields we've got a pointer and a size and a free so let's make sure that we do the easy ones first here right so we've going to make a note of how many bytes this entry represents remember that's the actual number of bytes the user can use and it's important for us as well to set the fact that this entry in our linked list is going to be unavailable it represents some memory there's actually been taken	address	98
entry so sometimes it takes a bit of getting used to the idea that i can just talk about a memory address and then immediately say ok now put these filters filters over eyes and don't think of it as just bits and bytes actually think of it as a piece of a data structure or actually think of it as an int or a double or something else see doesn't care the compiler doesn't care the cpu doesn't care up to a point more about that in a bid you can say at this particular address i want you to treat it as if this particular object or primitive value so great we're going to use those bytes as a metadata entry right so there's a few things we need to do here we need to set up those fields we've got a pointer and a size and a free so let's make sure that we do the easy ones first here right so we've going to make a note of how many bytes this entry represents remember that's the actual number of bytes the user can use and it's important for us as well to set the fact that this entry in our linked list is going to be unavailable it represents some memory there's actually been taken	pointer	700
ok and used right so what's this other piece of code doing back online thirty one here so we actually need to get some memory for the user right so let's find out the current top of the heap so that's going to be up here let me change colors red	memory	119
ok and used right so what's this other piece of code doing back online thirty one here so we actually need to get some memory for the user right so let's find out the current top of the heap so that's going to be up here let me change colors red	the heap	182
ok and used right so what's this other piece of code doing back online thirty one here so we actually need to get some memory for the user right so let's find out the current top of the heap so that's going to be up here let me change colors red	code	48
ok so point to here is going to be looking at the top of the heat right now and then we call s break for a fourth time to say alright and the user needed let's say two hundred bytes so there ya go right so we've just pushed up the top of the heap now by another two hundred bytes bytes	the heap	238
now what's this error checking in here so it's possible that the user after a lot of memory and that failed so this let's check to see if we didn't actually get that memory at which point my lock implementation is going to return null right what's the last part that we haven't talked about oh yeah we haven't actually updated are linked list so let's do that first thing we're going to do is for our new metadata entry chosen one we're going to change this next pointer to look at the old head in other words the original first entry of our linked list	memory	85
now what's this error checking in here so it's possible that the user after a lot of memory and that failed so this let's check to see if we didn't actually get that memory at which point my lock implementation is going to return null right what's the last part that we haven't talked about oh yeah we haven't actually updated are linked list so let's do that first thing we're going to do is for our new metadata entry chosen one we're going to change this next pointer to look at the old head in other words the original first entry of our linked list	pointer	463
and finally we need to return something to the user should we return chosen now that would be a mistake that would be the wrong memory address return we actually want to return the piece of memory that we allocated for them which is inside our data structure under the word pointer or under the field pointer ok right so what do you think about that does it work yes it does but there's a couple of bugs here so i'll talk about one and then we'll talk about some of the others in a little bit so one quick problem is it is actually pretty slow look at all of these system calls or calling s break here ass break their esport here ass break their perhaps surely you can do better than that well yes actually here's one quick way there if you actually read the description of how s brake works it returns the old	memory	128
and finally we need to return something to the user should we return chosen now that would be a mistake that would be the wrong memory address return we actually want to return the piece of memory that we allocated for them which is inside our data structure under the word pointer or under the field pointer ok right so what do you think about that does it work yes it does but there's a couple of bugs here so i'll talk about one and then we'll talk about some of the others in a little bit so one quick problem is it is actually pretty slow look at all of these system calls or calling s break here ass break their esport here ass break their perhaps surely you can do better than that well yes actually here's one quick way there if you actually read the description of how s brake works it returns the old	a struct	247
and finally we need to return something to the user should we return chosen now that would be a mistake that would be the wrong memory address return we actually want to return the piece of memory that we allocated for them which is inside our data structure under the word pointer or under the field pointer ok right so what do you think about that does it work yes it does but there's a couple of bugs here so i'll talk about one and then we'll talk about some of the others in a little bit so one quick problem is it is actually pretty slow look at all of these system calls or calling s break here ass break their esport here ass break their perhaps surely you can do better than that well yes actually here's one quick way there if you actually read the description of how s brake works it returns the old	address	135
and finally we need to return something to the user should we return chosen now that would be a mistake that would be the wrong memory address return we actually want to return the piece of memory that we allocated for them which is inside our data structure under the word pointer or under the field pointer ok right so what do you think about that does it work yes it does but there's a couple of bugs here so i'll talk about one and then we'll talk about some of the others in a little bit so one quick problem is it is actually pretty slow look at all of these system calls or calling s break here ass break their esport here ass break their perhaps surely you can do better than that well yes actually here's one quick way there if you actually read the description of how s brake works it returns the old	system	565
and finally we need to return something to the user should we return chosen now that would be a mistake that would be the wrong memory address return we actually want to return the piece of memory that we allocated for them which is inside our data structure under the word pointer or under the field pointer ok right so what do you think about that does it work yes it does but there's a couple of bugs here so i'll talk about one and then we'll talk about some of the others in a little bit so one quick problem is it is actually pretty slow look at all of these system calls or calling s break here ass break their esport here ass break their perhaps surely you can do better than that well yes actually here's one quick way there if you actually read the description of how s brake works it returns the old	pointer	274
position of the end of the heap so actually i could completely delete there we go this one and this one	the heap	23
hi so it's quite common to put aside a little bit of heat memory in order to define exactly what we want our thread to do so i want to give you an example of that and then talk about how would set it up right so here's the idea suppose i had an away and i want to be able to kind of process all the elements in my way and fortunately my task is embarrassingly parallel some part of it is meaning that i can easily just spit up my data and say ok thread you do this half and another thread ok you do that half so right now what if i got so i've got method then that i want or function that i want to speed up i want to make multithreaded here it is is my little calc method here and it's given a pointer to an integer ie the very first element of my array and the number of items we'd like to process ok so if we're going to speed things up let's just split this down the middle it doesn't make sense for one thread to say work on all the even indexed items and another fair to work and the odd indexed items that wouldn't be very great for cash there is much better to split it down the middle ok so will calculate the half of it and then game plan then is to create a thread or two to do this so for example we might do the following this call p thread create we're going to make a note of the thread id we don't pass we don't need pass any attributes today and then here's the actual image calculation method that we're going to use that we're going to use to actually do the calculation i just need to when i call that actually kind of passing some hints about what it should be doing so let's make a little task and put that on the heap so we'll have a little pointer here called say task one key which will represent what would like that thread to do ok so let's set this up right so what kind of information do i want to send to my image calculation well i probably would want to send the actual data so in this case this is just a pointer to the data so that can be data and then i need to decide or define how i want to specify the range that i wanted to work in there so i for example i could could specify the data always points to the beginning of the array and then provide a start and an end just like we did with the tiles before alternatively i could say that because it's just a simple contiguous array i could say that point going to pass into here is always the beginning of where i want my calculation to start i just need to say the number of items so let me put another squeeze in here another item in here so i've got the	the following	1221
hi so it's quite common to put aside a little bit of heat memory in order to define exactly what we want our thread to do so i want to give you an example of that and then talk about how would set it up right so here's the idea suppose i had an away and i want to be able to kind of process all the elements in my way and fortunately my task is embarrassingly parallel some part of it is meaning that i can easily just spit up my data and say ok thread you do this half and another thread ok you do that half so right now what if i got so i've got method then that i want or function that i want to speed up i want to make multithreaded here it is is my little calc method here and it's given a pointer to an integer ie the very first element of my array and the number of items we'd like to process ok so if we're going to speed things up let's just split this down the middle it doesn't make sense for one thread to say work on all the even indexed items and another fair to work and the odd indexed items that wouldn't be very great for cash there is much better to split it down the middle ok so will calculate the half of it and then game plan then is to create a thread or two to do this so for example we might do the following this call p thread create we're going to make a note of the thread id we don't pass we don't need pass any attributes today and then here's the actual image calculation method that we're going to use that we're going to use to actually do the calculation i just need to when i call that actually kind of passing some hints about what it should be doing so let's make a little task and put that on the heap so we'll have a little pointer here called say task one key which will represent what would like that thread to do ok so let's set this up right so what kind of information do i want to send to my image calculation well i probably would want to send the actual data so in this case this is just a pointer to the data so that can be data and then i need to decide or define how i want to specify the range that i wanted to work in there so i for example i could could specify the data always points to the beginning of the array and then provide a start and an end just like we did with the tiles before alternatively i could say that because it's just a simple contiguous array i could say that point going to pass into here is always the beginning of where i want my calculation to start i just need to say the number of items so let me put another squeeze in here another item in here so i've got the	memory	58
hi so it's quite common to put aside a little bit of heat memory in order to define exactly what we want our thread to do so i want to give you an example of that and then talk about how would set it up right so here's the idea suppose i had an away and i want to be able to kind of process all the elements in my way and fortunately my task is embarrassingly parallel some part of it is meaning that i can easily just spit up my data and say ok thread you do this half and another thread ok you do that half so right now what if i got so i've got method then that i want or function that i want to speed up i want to make multithreaded here it is is my little calc method here and it's given a pointer to an integer ie the very first element of my array and the number of items we'd like to process ok so if we're going to speed things up let's just split this down the middle it doesn't make sense for one thread to say work on all the even indexed items and another fair to work and the odd indexed items that wouldn't be very great for cash there is much better to split it down the middle ok so will calculate the half of it and then game plan then is to create a thread or two to do this so for example we might do the following this call p thread create we're going to make a note of the thread id we don't pass we don't need pass any attributes today and then here's the actual image calculation method that we're going to use that we're going to use to actually do the calculation i just need to when i call that actually kind of passing some hints about what it should be doing so let's make a little task and put that on the heap so we'll have a little pointer here called say task one key which will represent what would like that thread to do ok so let's set this up right so what kind of information do i want to send to my image calculation well i probably would want to send the actual data so in this case this is just a pointer to the data so that can be data and then i need to decide or define how i want to specify the range that i wanted to work in there so i for example i could could specify the data always points to the beginning of the array and then provide a start and an end just like we did with the tiles before alternatively i could say that because it's just a simple contiguous array i could say that point going to pass into here is always the beginning of where i want my calculation to start i just need to say the number of items so let me put another squeeze in here another item in here so i've got the	the heap	1632
hi so it's quite common to put aside a little bit of heat memory in order to define exactly what we want our thread to do so i want to give you an example of that and then talk about how would set it up right so here's the idea suppose i had an away and i want to be able to kind of process all the elements in my way and fortunately my task is embarrassingly parallel some part of it is meaning that i can easily just spit up my data and say ok thread you do this half and another thread ok you do that half so right now what if i got so i've got method then that i want or function that i want to speed up i want to make multithreaded here it is is my little calc method here and it's given a pointer to an integer ie the very first element of my array and the number of items we'd like to process ok so if we're going to speed things up let's just split this down the middle it doesn't make sense for one thread to say work on all the even indexed items and another fair to work and the odd indexed items that wouldn't be very great for cash there is much better to split it down the middle ok so will calculate the half of it and then game plan then is to create a thread or two to do this so for example we might do the following this call p thread create we're going to make a note of the thread id we don't pass we don't need pass any attributes today and then here's the actual image calculation method that we're going to use that we're going to use to actually do the calculation i just need to when i call that actually kind of passing some hints about what it should be doing so let's make a little task and put that on the heap so we'll have a little pointer here called say task one key which will represent what would like that thread to do ok so let's set this up right so what kind of information do i want to send to my image calculation well i probably would want to send the actual data so in this case this is just a pointer to the data so that can be data and then i need to decide or define how i want to specify the range that i wanted to work in there so i for example i could could specify the data always points to the beginning of the array and then provide a start and an end just like we did with the tiles before alternatively i could say that because it's just a simple contiguous array i could say that point going to pass into here is always the beginning of where i want my calculation to start i just need to say the number of items so let me put another squeeze in here another item in here so i've got the	a thread	1167
hi so it's quite common to put aside a little bit of heat memory in order to define exactly what we want our thread to do so i want to give you an example of that and then talk about how would set it up right so here's the idea suppose i had an away and i want to be able to kind of process all the elements in my way and fortunately my task is embarrassingly parallel some part of it is meaning that i can easily just spit up my data and say ok thread you do this half and another thread ok you do that half so right now what if i got so i've got method then that i want or function that i want to speed up i want to make multithreaded here it is is my little calc method here and it's given a pointer to an integer ie the very first element of my array and the number of items we'd like to process ok so if we're going to speed things up let's just split this down the middle it doesn't make sense for one thread to say work on all the even indexed items and another fair to work and the odd indexed items that wouldn't be very great for cash there is much better to split it down the middle ok so will calculate the half of it and then game plan then is to create a thread or two to do this so for example we might do the following this call p thread create we're going to make a note of the thread id we don't pass we don't need pass any attributes today and then here's the actual image calculation method that we're going to use that we're going to use to actually do the calculation i just need to when i call that actually kind of passing some hints about what it should be doing so let's make a little task and put that on the heap so we'll have a little pointer here called say task one key which will represent what would like that thread to do ok so let's set this up right so what kind of information do i want to send to my image calculation well i probably would want to send the actual data so in this case this is just a pointer to the data so that can be data and then i need to decide or define how i want to specify the range that i wanted to work in there so i for example i could could specify the data always points to the beginning of the array and then provide a start and an end just like we did with the tiles before alternatively i could say that because it's just a simple contiguous array i could say that point going to pass into here is always the beginning of where i want my calculation to start i just need to say the number of items so let me put another squeeze in here another item in here so i've got the	thread	109
hi so it's quite common to put aside a little bit of heat memory in order to define exactly what we want our thread to do so i want to give you an example of that and then talk about how would set it up right so here's the idea suppose i had an away and i want to be able to kind of process all the elements in my way and fortunately my task is embarrassingly parallel some part of it is meaning that i can easily just spit up my data and say ok thread you do this half and another thread ok you do that half so right now what if i got so i've got method then that i want or function that i want to speed up i want to make multithreaded here it is is my little calc method here and it's given a pointer to an integer ie the very first element of my array and the number of items we'd like to process ok so if we're going to speed things up let's just split this down the middle it doesn't make sense for one thread to say work on all the even indexed items and another fair to work and the odd indexed items that wouldn't be very great for cash there is much better to split it down the middle ok so will calculate the half of it and then game plan then is to create a thread or two to do this so for example we might do the following this call p thread create we're going to make a note of the thread id we don't pass we don't need pass any attributes today and then here's the actual image calculation method that we're going to use that we're going to use to actually do the calculation i just need to when i call that actually kind of passing some hints about what it should be doing so let's make a little task and put that on the heap so we'll have a little pointer here called say task one key which will represent what would like that thread to do ok so let's set this up right so what kind of information do i want to send to my image calculation well i probably would want to send the actual data so in this case this is just a pointer to the data so that can be data and then i need to decide or define how i want to specify the range that i wanted to work in there so i for example i could could specify the data always points to the beginning of the array and then provide a start and an end just like we did with the tiles before alternatively i could say that because it's just a simple contiguous array i could say that point going to pass into here is always the beginning of where i want my calculation to start i just need to say the number of items so let me put another squeeze in here another item in here so i've got the	pointer	695
right so very similar to the actual calling instructions we had four original kind of calculation here right so let's create a couple of examples of this so now when i create a task i i'm going to create that today on the heap so let's do that i can say right i'll have a task pointer ok	the heap	218
right so very similar to the actual calling instructions we had four original kind of calculation here right so let's create a couple of examples of this so now when i create a task i i'm going to create that today on the heap so let's do that i can say right i'll have a task pointer ok	pointer	277
and all this make my wanna little bit nicer though t one equals now i need to get some memory sir let me call malloc an as usual let's make sure we slow down and check the number of bytes that we actually want so i today want not navigo size of i don't want ask pointer only give me eight bytes or four bytes i actually want enough bytes to hold this little struct so there we go task underscore t right so now i've got that back good error checking would check to make sure that that is non null	memory	87
and all this make my wanna little bit nicer though t one equals now i need to get some memory sir let me call malloc an as usual let's make sure we slow down and check the number of bytes that we actually want so i today want not navigo size of i don't want ask pointer only give me eight bytes or four bytes i actually want enough bytes to hold this little struct so there we go task underscore t right so now i've got that back good error checking would check to make sure that that is non null	pointer	262
ok cool that as our argument here ok now how this memory be freed in fact we can delegate that to our image calculation so once that actually has completed it can call free on this argument so it's perfectly fine to create memory inside one thread will create heat memory inside one thread and release it inside another just be careful that when you free it you're completely sure that no thread is going to be accessing that data in the future	memory	50
ok cool that as our argument here ok now how this memory be freed in fact we can delegate that to our image calculation so once that actually has completed it can call free on this argument so it's perfectly fine to create memory inside one thread will create heat memory inside one thread and release it inside another just be careful that when you free it you're completely sure that no thread is going to be accessing that data in the future	thread	241
we would end up writing something like this we would say right number of items that we actually want should be our parameter an items minus the half that the lower half that the first thread is going to do for us ok so that's taken care of a potential off by one hour and in this case we are going to pass in the data ok now we can use pointer arithmetic let's make sure that we're pointing to the right kind of thing we just want to offset by half so you could imagine writing this in a loop as well	parameter	115
we would end up writing something like this we would say right number of items that we actually want should be our parameter an items minus the half that the lower half that the first thread is going to do for us ok so that's taken care of a potential off by one hour and in this case we are going to pass in the data ok now we can use pointer arithmetic let's make sure that we're pointing to the right kind of thing we just want to offset by half so you could imagine writing this in a loop as well	thread	184
we would end up writing something like this we would say right number of items that we actually want should be our parameter an items minus the half that the lower half that the first thread is going to do for us ok so that's taken care of a potential off by one hour and in this case we are going to pass in the data ok now we can use pointer arithmetic let's make sure that we're pointing to the right kind of thing we just want to offset by half so you could imagine writing this in a loop as well	pointer	336
you could actually potentially say alright if i'm running on a machine with eight spare cpu cause i could create threats alright so what do i need to finish well obviously i need to put another p thread creating here and then a whole order pizza joins to make sure that we don't continue until all of all of those threads have finished otherwise the caller will assume that the data has been properly and manipulated and the output is ready ok so don't forget to do the joins down here and in a sense what we've created is a barrier that we've started all these threads were going to let them earn independently but then this thread doesn't continue until we're certain that all those are the pets are finished ok one last comment here is that we could actually implement this just using one additional thread we could do half the work on the actual calling thread	thread	196
and so that would reduce the overhead of creating a second thread in this example does that save you alot little tiny bit but creating threads is pretty cheap and they were trying to create tens of thousands of them so the much cheaper than creating a process	a process	250
and so that would reduce the overhead of creating a second thread in this example does that save you alot little tiny bit but creating threads is pretty cheap and they were trying to create tens of thousands of them so the much cheaper than creating a process	thread	59
so great now you can actually walk into an internship and say right assume your code i will speed it up i will make it run twice as fast	code	80
except as mckenna discover you never get quite as much at speed up as we claim so you can use marketing speaking ceo will be up to twice as fast because we're pretty confident that there's going to be some additional overhead and other reasons why the actual final code won't run twice as fast and we'll talk about that again in the future right i'll see in the next video bye	code	265
ok question for you darcy i know contain the file name for ten to the ten to the ten points right so hopefully you say no ok the i know does not contain the file name the file name is just a way to organize our files in terms of her directory listing and that's it ok that's the kind of big idea right so can we have the same file appear in two different places inside of file system yes absolutely ok let's do that alright so right now the story so far	system	377
reducer is the reference count of my entry by one and if that gets down to zero then we know that i node is not useful anymore and so the disk blocks that i required	block	143
it's got a reference count of three but if i was to remove it so let's remove what i call it like another dot c o k that my reference count has gone down to two so we still need it so that's why we need reference counting just keep track of the number of entries that it appears so you might see how when we do forensic analysis on disks we can look for i knowed entries which have been deleted but which still don't appear inside anyways like my file system but we still might contain all of the meta information so for example it might be i did deleted i knowed entry can still point to the disk blocks that	block	598
it's got a reference count of three but if i was to remove it so let's remove what i call it like another dot c o k that my reference count has gone down to two so we still need it so that's why we need reference counting just keep track of the number of entries that it appears so you might see how when we do forensic analysis on disks we can look for i knowed entries which have been deleted but which still don't appear inside anyways like my file system but we still might contain all of the meta information so for example it might be i did deleted i knowed entry can still point to the disk blocks that	system	452
section two it is ok so you'll find lincoln or some systems link at as well where you can say right start with his existing directory so existing file and	section	0
section two it is ok so you'll find lincoln or some systems link at as well where you can say right start with his existing directory so existing file and	system	52
make a new entry there's only one thing you can't do with hard links and that is to create a hard link to a directory you can only do this for files perhaps you should think about why and i'll give that comment in a future lecture oh and another thing you can't do is create links across two different filesystems again perhaps you could think why that is true so making hardlinks only works for regular files you cannot do this for directories	system	306
hi so a big idea is that most file system devices are what is known as block based devices meaning that at the hardware level we don't ask for a single byte from a disk instead we have a convention and we say you know i'd like give me the first block of bytes please will give me the second block of bytes or i'd like to update this block of bytes with some new values so for performance reasons we don't make requests down to just very small units we much prefer to say to a disk system an external system gave me a whole bunch of bytes and useful ideas to make the same disk blocks the same size as our memory blocks in fact what we're going to see is all over our system examples where the blocks are based around four kilobyte chunks	memory	605
hi so a big idea is that most file system devices are what is known as block based devices meaning that at the hardware level we don't ask for a single byte from a disk instead we have a convention and we say you know i'd like give me the first block of bytes please will give me the second block of bytes or i'd like to update this block of bytes with some new values so for performance reasons we don't make requests down to just very small units we much prefer to say to a disk system an external system gave me a whole bunch of bytes and useful ideas to make the same disk blocks the same size as our memory blocks in fact what we're going to see is all over our system examples where the blocks are based around four kilobyte chunks	block	71
hi so a big idea is that most file system devices are what is known as block based devices meaning that at the hardware level we don't ask for a single byte from a disk instead we have a convention and we say you know i'd like give me the first block of bytes please will give me the second block of bytes or i'd like to update this block of bytes with some new values so for performance reasons we don't make requests down to just very small units we much prefer to say to a disk system an external system gave me a whole bunch of bytes and useful ideas to make the same disk blocks the same size as our memory blocks in fact what we're going to see is all over our system examples where the blocks are based around four kilobyte chunks	system	35
or you will find examples where the chunks are slightly smaller and also we can talk about blocks or super block such a much larger today but let's let's concentrate on this main convention here so in other words i'm throwing around four thousand ninety six bytes anytime i want to load or read something from the disk so you've probably been talking about kind of cache lines and this idea that if you make a request in main memory	memory	426
or you will find examples where the chunks are slightly smaller and also we can talk about blocks or super block such a much larger today but let's let's concentrate on this main convention here so in other words i'm throwing around four thousand ninety six bytes anytime i want to load or read something from the disk so you've probably been talking about kind of cache lines and this idea that if you make a request in main memory	block	91
for one byte you're going to get say the whole cache line which might be sixty four bytes or thirty two bites or hundred depending on the system a whole load of bytes are free they all come across right depending on the width of the actual physical number of lines between main memory in your cpu so you get all these bits for free	memory	278
for one byte you're going to get say the whole cache line which might be sixty four bytes or thirty two bites or hundred depending on the system a whole load of bytes are free they all come across right depending on the width of the actual physical number of lines between main memory in your cpu so you get all these bits for free	system	138
so the same thing applies for our file based systems and we are kind of at the lowest level saying hey i want to send a block of data to and from my device so why do we make these same size is my virtual memory is because think back to our virtual memory table where i needed to have a mapping from virtual addresses to physical addresses and the very first thing we did is we took our	memory	204
so the same thing applies for our file based systems and we are kind of at the lowest level saying hey i want to send a block of data to and from my device so why do we make these same size is my virtual memory is because think back to our virtual memory table where i needed to have a mapping from virtual addresses to physical addresses and the very first thing we did is we took our	block	120
so the same thing applies for our file based systems and we are kind of at the lowest level saying hey i want to send a block of data to and from my device so why do we make these same size is my virtual memory is because think back to our virtual memory table where i needed to have a mapping from virtual addresses to physical addresses and the very first thing we did is we took our	address	307
so the same thing applies for our file based systems and we are kind of at the lowest level saying hey i want to send a block of data to and from my device so why do we make these same size is my virtual memory is because think back to our virtual memory table where i needed to have a mapping from virtual addresses to physical addresses and the very first thing we did is we took our	system	45
physical memory and divided it up into these chunks into these rammed into these disk sorry into these memory blocks here and we needed to do things like say well these bytes right now i don't care about no one seems to be using word to paginate tables so all that code inside here is just wasting ram so why don't i evict it out of my memory meanwhile i've got some other stuff that i would like to have inside my ram inside my memory so i want to page that into from disk into memory maybe it's some code that i now need maybe it's part of a data structure that i haven't needed for several minutes	memory	9
physical memory and divided it up into these chunks into these rammed into these disk sorry into these memory blocks here and we needed to do things like say well these bytes right now i don't care about no one seems to be using word to paginate tables so all that code inside here is just wasting ram so why don't i evict it out of my memory meanwhile i've got some other stuff that i would like to have inside my ram inside my memory so i want to page that into from disk into memory maybe it's some code that i now need maybe it's part of a data structure that i haven't needed for several minutes	block	110
physical memory and divided it up into these chunks into these rammed into these disk sorry into these memory blocks here and we needed to do things like say well these bytes right now i don't care about no one seems to be using word to paginate tables so all that code inside here is just wasting ram so why don't i evict it out of my memory meanwhile i've got some other stuff that i would like to have inside my ram inside my memory so i want to page that into from disk into memory maybe it's some code that i now need maybe it's part of a data structure that i haven't needed for several minutes	a struct	547
physical memory and divided it up into these chunks into these rammed into these disk sorry into these memory blocks here and we needed to do things like say well these bytes right now i don't care about no one seems to be using word to paginate tables so all that code inside here is just wasting ram so why don't i evict it out of my memory meanwhile i've got some other stuff that i would like to have inside my ram inside my memory so i want to page that into from disk into memory maybe it's some code that i now need maybe it's part of a data structure that i haven't needed for several minutes	code	265
but now i'm starting to work on that part of the document or now i'm rendering this now i'm inside of game inside a new area of the world it's time to bring that stuff into memory so we want to be able to make our disk blocks line up neatly with our memory blocks and like i said for most operations today we're going to be talking about four kilobyte blocks as our standard unit in practice systems might actually support smaller blocks for example a hundred and twenty eight bytes often at sectors but we're going to ignore those particular implementation dipped implementation details and all will stick with four kb 's as a kind of standard unit when we kind of work through some examples	memory	173
but now i'm starting to work on that part of the document or now i'm rendering this now i'm inside of game inside a new area of the world it's time to bring that stuff into memory so we want to be able to make our disk blocks line up neatly with our memory blocks and like i said for most operations today we're going to be talking about four kilobyte blocks as our standard unit in practice systems might actually support smaller blocks for example a hundred and twenty eight bytes often at sectors but we're going to ignore those particular implementation dipped implementation details and all will stick with four kb 's as a kind of standard unit when we kind of work through some examples	block	219
but now i'm starting to work on that part of the document or now i'm rendering this now i'm inside of game inside a new area of the world it's time to bring that stuff into memory so we want to be able to make our disk blocks line up neatly with our memory blocks and like i said for most operations today we're going to be talking about four kilobyte blocks as our standard unit in practice systems might actually support smaller blocks for example a hundred and twenty eight bytes often at sectors but we're going to ignore those particular implementation dipped implementation details and all will stick with four kb 's as a kind of standard unit when we kind of work through some examples	system	392
wait so with this in mind given that i can now store a file by saying right let's store the contents in block number seven block number nine block number eleven twelve fifteen etc let's think about what else you want to store about the file so obviously for each file that we want to store we've actually got the content state of bytes of the file but what else would you like	block	104
so we might want to say if you are the following user you can read it if you are the following user you can write it if this user belongs to a certain group you can delete it so the simplest form in linux today considers users to be in three different kinds we have the owner we have	the following	35
any access at all so that's the simplest kind of access control that we might have there are more complicated versions today in other file systems what else could we have well in addition to the actual contents we've probably care about its size or some interesting meta information	system	139
cape we might care about the mind type so what kind of thing is this file and today we represent that using these types for example we've already seen a few of these we have things like if it's an html file then it's minetype is text slash html we can have a mind type for images in my own type for gifts for jeffs depending how you'd like to pronounce it we have a mind type of jpeg images we have a mine-type of a word documents etc so these are all different types of files	type	34
ok so we might care about how often or how recently these events occured we also might care about who as well so perhaps we want to keep an audit log of who created it who modified it and who accessed it modern linux systems	system	217
we could also store things like how about its name ok so presumably a file is going to exist and we need to be able to refer it we don't want to keep saying hey why don't we load file number seven while file number eight he let me share file number ten with you we like to give our files some kind of name we also might want to store some other additional meta information so we might have kind of search meta information so for example there might be key value pairs like who is the artist if it was a gps coordinates of where something was stored or found maybe if it was an image say the camera settings what lens you used that kind of stuff ok so we can have an arbitrary key value pairs to help come searching right so we could kind of keep going on here and we could keep kind of brainstorming a whole load of things that we might want to store about the file but i want to kind of simplify it back down to what linux does and what we see in most file systems ok right so	system	958
rarely used in fact it's disabled because we may for performance reasons not want to keep updating our disk all solid state drive every time someone touches a file so every time someone reads a file access control like i've already mentioned is kind of simplified down to just kind of a single group single owner and everybody else yes we definitely want the size yes of course we want the contents but no we don't use mine types so as much as mine types would be useful today we have much clunkier system which is to either look at the extension so for example will claim that a file that ends with say gif is a gift or jeff dot png is a png file that kind of thing or maybe we could have dot doc is a microsoft word document so will just look at some extension or we might look at the first few bytes of the file and try to infer from those bytes as to what it's likely to be but both of these systems are kind of clunky compared to actually having real mine-types	type	424
rarely used in fact it's disabled because we may for performance reasons not want to keep updating our disk all solid state drive every time someone touches a file so every time someone reads a file access control like i've already mentioned is kind of simplified down to just kind of a single group single owner and everybody else yes we definitely want the size yes of course we want the contents but no we don't use mine types so as much as mine types would be useful today we have much clunkier system which is to either look at the extension so for example will claim that a file that ends with say gif is a gift or jeff dot png is a png file that kind of thing or maybe we could have dot doc is a microsoft word document so will just look at some extension or we might look at the first few bytes of the file and try to infer from those bytes as to what it's likely to be but both of these systems are kind of clunky compared to actually having real mine-types	system	499
the other thing we're going to have is always nice meta search informations or regular filesystems don't give us that but here's the big one that i want to kind of surprise you with is that	system	91
yes has contents has size has some of this kind of meta information but it does not have a name instead what we're going to discover it is our file has this wonderful thing called and inode number so that is going to replace how we think about data being stored on a disk and a name is just something that which lives inside directory listing so if you happen to be inside a particular directory for example you happen to be inside say directory called sub two then inside that particular directory there's going to be a whole load of names that's your directory listing an each name is going to map to an inode number so the i node number becomes the authorative way to talk about a particular file on a particular file system. a name is just a kind of secondary add-on. a name is just a cute way for us to be able to have	system	721
so in other words were which disk blocks should i go to to actually start reading the contents of my cat dot jpeg so	block	34
hi ok so let's talk about critical sections of functions which are not necessarily thread safe in terms of their implementation so here's a little example based on some real code where we want to be able to internally log errors so we don't want to display them to the console now we actually want to store them on some file so let's have a quick look to see how it works so when you call my log error function it takes an error number some integer and an optional message which eventually we're going to save to a file so you'll see down here we call f printf we're going to store it in this file handle when we've just got a string of the message and some error string as well and then finally let's flush that as well so it is actually definitely written out of the file ok now let's look at some of the other details first of all notice that	code	174
hi ok so let's talk about critical sections of functions which are not necessarily thread safe in terms of their implementation so here's a little example based on some real code where we want to be able to internally log errors so we don't want to display them to the console now we actually want to store them on some file so let's have a quick look to see how it works so when you call my log error function it takes an error number some integer and an optional message which eventually we're going to save to a file so you'll see down here we call f printf we're going to store it in this file handle when we've just got a string of the message and some error string as well and then finally let's flush that as well so it is actually definitely written out of the file ok now let's look at some of the other details first of all notice that	printf	554
hi ok so let's talk about critical sections of functions which are not necessarily thread safe in terms of their implementation so here's a little example based on some real code where we want to be able to internally log errors so we don't want to display them to the console now we actually want to store them on some file so let's have a quick look to see how it works so when you call my log error function it takes an error number some integer and an optional message which eventually we're going to save to a file so you'll see down here we call f printf we're going to store it in this file handle when we've just got a string of the message and some error string as well and then finally let's flush that as well so it is actually definitely written out of the file ok now let's look at some of the other details first of all notice that	string	627
hi ok so let's talk about critical sections of functions which are not necessarily thread safe in terms of their implementation so here's a little example based on some real code where we want to be able to internally log errors so we don't want to display them to the console now we actually want to store them on some file so let's have a quick look to see how it works so when you call my log error function it takes an error number some integer and an optional message which eventually we're going to save to a file so you'll see down here we call f printf we're going to store it in this file handle when we've just got a string of the message and some error string as well and then finally let's flush that as well so it is actually definitely written out of the file ok now let's look at some of the other details first of all notice that	section	35
hi ok so let's talk about critical sections of functions which are not necessarily thread safe in terms of their implementation so here's a little example based on some real code where we want to be able to internally log errors so we don't want to display them to the console now we actually want to store them on some file so let's have a quick look to see how it works so when you call my log error function it takes an error number some integer and an optional message which eventually we're going to save to a file so you'll see down here we call f printf we're going to store it in this file handle when we've just got a string of the message and some error string as well and then finally let's flush that as well so it is actually definitely written out of the file ok now let's look at some of the other details first of all notice that	thread	83
my file up here is null so if not file then that's when i'm going to choose to f open it and i'm going to call it a file called error log dot text and i want to append so if there's any other content down there let's zip to the end of the file first ok so if two threads were calling this at the same time	thread	263
you could imagine where an interleaving of instructions where both threads see value of null because we haven't opened the file yet so both threads decide to call f open and then write that result into the single file handle the global variable there so that wouldn't be great we only want one thread to ever call ever open so that is certainly a critical section	section	356
you could imagine where an interleaving of instructions where both threads see value of null because we haven't opened the file yet so both threads decide to call f open and then write that result into the single file handle the global variable there so that wouldn't be great we only want one thread to ever call ever open so that is certainly a critical section	thread	67
the time between actually testing whether it is null and changing it we don't we don't want to be interrupted during those times there's a second question in here as well however which is how do we generate a character based error message here string called terror former number we're using something called store error i wonder if this is safe to call for multiple threads at the same time and of course one of the reasons that we kind of suspicious about this	string	244
the time between actually testing whether it is null and changing it we don't we don't want to be interrupted during those times there's a second question in here as well however which is how do we generate a character based error message here string called terror former number we're using something called store error i wonder if this is safe to call for multiple threads at the same time and of course one of the reasons that we kind of suspicious about this	thread	366
is because it takes an inch returns a character pointer	pointer	48
and it doesn't look like we need to free that character pointers so i wonder if it's going to internally using some static memory or something so warm way to find that out on a linux machine is to go and check the thread safety of the functions that you actually using so i want to mac right now so i pulled up the lyrics version of stuart error and will see a couple surprising things first of all there's a whole lot of additional versions with under school are underneath	memory	123
and it doesn't look like we need to free that character pointers so i wonder if it's going to internally using some static memory or something so warm way to find that out on a linux machine is to go and check the thread safety of the functions that you actually using so i want to mac right now so i pulled up the lyrics version of stuart error and will see a couple surprising things first of all there's a whole lot of additional versions with under school are underneath	thread	214
and it doesn't look like we need to free that character pointers so i wonder if it's going to internally using some static memory or something so warm way to find that out on a linux machine is to go and check the thread safety of the functions that you actually using so i want to mac right now so i pulled up the lyrics version of stuart error and will see a couple surprising things first of all there's a whole lot of additional versions with under school are underneath	pointer	56
right so how do we fix this well one option of course is to use these other versions to underscore art another is to use locking so for example we could use our mutex locks to lock a mutex at the beginning and unlock it at the end so if we wanted to make sure that i know of	a mutex	181
thread could also effort therefore flush at the same time to my file then i would unlock afterwards so that would be one way	thread	0
about the performance hit now on my application because now every time i'm looking something i've every time i log in some things only one time can do that and only one thread at a time can write to the message and flush the files so with all these flashes going on as well it might actually slow down my application so how can i fix that or maybe i need to develop a better logging mechanism say	thread	169
hi ok so let's take a look at some code that i found on the internet that claims to solve their dining philosophers and we will analyze it and see what we think ok so here we go it uses all the good stuff that we now understand	code	35
we've got a little structure here called philosopher and you can see it's going to be typed deft so that we can just say philosopher later on inside that i'm going to have a pointer to the left fork and the right fork and of course a philosopher has a name	type	86
we've got a little structure here called philosopher and you can see it's going to be typed deft so that we can just say philosopher later on inside that i'm going to have a pointer to the left fork and the right fork and of course a philosopher has a name	pointer	174
and associated with it ap thread and some output variable say whether it failed or not ok we have a global variable to see whether this program should keep running or not ok and let's have a look see how things get initialized	thread	26
ok so we've got a new way of character pointers and that's just a name of five philosophers would like today we're going to have five mutex locks they're going to be our forks and five philosophers ok so	pointer	39
my philosophers so that's just a simple stack away it's ok to do this on inside the main threat because we'll see all of my threads which are going to run	thread	124
finish before we exit made right so great let's get myself a philosopher will get the i th one will initialize its name will initialize it left hand and right hand fork to be one of my five mutex locks look i'm using modulo arithmetic so that the fifth philosopher wraps around and gets to zero for kids game right after setting that all up let's start off threats will call preferred create will make a note of the thread id and will ask it to actually run some multithreaded code which will look at in a moment i learned the rest of my main thread doesn't do much it sleeps with forty seconds then changes running and now just wait for those five threats to finish	code	477
finish before we exit made right so great let's get myself a philosopher will get the i th one will initialize its name will initialize it left hand and right hand fork to be one of my five mutex locks look i'm using modulo arithmetic so that the fifth philosopher wraps around and gets to zero for kids game right after setting that all up let's start off threats will call preferred create will make a note of the thread id and will ask it to actually run some multithreaded code which will look at in a moment i learned the rest of my main thread doesn't do much it sleeps with forty seconds then changes running and now just wait for those five threats to finish	thread	416
otherwise will exit ok so that's my main threat now let's let's have a look at the code that we get that is run by each philosopher oh yes and here's my source	code	83
ok so each philosopher is going to be given a pointer to its little struct there ok so each plus is going to get its own unique name etc right so we also have some local stack variables which mirror what we find inside the the struct you'll see why in a moment so let's see what	pointer	46
my little threads going to do here so for forty seconds until that global variable is changed the first thing that my my philosophy does is sleep in other words thanks a bit so will print out his name then will sleep for and amount of time so in this case let's sleep for say some two one and eight seconds alright and then the philosopher goes to pick up the two folks	thread	10
let's see all chill at the moment ok so we're going to get out of there were going to take this check this after you run through this code once i know notice it is frayed i apologize the logic as given incorrect let's have a look see what it does first of all philosopher waist to pick up the fork on the left ok so that's only going to proceed once you get exclusive access to that particular fork alright and then it's going to change this local variable failed to based on on what happens when it tries to pick up the the fork on the right so notice that initial value of tries left is too so actually it's going to call this function called trilok which we haven't seen before trilok never blocks instead rather than blocking if it's unable to acquire this mutex	block	694
let's see all chill at the moment ok so we're going to get out of there were going to take this check this after you run through this code once i know notice it is frayed i apologize the logic as given incorrect let's have a look see what it does first of all philosopher waist to pick up the fork on the left ok so that's only going to proceed once you get exclusive access to that particular fork alright and then it's going to change this local variable failed to based on on what happens when it tries to pick up the the fork on the right so notice that initial value of tries left is too so actually it's going to call this function called trilok which we haven't seen before trilok never blocks instead rather than blocking if it's unable to acquire this mutex	code	134
it just returns an error numbers returns a non zero value so the very first time that we running this code with twice left equal to two if we caught acquire that second log we just say we failed so what do we do if we failed we immediately unlock the left hand thread	code	102
it just returns an error numbers returns a non zero value so the very first time that we running this code with twice left equal to two if we caught acquire that second log we just say we failed so what do we do if we failed we immediately unlock the left hand thread	thread	261
great you say this looks a lot like we're not going to implement holding wait we're not holding onto the fork on the left we are definitely releasing it so then what does this code do well it	code	176
and then we release both looks ok then we go round the loop we keep going until we've hdr forty seconds is up so what do you think about that is that code correct does	the loop	51
and then we release both looks ok then we go round the loop we keep going until we've hdr forty seconds is up so what do you think about that is that code correct does	code	150
for the fork on the right in other words they all get blocked so yes there is a chance that all my possibles will will deadlock because all waiting for resource it is never going to be released so oh dear this apparent code on the internet is not smart enough to solve this problem so yes ladies and gentlemen as a series two forty one	block	54
for the fork on the right in other words they all get blocked so yes there is a chance that all my possibles will will deadlock because all waiting for resource it is never going to be released so oh dear this apparent code on the internet is not smart enough to solve this problem so yes ladies and gentlemen as a series two forty one	code	219
student now smarter than the internet ok so we can prove we can show the circumstances in which deadlock is can occur this actually see if we can actually see that occur if we actually run this code in practice so here's here's the same code that i prepared earlier i wanted to get out of this and go to handouts but code	code	194
there we go right go to code	code	24
but i need cs two forty one lectures code right	code	37
p thread	thread	2
ok finally great let's ok off they go oh alright look at this we've run into deadlock where all five were hungry at exactly the same time so in practice causing this is actually actually difficult let me just run it one more time will see if we can generate it so you can see no expense spared on the graphics we've got five philosophers going through the states of either hungry eating or sleeping and yes we run into deadlock again this actually kind of take a look at this code because i want to show you that i actually had to work a little bit hard to make deadlock occur here so i want to reset my group right and let's	code	476
threads word acquire the left hand lock that was interesting is that right now i'm recording this so one of my cpu cores is busy capturing the lecture content the video content so i was actually surprised that so quickly run into deadlock the other thing that i did to try to make it more likely is i'm using micro sleeps too actually sure that we have an opportunity for deadlock many many many more times in the original provider coded only tested this with sleeps for eight seconds or so over forty second window so opportunity for deadlock is is only handful of times order of ten times or so we would like it to be much higher alright so yes i have i can run it in slow motion let's see how we do that	code	432
threads word acquire the left hand lock that was interesting is that right now i'm recording this so one of my cpu cores is busy capturing the lecture content the video content so i was actually surprised that so quickly run into deadlock the other thing that i did to try to make it more likely is i'm using micro sleeps too actually sure that we have an opportunity for deadlock many many many more times in the original provider coded only tested this with sleeps for eight seconds or so over forty second window so opportunity for deadlock is is only handful of times order of ten times or so we would like it to be much higher alright so yes i have i can run it in slow motion let's see how we do that	thread	0
hi. so, ok, we've talked about a scanf() which would read from default from the standard input but guess what we can do a lot more using the same ideas so we call it the scanf family just like printf has a family we can say instead you know what i don't want to just read from standard in i want to specify which file to read from which filestream so this f scanner for that or you might say actually guess what i've got some bytes in memory that i did as a c string and i want to pass the output from that so in which case i can use snf and all i need to do is pass in the address of my c string right so	memory	435
hi. so, ok, we've talked about a scanf() which would read from default from the standard input but guess what we can do a lot more using the same ideas so we call it the scanf family just like printf has a family we can say instead you know what i don't want to just read from standard in i want to specify which file to read from which filestream so this f scanner for that or you might say actually guess what i've got some bytes in memory that i did as a c string and i want to pass the output from that so in which case i can use snf and all i need to do is pass in the address of my c string right so	printf	193
hi. so, ok, we've talked about a scanf() which would read from default from the standard input but guess what we can do a lot more using the same ideas so we call it the scanf family just like printf has a family we can say instead you know what i don't want to just read from standard in i want to specify which file to read from which filestream so this f scanner for that or you might say actually guess what i've got some bytes in memory that i did as a c string and i want to pass the output from that so in which case i can use snf and all i need to do is pass in the address of my c string right so	string	460
hi. so, ok, we've talked about a scanf() which would read from default from the standard input but guess what we can do a lot more using the same ideas so we call it the scanf family just like printf has a family we can say instead you know what i don't want to just read from standard in i want to specify which file to read from which filestream so this f scanner for that or you might say actually guess what i've got some bytes in memory that i did as a c string and i want to pass the output from that so in which case i can use snf and all i need to do is pass in the address of my c string right so	address	574
called my data dot csv it got some values in it and i want to be real read those and then start processing that data so let's have a play with this great so we want to turn it off and start writing some code right and i will call it say if	code	203
be right ok good so our game plan then is we want to say hey see lightly please open the following so i'm going to use to see lobby version now which underneath is going to call open but it's also potentially going to buffer my input as well for better performance ok so even though i might only be reading say one line at a time the c library will read many more bites in an attempt to have better throughput so we can load our files in quicker right so i've got myself a file for good error checking i could see it failed so if f is is null we could do something about this we could see could not open whoops i want to send a little error message to the standard error could not open	the following	85
and let's quit at that point so i could also type to return one	type	45
uh i pass have a better variable actually represents that capacity so let's have available compact code called capacity and will go back and fix that one hundred in a moment ok so whilst we haven't got to the end yet i want to start reading things ok so how can we do this well remember we're going to say hey sdf	code	99
i expect to see at integer comma and another integer and now i need to give it some addresses so before we used ampersand x but now i'm actually going to need to calculate a place inside my way so what do you think of data plus the number of red so we're doing it so we're doing pointer arithmetic which means the compiler is going to make use of the type and it knows that data is an array of integers so every time we add one we're actually going to bounce by four bytes or however big an interview is well that's not bad but i have to decide where i actually want to put my data on all the x values together and then all the wise or maybe i want to do xy xy xy xy let's do the xy xy xy xy so so if i do that then	type	351
i expect to see at integer comma and another integer and now i need to give it some addresses so before we used ampersand x but now i'm actually going to need to calculate a place inside my way so what do you think of data plus the number of red so we're doing it so we're doing pointer arithmetic which means the compiler is going to make use of the type and it knows that data is an array of integers so every time we add one we're actually going to bounce by four bytes or however big an interview is well that's not bad but i have to decide where i actually want to put my data on all the x values together and then all the wise or maybe i want to do xy xy xy xy let's do the xy xy xy xy so so if i do that then	address	84
i expect to see at integer comma and another integer and now i need to give it some addresses so before we used ampersand x but now i'm actually going to need to calculate a place inside my way so what do you think of data plus the number of red so we're doing it so we're doing pointer arithmetic which means the compiler is going to make use of the type and it knows that data is an array of integers so every time we add one we're actually going to bounce by four bytes or however big an interview is well that's not bad but i have to decide where i actually want to put my data on all the x values together and then all the wise or maybe i want to do xy xy xy xy let's do the xy xy xy xy so so if i do that then	pointer	279
two then great we're happy we what should we do we will declare that the number of red has been incremented successfully so will advantage by two and we want to get down the go round the loop again so you could say continue for example alright what other possibilities other if we only managed to read one value that's a problem so maybe we should print something out so i could do my little f printf things standard error	the loop	183
two then great we're happy we what should we do we will declare that the number of red has been incremented successfully so will advantage by two and we want to get down the go round the loop again so you could say continue for example alright what other possibilities other if we only managed to read one value that's a problem so maybe we should print something out so i could do my little f printf things standard error	printf	394
now i've got myself some code let's try compiling it s connect demo k now we're trying to use exit but we never included standard lib so let's fix that right hash include standard lip	code	25
ok is compiled without error great so should we try it sure off we go right so will run it says could not open data file ok so that's our first hint that something went wrong let's have a look at our code and shape were trying to open the right file which one are open file called my data dot csv do we have such a file no we have something called data dot csv so we can let's either fix rc code or change our files i'll use medidata to change the file i want to move data dot csv to my data dot csv	code	200
ok and see how we went around that loop seven times if we actually look at the data my data dot csv you'll see that i've got seven items seven rose here to read so great we've successfully managed to read them ok is this the end no of course not we should actually test this and we should do things to deliberately trying to break it and actually give it bad day to the other thing that i might do is rather than hardcode the name why not pass it as an argument to the program but that's it that's a lot of video for now i will see you in the next video when we talk about something that is going to be very useful in this course which is called get line ok bye	code	417
ok sir how could it be the celcom malik take the same amount of time well the answer is it depends it depends upon actually which operating system we're talking about and also actually just now talking about implementation choices based on implementation toys choices you'll find inside bsd and linux so let me give you kind of two two explanations how this could possibly be true and first of all let's do the the bsd one here's what bsd says bsd says you know we want to be very security conscious and that in fact is going to be our guiding principle that we want to make it secure operating system as possible so if a process has finished with a page of memory here then there could be important secrets inside that memory for example maybe there's a public private key information inside there maybe there's a password that you typed in maybe some sense of information that you just loaded from a file but whatever it is it's currently inside the ram so it would be unfortunate if that data got copied or access at some point in the future by a malicious process or malicious actor so what vsd does is to say we will have a background process to scrub all old pieces of memory so we're basically going to zero it all out so everyone is happy so that now i've got we put that as a little zero here a piece of memory that has been cleaned prewashed ready to go so if you called the kernel and say hey i need you to map please map some some pages of memory for me how many were let's say	a page	648
ok sir how could it be the celcom malik take the same amount of time well the answer is it depends it depends upon actually which operating system we're talking about and also actually just now talking about implementation choices based on implementation toys choices you'll find inside bsd and linux so let me give you kind of two two explanations how this could possibly be true and first of all let's do the the bsd one here's what bsd says bsd says you know we want to be very security conscious and that in fact is going to be our guiding principle that we want to make it secure operating system as possible so if a process has finished with a page of memory here then there could be important secrets inside that memory for example maybe there's a public private key information inside there maybe there's a password that you typed in maybe some sense of information that you just loaded from a file but whatever it is it's currently inside the ram so it would be unfortunate if that data got copied or access at some point in the future by a malicious process or malicious actor so what vsd does is to say we will have a background process to scrub all old pieces of memory so we're basically going to zero it all out so everyone is happy so that now i've got we put that as a little zero here a piece of memory that has been cleaned prewashed ready to go so if you called the kernel and say hey i need you to map please map some some pages of memory for me how many were let's say	memory	658
ok sir how could it be the celcom malik take the same amount of time well the answer is it depends it depends upon actually which operating system we're talking about and also actually just now talking about implementation choices based on implementation toys choices you'll find inside bsd and linux so let me give you kind of two two explanations how this could possibly be true and first of all let's do the the bsd one here's what bsd says bsd says you know we want to be very security conscious and that in fact is going to be our guiding principle that we want to make it secure operating system as possible so if a process has finished with a page of memory here then there could be important secrets inside that memory for example maybe there's a public private key information inside there maybe there's a password that you typed in maybe some sense of information that you just loaded from a file but whatever it is it's currently inside the ram so it would be unfortunate if that data got copied or access at some point in the future by a malicious process or malicious actor so what vsd does is to say we will have a background process to scrub all old pieces of memory so we're basically going to zero it all out so everyone is happy so that now i've got we put that as a little zero here a piece of memory that has been cleaned prewashed ready to go so if you called the kernel and say hey i need you to map please map some some pages of memory for me how many were let's say	type	833
ok sir how could it be the celcom malik take the same amount of time well the answer is it depends it depends upon actually which operating system we're talking about and also actually just now talking about implementation choices based on implementation toys choices you'll find inside bsd and linux so let me give you kind of two two explanations how this could possibly be true and first of all let's do the the bsd one here's what bsd says bsd says you know we want to be very security conscious and that in fact is going to be our guiding principle that we want to make it secure operating system as possible so if a process has finished with a page of memory here then there could be important secrets inside that memory for example maybe there's a public private key information inside there maybe there's a password that you typed in maybe some sense of information that you just loaded from a file but whatever it is it's currently inside the ram so it would be unfortunate if that data got copied or access at some point in the future by a malicious process or malicious actor so what vsd does is to say we will have a background process to scrub all old pieces of memory so we're basically going to zero it all out so everyone is happy so that now i've got we put that as a little zero here a piece of memory that has been cleaned prewashed ready to go so if you called the kernel and say hey i need you to map please map some some pages of memory for me how many were let's say	a process	620
ok sir how could it be the celcom malik take the same amount of time well the answer is it depends it depends upon actually which operating system we're talking about and also actually just now talking about implementation choices based on implementation toys choices you'll find inside bsd and linux so let me give you kind of two two explanations how this could possibly be true and first of all let's do the the bsd one here's what bsd says bsd says you know we want to be very security conscious and that in fact is going to be our guiding principle that we want to make it secure operating system as possible so if a process has finished with a page of memory here then there could be important secrets inside that memory for example maybe there's a public private key information inside there maybe there's a password that you typed in maybe some sense of information that you just loaded from a file but whatever it is it's currently inside the ram so it would be unfortunate if that data got copied or access at some point in the future by a malicious process or malicious actor so what vsd does is to say we will have a background process to scrub all old pieces of memory so we're basically going to zero it all out so everyone is happy so that now i've got we put that as a little zero here a piece of memory that has been cleaned prewashed ready to go so if you called the kernel and say hey i need you to map please map some some pages of memory for me how many were let's say	background	1129
ok sir how could it be the celcom malik take the same amount of time well the answer is it depends it depends upon actually which operating system we're talking about and also actually just now talking about implementation choices based on implementation toys choices you'll find inside bsd and linux so let me give you kind of two two explanations how this could possibly be true and first of all let's do the the bsd one here's what bsd says bsd says you know we want to be very security conscious and that in fact is going to be our guiding principle that we want to make it secure operating system as possible so if a process has finished with a page of memory here then there could be important secrets inside that memory for example maybe there's a public private key information inside there maybe there's a password that you typed in maybe some sense of information that you just loaded from a file but whatever it is it's currently inside the ram so it would be unfortunate if that data got copied or access at some point in the future by a malicious process or malicious actor so what vsd does is to say we will have a background process to scrub all old pieces of memory so we're basically going to zero it all out so everyone is happy so that now i've got we put that as a little zero here a piece of memory that has been cleaned prewashed ready to go so if you called the kernel and say hey i need you to map please map some some pages of memory for me how many were let's say	system	140
two hundred thousand bytes then we can say hey that's great you know what we already have some memory ready to go so just allocating some memory to your process	memory	95
ok well how about we lie how about we use copy on write so also known as the tabakow c o w copy on write ok so here's what we could do let's make use of the virtual memory machinery to lie to our poor process so for example you asked for two hundred thousand bytes all zeroed out to be equal to zero i could cheat at this point and say this is what your address based looks like	memory	165
ok well how about we lie how about we use copy on write so also known as the tabakow c o w copy on write ok so here's what we could do let's make use of the virtual memory machinery to lie to our poor process so for example you asked for two hundred thousand bytes all zeroed out to be equal to zero i could cheat at this point and say this is what your address based looks like	address	354
is your regular virtual addresses in the order as lots of them and we can of course divide this into pages so here's where the big lie comes is that we could have a single page of ram	address	24
here is with some zeros in and now the big trick is to map this so that the different parts of the address space all mapped to the same piece of ram and my little processes will be none the wiser if they just simply look through all of these different addresses they will just see a lot of zeros even though in practice i set up my hardware so that it actually goes back to the same piece of main memory ok so that's a wonderful electric i actually only need a single page four kilobytes of memory and i can easily give you now two hundred thousand bytes of memory where is all been zeroed out just by playing this game with the mappings between virtual memory an actual physical memory so there is no cost to giving you memory that appears to all have been zeroed out	memory	397
here is with some zeros in and now the big trick is to map this so that the different parts of the address space all mapped to the same piece of ram and my little processes will be none the wiser if they just simply look through all of these different addresses they will just see a lot of zeros even though in practice i set up my hardware so that it actually goes back to the same piece of main memory ok so that's a wonderful electric i actually only need a single page four kilobytes of memory and i can easily give you now two hundred thousand bytes of memory where is all been zeroed out just by playing this game with the mappings between virtual memory an actual physical memory so there is no cost to giving you memory that appears to all have been zeroed out	address	99
it's only the moment that you attempt to change a single byte inside a particular memory do we actually have to do any work so the moment that you decide that you want to start writing site into this particular page here then i need to do a copy on write in other words let me find a new piece of ram here which initially is going to be all zeros and update my mapping scissors here there we go	memory	82
tennis is it off so that now this page points to its own piece of memory so now if you want to modify a little bite inside here you can without affecting anybody else but notice all of this stuff about duplicating and a cloning this first page so that copy on write is so right is possible that can actually happen after the colour calling malloc calls of occured that	memory	66
actually by causing a page fault when you attempt to modify a bite is only then do we change the mapping so that this new page now 'cause now is now going to be looking at a new piece of memory until that moment occurs we can just keep all of our pages looking at the same piece of memory which i think is pretty cool ok so that's kind of an idea about why we can in practice if you benchmark calloc and malloc you will often actually see similar performances because of all these kind of sophisticated tricks that are operating systems play on us behind the scenes alright i'll see you in the next video bye	a page	20
actually by causing a page fault when you attempt to modify a bite is only then do we change the mapping so that this new page now 'cause now is now going to be looking at a new piece of memory until that moment occurs we can just keep all of our pages looking at the same piece of memory which i think is pretty cool ok so that's kind of an idea about why we can in practice if you benchmark calloc and malloc you will often actually see similar performances because of all these kind of sophisticated tricks that are operating systems play on us behind the scenes alright i'll see you in the next video bye	memory	187
actually by causing a page fault when you attempt to modify a bite is only then do we change the mapping so that this new page now 'cause now is now going to be looking at a new piece of memory until that moment occurs we can just keep all of our pages looking at the same piece of memory which i think is pretty cool ok so that's kind of an idea about why we can in practice if you benchmark calloc and malloc you will often actually see similar performances because of all these kind of sophisticated tricks that are operating systems play on us behind the scenes alright i'll see you in the next video bye	system	529
and all the gardeners will agree on this order and agreed to acquire the tools in this order so perhaps will put them in the order can just be say their distance from the door right as you walk into the shed ok so if you need tools one two and three you will be acquiring one and then two and three if you need tools say two and four you'll be requiring two and then for if you need three in six and seven you'll be behind three six seven if you need tools say one four and six you'll be requiring one first and then four and then six so if all gardeners agree on this rank ordering and agree to acquire resources in this order it becomes impossible to set up a cycle you cannot end up with garden one waiting for gardner to who's waiting for gardner three who's waiting for gardner one ok so there's quite a bit of fun i invite you to come up with your own rules perhaps you're going to	resources	604
but later on will have a quick look at creating 'named pipes' where they actually exist in the file system right, so let's get started. okay, do i have a... great. o you know that we can do things like call write() and in fact when we call print f f print and f three def right etc underneath it all we're "talking to the kernel to say ""hey, i want to write to a" "particular file script."" ok so here's my file descriptor" and that is typically a small number say 0, 1, or 2 for standard in standard out instead of error and then if i start making files with fopen(), i'm going to have some more... 3, 4, 5, etc.	system	100
and we also will see these again when we actually wanted to make network code as well. so this will be the way that we send a bytes over the network say to a server or say back to the client. right but today we're going to use this with the pipe. so, i need a way to create a pipe and each my anonymous pipes have an input and output so that means they have two file descriptors, ok. so let me make a little array that's just enough space for two file descriptors ok, so there we go.	code	73
and right now these are initialized to anything but if i called pipe() then you can pass in the starting address at my two integers. ok that's easy. it's just fd	address	105
start writing some code. so i'll have my file descriptors	code	19
"ok and then we will say ""i need you please and here are" my integers better code would check this succeeds	code	78
kate dot slash i can't type this morning let's try again and look at that it's blocked yes so our course to read and write by default can block in other words they can take forever so in this case my reed call is waiting for bites to appear but it's a pipe and no ones written anything to those bites yet ok so let's write some bites so what do you think about the following let's write an remembering the right is the second file descriptor case so one and will say hello right and how many bytes do we want to send let's send one two three four five one two three	the following	361
kate dot slash i can't type this morning let's try again and look at that it's blocked yes so our course to read and write by default can block in other words they can take forever so in this case my reed call is waiting for bites to appear but it's a pipe and no ones written anything to those bites yet ok so let's write some bites so what do you think about the following let's write an remembering the right is the second file descriptor case so one and will say hello right and how many bytes do we want to send let's send one two three four five one two three	block	79
kate dot slash i can't type this morning let's try again and look at that it's blocked yes so our course to read and write by default can block in other words they can take forever so in this case my reed call is waiting for bites to appear but it's a pipe and no ones written anything to those bites yet ok so let's write some bites so what do you think about the following let's write an remembering the right is the second file descriptor case so one and will say hello right and how many bytes do we want to send let's send one two three four five one two three	type	23
k let's do it let's do six bytes and say hello in exclamation point but not the super bite at the end ok what do you think about that what's going to happen now ok so if i exit this and try to run it of course it's still blocked because my right call never returned my thread is still stuck inside here ok so what could i do what i could now make this a multithreaded program and execute my right order different thread all i could i don't want to fold that i or i could let's do my right early so let's let's put that	block	221
k let's do it let's do six bytes and say hello in exclamation point but not the super bite at the end ok what do you think about that what's going to happen now ok so if i exit this and try to run it of course it's still blocked because my right call never returned my thread is still stuck inside here ok so what could i do what i could now make this a multithreaded program and execute my right order different thread all i could i don't want to fold that i or i could let's do my right early so let's let's put that	thread	269
when we compile it ok you can see great we got back my read return dad it says ok i got by six bytes and of course if we wished we could print that out now it would be dangerous to treat it as a c string because there's no guarantee that a) they would get order those bytes in one go and b) we never even sent a zero byte so i'm just going to print it out directly using right today so if none read was at least positive integer let's actually display it right so i'm going to print it out to standard out and i want this kind of here's my buffer and here are the number of quite so we actually want to display ok so we're using lots of fire descriptors now we've sent hello down the pipe and eventually we get to read it ok so let's run this and prove that prints out hello ok great there it is my program is shufflings bites through a pipe we read it and then we display it. right but we can now actually use a pipe to communicate between different processes so let's take my write and do it inside a different process, ok. so for that i'm going to use fork so let's write pid and i want the chil. ok, so let's call fork and if my child is 0 then i know that i am the child! right and inside the child we will call the write and then will do nothing else ok let's immediately exit so we can return from maine	string	197
no it's still like that i've missed out a semi color somewhere i have that's my first error right with a different type	type	115
what you mean i can't read i can't write code this morning different character type	type	79
what you mean i can't read i can't write code this morning different character type	code	41
low level things to give me one of these c library file handles one of these file pointers ok so this makes the life little bit easier. we'll call it easy right because now i can use fprintf() so now i can say things like ok i want to...	printf	184
low level things to give me one of these c library file handles one of these file pointers ok so this makes the life little bit easier. we'll call it easy right because now i can use fprintf() so now i can say things like ok i want to...	pointer	82
"print out a number so ""print this following floating" "point number"" right or put it in scientific so say three" point one four one five nine right so i can say see the answer to life etc is ok. so now i can do formatted output more a little bit more easily. ok so there are some gotchas here however. we want to make sure that this output is flushed and just by putting a new line that's not enough if you're output is not going to a terminal, so remember with these things that it's best to call fflush() and in fact	a terminal	436
like code here so that we are now sending data that way right and in fact there's another kind of gotchas that now if you're using file handles with fork it's important to flush them so that's if we'd made our file handle before calling fork it's always important to make sure that we flushed anything. so do this on any input and output file handles tests are there we go. we'll flush it because we're calling fork	code	5
so now we've made our server file handle and we're going to call that right so let's run this and off we go after two seconds yeah great we get thirty characters back and then we send them back to the child ok so remember this trick that you can convert from a low level file descriptor to sea level four handle using fdopen() right that's enough for one video in the next video let's talk about when pipes go bad or rather what can we do when we actually wanted to close down the pipes and also pass we'll we'll see if we get a pipe to block as well ok that's it for this video see in the next one bye	block	537
hi so let's actually think about writing a version of get line will sketch it out here and i'll add the complete code to the repository there's some gnarly little points inside here so we've used get line a few times this is its signature where we have pointed to a point to remember an a pointer to a size variable so those were the variables that we had we called get line	code	113
hi so let's actually think about writing a version of get line will sketch it out here and i'll add the complete code to the repository there's some gnarly little points inside here so we've used get line a few times this is its signature where we have pointed to a point to remember an a pointer to a size variable so those were the variables that we had we called get line	pointer	289
we were passing in the address of all line and the address of our capacity right so the values which are actually going into get line or the memory locations of those two variables so just to be clear what we're doing is we're diving in to get line and pretending that we actually need to write this little function	memory	141
we were passing in the address of all line and the address of our capacity right so the values which are actually going into get line or the memory locations of those two variables so just to be clear what we're doing is we're diving in to get line and pretending that we actually need to write this little function	address	23
and we want to be able to keep reading characters until their normal characters to read all we hit a new line at which point great we can return but we have to be careful because our lines might be very long and actually the area of memory that were right into may not be sufficient ok so let's see how this solution is going to work here	memory	233
so i need a little sketches here great so the first thing we'll do is hey let's let's see if we bought any memory at all so we need an expression in here to say look looks like this is line point two and then have not been initialized so one way to write this might be for example look if star when is zero that's pretty useless there's	memory	107
nothing there ok so i better actually call malloc can make a note of that another would be to say look let me check the line pointer and see if actually that is equal to null so mistake would be to say the following	the following	202
nothing there ok so i better actually call malloc can make a note of that another would be to say look let me check the line pointer and see if actually that is equal to null so mistake would be to say the following	pointer	125
let's take what you gave me this kind of line pointer here and see if that is equal to zero why is that why is that incorrect	pointer	46
ok well hopefully with a little bit of thought you would have realized that are very variable inside here doesn't point to heap memory is actually pointing to that little variable that is on the outside that that is actually going to hold the result so that's not what we need we actually need to use that pointer there we go and actually follow it so if that is like looking at all then we know we have no heap memory to actually hold the result so we might wait that if we do actually end up calling malloc then i actually want to change that variable so again same idea it would be mistake just line pointer inside here yes that will change	heap memory	123
ok well hopefully with a little bit of thought you would have realized that are very variable inside here doesn't point to heap memory is actually pointing to that little variable that is on the outside that that is actually going to hold the result so that's not what we need we actually need to use that pointer there we go and actually follow it so if that is like looking at all then we know we have no heap memory to actually hold the result so we might wait that if we do actually end up calling malloc then i actually want to change that variable so again same idea it would be mistake just line pointer inside here yes that will change	memory	128
ok well hopefully with a little bit of thought you would have realized that are very variable inside here doesn't point to heap memory is actually pointing to that little variable that is on the outside that that is actually going to hold the result so that's not what we need we actually need to use that pointer there we go and actually follow it so if that is like looking at all then we know we have no heap memory to actually hold the result so we might wait that if we do actually end up calling malloc then i actually want to change that variable so again same idea it would be mistake just line pointer inside here yes that will change	pointer	306
my little my little variable here but that's not what you want change we actually want to write back into the callers code and change their variable so we need something like that	code	118
now it's actually twice starts trying to read some characters and the trick here is to know about the following is that i can actually read one character at a time and i can read it into a little integer variable and the reason to read it into an integer is the f get see will return a negative value if it fails	the following	98
code down here that says look after i've put that see value into storage then if it was a new line then it's time to break out of this code	code	0
kay break out of that loop but we also want to store that new line inside the result so let's always store the value of c inside area so we need to say something like ok hey line pointer i know that you are looking at	pointer	179
case of men heap queso dereference that little variable ok we're going to do that first after dereferencing it now great we've actually looking at the heap memory and that is where i can now start writing things in so let me now treat that as a way of bites and i can use my bites rate	heap memory	151
case of men heap queso dereference that little variable ok we're going to do that first after dereferencing it now great we've actually looking at the heap memory and that is where i can now start writing things in so let me now treat that as a way of bites and i can use my bites rate	memory	156
case of men heap queso dereference that little variable ok we're going to do that first after dereferencing it now great we've actually looking at the heap memory and that is where i can now start writing things in so let me now treat that as a way of bites and i can use my bites rate	the heap	147
to make sure i update that heat map in the right spot queso bites read i can use post increment after i finished writing into that little application i want bites read to be incremented i want and let's store the character that i've just read for my input stream and each time around the loop then efficacy is going to give me the next character from the input stream if i haven't typed anything there an f gets see or block it will wait until a new character is given to this process	the loop	284
to make sure i update that heat map in the right spot queso bites read i can use post increment after i finished writing into that little application i want bites read to be incremented i want and let's store the character that i've just read for my input stream and each time around the loop then efficacy is going to give me the next character from the input stream if i haven't typed anything there an f gets see or block it will wait until a new character is given to this process	block	419
to make sure i update that heat map in the right spot queso bites read i can use post increment after i finished writing into that little application i want bites read to be incremented i want and let's store the character that i've just read for my input stream and each time around the loop then efficacy is going to give me the next character from the input stream if i haven't typed anything there an f gets see or block it will wait until a new character is given to this process	type	381
for performance may not ask for just one bite it might say yeah guess what the c library has lots of space that's a full thousand six bytes or something for for a buffer area itself in order to make the code performance alright are we done now we've got a little bit more work here because it could be that the number of bytes we've read actually is going to exceed our buffer and we might write a code a bit like this we have to be a little bit careful however because we're going to need to return a c string so at the end of my code	code	203
for performance may not ask for just one bite it might say yeah guess what the c library has lots of space that's a full thousand six bytes or something for for a buffer area itself in order to make the code performance alright are we done now we've got a little bit more work here because it could be that the number of bytes we've read actually is going to exceed our buffer and we might write a code a bit like this we have to be a little bit careful however because we're going to need to return a c string so at the end of my code	string	504
kate is disappeared right anyway code that's the case i'm going to write it for real the enemy code you can get way there we go we've got one last thing to do which is we need to take my	code	33
i line pointer dereferences with now looking at the heap memory and then put a null byte at the end to ensure that what we return is a proper terminated c string so let me go bites weird and you would say	heap memory	52
i line pointer dereferences with now looking at the heap memory and then put a null byte at the end to ensure that what we return is a proper terminated c string so let me go bites weird and you would say	memory	57
i line pointer dereferences with now looking at the heap memory and then put a null byte at the end to ensure that what we return is a proper terminated c string so let me go bites weird and you would say	the heap	48
i line pointer dereferences with now looking at the heap memory and then put a null byte at the end to ensure that what we return is a proper terminated c string so let me go bites weird and you would say	string	155
i line pointer dereferences with now looking at the heap memory and then put a null byte at the end to ensure that what we return is a proper terminated c string so let me go bites weird and you would say	pointer	7
and there is no ip version five in existence that's being used today but there is a ip aversion six that is starting to be used more about that a little bit so i p four is an addressing scheme and it takes four bytes or more correctly if you want to talk to networking engineers four octets so four eight bit numbers so i pv four is a thirty two bit addressing scheme and the idea is that hey that should be enough everybody unfortunately today the number of people on this world is greater than two to the thirty two so we cannot have each individual address for each person	address	175
and of course each of us test came around more than one device today so this actually is not enough for everybody but back in when addressing was being considered we were worried about using too many octets too many bytes to represent addresses were worried about the overhead of making our address based too large so if there's one thing i wish we could change and vince cerf agrees we here	address	131
is that i wish that our earlier address schemes had decided to use a bigger address space for our network packets then just just the thirty two bits so today these thirty two bits are described as octets so an octet is just eight bits so if i can spell out text correctly i think we need another see inside their octets and so when we talk about addresses such as this one hundred and twenty seven point zero point zero point one	address	32
i'm actually describing four octets here and so this is just a four numbers each number is going to be between zero and two hundred and fifty five because each number refers to eight bits and this particular address here hundred and twenty seven point zero point zero point one is a very special address it is no place like home this is equivalent to localhost if you start creating network packets that are destined for this address you can be sure that they will never leave your machine with lots of virtual machine or physical machine this address is special it actually means the current host or the localhost ok so if we create packets with this destination they're not going anywhere that actually targeting the current machine so next time you meet hacker why don't you suggest that they actually try to hack this specific address so back to ip four	address	208
by before then is an address protocol when we want to talk about	address	21
where to send internet packets and these packets themselves could be based using carrier pigeons that it could be based on electrical pulses that could be using light pulses ip four doesn't work at the level of describing exactly how we're going to send this information rather it's an idea about how we want to communicate between two endpoints between two machines and so we can talk about our address game then as just a number thirty two bit 's ok and if we want to start sending packets then typically we're going to	address	396
describe then starting point and ending point so we'll have a source address and a destination address ok so we're already up to four bytes or let's be precise	address	69
right so this is ip four it's a very very simple idea of let's have a thirty two bits there's a little bit more to it we can actually start talking about address spaces within that you can talk about subnets etc and how we divide up this total address space of two to the thirty two possible addresses we can reserve different parts of it from i don't get there today instead i wanted to	address	154
ok so you've only got numbers between zero and two to the sixteen minus one possible port numbers and so port numbers will be a way to specify which application should be receiving this network packet so every time we set a network packet typically will have a source port and destination port as well so let me complete my little diagram in here ok so i've got the ip four address which is going to be made of eight octets for both the source and the destination and then i'm going to need a port number as well for the source and the destination	address	374
to our packets to allow us to stream information ok so we will look at the actual details of this at least some of the ideas of tcp where the protocol itself specifies a whole additional set of bytes octets	the protocol	138
in practice you'll say see people talk about tcp ip protocols because they're using ip say version four for their addressing and tcp in order to implement a pipe in order to be able to use read and write on the outside of this ok so just to kind of couple more points before we close this lecture today first of all can you program is listening on any port ok the answer is new so the ports less than a thousand and twenty four are called privileged ports so zero two thousand and twenty three thousand twenty three of what's called privileged ports and you need to have administrative access spell this correctly privileged ports	address	114
and so on a unix system that means you need to be running as root so	system	17
the idea here is that this gives us a hint to a client that if i'm connecting to a low numbered port so for example port eighty four unencrypted web access so i expect to be able to speak http to port eighty or for example how about connecting on port twenty three for ssh then this is a big hint that you're talking to a process that has at least root access so if we trust the machine	a process	320
ok so i'll port numbers themselves are specific to the protocol so if i'm talking about a tcp protocol then listening on port twenty three will be the ssh service so i can log in using ssd or if i'm listening on port eighty for http then i expect to be talking to a web server there's another kind of protocol that i briefly mentioned which is this udp protocol and udp is very rarely used	the protocol	51
does not behave like a stream so if i send a picture of my cat and i break it up into udp packets then u d pieces oh yeah ok today i got you another packet i got another package i've got another packet and you would have to write additional code to kind of re assemble these and look for duplicates and even look for missing packets so udp is useful for streaming information when we don't care about missing piece of information so for example suppose you are writing a game server and you're continuously sending out updates about where the characters the avatars have moved to you don't care about trying to reassemble these packets back into any kind of order because	code	241
ok so that's very quick introduction to some basic ideas from udp we talked about ip four it's the most common kind of packet you'll see today on the internet we talked about this special ip four address and we	address	196
hi welcome to lecture twenty so let's have a code review where we're going to talk about a little bit of code that uses condition variables are you ready ok so my little application is very simple it's just got two threads one thread some point is going to modify this value of x and then call signal another thread is waiting for x d b positive so we can think of this basically like a latch and only after it's become positive do we continue right so what do we think about this code	code	45
hi welcome to lecture twenty so let's have a code review where we're going to talk about a little bit of code that uses condition variables are you ready ok so my little application is very simple it's just got two threads one thread some point is going to modify this value of x and then call signal another thread is waiting for x d b positive so we can think of this basically like a latch and only after it's become positive do we continue right so what do we think about this code	thread	215
right so what do we notice first of all that my code over here on the right really does need a mutex lock before we change value of x and we signal ok let's see why the problem occurs is when we call change at the same time that our second thread is actually called in this wait for positive x let's see where the problem could occur	code	48
right so what do we notice first of all that my code over here on the right really does need a mutex lock before we change value of x and we signal ok let's see why the problem occurs is when we call change at the same time that our second thread is actually called in this wait for positive x let's see where the problem could occur	a mutex	93
right so what do we notice first of all that my code over here on the right really does need a mutex lock before we change value of x and we signal ok let's see why the problem occurs is when we call change at the same time that our second thread is actually called in this wait for positive x let's see where the problem could occur	thread	240
we've got this test here and then later maybe a few nanoseconds later but it might be a bit longer eventually by calling peter condition wait my thread is going to block so here's the problem scenario what if we had an interleaving of these operations such that changing the value of x here happens after this test	block	164
we've got this test here and then later maybe a few nanoseconds later but it might be a bit longer eventually by calling peter condition wait my thread is going to block so here's the problem scenario what if we had an interleaving of these operations such that changing the value of x here happens after this test	thread	145
and calling peter condition signal happens before the thread blocks and waits for signals ok so now what's happened our second thread is going to deadlock it's now waiting for a signal that is never going to happen	block	61
and calling peter condition signal happens before the thread blocks and waits for signals ok so now what's happened our second thread is going to deadlock it's now waiting for a signal that is never going to happen	thread	54
so right now yes we have a small opportunity a chance that our second thread will deadlock how do we fix it by locking on the same mutex because then the only way that you can continue is after the threat has acquired the mutex so another thread will have to wait so now if we do that it becomes impossible to be executing these two lines of code at the same time that these two lines are being executed	code	342
so right now yes we have a small opportunity a chance that our second thread will deadlock how do we fix it by locking on the same mutex because then the only way that you can continue is after the threat has acquired the mutex so another thread will have to wait so now if we do that it becomes impossible to be executing these two lines of code at the same time that these two lines are being executed	thread	70
right the second thing that we'd like to change is this if inside here so in practice this can bite you in two different ways first of all maybe in other applications you have multiple threads calling this and we really just want to ensure their x really is positive before we continue and other things may change value x the second problem with this code is the actual deep condition wait is occasionally may suffer from what's called a spurious wake up it never truly went to sleep ok	code	351
right the second thing that we'd like to change is this if inside here so in practice this can bite you in two different ways first of all maybe in other applications you have multiple threads calling this and we really just want to ensure their x really is positive before we continue and other things may change value x the second problem with this code is the actual deep condition wait is occasionally may suffer from what's called a spurious wake up it never truly went to sleep ok	thread	185
right so why does that occur well let's let's go back and talk about the implications for how conditioned weight is actually implemented right so we've just seen this problem of change in value of x and then signaling too early before they thread is actually blocking and waiting for that signal to arrive so in practice what does this mean it means that unlocking the mutex	block	259
right so why does that occur well let's let's go back and talk about the implications for how conditioned weight is actually implemented right so we've just seen this problem of change in value of x and then signaling too early before they thread is actually blocking and waiting for that signal to arrive so in practice what does this mean it means that unlocking the mutex	thread	240
blocking a waiting for that signal has to be it has to behave as if it is an a single atomic operation in other words there is no clock cycle no moment in time between between these two events otherwise the very same argument that we just gave hear about these two operations happening just within that now window would apply to all of our cause to p three condition wait ok so we have to ensure that these behave can instantaneously together now in practice that may be impossible there could be a very narrow window between when we unlock the window unlock the mutex and block so in practice if that may occur for example because i really do have multiple cpus running on different pieces of silicon then what will happen is rather than blocking forever rp threat condition variable instead will suffer a spurious wake up to say i'm sorry maybe i missed a single maybe it just happened so that is why we always need to write this using a while so that	block	0
we can only continue if condition is met in this case the taxes become positive ok right so that's it for code review in next video let's talk about life lock by	code	106
ok so let's think about how we can write a malloc so had we can might realloc right so the story so far we've been called with position to an old pointer and how much space they would now like k now let's get rid of one edge cases to begin with which is just if you read the man page of real ac one thing we have to think about is what if there is no current space in other words if old is null ok then our behavior should just be like we like malloc so let's do that let's just rely on malac to implement that force	pointer	146
let's think about what this means that if realloc is being called to say i actually i need so much space we better be careful that we don't copy in too many bytes into a new area so let's just kind of think about how this might go wrong let's write a really kind of simple implementation of real to begin with which always just copies to some new memory ok so we do something	memory	347
like the following here's a simple idea let's get malloc to do all the work flows will get we've already written are malloc linked list code that seems to be working so let's just rely on that ok so i'm going to say right my log get me some new space and i'm just going to copy everything across ok so this will be my my result and i want to copy some bites so we'll use mem copy into	the following	5
like the following here's a simple idea let's get malloc to do all the work flows will get we've already written are malloc linked list code that seems to be working so let's just rely on that ok so i'm going to say right my log get me some new space and i'm just going to copy everything across ok so this will be my my result and i want to copy some bites so we'll use mem copy into	code	136
what if their actual size was this new size was bigger than the old size then we've just copied a lot of bytes from the old location in fact we technically copied more bites than were necessary so maybe we should do here is to make sure we don't accidentally read from some invalid memory is we need a minimum size which is the minimum of the older than you ok so now we want to start thinking about the minimum size of	memory	282
number of bytes tiny i should be copying is going to be yes to new size and of the old size ok at this point we run into a snag i don't have the old size how are we going to get that right so somehow i need a way to get my linked list entry for that given so somehow i need to go from the old tube the linked list now i've shown you one way to do this before with three where we just walk through the linked list looking for their entry until we found one with until the pointer of the linked list the point of entry of that linked list data actually was equal to the user area but maybe we've actually made a decision to have a better performing malloc and free so that the metadata entry can be found in order one way maybe we've said that the metadata is directly before the user area ok so how would we write this code so for that here's what we'll do is let's play with pointer arithmetic let's have a look at that old pointer but first we're going to cast it to an entry type k so if we've got that there were not looking at the right spot yet but we know just before that we stored our metadata entries so great we found now the real data entry now are we sure about that well let's put in a few asserts ok so let's double check for example the pointer really is looking at what we expect let's check for example that the windows correspond to some memory that is has been taken its current year allocated right so now we've got that entry i can look at the old size so let's pull it out the old sizes entry	memory	1356
number of bytes tiny i should be copying is going to be yes to new size and of the old size ok at this point we run into a snag i don't have the old size how are we going to get that right so somehow i need a way to get my linked list entry for that given so somehow i need to go from the old tube the linked list now i've shown you one way to do this before with three where we just walk through the linked list looking for their entry until we found one with until the pointer of the linked list the point of entry of that linked list data actually was equal to the user area but maybe we've actually made a decision to have a better performing malloc and free so that the metadata entry can be found in order one way maybe we've said that the metadata is directly before the user area ok so how would we write this code so for that here's what we'll do is let's play with pointer arithmetic let's have a look at that old pointer but first we're going to cast it to an entry type k so if we've got that there were not looking at the right spot yet but we know just before that we stored our metadata entries so great we found now the real data entry now are we sure about that well let's put in a few asserts ok so let's double check for example the pointer really is looking at what we expect let's check for example that the windows correspond to some memory that is has been taken its current year allocated right so now we've got that entry i can look at the old size so let's pull it out the old sizes entry	type	977
number of bytes tiny i should be copying is going to be yes to new size and of the old size ok at this point we run into a snag i don't have the old size how are we going to get that right so somehow i need a way to get my linked list entry for that given so somehow i need to go from the old tube the linked list now i've shown you one way to do this before with three where we just walk through the linked list looking for their entry until we found one with until the pointer of the linked list the point of entry of that linked list data actually was equal to the user area but maybe we've actually made a decision to have a better performing malloc and free so that the metadata entry can be found in order one way maybe we've said that the metadata is directly before the user area ok so how would we write this code so for that here's what we'll do is let's play with pointer arithmetic let's have a look at that old pointer but first we're going to cast it to an entry type k so if we've got that there were not looking at the right spot yet but we know just before that we stored our metadata entries so great we found now the real data entry now are we sure about that well let's put in a few asserts ok so let's double check for example the pointer really is looking at what we expect let's check for example that the windows correspond to some memory that is has been taken its current year allocated right so now we've got that entry i can look at the old size so let's pull it out the old sizes entry	code	818
number of bytes tiny i should be copying is going to be yes to new size and of the old size ok at this point we run into a snag i don't have the old size how are we going to get that right so somehow i need a way to get my linked list entry for that given so somehow i need to go from the old tube the linked list now i've shown you one way to do this before with three where we just walk through the linked list looking for their entry until we found one with until the pointer of the linked list the point of entry of that linked list data actually was equal to the user area but maybe we've actually made a decision to have a better performing malloc and free so that the metadata entry can be found in order one way maybe we've said that the metadata is directly before the user area ok so how would we write this code so for that here's what we'll do is let's play with pointer arithmetic let's have a look at that old pointer but first we're going to cast it to an entry type k so if we've got that there were not looking at the right spot yet but we know just before that we stored our metadata entries so great we found now the real data entry now are we sure about that well let's put in a few asserts ok so let's double check for example the pointer really is looking at what we expect let's check for example that the windows correspond to some memory that is has been taken its current year allocated right so now we've got that entry i can look at the old size so let's pull it out the old sizes entry	pointer	471
and so now i can copy the right number of bytes which is great so it's going to be more performant if we only copy the correct number of bytes and we won't accidentally try to read or write into some invalid memory areas	memory	208
for example say things like if the actual old size which represents the maximum capacity if there is actually bigger than new size then hey there's no point getting a new block we can just keep you happy by by leaving you where you are ok i'm not going to update this size of my metadata entry based on what the user is asking for and just going to let them sit where they are so ok so 'cause remember the size in data entry actually corresponds to the capacity not necessarily how much to users truly using their so we said that there's no point using them ok so we're only going to move if that's not true if it is not enough space there are some other options that are high performance that are more performant version might might use for example perhaps it could be that rather than calling malloc to get some new memory maybe the apartment next to you so so here's a data that the users currently using maybe the piece of maybe next to you over here is actually available so there's nothing there nothing in that second block in which case maybe we time to do some block coalesce in here	memory	818
for example say things like if the actual old size which represents the maximum capacity if there is actually bigger than new size then hey there's no point getting a new block we can just keep you happy by by leaving you where you are ok i'm not going to update this size of my metadata entry based on what the user is asking for and just going to let them sit where they are so ok so 'cause remember the size in data entry actually corresponds to the capacity not necessarily how much to users truly using their so we said that there's no point using them ok so we're only going to move if that's not true if it is not enough space there are some other options that are high performance that are more performant version might might use for example perhaps it could be that rather than calling malloc to get some new memory maybe the apartment next to you so so here's a data that the users currently using maybe the piece of maybe next to you over here is actually available so there's nothing there nothing in that second block in which case maybe we time to do some block coalesce in here	block	171
we could change it so that our pointer in our own block rather than jumping to this one actually jumps to	block	50
we could change it so that our pointer in our own block rather than jumping to this one actually jumps to	pointer	31
its pointer to its next pointer and we get rid of that metadata entry and so now the user has all this extra space to expand into so we could do that now the possibility is imagine for a moment that we had	pointer	4
huge apartment here or say two megabytes but now we are lock has been called to say actually we only need a megabyte or any need half this space or even perhaps even smaller than that ok say i won't bother to move your data but now i've got all this wasted memory over here that is never going to be used you just told me that you want to shrink so maybe this space now is just wasted memory how could we deal with that but one thing we could do is do the opposite of my little diagram here which is that if you decided to the reality is being called an ascending is fifty percent of the space then or less then maybe it's time to put in a new metadata entry here and mark this entry this unused ram as available for future malloc requests if you start implementing things like that there's one little gotcha which is imagine that the amount of space that is going to be left is tiny so yes so user might be calling real octa say yeah i've decided that	memory	257
huge apartment here or say two megabytes but now we are lock has been called to say actually we only need a megabyte or any need half this space or even perhaps even smaller than that ok say i won't bother to move your data but now i've got all this wasted memory over here that is never going to be used you just told me that you want to shrink so maybe this space now is just wasted memory how could we deal with that but one thing we could do is do the opposite of my little diagram here which is that if you decided to the reality is being called an ascending is fifty percent of the space then or less then maybe it's time to put in a new metadata entry here and mark this entry this unused ram as available for future malloc requests if you start implementing things like that there's one little gotcha which is imagine that the amount of space that is going to be left is tiny so yes so user might be calling real octa say yeah i've decided that	a megabyte	106
and have any space left over actually be useful so don't start trying to carve up new blocks if the space is too small and that should be a parameter in your	block	86
and have any space left over actually be useful so don't start trying to carve up new blocks if the space is too small and that should be a parameter in your	parameter	140
in your model to see what kind of performances differences you can get if you decide to implement this so let's go back to our code and see what we have we've got the idea of there we go there we go we've got the idea of only using malloc if we truly need to we've got the idea of trying to not move data around unless we absolutely have to let's just try to kind of implement or sketch out then	code	127
we've got again clearly that the amount of space is being a lot smaller but less anybody would do anything if the difference is actually significant so perhaps like if the old size minus the new size is greater than some threshold so what would that threshold look like good question let's say a thousand and twenty four bytes right so i would if this is production code i would definitely put that into a variable ok so in which case now we know we've got some spare space arm it's at least as big as a metadata and even after that is going to be useful so what would we do at this point ok so here's the kind of wonderful thing is that i could make a pointer to any memory i want and declare this truck there so i can say ok this is my my new entry here and that will be where my existing data ends so what would that look like well it might look something like this what do you think about the following i've got the existing entry entry we're currently talking about and i just need to go to the end so that would be	the following	893
we've got again clearly that the amount of space is being a lot smaller but less anybody would do anything if the difference is actually significant so perhaps like if the old size minus the new size is greater than some threshold so what would that threshold look like good question let's say a thousand and twenty four bytes right so i would if this is production code i would definitely put that into a variable ok so in which case now we know we've got some spare space arm it's at least as big as a metadata and even after that is going to be useful so what would we do at this point ok so here's the kind of wonderful thing is that i could make a pointer to any memory i want and declare this truck there so i can say ok this is my my new entry here and that will be where my existing data ends so what would that look like well it might look something like this what do you think about the following i've got the existing entry entry we're currently talking about and i just need to go to the end so that would be	memory	668
we've got again clearly that the amount of space is being a lot smaller but less anybody would do anything if the difference is actually significant so perhaps like if the old size minus the new size is greater than some threshold so what would that threshold look like good question let's say a thousand and twenty four bytes right so i would if this is production code i would definitely put that into a variable ok so in which case now we know we've got some spare space arm it's at least as big as a metadata and even after that is going to be useful so what would we do at this point ok so here's the kind of wonderful thing is that i could make a pointer to any memory i want and declare this truck there so i can say ok this is my my new entry here and that will be where my existing data ends so what would that look like well it might look something like this what do you think about the following i've got the existing entry entry we're currently talking about and i just need to go to the end so that would be	code	366
we've got again clearly that the amount of space is being a lot smaller but less anybody would do anything if the difference is actually significant so perhaps like if the old size minus the new size is greater than some threshold so what would that threshold look like good question let's say a thousand and twenty four bytes right so i would if this is production code i would definitely put that into a variable ok so in which case now we know we've got some spare space arm it's at least as big as a metadata and even after that is going to be useful so what would we do at this point ok so here's the kind of wonderful thing is that i could make a pointer to any memory i want and declare this truck there so i can say ok this is my my new entry here and that will be where my existing data ends so what would that look like well it might look something like this what do you think about the following i've got the existing entry entry we're currently talking about and i just need to go to the end so that would be	pointer	653
ok that is going to be just knew size ok right whoops this is a great example of forgetting about pointer arithmetic the type here is not a void pointer it's pointer to one of these entry struts so i'm not adding just one i'm adding a very large number here but this is in bytes so what's the address i've just calculated here will be incorrect and my program will crash and do exciting and unexpected and undefined things whoopsie just from doing simple better points with matich so be very careful of that kind of stuff but anyway let's sketch out what we might do here so i now have a idea of where i want to put a new entry now set this up so i do things like ok this needs to point	type	121
ok that is going to be just knew size ok right whoops this is a great example of forgetting about pointer arithmetic the type here is not a void pointer it's pointer to one of these entry struts so i'm not adding just one i'm adding a very large number here but this is in bytes so what's the address i've just calculated here will be incorrect and my program will crash and do exciting and unexpected and undefined things whoopsie just from doing simple better points with matich so be very careful of that kind of stuff but anyway let's sketch out what we might do here so i now have a idea of where i want to put a new entry now set this up so i do things like ok this needs to point	address	293
ok that is going to be just knew size ok right whoops this is a great example of forgetting about pointer arithmetic the type here is not a void pointer it's pointer to one of these entry struts so i'm not adding just one i'm adding a very large number here but this is in bytes so what's the address i've just calculated here will be incorrect and my program will crash and do exciting and unexpected and undefined things whoopsie just from doing simple better points with matich so be very careful of that kind of stuff but anyway let's sketch out what we might do here so i now have a idea of where i want to put a new entry now set this up so i do things like ok this needs to point	pointer	98
the pointer here needs to point to where the start of the user entry will be so we know that will be a new entry plus one and this time i'm actually getting pointer arithmetic correct it's going to be a new entry which represents available bites so let's remember to do that and the last thing in my struct is to say ok its size and its next so let's be able to do everything also this how big it is ok so now i need to do some calculation that is going to be things like gnu size minus old size minus size of the entry space that we have ok this is	pointer	4
last thing is what about the next pointers so i want it to look at where my current entry is looking so you can look at me and my entry will look at you so let's update my entry next pointer to	pointer	34
new entry so great now i've inserted it into my linked list chain ok there are other ways to calculate the size you can do differences are two pointers if you do that as usual remember to always be working with void pointers or character pointers void pointers you're not supposed to do pointer arithmetic on but in practice all modern c compilers will support that	pointer	143
okie right so we scared out some ideas here as you can see it's kind of tricky to keep everything in mind you have to keep very clear idea about what your data structures look going to look like in memory and don't make any mistakes with pointer arithmetic so get it working first with a simple idea and then proceed slowly as you try to kind of optimize your code when things are working make sure you commit your code so you've always got something to go back to and also as a way to be able to discover early on when you've made a breaking change rather than writing hundreds of lines of code and they're wondering where the error was so so test early and test often alright where that asks you in the next video bye	memory	198
okie right so we scared out some ideas here as you can see it's kind of tricky to keep everything in mind you have to keep very clear idea about what your data structures look going to look like in memory and don't make any mistakes with pointer arithmetic so get it working first with a simple idea and then proceed slowly as you try to kind of optimize your code when things are working make sure you commit your code so you've always got something to go back to and also as a way to be able to discover early on when you've made a breaking change rather than writing hundreds of lines of code and they're wondering where the error was so so test early and test often alright where that asks you in the next video bye	a struct	158
okie right so we scared out some ideas here as you can see it's kind of tricky to keep everything in mind you have to keep very clear idea about what your data structures look going to look like in memory and don't make any mistakes with pointer arithmetic so get it working first with a simple idea and then proceed slowly as you try to kind of optimize your code when things are working make sure you commit your code so you've always got something to go back to and also as a way to be able to discover early on when you've made a breaking change rather than writing hundreds of lines of code and they're wondering where the error was so so test early and test often alright where that asks you in the next video bye	code	360
okie right so we scared out some ideas here as you can see it's kind of tricky to keep everything in mind you have to keep very clear idea about what your data structures look going to look like in memory and don't make any mistakes with pointer arithmetic so get it working first with a simple idea and then proceed slowly as you try to kind of optimize your code when things are working make sure you commit your code so you've always got something to go back to and also as a way to be able to discover early on when you've made a breaking change rather than writing hundreds of lines of code and they're wondering where the error was so so test early and test often alright where that asks you in the next video bye	pointer	238
ok hi right so question three we've got a lot of different pieces of memory inside our process each time it once we need some memory to hold of global variables are stack variables so actually look at that in action right so here is some crazy code that we wrote this is actually going to illustrate some of these ideas right so what do we have do i have a little ok great so the first thing is i've got a little variable up here called global do i have i'm in text mode let's go to squiggly line mode ok yeah ok	memory	69
ok hi right so question three we've got a lot of different pieces of memory inside our process each time it once we need some memory to hold of global variables are stack variables so actually look at that in action right so here is some crazy code that we wrote this is actually going to illustrate some of these ideas right so what do we have do i have a little ok great so the first thing is i've got a little variable up here called global do i have i'm in text mode let's go to squiggly line mode ok yeah ok	code	244
ok good alright so i got available here called global now globals are dangerous and great at the same time in the sense that i once you declare a global you can use it anywhere else in the code below so they really have global scope so that's not great engineering if we want to make all of our variables global in scope it means that our code comes out kind of complex and fragile but it's not unusual to have say one or two global variables which might represents a debug flag or something like that and you'll see the lot in very simple and small programs	code	189
process it's not in a heap is not in the stack it's inside his own kind of memory segment and there you can either have been an issue value of zero or if we wish inside our code we can course initialize them to a value right	memory	75
process it's not in a heap is not in the stack it's inside his own kind of memory segment and there you can either have been an issue value of zero or if we wish inside our code we can course initialize them to a value right	code	173
so the next thing to look at is what about our constants here and the code right so also in our process we have something called the text segment that's going to hold	code	70
the code itself so the instructions required for this cpu or those bites that the cpu is going to interpret	code	4
as instructions in terms of changing registers reading or writing from memory branches and conditionals etc etc etc etc all that has to live inside the process somewhere all of that has a memory address and that's all take segment and that is read only you try to write to that memory huh good luck trying you won't be able to on a modern cpu memory texture will kick in and your process will be kicked out so here's some examples of things were going to be stored inside the text segment and if we use the insider program then what do we get will actually what you get here is	memory	71
as instructions in terms of changing registers reading or writing from memory branches and conditionals etc etc etc etc all that has to live inside the process somewhere all of that has a memory address and that's all take segment and that is read only you try to write to that memory huh good luck trying you won't be able to on a modern cpu memory texture will kick in and your process will be kicked out so here's some examples of things were going to be stored inside the text segment and if we use the insider program then what do we get will actually what you get here is	address	195
is what you use inside the expression you get the memory address of the very first item ok so when we use these inside	memory	50
is what you use inside the expression you get the memory address of the very first item ok so when we use these inside	address	57
inside a little code here then a couple other things going to happen first of all let's look at t one t one is stored on the stack why it's an automatic variable that only exists whilst we are inside and running code inside test so we need a place in memory just a temporary hold automatic variables are little stack variables here and that includes parameters as well	memory	251
inside a little code here then a couple other things going to happen first of all let's look at t one t one is stored on the stack why it's an automatic variable that only exists whilst we are inside and running code inside test so we need a place in memory just a temporary hold automatic variables are little stack variables here and that includes parameters as well	parameter	350
inside a little code here then a couple other things going to happen first of all let's look at t one t one is stored on the stack why it's an automatic variable that only exists whilst we are inside and running code inside test so we need a place in memory just a temporary hold automatic variables are little stack variables here and that includes parameters as well	code	16
so what is t one and what's it doing what t one what does this type is a pointer to a character and otherwise it's going to hold a memory address and add that memory address we expect to find characters	memory	131
so what is t one and what's it doing what t one what does this type is a pointer to a character and otherwise it's going to hold a memory address and add that memory address we expect to find characters	type	63
so what is t one and what's it doing what t one what does this type is a pointer to a character and otherwise it's going to hold a memory address and add that memory address we expect to find characters	address	138
so what is t one and what's it doing what t one what does this type is a pointer to a character and otherwise it's going to hold a memory address and add that memory address we expect to find characters	pointer	73
right but we're giving it this string so actually t one is going to hold the memory dress of that age is going to point directly into the text segment is going to hold that memory address which between you and me is going to be a low value the text segment is it near the beginning of the processes memory now there's a surprise however with t two t two is not a pointer is actually an away we didn't bother to specify the size because the compiler can work that out itself and the surprise here is actually the compiler is going to write some extra code for us here because rather than just looking at that string	memory	77
right but we're giving it this string so actually t one is going to hold the memory dress of that age is going to point directly into the text segment is going to hold that memory address which between you and me is going to be a low value the text segment is it near the beginning of the processes memory now there's a surprise however with t two t two is not a pointer is actually an away we didn't bother to specify the size because the compiler can work that out itself and the surprise here is actually the compiler is going to write some extra code for us here because rather than just looking at that string	code	550
right but we're giving it this string so actually t one is going to hold the memory dress of that age is going to point directly into the text segment is going to hold that memory address which between you and me is going to be a low value the text segment is it near the beginning of the processes memory now there's a surprise however with t two t two is not a pointer is actually an away we didn't bother to specify the size because the compiler can work that out itself and the surprise here is actually the compiler is going to write some extra code for us here because rather than just looking at that string	string	31
right but we're giving it this string so actually t one is going to hold the memory dress of that age is going to point directly into the text segment is going to hold that memory address which between you and me is going to be a low value the text segment is it near the beginning of the processes memory now there's a surprise however with t two t two is not a pointer is actually an away we didn't bother to specify the size because the compiler can work that out itself and the surprise here is actually the compiler is going to write some extra code for us here because rather than just looking at that string	address	180
right but we're giving it this string so actually t one is going to hold the memory dress of that age is going to point directly into the text segment is going to hold that memory address which between you and me is going to be a low value the text segment is it near the beginning of the processes memory now there's a surprise however with t two t two is not a pointer is actually an away we didn't bother to specify the size because the compiler can work that out itself and the surprise here is actually the compiler is going to write some extra code for us here because rather than just looking at that string	pointer	363
literal in memory when we call this function it's actually going to copy those bikes it's going to copy the one two three four five six seven eight nine bytes including that zero bite at the end into the stack memory forwards so if i was to stop my process and actually use a debugger to have a look around i would find the original abcdefg h and then i try to copy of that inside the stack and the difference between the two of course is that the stack version we can modify	memory	11
its mutable because it's just stack memory so let's see what happens next right ok so the online seven	memory	36
we used t two and it looks like we're using as a pointer this is ok array variables behave a bit like pointers if you use them in a pointer context like this then the variable behave as if it's talking about the very first address of the array in other words we're looking at the very first element of the array in the stack itself	address	223
we used t two and it looks like we're using as a pointer this is ok array variables behave a bit like pointers if you use them in a pointer context like this then the variable behave as if it's talking about the very first address of the array in other words we're looking at the very first element of the array in the stack itself	pointer	49
four bytes ok so t one would hold the address of this first bite here and	address	38
so the difference between these is subtle but important that t one doesn't hold the string high instead it's a pointer and in this my little world here i'm working on a thirty two bit machine as you can see i used four bytes to hold the address of of t one so you've got to follow the money if you like you've got to actually go to that other address if you actually want to see those bytes h and i it's not going to be found directly inside the stack ok versus t two actually has	string	84
so the difference between these is subtle but important that t one doesn't hold the string high instead it's a pointer and in this my little world here i'm working on a thirty two bit machine as you can see i used four bytes to hold the address of of t one so you've got to follow the money if you like you've got to actually go to that other address if you actually want to see those bytes h and i it's not going to be found directly inside the stack ok versus t two actually has	address	237
so the difference between these is subtle but important that t one doesn't hold the string high instead it's a pointer and in this my little world here i'm working on a thirty two bit machine as you can see i used four bytes to hold the address of of t one so you've got to follow the money if you like you've got to actually go to that other address if you actually want to see those bytes h and i it's not going to be found directly inside the stack ok versus t two actually has	pointer	111
abc carpet into it ok and so on and so on and so on up to h and then one last bite for the zoo at the end and you'll notice i put my address is the highest at the top and the lowest at the bottom of the page	address	133
hello will you live seven we are going to change that first element of the rays so i'm actually changing by stack when we directly here and then line eight we do a calculation that says take two two so treat it as as an address add one to it and then dereference is follow the money the astrex here actually use that address so in other words changed a lowercase b that we put in there into an upper case b line nine actually does the same thing so these two lines are equivalent just different syntax as you can see a little bit nicer to use square brackets and remember though the square brackets means also right to those locations just as a fun thing actually if you want to confuse your cs two twenty five friends you could write this equivalently by swapping the two sites so you could also write one square bracket t two and that would compile as well so you could swap these around if you so in client wouldn't do that for real production code but it's great fun for confusing confusing people right now let's look at line tent line ten says ok take the address that t one holds and use it change was there but hold on yes a t one doesn't actually have their contents or so we are going to be a very unhappy here put my little fun smiley face because will try to follow the address that we stored inside t one which you pointing to some read only memory and we're not allowed to change that so the moment that you actually try to dereference this memory and actually write to it the cpu will notice and say well hold on let's stop the program anymore get a segmentation fault the last line here says if we actually got to this last last line hey malloc i need some heat memory and this is the number of bytes i'd like i'd like a hundred and twenty three and i promise not to invite extra bytes after that point and i promise not to try to write any bias before they start start of the place you give me so if it succeeds is actually going to turn an address and we can use that particular address	memory	1355
hello will you live seven we are going to change that first element of the rays so i'm actually changing by stack when we directly here and then line eight we do a calculation that says take two two so treat it as as an address add one to it and then dereference is follow the money the astrex here actually use that address so in other words changed a lowercase b that we put in there into an upper case b line nine actually does the same thing so these two lines are equivalent just different syntax as you can see a little bit nicer to use square brackets and remember though the square brackets means also right to those locations just as a fun thing actually if you want to confuse your cs two twenty five friends you could write this equivalently by swapping the two sites so you could also write one square bracket t two and that would compile as well so you could swap these around if you so in client wouldn't do that for real production code but it's great fun for confusing confusing people right now let's look at line tent line ten says ok take the address that t one holds and use it change was there but hold on yes a t one doesn't actually have their contents or so we are going to be a very unhappy here put my little fun smiley face because will try to follow the address that we stored inside t one which you pointing to some read only memory and we're not allowed to change that so the moment that you actually try to dereference this memory and actually write to it the cpu will notice and say well hold on let's stop the program anymore get a segmentation fault the last line here says if we actually got to this last last line hey malloc i need some heat memory and this is the number of bytes i'd like i'd like a hundred and twenty three and i promise not to invite extra bytes after that point and i promise not to try to write any bias before they start start of the place you give me so if it succeeds is actually going to turn an address and we can use that particular address	code	947
hello will you live seven we are going to change that first element of the rays so i'm actually changing by stack when we directly here and then line eight we do a calculation that says take two two so treat it as as an address add one to it and then dereference is follow the money the astrex here actually use that address so in other words changed a lowercase b that we put in there into an upper case b line nine actually does the same thing so these two lines are equivalent just different syntax as you can see a little bit nicer to use square brackets and remember though the square brackets means also right to those locations just as a fun thing actually if you want to confuse your cs two twenty five friends you could write this equivalently by swapping the two sites so you could also write one square bracket t two and that would compile as well so you could swap these around if you so in client wouldn't do that for real production code but it's great fun for confusing confusing people right now let's look at line tent line ten says ok take the address that t one holds and use it change was there but hold on yes a t one doesn't actually have their contents or so we are going to be a very unhappy here put my little fun smiley face because will try to follow the address that we stored inside t one which you pointing to some read only memory and we're not allowed to change that so the moment that you actually try to dereference this memory and actually write to it the cpu will notice and say well hold on let's stop the program anymore get a segmentation fault the last line here says if we actually got to this last last line hey malloc i need some heat memory and this is the number of bytes i'd like i'd like a hundred and twenty three and i promise not to invite extra bytes after that point and i promise not to try to write any bias before they start start of the place you give me so if it succeeds is actually going to turn an address and we can use that particular address	address	220
and that address up to one hundred and twenty two for whatever we want to do maybe we want to store some integers in there maybe will store the little picture whatever we want to do maybe want to still a long string i don't know malloc doesn't care or ballot noses it's assigned a given that memory and promises not to give anybody else that that same piece of memory until the day that we say ok i'm done with this and how do i say i'm done with this i call free and i pass back the same	memory	292
and that address up to one hundred and twenty two for whatever we want to do maybe we want to store some integers in there maybe will store the little picture whatever we want to do maybe want to still a long string i don't know malloc doesn't care or ballot noses it's assigned a given that memory and promises not to give anybody else that that same piece of memory until the day that we say ok i'm done with this and how do i say i'm done with this i call free and i pass back the same	string	209
and that address up to one hundred and twenty two for whatever we want to do maybe we want to store some integers in there maybe will store the little picture whatever we want to do maybe want to still a long string i don't know malloc doesn't care or ballot noses it's assigned a given that memory and promises not to give anybody else that that same piece of memory until the day that we say ok i'm done with this and how do i say i'm done with this i call free and i pass back the same	address	9
well stop drawing right pass back the same the same address that we got originally from malloc so i call free with t one	address	52
ok so our code will fail at line ten the only way that we could start this code from failing at line ten would be if we swapped lines ten eleven because this is what we can do with pointers with pointers you can say hey pointer pointer something else and so if we swap those two lines around by calling malloc first we would have changed t one to now point to some brand new memory to some heap memory and we could have set that very first bite to an agent but we would not have created a string because of h of to be a c string would have to also have a zero bite after it and malik doesn't guarantee as anything about the memory that we actually get with that i'll see you next video for further next question by	heap memory	390
ok so our code will fail at line ten the only way that we could start this code from failing at line ten would be if we swapped lines ten eleven because this is what we can do with pointers with pointers you can say hey pointer pointer something else and so if we swap those two lines around by calling malloc first we would have changed t one to now point to some brand new memory to some heap memory and we could have set that very first bite to an agent but we would not have created a string because of h of to be a c string would have to also have a zero bite after it and malik doesn't guarantee as anything about the memory that we actually get with that i'll see you next video for further next question by	memory	375
ok so our code will fail at line ten the only way that we could start this code from failing at line ten would be if we swapped lines ten eleven because this is what we can do with pointers with pointers you can say hey pointer pointer something else and so if we swap those two lines around by calling malloc first we would have changed t one to now point to some brand new memory to some heap memory and we could have set that very first bite to an agent but we would not have created a string because of h of to be a c string would have to also have a zero bite after it and malik doesn't guarantee as anything about the memory that we actually get with that i'll see you next video for further next question by	code	10
ok so our code will fail at line ten the only way that we could start this code from failing at line ten would be if we swapped lines ten eleven because this is what we can do with pointers with pointers you can say hey pointer pointer something else and so if we swap those two lines around by calling malloc first we would have changed t one to now point to some brand new memory to some heap memory and we could have set that very first bite to an agent but we would not have created a string because of h of to be a c string would have to also have a zero bite after it and malik doesn't guarantee as anything about the memory that we actually get with that i'll see you next video for further next question by	string	489
ok so our code will fail at line ten the only way that we could start this code from failing at line ten would be if we swapped lines ten eleven because this is what we can do with pointers with pointers you can say hey pointer pointer something else and so if we swap those two lines around by calling malloc first we would have changed t one to now point to some brand new memory to some heap memory and we could have set that very first bite to an agent but we would not have created a string because of h of to be a c string would have to also have a zero bite after it and malik doesn't guarantee as anything about the memory that we actually get with that i'll see you next video for further next question by	pointer	181
hi so we're going to start looking at a wonderful library called pthreads now pthreads has been a while around for quite awhile it's extremely portable	thread	66
that you have other alternatives today for example c plus plus has its own thread primitives c now has its own thread primitives however there not as versatile as the p thread versions and they're not configurable anna not as portable so today if i was to start a new project and i really want to make sure that i could tweet	thread	75
things for example how much stack space that particular thread might need my first choice today would be p threads so that's what we're going to look at it's also the standard part of posix it's also found in many many projects so yes whilst i encourage you to maybe look at what's currently do with it's new it's new threading libraries there are relatively new and p threads are still holds the throne as as the most important and most valuable anyway so off we go right so let's have a look at the threats	thread	56
ok so there's several things we want to be able to do we want to be able to create a new thread of execution and when we do that is very different from folk when we do this we want to be able to say ok start running from here so for example i might want to say right in the background i want to start running a thread that is going to mine bitcoin so please i'm going to have a function called mind for example i'm going to use your spare cpu and i don't care about the environment and i'm not paying for electricity that kind of thing obviously don't do this all the university machine but i want to be able to say ok peter head start on my function called mine right now i wouldn't actually write mine like this because this means coal mine instead i need the address of my function and surprisingly if you just give the name of a function then that is actually that actually says ok where is this function or another one perhaps i've got a function which is going to download something in the background so maybe i've got a function called to know download update or does something else useful for me in in the background ok so then i'm just need to somehow to say hey system i've got this function please assign a new cpu to this function and start running it and that's the purpose of pthread create so this creates a new thread and for this we're going to pass in a function where we wanted to start for so it be very strange to say please start from maine instead we're going to write our own function and that's where we'll start ok so how do you then wait for that function to finish for example suppose i had a function that rendered a manageable picture or found me a bitcoin now i want to wait for that to finish before continuing ok so here's how we can do this we can call p thread join	a thread	309
ok so there's several things we want to be able to do we want to be able to create a new thread of execution and when we do that is very different from folk when we do this we want to be able to say ok start running from here so for example i might want to say right in the background i want to start running a thread that is going to mine bitcoin so please i'm going to have a function called mind for example i'm going to use your spare cpu and i don't care about the environment and i'm not paying for electricity that kind of thing obviously don't do this all the university machine but i want to be able to say ok peter head start on my function called mine right now i wouldn't actually write mine like this because this means coal mine instead i need the address of my function and surprisingly if you just give the name of a function then that is actually that actually says ok where is this function or another one perhaps i've got a function which is going to download something in the background so maybe i've got a function called to know download update or does something else useful for me in in the background ok so then i'm just need to somehow to say hey system i've got this function please assign a new cpu to this function and start running it and that's the purpose of pthread create so this creates a new thread and for this we're going to pass in a function where we wanted to start for so it be very strange to say please start from maine instead we're going to write our own function and that's where we'll start ok so how do you then wait for that function to finish for example suppose i had a function that rendered a manageable picture or found me a bitcoin now i want to wait for that to finish before continuing ok so here's how we can do this we can call p thread join	thread	89
ok so there's several things we want to be able to do we want to be able to create a new thread of execution and when we do that is very different from folk when we do this we want to be able to say ok start running from here so for example i might want to say right in the background i want to start running a thread that is going to mine bitcoin so please i'm going to have a function called mind for example i'm going to use your spare cpu and i don't care about the environment and i'm not paying for electricity that kind of thing obviously don't do this all the university machine but i want to be able to say ok peter head start on my function called mine right now i wouldn't actually write mine like this because this means coal mine instead i need the address of my function and surprisingly if you just give the name of a function then that is actually that actually says ok where is this function or another one perhaps i've got a function which is going to download something in the background so maybe i've got a function called to know download update or does something else useful for me in in the background ok so then i'm just need to somehow to say hey system i've got this function please assign a new cpu to this function and start running it and that's the purpose of pthread create so this creates a new thread and for this we're going to pass in a function where we wanted to start for so it be very strange to say please start from maine instead we're going to write our own function and that's where we'll start ok so how do you then wait for that function to finish for example suppose i had a function that rendered a manageable picture or found me a bitcoin now i want to wait for that to finish before continuing ok so here's how we can do this we can call p thread join	background	274
ok so there's several things we want to be able to do we want to be able to create a new thread of execution and when we do that is very different from folk when we do this we want to be able to say ok start running from here so for example i might want to say right in the background i want to start running a thread that is going to mine bitcoin so please i'm going to have a function called mind for example i'm going to use your spare cpu and i don't care about the environment and i'm not paying for electricity that kind of thing obviously don't do this all the university machine but i want to be able to say ok peter head start on my function called mine right now i wouldn't actually write mine like this because this means coal mine instead i need the address of my function and surprisingly if you just give the name of a function then that is actually that actually says ok where is this function or another one perhaps i've got a function which is going to download something in the background so maybe i've got a function called to know download update or does something else useful for me in in the background ok so then i'm just need to somehow to say hey system i've got this function please assign a new cpu to this function and start running it and that's the purpose of pthread create so this creates a new thread and for this we're going to pass in a function where we wanted to start for so it be very strange to say please start from maine instead we're going to write our own function and that's where we'll start ok so how do you then wait for that function to finish for example suppose i had a function that rendered a manageable picture or found me a bitcoin now i want to wait for that to finish before continuing ok so here's how we can do this we can call p thread join	address	762
ok so there's several things we want to be able to do we want to be able to create a new thread of execution and when we do that is very different from folk when we do this we want to be able to say ok start running from here so for example i might want to say right in the background i want to start running a thread that is going to mine bitcoin so please i'm going to have a function called mind for example i'm going to use your spare cpu and i don't care about the environment and i'm not paying for electricity that kind of thing obviously don't do this all the university machine but i want to be able to say ok peter head start on my function called mine right now i wouldn't actually write mine like this because this means coal mine instead i need the address of my function and surprisingly if you just give the name of a function then that is actually that actually says ok where is this function or another one perhaps i've got a function which is going to download something in the background so maybe i've got a function called to know download update or does something else useful for me in in the background ok so then i'm just need to somehow to say hey system i've got this function please assign a new cpu to this function and start running it and that's the purpose of pthread create so this creates a new thread and for this we're going to pass in a function where we wanted to start for so it be very strange to say please start from maine instead we're going to write our own function and that's where we'll start ok so how do you then wait for that function to finish for example suppose i had a function that rendered a manageable picture or found me a bitcoin now i want to wait for that to finish before continuing ok so here's how we can do this we can call p thread join	system	1172
so join is the idea that hey i've been running along let me do it let me do this where time goes to the right so my main functions been started and then i call pay through it creates so at the same time now and you function starts and it's running along doing a calculation but at some point it finishes ok so now we want to make sure that in our main thread we don't continue until we're sure that other functions finished so we would call p thread joint here	thread	352
ok and now i'm not going to continue until that is true so so in my first or diagram here my new thread finished early but we could imagine separate scenario where it keeps on running took a lot longer to find a bitcoin this time ok so now nothing is going to happen until	thread	97
the threads i'm joining on has finished as quick and then i can continue so please join can block right meeting that hey the cpu is no it is not going to do anything on my program for potentially along time and in fact the colonel will give that cpu to another thread that would like to run or tell that can't cpu core to shut down and go into low power mode ok so pthread can take a long time right now how do we say if we actually inside a thread hey i'm done i don't want to do anymore ok so for this we need to say i'd like to exit please so : pthread_exit right so the peace road exit is the last thing your thread will ever do there is no return from p thread exit it's done your cpu causes ok i'm going to wash my hands of this thread i know that there's nothing else is going to happen so p thread exit is a one way ticket do not try to execute anymore code after p calling p thread exit right so if i've got my little function let's call it say mine to continue that silly idea at some point i wanted to quit so i would call p thread exit by the way if you return from that function in other words if there's no more stack frames then that is equivalent of calling p thread exit so i might have some code in here this might call other functions called air from that cause g and that cause premier fanatic or something else etc it opens files whatever	block	92
the threads i'm joining on has finished as quick and then i can continue so please join can block right meeting that hey the cpu is no it is not going to do anything on my program for potentially along time and in fact the colonel will give that cpu to another thread that would like to run or tell that can't cpu core to shut down and go into low power mode ok so pthread can take a long time right now how do we say if we actually inside a thread hey i'm done i don't want to do anymore ok so for this we need to say i'd like to exit please so : pthread_exit right so the peace road exit is the last thing your thread will ever do there is no return from p thread exit it's done your cpu causes ok i'm going to wash my hands of this thread i know that there's nothing else is going to happen so p thread exit is a one way ticket do not try to execute anymore code after p calling p thread exit right so if i've got my little function let's call it say mine to continue that silly idea at some point i wanted to quit so i would call p thread exit by the way if you return from that function in other words if there's no more stack frames then that is equivalent of calling p thread exit so i might have some code in here this might call other functions called air from that cause g and that cause premier fanatic or something else etc it opens files whatever	code	861
the threads i'm joining on has finished as quick and then i can continue so please join can block right meeting that hey the cpu is no it is not going to do anything on my program for potentially along time and in fact the colonel will give that cpu to another thread that would like to run or tell that can't cpu core to shut down and go into low power mode ok so pthread can take a long time right now how do we say if we actually inside a thread hey i'm done i don't want to do anymore ok so for this we need to say i'd like to exit please so : pthread_exit right so the peace road exit is the last thing your thread will ever do there is no return from p thread exit it's done your cpu causes ok i'm going to wash my hands of this thread i know that there's nothing else is going to happen so p thread exit is a one way ticket do not try to execute anymore code after p calling p thread exit right so if i've got my little function let's call it say mine to continue that silly idea at some point i wanted to quit so i would call p thread exit by the way if you return from that function in other words if there's no more stack frames then that is equivalent of calling p thread exit so i might have some code in here this might call other functions called air from that cause g and that cause premier fanatic or something else etc it opens files whatever	a thread	440
the threads i'm joining on has finished as quick and then i can continue so please join can block right meeting that hey the cpu is no it is not going to do anything on my program for potentially along time and in fact the colonel will give that cpu to another thread that would like to run or tell that can't cpu core to shut down and go into low power mode ok so pthread can take a long time right now how do we say if we actually inside a thread hey i'm done i don't want to do anymore ok so for this we need to say i'd like to exit please so : pthread_exit right so the peace road exit is the last thing your thread will ever do there is no return from p thread exit it's done your cpu causes ok i'm going to wash my hands of this thread i know that there's nothing else is going to happen so p thread exit is a one way ticket do not try to execute anymore code after p calling p thread exit right so if i've got my little function let's call it say mine to continue that silly idea at some point i wanted to quit so i would call p thread exit by the way if you return from that function in other words if there's no more stack frames then that is equivalent of calling p thread exit so i might have some code in here this might call other functions called air from that cause g and that cause premier fanatic or something else etc it opens files whatever	thread	4
but eventually if any of these called p thread exit	thread	40
then all we return from here that thread is done ok so there's a bit of a kind of mind moment here that i want you to realize that now we write code on a page but it's important to think about which thread is actually running that code and of course by default you get one thread for free you get one thread that starts up in all of your programs which executes maine	a page	152
then all we return from here that thread is done ok so there's a bit of a kind of mind moment here that i want you to realize that now we write code on a page but it's important to think about which thread is actually running that code and of course by default you get one thread for free you get one thread that starts up in all of your programs which executes maine	code	144
then all we return from here that thread is done ok so there's a bit of a kind of mind moment here that i want you to realize that now we write code on a page but it's important to think about which thread is actually running that code and of course by default you get one thread for free you get one thread that starts up in all of your programs which executes maine	thread	34
and it's up to us then to create additional threads when we want them so and just like	thread	44
rp for example when we return from maine we also finished out thread however the one exciting piece of news is when you return from maine that kills that's the end of your process that's the equivalent to calling exit not p thread exit but process exit and when we do that everything disappears all of your other threads disappear ok so i think it's time for a demo soon but first of all let's actually kind of have a look how we can use p thread and  detangle this ok so let's have a look at what the manpage tells us and we'll see the following kind of thing so let me for example take care p thread exit	the following	533
rp for example when we return from maine we also finished out thread however the one exciting piece of news is when you return from maine that kills that's the end of your process that's the equivalent to calling exit not p thread exit but process exit and when we do that everything disappears all of your other threads disappear ok so i think it's time for a demo soon but first of all let's actually kind of have a look how we can use p thread and  detangle this ok so let's have a look at what the manpage tells us and we'll see the following kind of thing so let me for example take care p thread exit	thread	62
and type it into man page ok so man p thread x copy so it creates do that one ok and we see the following ok right and we can read about this and we can see that all sorts of wonderful things ok do i have a little	the following	92
and type it into man page ok so man p thread x copy so it creates do that one ok and we see the following ok right and we can read about this and we can see that all sorts of wonderful things ok do i have a little	type	4
and type it into man page ok so man p thread x copy so it creates do that one ok and we see the following ok right and we can read about this and we can see that all sorts of wonderful things ok do i have a little	thread	38
shiny thing here ok great i do alright so what do i have i take full things eight pointer to this type i another pointed some attributes so we're not going to use these attributes inside cs two forty one but here's where we can say things like you know this thread might do a lot of recursion i need a lot of stack space and then this really gnarly looking voidstar starve start routine voidstar let's talk about that in a moment and then finally avoid points are to arg yes we got a pirate amongst us ok so let's talk about this lot ok let's just get back to my slides here right so i've	type	98
shiny thing here ok great i do alright so what do i have i take full things eight pointer to this type i another pointed some attributes so we're not going to use these attributes inside cs two forty one but here's where we can say things like you know this thread might do a lot of recursion i need a lot of stack space and then this really gnarly looking voidstar starve start routine voidstar let's talk about that in a moment and then finally avoid points are to arg yes we got a pirate amongst us ok so let's talk about this lot ok let's just get back to my slides here right so i've	thread	258
shiny thing here ok great i do alright so what do i have i take full things eight pointer to this type i another pointed some attributes so we're not going to use these attributes inside cs two forty one but here's where we can say things like you know this thread might do a lot of recursion i need a lot of stack space and then this really gnarly looking voidstar starve start routine voidstar let's talk about that in a moment and then finally avoid points are to arg yes we got a pirate amongst us ok so let's talk about this lot ok let's just get back to my slides here right so i've	pointer	82
i want to i want to talk about this nasty thing this start routine part here ok so we need a way to say to the cpu hey please start running this particular function and the kind of function that peter supports is something that takes a void pointer and returns a void pointer so hopefully this is no longer looking quite so so gnarly right so we can see this returning a void pointer and takes a void pointer it still looks pretty awful and that's because it's a they function definition in c so let's talk about that when you want to talk about pointers to functions first of all just write down what kind of just imagine you were writing down the function declaration so for example suppose i wanted a function that we turned a double	pointer	241
right so that's my function declaration how can i now create pointers that points to these kinds of functions let's have a different color ok	pointer	61
wait so here's a trick it's not hard at all so all we have to do is put an asterix before the name and surround that with parentheses so now you can read these things right now you can see oh you want to talk about pointers to functions and the kind of functions you care or once we take a double and return a double and that's exactly what we have here for a start routine we want to talk about functions that take a void pointer and return a void pointer now the taking and returning avoid pointers p thread doesn't actually care about those values they are for our benefits and in fact when we say hey colonel please start my other function for me on a new cpu core i want to be able to pass something into the start routine	thread	503
wait so here's a trick it's not hard at all so all we have to do is put an asterix before the name and surround that with parentheses so now you can read these things right now you can see oh you want to talk about pointers to functions and the kind of functions you care or once we take a double and return a double and that's exactly what we have here for a start routine we want to talk about functions that take a void pointer and return a void pointer now the taking and returning avoid pointers p thread doesn't actually care about those values they are for our benefits and in fact when we say hey colonel please start my other function for me on a new cpu core i want to be able to pass something into the start routine	pointer	215
so that's actually going to be the purpose of this fourth argument for pthread create basically you're handing over a pointer to say when the cpu finally starts my mining function or whatever it's going to be	thread	72
so that's actually going to be the purpose of this fourth argument for pthread create basically you're handing over a pointer to say when the cpu finally starts my mining function or whatever it's going to be	pointer	118
give them this value as their parameter so eventually when our start routine actually start so we don't know when that might be it might be the milliseconds time or it might be practically instantaneous but at some point in the future they we know that the function takes a void pointer and so this is the value would like to pass in ok and the return value that is going to be the exit value from the function so if the thread never calls p thread exit its return value will be the threads exit value ok so let's go and actually kind of demos demonstrate this now right so i need a little bit of a program ok so here we go right here's my very first program this time we actually use the exit success rather than saying return zero you don't need to wait for me to type that ok so how can i now do things with with threats so i need of course the preferred library so let me include that hash include	type	766
give them this value as their parameter so eventually when our start routine actually start so we don't know when that might be it might be the milliseconds time or it might be practically instantaneous but at some point in the future they we know that the function takes a void pointer and so this is the value would like to pass in ok and the return value that is going to be the exit value from the function so if the thread never calls p thread exit its return value will be the threads exit value ok so let's go and actually kind of demos demonstrate this now right so i need a little bit of a program ok so here we go right here's my very first program this time we actually use the exit success rather than saying return zero you don't need to wait for me to type that ok so how can i now do things with with threats so i need of course the preferred library so let me include that hash include	parameter	30
give them this value as their parameter so eventually when our start routine actually start so we don't know when that might be it might be the milliseconds time or it might be practically instantaneous but at some point in the future they we know that the function takes a void pointer and so this is the value would like to pass in ok and the return value that is going to be the exit value from the function so if the thread never calls p thread exit its return value will be the threads exit value ok so let's go and actually kind of demos demonstrate this now right so i need a little bit of a program ok so here we go right here's my very first program this time we actually use the exit success rather than saying return zero you don't need to wait for me to type that ok so how can i now do things with with threats so i need of course the preferred library so let me include that hash include	thread	421
give them this value as their parameter so eventually when our start routine actually start so we don't know when that might be it might be the milliseconds time or it might be practically instantaneous but at some point in the future they we know that the function takes a void pointer and so this is the value would like to pass in ok and the return value that is going to be the exit value from the function so if the thread never calls p thread exit its return value will be the threads exit value ok so let's go and actually kind of demos demonstrate this now right so i need a little bit of a program ok so here we go right here's my very first program this time we actually use the exit success rather than saying return zero you don't need to wait for me to type that ok so how can i now do things with with threats so i need of course the preferred library so let me include that hash include	pointer	279
p thread to h i get that from the band page now let me have something which actually runs separately ok	thread	2
i know it has to return a void pointer and i will call it let's say hello alright and key and we know it takes a void pointer right so what should my little program do i will make my little thread wanna do a big calculation yeah i'll get it to just call sleep for a second ok and then we'll get it to say something so how about we call printf from here and we can say right hello what	printf	336
i know it has to return a void pointer and i will call it let's say hello alright and key and we know it takes a void pointer right so what should my little program do i will make my little thread wanna do a big calculation yeah i'll get it to just call sleep for a second ok and then we'll get it to say something so how about we call printf from here and we can say right hello what	thread	190
i know it has to return a void pointer and i will call it let's say hello alright and key and we know it takes a void pointer right so what should my little program do i will make my little thread wanna do a big calculation yeah i'll get it to just call sleep for a second ok and then we'll get it to say something so how about we call printf from here and we can say right hello what	pointer	31
so now we need to make it to to finish what should we do ok we got two options here they're both equivalent i can either return something from here so i could return say null alternatively i can call p thread	thread	202
and it's important to bear in mind that anything else any other threads that are running will continue to exit it's just that one thread that happens to be running this hello code ok right so we could now start to kind of create create our threads here so let's do p thread create and at this point i need to give it a pointer to a thread id so i need the address of my little variable here will make that in a moment the next thing is the attributes and i don't need any of those	code	175
and it's important to bear in mind that anything else any other threads that are running will continue to exit it's just that one thread that happens to be running this hello code ok right so we could now start to kind of create create our threads here so let's do p thread create and at this point i need to give it a pointer to a thread id so i need the address of my little variable here will make that in a moment the next thing is the attributes and i don't need any of those	a thread	330
and it's important to bear in mind that anything else any other threads that are running will continue to exit it's just that one thread that happens to be running this hello code ok right so we could now start to kind of create create our threads here so let's do p thread create and at this point i need to give it a pointer to a thread id so i need the address of my little variable here will make that in a moment the next thing is the attributes and i don't need any of those	thread	64
and it's important to bear in mind that anything else any other threads that are running will continue to exit it's just that one thread that happens to be running this hello code ok right so we could now start to kind of create create our threads here so let's do p thread create and at this point i need to give it a pointer to a thread id so i need the address of my little variable here will make that in a moment the next thing is the attributes and i don't need any of those	address	356
and it's important to bear in mind that anything else any other threads that are running will continue to exit it's just that one thread that happens to be running this hello code ok right so we could now start to kind of create create our threads here so let's do p thread create and at this point i need to give it a pointer to a thread id so i need the address of my little variable here will make that in a moment the next thing is the attributes and i don't need any of those	pointer	319
wait is that the way we rounded let's check yet the attributes yet and now we need the function pointer the address of my function that likely to start ok so i could just type hello it is actually possible to it ampersand hello and the c compiler just ignores the ten percent so that's hello hello parentheses otherwise you'll be evaluating you'll be calling hello on the main thread and that's not what we want we actually just want the address of a function ok and what would we like to pass into hello	type	171
wait is that the way we rounded let's check yet the attributes yet and now we need the function pointer the address of my function that likely to start ok so i could just type hello it is actually possible to it ampersand hello and the c compiler just ignores the ten percent so that's hello hello parentheses otherwise you'll be evaluating you'll be calling hello on the main thread and that's not what we want we actually just want the address of a function ok and what would we like to pass into hello	thread	377
wait is that the way we rounded let's check yet the attributes yet and now we need the function pointer the address of my function that likely to start ok so i could just type hello it is actually possible to it ampersand hello and the c compiler just ignores the ten percent so that's hello hello parentheses otherwise you'll be evaluating you'll be calling hello on the main thread and that's not what we want we actually just want the address of a function ok and what would we like to pass into hello	address	108
wait is that the way we rounded let's check yet the attributes yet and now we need the function pointer the address of my function that likely to start ok so i could just type hello it is actually possible to it ampersand hello and the c compiler just ignores the ten percent so that's hello hello parentheses otherwise you'll be evaluating you'll be calling hello on the main thread and that's not what we want we actually just want the address of a function ok and what would we like to pass into hello	pointer	96
how about a banana ok right so remember was not going to do that is going to take the address of this string literal i could also do it like the following i could say that i've got some pointer here and for it pointer	the following	141
how about a banana ok right so remember was not going to do that is going to take the address of this string literal i could also do it like the following i could say that i've got some pointer here and for it pointer	string	102
how about a banana ok right so remember was not going to do that is going to take the address of this string literal i could also do it like the following i could say that i've got some pointer here and for it pointer	address	86
how about a banana ok right so remember was not going to do that is going to take the address of this string literal i could also do it like the following i could say that i've got some pointer here and for it pointer	pointer	186
and i could come up with an address like dead beef or i could say use this string there we go and that of course will be the very first with the address of the first bite in my string literal ok so let's run that and see if you can guess what's going to happen ok so let's let's start this	string	75
and i could come up with an address like dead beef or i could say use this string there we go and that of course will be the very first with the address of the first bite in my string literal ok so let's run that and see if you can guess what's going to happen ok so let's let's start this	address	28
and will try to compile it ok so i call it p thread demo	thread	45
see i'm not quite that thread demo gcc thread demo ok an important idea here is we need to give a hint to the compiler that we're now going to work with threads so for example any calls to malloc and printf should be thread safe meaning we don't want to program just crash in surprising ways just because two threads called malik at the same time so we want to say hey	printf	200
see i'm not quite that thread demo gcc thread demo ok an important idea here is we need to give a hint to the compiler that we're now going to work with threads so for example any calls to malloc and printf should be thread safe meaning we don't want to program just crash in surprising ways just because two threads called malik at the same time so we want to say hey	thread	23
gcc please realize from using p threads so there's actually an option for that is like a p three p threads i have to check it yes ok so let's do that right now we've got some warnings going on here we didn't invite declare sleep so let's fix that and let's fix our thread id ok so we need an argument here we need to include uni standard for sleep ok and what was our last issue oh yes that id so i need available for that third	thread	32
he thread on his guilty and i call that tid ok wait oh it come puzzles are you ready let's run it and we get nothing are you surprised let's have a look why do you think we got nothing	thread	3
ok so what we actually have here is a race condition we asked the people i be to start a new thread but before it had a chance to actually print anything out so those are sleeping second here it was going to be executing this then it was going to be exiting what are their main thread do our main thread immediately returned from maine at that point our program our process exits and threats live inside a process let me say it again they live inside a process so that's really important idea without the process without there's no memory there's no files threads have nowhere to exist ok so we think about it as memory and now we're co opting a whole load of cpus to come and work on our program together	memory	532
ok so what we actually have here is a race condition we asked the people i be to start a new thread but before it had a chance to actually print anything out so those are sleeping second here it was going to be executing this then it was going to be exiting what are their main thread do our main thread immediately returned from maine at that point our program our process exits and threats live inside a process let me say it again they live inside a process so that's really important idea without the process without there's no memory there's no files threads have nowhere to exist ok so we think about it as memory and now we're co opting a whole load of cpus to come and work on our program together	a process	404
ok so what we actually have here is a race condition we asked the people i be to start a new thread but before it had a chance to actually print anything out so those are sleeping second here it was going to be executing this then it was going to be exiting what are their main thread do our main thread immediately returned from maine at that point our program our process exits and threats live inside a process let me say it again they live inside a process so that's really important idea without the process without there's no memory there's no files threads have nowhere to exist ok so we think about it as memory and now we're co opting a whole load of cpus to come and work on our program together	thread	93
say two cpus on my my machine then the operating system lies to us it gives it it plays a game where we pretend that we've got an infinite number of cpus versus really in fact what you have is like a a short order cook that is able to quickly work on one job and then go and work over here and then go and work over here and if we keep switching what that cook is working on fast enough say every millisecond or every ten milliseconds you'll never know really there's just one cook in the kitchen ok so let's let's fix this by waiting around for its ok so will say sleep for two seconds here right and now let's run it and	system	49
ok all look at the one second it printed hello right ok can we prove that we really are doing two things at the same time sure how about i create another thread ok so let's have two thread i ds here through an id to	thread	154
right so let's pass in less actually start to use this value here so rather than just saying hello here let me have a screen ok where should i get that string form remember this argument i've got here well that points to some memory and you and i know that at that memory is a secret message so let me have a pointer now a character pointed to do that for me to then using my code k right so i could now just start writing the normal code i have and ok let's run this	memory	226
right so let's pass in less actually start to use this value here so rather than just saying hello here let me have a screen ok where should i get that string form remember this argument i've got here well that points to some memory and you and i know that at that memory is a secret message so let me have a pointer now a character pointed to do that for me to then using my code k right so i could now just start writing the normal code i have and ok let's run this	code	376
right so let's pass in less actually start to use this value here so rather than just saying hello here let me have a screen ok where should i get that string form remember this argument i've got here well that points to some memory and you and i know that at that memory is a secret message so let me have a pointer now a character pointed to do that for me to then using my code k right so i could now just start writing the normal code i have and ok let's run this	string	152
right so let's pass in less actually start to use this value here so rather than just saying hello here let me have a screen ok where should i get that string form remember this argument i've got here well that points to some memory and you and i know that at that memory is a secret message so let me have a pointer now a character pointed to do that for me to then using my code k right so i could now just start writing the normal code i have and ok let's run this	pointer	309
but maybe if we were running on a busy system where there isn't a cpu immediately available for that first thread you can imagine that the tomato line actually gets printed out first so great we're using pizza create and many programs unfortunately in the world today will work by accident so the fact that our happened to run because we happen to be waiting long enough doesn't give me a nice warm fuzzy feeling inside but unfortunately today many programs real programs in development and actually in production i have little delay loops in an attempt to it to make sure that they work right but as a ui uc student i hope you can do better than this so let's actually now do a better job in this sleeping for two seconds we want to make sure that we wait for both of these threads to actually finish so how can we do that ok so let's do pizza hut join on right and now i need to say the	thread	107
but maybe if we were running on a busy system where there isn't a cpu immediately available for that first thread you can imagine that the tomato line actually gets printed out first so great we're using pizza create and many programs unfortunately in the world today will work by accident so the fact that our happened to run because we happen to be waiting long enough doesn't give me a nice warm fuzzy feeling inside but unfortunately today many programs real programs in development and actually in production i have little delay loops in an attempt to it to make sure that they work right but as a ui uc student i hope you can do better than this so let's actually now do a better job in this sleeping for two seconds we want to make sure that we wait for both of these threads to actually finish so how can we do that ok so let's do pizza hut join on right and now i need to say the	system	39
on the thread that i want to join about so i'm going to wait for third one ok and i need a k return value on and	thread	7
i'm going to have another thread to quit ok so	thread	26
let's have a look at p thread joint and p thread	thread	23
join and you'll see it takes a pointer to a pointer to avoid star ok so	pointer	31
the idea here is that we actually give it some memory	memory	47
that is going to write into so here's my voice dial pointer	pointer	52
ok and we want the address of these variables because they're going to be changed ok so just to kind of see that they're being changed let's dump actually look at their values so i can say things like	address	19
printf right return	printf	0
and so we can now will only print out return value after both these threads have finished ok so let's	thread	68
but i want you to treat it as a memory address and we don't care what's there so the type is just void ok so let's compile that	memory	32
but i want you to treat it as a memory address and we don't care what's there so the type is just void ok so let's compile that	type	85
but i want you to treat it as a memory address and we don't care what's there so the type is just void ok so let's compile that	address	39
ok after one second they both finish what return value one is zero what did we do ok so see void pointer	pointer	97
wait oh because yes do you see why ok we never got to return statement yes my p three at exit took away my thread never to return ok so now let's prove that dead code here right so i better spelled that code as a hexadecimal value ok so let's let's see if if we can make these things do different things so for example that we take a look at my message i'm just care about the first character if that first character is eighty because it's tomato i wanted to run down here ok wait so let's run this now ok clear	code	162
wait oh because yes do you see why ok we never got to return statement yes my p three at exit took away my thread never to return ok so now let's prove that dead code here right so i better spelled that code as a hexadecimal value ok so let's let's see if if we can make these things do different things so for example that we take a look at my message i'm just care about the first character if that first character is eighty because it's tomato i wanted to run down here ok wait so let's run this now ok clear	thread	107
ok so after one second great now we have a return value of dead beef and if i was to look at the other one we would see dead code so that last part of our demo right case so return value two is ok there ok right	code	125
so one thing i hope i persuaded you is that yeah we got deadbeef here and dead code there ok so one thing i hope i persuaded you is that we really are doing two things at the same time i've got one thread over here	code	79
so one thing i hope i persuaded you is that yeah we got deadbeef here and dead code there ok so one thing i hope i persuaded you is that we really are doing two things at the same time i've got one thread over here	thread	198
calling functions printf and all that kind of stuff independently because it has its own stack its own thread of execution so that thread has his own variable called message and there's another thread with a different stack with ok so different part of memory that takes a different argument an runs to a different sort of execution is going to end up in p thread exit so just kind of prove that these variables are living in different places let's actually print out the address of my local variable here so my message is at let's actually look at the address of	memory	253
calling functions printf and all that kind of stuff independently because it has its own stack its own thread of execution so that thread has his own variable called message and there's another thread with a different stack with ok so different part of memory that takes a different argument an runs to a different sort of execution is going to end up in p thread exit so just kind of prove that these variables are living in different places let's actually print out the address of my local variable here so my message is at let's actually look at the address of	printf	18
calling functions printf and all that kind of stuff independently because it has its own stack its own thread of execution so that thread has his own variable called message and there's another thread with a different stack with ok so different part of memory that takes a different argument an runs to a different sort of execution is going to end up in p thread exit so just kind of prove that these variables are living in different places let's actually print out the address of my local variable here so my message is at let's actually look at the address of	thread	103
calling functions printf and all that kind of stuff independently because it has its own stack its own thread of execution so that thread has his own variable called message and there's another thread with a different stack with ok so different part of memory that takes a different argument an runs to a different sort of execution is going to end up in p thread exit so just kind of prove that these variables are living in different places let's actually print out the address of my local variable here so my message is at let's actually look at the address of	address	472
just to make our life a little bit saner let's put some new lines in here as well ok so now we're going to look to see where is my message to get a feel for where the stack is of these different different threads ok so let's clear this compile it ok	thread	205
right and you'll see that they live in different areas and if if we did a bit of math we could actually figure out how spaced apart they are and first impressions are is that they're actually not that they're not spaced apart that much actually so be careful just how much recursion we do on these threads	thread	298
values while np thread joint there is one common culture	thread	16
and let's make a typo here so some common typos are the only time you need to take the address of a thread id is at the beginning here so in all the cases all other cases we need its value	a thread	98
and let's make a typo here so some common typos are the only time you need to take the address of a thread id is at the beginning here so in all the cases all other cases we need its value	thread	100
and let's make a typo here so some common typos are the only time you need to take the address of a thread id is at the beginning here so in all the cases all other cases we need its value	address	87
because my i'm not waiting now on on a valid thread id and in fact the behaviors can be worse than that it can crash for example right so be very very careful if you're just copying pasting this kind of code much much better to have raise	code	203
because my i'm not waiting now on on a valid thread id and in fact the behaviors can be worse than that it can crash for example right so be very very careful if you're just copying pasting this kind of code much much better to have raise	thread	45
and and and be very careful about about typos when you copy paste code alright so we've made our first program that can run two things at the same time in fact is doing three things at the same time we've got our original thread that's going to get stuck at these two places these two gatekeepers the only way you can get through both is after both threads have finished and we had two threads running hello we could have made it more complicated example where we started another thread starting on yeah or different function altogether ok the big news however is to all of these threads live inside the same address space they can all see the same physical ram if you had one thread that was like agent smith that wanted to go haywire it could actually overwrite the other pieces of memory of the other threads in an effort to take over the world ok right so i'll see you in the next video bye	memory	784
and and and be very careful about about typos when you copy paste code alright so we've made our first program that can run two things at the same time in fact is doing three things at the same time we've got our original thread that's going to get stuck at these two places these two gatekeepers the only way you can get through both is after both threads have finished and we had two threads running hello we could have made it more complicated example where we started another thread starting on yeah or different function altogether ok the big news however is to all of these threads live inside the same address space they can all see the same physical ram if you had one thread that was like agent smith that wanted to go haywire it could actually overwrite the other pieces of memory of the other threads in an effort to take over the world ok right so i'll see you in the next video bye	code	66
and and and be very careful about about typos when you copy paste code alright so we've made our first program that can run two things at the same time in fact is doing three things at the same time we've got our original thread that's going to get stuck at these two places these two gatekeepers the only way you can get through both is after both threads have finished and we had two threads running hello we could have made it more complicated example where we started another thread starting on yeah or different function altogether ok the big news however is to all of these threads live inside the same address space they can all see the same physical ram if you had one thread that was like agent smith that wanted to go haywire it could actually overwrite the other pieces of memory of the other threads in an effort to take over the world ok right so i'll see you in the next video bye	thread	222
and and and be very careful about about typos when you copy paste code alright so we've made our first program that can run two things at the same time in fact is doing three things at the same time we've got our original thread that's going to get stuck at these two places these two gatekeepers the only way you can get through both is after both threads have finished and we had two threads running hello we could have made it more complicated example where we started another thread starting on yeah or different function altogether ok the big news however is to all of these threads live inside the same address space they can all see the same physical ram if you had one thread that was like agent smith that wanted to go haywire it could actually overwrite the other pieces of memory of the other threads in an effort to take over the world ok right so i'll see you in the next video bye	address	609
hi welcome to lecture twelve ok so let's get started i've got a little challenge for you take a look at this code and here's the challenge is we want to figure out where in memory will you find some memory that actually is mapped this see variable here ok so let's say analyzes code and see what we can see right so we're going to have looks like three new threads created	memory	173
hi welcome to lecture twelve ok so let's get started i've got a little challenge for you take a look at this code and here's the challenge is we want to figure out where in memory will you find some memory that actually is mapped this see variable here ok so let's say analyzes code and see what we can see right so we're going to have looks like three new threads created	code	109
hi welcome to lecture twelve ok so let's get started i've got a little challenge for you take a look at this code and here's the challenge is we want to figure out where in memory will you find some memory that actually is mapped this see variable here ok so let's say analyzes code and see what we can see right so we're going to have looks like three new threads created	thread	357
and inside my main method i'm going to have an array of these thread i ds ok so it looks like we need to fill in some code here right so what should be right here we need something to to create it thread so let's see if i can get myself a	code	118
and inside my main method i'm going to have an array of these thread i ds ok so it looks like we need to fill in some code here right so what should be right here we need something to to create it thread so let's see if i can get myself a	thread	62
p thread creates and now we need an address to store the thread id so pthread create is going to write into our memory so remember i could write something like and td ampersand td bracket but there's no point we can just say hey treat this as the tid as the starting	memory	112
p thread creates and now we need an address to store the thread id so pthread create is going to write into our memory so remember i could write something like and td ampersand td bracket but there's no point we can just say hey treat this as the tid as the starting	thread	2
p thread creates and now we need an address to store the thread id so pthread create is going to write into our memory so remember i could write something like and td ampersand td bracket but there's no point we can just say hey treat this as the tid as the starting	address	36
address of the array and i want an offset of i right next we need to do we have any attributes and what function do we want to call ok so we don't have any special things we want to do with this stack today but we do want to tell peter create where the other	address	0
cpu should start ok so we would like to start at this function called start ok so why is it that we don't call my little recursive function directly ok so here's an idea where you've already got a function that you'd like to use but remember p thread create only lights to start functions which take avoid parameter and return avoid parameter so what i've done is just a rap my reekers function where they are very simple wrapper this piece of gift wrapping here that doesn't doesn't care about the parameter and is only job is to actually delegate all the work to this recurse function	parameter	306
cpu should start ok so we would like to start at this function called start ok so why is it that we don't call my little recursive function directly ok so here's an idea where you've already got a function that you'd like to use but remember p thread create only lights to start functions which take avoid parameter and return avoid parameter so what i've done is just a rap my reekers function where they are very simple wrapper this piece of gift wrapping here that doesn't doesn't care about the parameter and is only job is to actually delegate all the work to this recurse function	thread	244
ok so we're going to call start and that's the last thing is the parameter value that is going to be passed in when we do finally get round to starting a new thread will go in here so that null is going to be the value of this pointer if i'd said something else like an address of a variable again that void pointer would have taken that address ok so great we're starting three threads and then after that loop we're going to call it p thread exit and as you know what does p thread exit do is the point of no return it's the one way ticket to oblivion for my poor little thread and in this case i'm doing it on the main thread which means that we will never return from this call that's the end of the line for this cpu here executing the main thread which means of course we won't actually return from maine which means that we won't exit the process at that point so instead my process is going to continue until all my other threads are completed	parameter	65
ok so we're going to call start and that's the last thing is the parameter value that is going to be passed in when we do finally get round to starting a new thread will go in here so that null is going to be the value of this pointer if i'd said something else like an address of a variable again that void pointer would have taken that address ok so great we're starting three threads and then after that loop we're going to call it p thread exit and as you know what does p thread exit do is the point of no return it's the one way ticket to oblivion for my poor little thread and in this case i'm doing it on the main thread which means that we will never return from this call that's the end of the line for this cpu here executing the main thread which means of course we won't actually return from maine which means that we won't exit the process at that point so instead my process is going to continue until all my other threads are completed	thread	158
ok so we're going to call start and that's the last thing is the parameter value that is going to be passed in when we do finally get round to starting a new thread will go in here so that null is going to be the value of this pointer if i'd said something else like an address of a variable again that void pointer would have taken that address ok so great we're starting three threads and then after that loop we're going to call it p thread exit and as you know what does p thread exit do is the point of no return it's the one way ticket to oblivion for my poor little thread and in this case i'm doing it on the main thread which means that we will never return from this call that's the end of the line for this cpu here executing the main thread which means of course we won't actually return from maine which means that we won't exit the process at that point so instead my process is going to continue until all my other threads are completed	address	270
ok so we're going to call start and that's the last thing is the parameter value that is going to be passed in when we do finally get round to starting a new thread will go in here so that null is going to be the value of this pointer if i'd said something else like an address of a variable again that void pointer would have taken that address ok so great we're starting three threads and then after that loop we're going to call it p thread exit and as you know what does p thread exit do is the point of no return it's the one way ticket to oblivion for my poor little thread and in this case i'm doing it on the main thread which means that we will never return from this call that's the end of the line for this cpu here executing the main thread which means of course we won't actually return from maine which means that we won't exit the process at that point so instead my process is going to continue until all my other threads are completed	pointer	227
ok so right what do we do inside recurse three well inside because three we have a little stack variable here called c o increment its value and then providing the parameter value was greater than one we call ourselves again with parameter minus one ok so my question again is can you sketch in memory where there are these values of c where you find them ok i'll give you ten seconds to think about that maybe have ago it actually sketching it would you expect to see	memory	295
ok so right what do we do inside recurse three well inside because three we have a little stack variable here called c o increment its value and then providing the parameter value was greater than one we call ourselves again with parameter minus one ok so my question again is can you sketch in memory where there are these values of c where you find them ok i'll give you ten seconds to think about that maybe have ago it actually sketching it would you expect to see	parameter	164
ok right so remember each thread has its own stack so we've got the main stack or sort of the main thread there's nothing in there that we care about the array for my tds but we're not going to find any values of c in there and then we have this stack of the very first thread that we create so let's put this down a bit here k we've got one stack frame associated with start	thread	26
in theory that might be that parameter ptr if we were passing that by memory	memory	70
in theory that might be that parameter ptr if we were passing that by memory	parameter	29
also in this space we have the return value for the process counter for the for the pc but now i've got another stack frame where i've created another value of c k which is initially ten and i change that two eleven and then i make another recursive call ok so let's just keep track of the parameter values when i first called it my property value is three that would be in memory inside it all inside register cpu register and then we make a call it with value of two ok and finally we we call my little recursive function	memory	374
also in this space we have the return value for the process counter for the for the pc but now i've got another stack frame where i've created another value of c k which is initially ten and i change that two eleven and then i make another recursive call ok so let's just keep track of the parameter values when i first called it my property value is three that would be in memory inside it all inside register cpu register and then we make a call it with value of two ok and finally we we call my little recursive function	parameter	290
with one case i've got another value of c inside here which is ten and then change to eleven ok are we done no that was just for one thread ok so this is kind of the big important idea that's the whole point of this example is that we're looking at the stack of just one thread here but in fact we're going to start three threads so we have the same picture again for the second thread that we start and these could all be running independently so in fact i'm going to see the value of c nine times so we saw it three here and we know we got three threads down here another three here and then lower down in memory another thread that we started and we're going to see the value of c a three more time so each of those us stack frames because we have recursive function i'm right so that's a lot of c values and hopefully i've got the point across that even though we've just written this once inside our code we might see it many times inside a memory but wait you say i happen to know something about compilers i mean i happen to know this is real tail recursion and the compiler could have optimized this to actually just be a loop it could have changed value program and just gone around the loop and run again so in fact i wouldn't actually be there in memory three times well yes you're correct you could also say but wait the compiler can notice that sees never actually used and so therefore it could optimize it out completely and therefore it won't be in memory at all and you'd be correct again so yes we have to be careful about where they were talking about what truly happens when we turn on all optimizations and what happens with our simple model of how we compile c code to running code with that we're going to skip into the next video where i talk now about more exciting example where actually going to start working on a real problem and we are going to kind of generate manderbach pictures using	optimizations	1610
with one case i've got another value of c inside here which is ten and then change to eleven ok are we done no that was just for one thread ok so this is kind of the big important idea that's the whole point of this example is that we're looking at the stack of just one thread here but in fact we're going to start three threads so we have the same picture again for the second thread that we start and these could all be running independently so in fact i'm going to see the value of c nine times so we saw it three here and we know we got three threads down here another three here and then lower down in memory another thread that we started and we're going to see the value of c a three more time so each of those us stack frames because we have recursive function i'm right so that's a lot of c values and hopefully i've got the point across that even though we've just written this once inside our code we might see it many times inside a memory but wait you say i happen to know something about compilers i mean i happen to know this is real tail recursion and the compiler could have optimized this to actually just be a loop it could have changed value program and just gone around the loop and run again so in fact i wouldn't actually be there in memory three times well yes you're correct you could also say but wait the compiler can notice that sees never actually used and so therefore it could optimize it out completely and therefore it won't be in memory at all and you'd be correct again so yes we have to be careful about where they were talking about what truly happens when we turn on all optimizations and what happens with our simple model of how we compile c code to running code with that we're going to skip into the next video where i talk now about more exciting example where actually going to start working on a real problem and we are going to kind of generate manderbach pictures using	the loop	1192
with one case i've got another value of c inside here which is ten and then change to eleven ok are we done no that was just for one thread ok so this is kind of the big important idea that's the whole point of this example is that we're looking at the stack of just one thread here but in fact we're going to start three threads so we have the same picture again for the second thread that we start and these could all be running independently so in fact i'm going to see the value of c nine times so we saw it three here and we know we got three threads down here another three here and then lower down in memory another thread that we started and we're going to see the value of c a three more time so each of those us stack frames because we have recursive function i'm right so that's a lot of c values and hopefully i've got the point across that even though we've just written this once inside our code we might see it many times inside a memory but wait you say i happen to know something about compilers i mean i happen to know this is real tail recursion and the compiler could have optimized this to actually just be a loop it could have changed value program and just gone around the loop and run again so in fact i wouldn't actually be there in memory three times well yes you're correct you could also say but wait the compiler can notice that sees never actually used and so therefore it could optimize it out completely and therefore it won't be in memory at all and you'd be correct again so yes we have to be careful about where they were talking about what truly happens when we turn on all optimizations and what happens with our simple model of how we compile c code to running code with that we're going to skip into the next video where i talk now about more exciting example where actually going to start working on a real problem and we are going to kind of generate manderbach pictures using	memory	608
with one case i've got another value of c inside here which is ten and then change to eleven ok are we done no that was just for one thread ok so this is kind of the big important idea that's the whole point of this example is that we're looking at the stack of just one thread here but in fact we're going to start three threads so we have the same picture again for the second thread that we start and these could all be running independently so in fact i'm going to see the value of c nine times so we saw it three here and we know we got three threads down here another three here and then lower down in memory another thread that we started and we're going to see the value of c a three more time so each of those us stack frames because we have recursive function i'm right so that's a lot of c values and hopefully i've got the point across that even though we've just written this once inside our code we might see it many times inside a memory but wait you say i happen to know something about compilers i mean i happen to know this is real tail recursion and the compiler could have optimized this to actually just be a loop it could have changed value program and just gone around the loop and run again so in fact i wouldn't actually be there in memory three times well yes you're correct you could also say but wait the compiler can notice that sees never actually used and so therefore it could optimize it out completely and therefore it won't be in memory at all and you'd be correct again so yes we have to be careful about where they were talking about what truly happens when we turn on all optimizations and what happens with our simple model of how we compile c code to running code with that we're going to skip into the next video where i talk now about more exciting example where actually going to start working on a real problem and we are going to kind of generate manderbach pictures using	code	905
with one case i've got another value of c inside here which is ten and then change to eleven ok are we done no that was just for one thread ok so this is kind of the big important idea that's the whole point of this example is that we're looking at the stack of just one thread here but in fact we're going to start three threads so we have the same picture again for the second thread that we start and these could all be running independently so in fact i'm going to see the value of c nine times so we saw it three here and we know we got three threads down here another three here and then lower down in memory another thread that we started and we're going to see the value of c a three more time so each of those us stack frames because we have recursive function i'm right so that's a lot of c values and hopefully i've got the point across that even though we've just written this once inside our code we might see it many times inside a memory but wait you say i happen to know something about compilers i mean i happen to know this is real tail recursion and the compiler could have optimized this to actually just be a loop it could have changed value program and just gone around the loop and run again so in fact i wouldn't actually be there in memory three times well yes you're correct you could also say but wait the compiler can notice that sees never actually used and so therefore it could optimize it out completely and therefore it won't be in memory at all and you'd be correct again so yes we have to be careful about where they were talking about what truly happens when we turn on all optimizations and what happens with our simple model of how we compile c code to running code with that we're going to skip into the next video where i talk now about more exciting example where actually going to start working on a real problem and we are going to kind of generate manderbach pictures using	thread	133
using threads ok bye	thread	6
hello ok welcome. welcome to lecture thirteen. so in this lecture we're going to start talking about thread safety and in particular we're going to start looking at how we can use mutex locks to ensure that only one	thread	101
thread of the time alters our data structure. or if we are modifying a data structure another thread can't read it. ok so let's get started. let's there's a little warm up have a look at some multithreaded code that i've written to download two things at the same time so this is what we got so far here's my main method i'm going to use two p threads today so we can see i've got two thread i ds and when i call pizza hut create i'm going to pass in the address of my two little variables there and i was saying ok p thread please create a thread for me and i wanted to start with my download function that i'm going to pass in a string so my first new thread is going to be given this string and my second youth thread thread is going to get to this this other string so as you can see we're dialed loading some pirate resources from the web right so let's kind of look at my download function here it is so it's going to be given a url and	a struct	33
thread of the time alters our data structure. or if we are modifying a data structure another thread can't read it. ok so let's get started. let's there's a little warm up have a look at some multithreaded code that i've written to download two things at the same time so this is what we got so far here's my main method i'm going to use two p threads today so we can see i've got two thread i ds and when i call pizza hut create i'm going to pass in the address of my two little variables there and i was saying ok p thread please create a thread for me and i wanted to start with my download function that i'm going to pass in a string so my first new thread is going to be given this string and my second youth thread thread is going to get to this this other string so as you can see we're dialed loading some pirate resources from the web right so let's kind of look at my download function here it is so it's going to be given a url and	code	206
thread of the time alters our data structure. or if we are modifying a data structure another thread can't read it. ok so let's get started. let's there's a little warm up have a look at some multithreaded code that i've written to download two things at the same time so this is what we got so far here's my main method i'm going to use two p threads today so we can see i've got two thread i ds and when i call pizza hut create i'm going to pass in the address of my two little variables there and i was saying ok p thread please create a thread for me and i wanted to start with my download function that i'm going to pass in a string so my first new thread is going to be given this string and my second youth thread thread is going to get to this this other string so as you can see we're dialed loading some pirate resources from the web right so let's kind of look at my download function here it is so it's going to be given a url and	a thread	539
thread of the time alters our data structure. or if we are modifying a data structure another thread can't read it. ok so let's get started. let's there's a little warm up have a look at some multithreaded code that i've written to download two things at the same time so this is what we got so far here's my main method i'm going to use two p threads today so we can see i've got two thread i ds and when i call pizza hut create i'm going to pass in the address of my two little variables there and i was saying ok p thread please create a thread for me and i wanted to start with my download function that i'm going to pass in a string so my first new thread is going to be given this string and my second youth thread thread is going to get to this this other string so as you can see we're dialed loading some pirate resources from the web right so let's kind of look at my download function here it is so it's going to be given a url and	string	631
thread of the time alters our data structure. or if we are modifying a data structure another thread can't read it. ok so let's get started. let's there's a little warm up have a look at some multithreaded code that i've written to download two things at the same time so this is what we got so far here's my main method i'm going to use two p threads today so we can see i've got two thread i ds and when i call pizza hut create i'm going to pass in the address of my two little variables there and i was saying ok p thread please create a thread for me and i wanted to start with my download function that i'm going to pass in a string so my first new thread is going to be given this string and my second youth thread thread is going to get to this this other string so as you can see we're dialed loading some pirate resources from the web right so let's kind of look at my download function here it is so it's going to be given a url and	thread	0
thread of the time alters our data structure. or if we are modifying a data structure another thread can't read it. ok so let's get started. let's there's a little warm up have a look at some multithreaded code that i've written to download two things at the same time so this is what we got so far here's my main method i'm going to use two p threads today so we can see i've got two thread i ds and when i call pizza hut create i'm going to pass in the address of my two little variables there and i was saying ok p thread please create a thread for me and i wanted to start with my download function that i'm going to pass in a string so my first new thread is going to be given this string and my second youth thread thread is going to get to this this other string so as you can see we're dialed loading some pirate resources from the web right so let's kind of look at my download function here it is so it's going to be given a url and	resources	821
thread of the time alters our data structure. or if we are modifying a data structure another thread can't read it. ok so let's get started. let's there's a little warm up have a look at some multithreaded code that i've written to download two things at the same time so this is what we got so far here's my main method i'm going to use two p threads today so we can see i've got two thread i ds and when i call pizza hut create i'm going to pass in the address of my two little variables there and i was saying ok p thread please create a thread for me and i wanted to start with my download function that i'm going to pass in a string so my first new thread is going to be given this string and my second youth thread thread is going to get to this this other string so as you can see we're dialed loading some pirate resources from the web right so let's kind of look at my download function here it is so it's going to be given a url and	address	455
we'll start by getting some heat memory ok so both my threads or how many things i make will get their own heat memory here this malloc call right and then we'll have some code in here that we weren't talking about yet to actually start downloading those bytes will get to that when we start talking about tcp and other network ideas great so we've got ourselves a few bytes here now i want to save those bites	memory	33
we'll start by getting some heat memory ok so both my threads or how many things i make will get their own heat memory here this malloc call right and then we'll have some code in here that we weren't talking about yet to actually start downloading those bytes will get to that when we start talking about tcp and other network ideas great so we've got ourselves a few bytes here now i want to save those bites	code	172
we'll start by getting some heat memory ok so both my threads or how many things i make will get their own heat memory here this malloc call right and then we'll have some code in here that we weren't talking about yet to actually start downloading those bytes will get to that when we start talking about tcp and other network ideas great so we've got ourselves a few bytes here now i want to save those bites	thread	54
to a file so will calculate some kind of short name from that url and let's you can have some market ok great so i want to open a file of f open and now assuming that works and assuming that i've managed to get some bites from my download then i should i should save that ok so let's use a function part of the seal i be called f right where i'm going to save my heat memory and the number of bytes i've managed to download here some number between zero and two thousand forty eight k will talk about f right in the future but we just want to save it to a file but i've done that is always a good thing to close resources so let's say ok now we're done with this file and finally let's get out of here so how do i finish my thread just by returning from this functions so might say return my memory if someone else wants to use it or i might	memory	368
to a file so will calculate some kind of short name from that url and let's you can have some market ok great so i want to open a file of f open and now assuming that works and assuming that i've managed to get some bites from my download then i should i should save that ok so let's use a function part of the seal i be called f right where i'm going to save my heat memory and the number of bytes i've managed to download here some number between zero and two thousand forty eight k will talk about f right in the future but we just want to save it to a file but i've done that is always a good thing to close resources so let's say ok now we're done with this file and finally let's get out of here so how do i finish my thread just by returning from this functions so might say return my memory if someone else wants to use it or i might	thread	724
to a file so will calculate some kind of short name from that url and let's you can have some market ok great so i want to open a file of f open and now assuming that works and assuming that i've managed to get some bites from my download then i should i should save that ok so let's use a function part of the seal i be called f right where i'm going to save my heat memory and the number of bytes i've managed to download here some number between zero and two thousand forty eight k will talk about f right in the future but we just want to save it to a file but i've done that is always a good thing to close resources so let's say ok now we're done with this file and finally let's get out of here so how do i finish my thread just by returning from this functions so might say return my memory if someone else wants to use it or i might	resources	612
equivalent discord pizza at exit remember they do the same thing but they say that this thread doesn't need to run anymore ok great so if i run this i've got a potential race condition can you see where	thread	88
ok so our race condition is that my main method might finish early or at least might continue to early if i actually now wanted to wait for these things to complete how would i do that ok so hopefully now you could write this code in alright so hopefully you now know there's two ways to do this you could call p thread joint so i'll dis yp for shorthand	code	226
ok so our race condition is that my main method might finish early or at least might continue to early if i actually now wanted to wait for these things to complete how would i do that ok so hopefully now you could write this code in alright so hopefully you now know there's two ways to do this you could call p thread joint so i'll dis yp for shorthand	thread	313
pizza join and pass in the thread i ds so i'm going to wait ampersand but is that correct no i don't want the address i want their actual values so i actually want my thread id one and do i care about the memory well right now i do if i don't want to a memory leak so i would have i would have the same memory one from the first one this is where the spanish dollar is going to go ok at least up to the first two thousand forty forty eight bytes ok and if i wanted to wait for the other one same thing again i could call pizza i'd join right and here is why i always wonder why that percent k things said i do teeth p thread id two and here is the address of memory two so great i've done that and now now i i can do whatever i want with that memory perhaps at some point however i should fit ok so let's free memory one there we go and similar for for two as well so ok so now go to a program that	memory	205
pizza join and pass in the thread i ds so i'm going to wait ampersand but is that correct no i don't want the address i want their actual values so i actually want my thread id one and do i care about the memory well right now i do if i don't want to a memory leak so i would have i would have the same memory one from the first one this is where the spanish dollar is going to go ok at least up to the first two thousand forty forty eight bytes ok and if i wanted to wait for the other one same thing again i could call pizza i'd join right and here is why i always wonder why that percent k things said i do teeth p thread id two and here is the address of memory two so great i've done that and now now i i can do whatever i want with that memory perhaps at some point however i should fit ok so let's free memory one there we go and similar for for two as well so ok so now go to a program that	thread	27
pizza join and pass in the thread i ds so i'm going to wait ampersand but is that correct no i don't want the address i want their actual values so i actually want my thread id one and do i care about the memory well right now i do if i don't want to a memory leak so i would have i would have the same memory one from the first one this is where the spanish dollar is going to go ok at least up to the first two thousand forty forty eight bytes ok and if i wanted to wait for the other one same thing again i could call pizza i'd join right and here is why i always wonder why that percent k things said i do teeth p thread id two and here is the address of memory two so great i've done that and now now i i can do whatever i want with that memory perhaps at some point however i should fit ok so let's free memory one there we go and similar for for two as well so ok so now go to a program that	address	110
now you listen to text here so this should be two ways for these stories to complete yeah the other way would be just in my main thread if that's the only thing i wanted this program to do is i could call p thread exit and the the words i'm asking my main thread to not do anymore work ok so i went to say pizza exit null and that's the end of it for my main thread	thread	129
ok by the way this twisted we create can cause create their own threads right i gotta question for you let's go look at this code at the top here suppose someone said you will hold on a moment i'm kind of confused because isn't there a race condition as well with this this malloc and the fact that i've got i've got a stack variable here i mean isn't it possible that both threads might end up using the same piece of heap memory	heap memory	419
ok by the way this twisted we create can cause create their own threads right i gotta question for you let's go look at this code at the top here suppose someone said you will hold on a moment i'm kind of confused because isn't there a race condition as well with this this malloc and the fact that i've got i've got a stack variable here i mean isn't it possible that both threads might end up using the same piece of heap memory	memory	424
ok by the way this twisted we create can cause create their own threads right i gotta question for you let's go look at this code at the top here suppose someone said you will hold on a moment i'm kind of confused because isn't there a race condition as well with this this malloc and the fact that i've got i've got a stack variable here i mean isn't it possible that both threads might end up using the same piece of heap memory	code	125
ok by the way this twisted we create can cause create their own threads right i gotta question for you let's go look at this code at the top here suppose someone said you will hold on a moment i'm kind of confused because isn't there a race condition as well with this this malloc and the fact that i've got i've got a stack variable here i mean isn't it possible that both threads might end up using the same piece of heap memory	thread	64
so can you see why that's not true why is it that both threads will always end up with their own heat memory	memory	102
so can you see why that's not true why is it that both threads will always end up with their own heat memory	thread	55
head should be something like lists ok so first of all both certain execute this code so both threads are actually going to call malloc independently in other words we're going to see two malloc course operating on the two different threats and the great news is that my lock will see those two threads and will definitely give each one its own memory malloc is what's called thread safe and how does it do that with something we're going to talk about today called mutex locks we actually we could do it with other ways but mutex locks would work if you implement malloc for a real programmer is multithreaded you two would need mutex logs or somebody equivalent mechanism some other equivalent synchronization mechanism	memory	345
head should be something like lists ok so first of all both certain execute this code so both threads are actually going to call malloc independently in other words we're going to see two malloc course operating on the two different threats and the great news is that my lock will see those two threads and will definitely give each one its own memory malloc is what's called thread safe and how does it do that with something we're going to talk about today called mutex locks we actually we could do it with other ways but mutex locks would work if you implement malloc for a real programmer is multithreaded you two would need mutex logs or somebody equivalent mechanism some other equivalent synchronization mechanism	code	81
head should be something like lists ok so first of all both certain execute this code so both threads are actually going to call malloc independently in other words we're going to see two malloc course operating on the two different threats and the great news is that my lock will see those two threads and will definitely give each one its own memory malloc is what's called thread safe and how does it do that with something we're going to talk about today called mutex locks we actually we could do it with other ways but mutex locks would work if you implement malloc for a real programmer is multithreaded you two would need mutex logs or somebody equivalent mechanism some other equivalent synchronization mechanism	thread	94
to ensure that even if malloc is quoted exactly the same time the same nanosecond the same clock cycle that ultimately it becomes one malloc request and another malloc request that end up with two different pieces of memory secondly ok the results come back it looks like we're storing inside the same map inside the same variable but remember this is actually a stack variable so it's local to the actual thread that is running and we know that because each thread gets it	memory	217
to ensure that even if malloc is quoted exactly the same time the same nanosecond the same clock cycle that ultimately it becomes one malloc request and another malloc request that end up with two different pieces of memory secondly ok the results come back it looks like we're storing inside the same map inside the same variable but remember this is actually a stack variable so it's local to the actual thread that is running and we know that because each thread gets it	thread	406
own stack so the value of memphis tag for thread one is different from the value of member thread two so no they are they are going to be completely independent right so this was nice embarrassingly parallel problem again where my two threads didn't need to interact the only synchronization they had to worry about was at the very end when we had to wait for both of us to complete it's going to get a little bit more complicated when we start wanting the threads to share data alright so	thread	42
the last thing is can you fill in this why is it that you can call malloc from two threads and by the way is a hint don't forget when we compile we gotta give a hint to the compiler to say alright we need p thread support please load the version of the c library which includes malloc that supports multiple threads	thread	83
ok so we've we've talked about e x t two and how we can represent a small and\large files efficiently so what does x t three nxd four givers so i've already mentioned one thing which is that they were expanded to allow much larger files but ext3 gavers are journaling which is the ability to make sure that our file system is always in a good state so a file system of course has to keep track of unused disk blocks so we want to make sure that even if there's a power failure we don't accidentally start relying on bad information that if our idea of which disk blocks were available was incorrect that oh we might start overwriting valid files so ext3 implement this idea called journaling which is that i can consider in time all of my writes to disk to be modifications to my disk so i can have checkpoints where i can have an idea that ok a certain time my disk is in a well known state whatever is actually physically stored on the disk surface is in a consistent well	block	409
ok so we've we've talked about e x t two and how we can represent a small and\large files efficiently so what does x t three nxd four givers so i've already mentioned one thing which is that they were expanded to allow much larger files but ext3 gavers are journaling which is the ability to make sure that our file system is always in a good state so a file system of course has to keep track of unused disk blocks so we want to make sure that even if there's a power failure we don't accidentally start relying on bad information that if our idea of which disk blocks were available was incorrect that oh we might start overwriting valid files so ext3 implement this idea called journaling which is that i can consider in time all of my writes to disk to be modifications to my disk so i can have checkpoints where i can have an idea that ok a certain time my disk is in a well known state whatever is actually physically stored on the disk surface is in a consistent well	system	316
the data i've made modifications to my directory to say there's a new file that exists here but i haven't yet updated say the disk blocks which are no longer available that kind of thing so i've got multiple rights i need to my disk and it's only when i get to second checkpoint do i know that all of the changes have been complete so if a power outage occurs or some other	block	131
let's have a look at a common pattern that people used inside existing programs so our code might be written inside the c layer but we know that ultimately that gets translated into low level system calls so let's have a look at kind of a standard standard pattern	code	87
let's have a look at a common pattern that people used inside existing programs so our code might be written inside the c layer but we know that ultimately that gets translated into low level system calls so let's have a look at kind of a standard standard pattern	system	192
so if we looked in times kind of ghost and stuff so there's a problem with this which is that if the power went out between say my right corner make clothes and the actual data being written to disk then tomorrow when i restart my machine i would discover that hey my entire files gone because the only thing that's happened was i managed to truncate it so many programs instead of opted for a kind of a safer version of this which is the following ok so let's	the following	435
the actual data for the new file was written later than the updates to the directory so in ext4 if there was a power outage we might suddenly find that or when we restart this we've managed to rename the file yes but the data that we thought we'd written was not actually on the disk yet so there was still a small corner case where we could lose all of the contents ok so this wasn't unhappy situation for awhile and the fix was to actually to provide a new option for xt four where we could disable delayed data right so there was a trade off in performance to say actually we want to make sure that all of our data content happens before we update kind of directory information so that's kind of kind of cute little example of how in the quest for better performance we hope we expose ourselves data loss in these kind of difficult corner cases so kind of hope you like that little kind of little confirmed case study of why creating file systems that are performed and secure is difficult the last thing i will mention is here's another when we started this section when we just brainstormed a list of features that we would like ok let's have a look at a real list of features of a real modern filesystems and this is just kind of a high level feature list	this section	1057
the actual data for the new file was written later than the updates to the directory so in ext4 if there was a power outage we might suddenly find that or when we restart this we've managed to rename the file yes but the data that we thought we'd written was not actually on the disk yet so there was still a small corner case where we could lose all of the contents ok so this wasn't unhappy situation for awhile and the fix was to actually to provide a new option for xt four where we could disable delayed data right so there was a trade off in performance to say actually we want to make sure that all of our data content happens before we update kind of directory information so that's kind of kind of cute little example of how in the quest for better performance we hope we expose ourselves data loss in these kind of difficult corner cases so kind of hope you like that little kind of little confirmed case study of why creating file systems that are performed and secure is difficult the last thing i will mention is here's another when we started this section when we just brainstormed a list of features that we would like ok let's have a look at a real list of features of a real modern filesystems and this is just kind of a high level feature list	section	1062
the actual data for the new file was written later than the updates to the directory so in ext4 if there was a power outage we might suddenly find that or when we restart this we've managed to rename the file yes but the data that we thought we'd written was not actually on the disk yet so there was still a small corner case where we could lose all of the contents ok so this wasn't unhappy situation for awhile and the fix was to actually to provide a new option for xt four where we could disable delayed data right so there was a trade off in performance to say actually we want to make sure that all of our data content happens before we update kind of directory information so that's kind of kind of cute little example of how in the quest for better performance we hope we expose ourselves data loss in these kind of difficult corner cases so kind of hope you like that little kind of little confirmed case study of why creating file systems that are performed and secure is difficult the last thing i will mention is here's another when we started this section when we just brainstormed a list of features that we would like ok let's have a look at a real list of features of a real modern filesystems and this is just kind of a high level feature list	system	942
of two two file systems that you'll probably hear about one is zfs and this support things like raid what's raid ok will talk about raid in the future we actually want to be able to work with different pools of files so we want to be able to have kind of enterprising features to make it easy to manage all of our different file systems so we had this idea of different storage pools so we've introduced abstraction layers between the physical disks and the actual kind of virtual disks disk pools that we actually might want to manipulate for applications	system	16
we want to implement things like copy on write an make it transactional we want snapshots we want clones we want to be able to send these snapshots from one disk to a different disk we want to be able to stripe physically i'm store our our data across different parts of a disk we want to have variable block size is we want to make it lightweight we want to be able to modify our cash we want even potentially different endianness for performance and of course you want things like deduplication encryption right so that's going to take awhile to write all the code to support about that and here's another one which another file system that then exports today yeah we want space efficient indices and packing of very small files while being able to support very large files we don't want to have to make choices at format time how many i knows we want again we want snapshot beat your vest has checksums to make sure that the data and the metadata or can still correct we want different compression algorithms	block	303
we want to implement things like copy on write an make it transactional we want snapshots we want clones we want to be able to send these snapshots from one disk to a different disk we want to be able to stripe physically i'm store our our data across different parts of a disk we want to have variable block size is we want to make it lightweight we want to be able to modify our cash we want even potentially different endianness for performance and of course you want things like deduplication encryption right so that's going to take awhile to write all the code to support about that and here's another one which another file system that then exports today yeah we want space efficient indices and packing of very small files while being able to support very large files we don't want to have to make choices at format time how many i knows we want again we want snapshot beat your vest has checksums to make sure that the data and the metadata or can still correct we want different compression algorithms	code	562
we want to implement things like copy on write an make it transactional we want snapshots we want clones we want to be able to send these snapshots from one disk to a different disk we want to be able to stripe physically i'm store our our data across different parts of a disk we want to have variable block size is we want to make it lightweight we want to be able to modify our cash we want even potentially different endianness for performance and of course you want things like deduplication encryption right so that's going to take awhile to write all the code to support about that and here's another one which another file system that then exports today yeah we want space efficient indices and packing of very small files while being able to support very large files we don't want to have to make choices at format time how many i knows we want again we want snapshot beat your vest has checksums to make sure that the data and the metadata or can still correct we want different compression algorithms	system	631
copacetic with our actual physical storage mechanisms so for example it should work well with ssd and have other optimizations associated with physical hardware we want to have incremental backup that works efficiently	optimizations	113
we want to be able to kind of scrub our disk for and look for errors in the background and so on and so on and so on and so on and so on so that i just want to go blow your mind or expand your mind in terms of ok this is all that cool stuff that are real modern day file system can kind of give to us ok and unfortunately however beta office is still only beginning to be used for real enterprise systems because realize that these features can start to bite you in the corner cases that we've just seen even with relatively simple file systems like e x two three n x t four if the corner cases that case for example where your disk is now full or suddenly you've got one disk going down and a quota changing plays and something else happening at the same time that people are paranoid about that the last thing i want to do is how to lose all of our data or worse have a data corruption that were not even aware of if we lost all our data then ok in the worst case we've last saturday of business and we can hopefully restore it but what is scary is to say we've got a bad piece of data we don't even aware of this so overtime we will just simply copy that the bad data into our	background	76
we want to be able to kind of scrub our disk for and look for errors in the background and so on and so on and so on and so on and so on so that i just want to go blow your mind or expand your mind in terms of ok this is all that cool stuff that are real modern day file system can kind of give to us ok and unfortunately however beta office is still only beginning to be used for real enterprise systems because realize that these features can start to bite you in the corner cases that we've just seen even with relatively simple file systems like e x two three n x t four if the corner cases that case for example where your disk is now full or suddenly you've got one disk going down and a quota changing plays and something else happening at the same time that people are paranoid about that the last thing i want to do is how to lose all of our data or worse have a data corruption that were not even aware of if we lost all our data then ok in the worst case we've last saturday of business and we can hopefully restore it but what is scary is to say we've got a bad piece of data we don't even aware of this so overtime we will just simply copy that the bad data into our	system	271
it for file changes if you really want to make make strong difficult c code your life then i said yes do you make your own file system that's it for now and the end of this lecture by	code	71
it for file changes if you really want to make make strong difficult c code your life then i said yes do you make your own file system that's it for now and the end of this lecture by	system	128
are hints i'm sending it to zero i want to do everything where i just done by by paper and maybe i want to connect locally or maybe i want to connect to illinois ok so first of all let's try let's try it annoys see what it says if we do this ok so pick an address right so how about cs ok	address	256
right i remember that the port number must be in double quotes for passing a string ok and we're taking the address of my hints tractor in the address of the pointer	string	77
right i remember that the port number must be in double quotes for passing a string ok and we're taking the address of my hints tractor in the address of the pointer	address	108
right i remember that the port number must be in double quotes for passing a string ok and we're taking the address of my hints tractor in the address of the pointer	pointer	158
so if it fails let's just exit after printing out to the an error ok and here's where we're just going to only look at the very first entry so i make a socket with the wright family and the right socket type and	type	203
then i'm going to connect and connect all that needs is the socket file descriptor key and the address and the length of of that struct ok so let's compile this then we talk about the remainder of the code key right so	code	201
then i'm going to connect and connect all that needs is the socket file descriptor key and the address and the length of of that struct ok so let's compile this then we talk about the remainder of the code key right so	address	95
wait who it connected ok and what it gave us it told us to go to a different page ok so please refresh this and go to this other web page fine so i'd write a web server web client now which actually kind of understands this text and follow that link right but we'll see that fundamentally our request was ok and it gave us back a hundred and sixty three bites of actual content and the content gavers was a web page ok that's the mind type text slash html so let's have a brief look at the remainder of the code to see how it works	type	435
wait who it connected ok and what it gave us it told us to go to a different page ok so please refresh this and go to this other web page fine so i'd write a web server web client now which actually kind of understands this text and follow that link right but we'll see that fundamentally our request was ok and it gave us back a hundred and sixty three bites of actual content and the content gavers was a web page ok that's the mind type text slash html so let's have a brief look at the remainder of the code to see how it works	code	507
first of all i'm defining my request here just using a macro so this time rather than just requesting a resource i'm also telling the server that i want it to behave as if i connect as if it was this other address this other host name illinois to edu here's why today we can have multiple hostnames which resolve to the same ip address and so our web server doesn't know which actual host that you would like it to pretend to be unless you tell it so perhaps if i told it that we wanted to connect to behave as ww dot c s dot illinois dot you it might give us a different response hey let's just try that for a moment ok so will compile it ok and will run the client again	address	206
ok ok nope that's still telling us to go to a different web page ok but you might notice something surprising here which is that i'm using this call i haven't talked about it before called d printf ok so d print f is this very strange call is not truly part of the posix standard but it makes our life a lot easier what it does is it	printf	191
and start passing in additional parameters ok so if you've got strings and integer numbers do you want to send to your socket remember d printf can be a useful tool here rather than using right directly and then i'm going to start reading back what the service says so a little buffer and i've got my little read loop in here and every time i get some bites back i'm going to write them out to standard out i'm going to finish if it	parameter	32
and start passing in additional parameters ok so if you've got strings and integer numbers do you want to send to your socket remember d printf can be a useful tool here rather than using right directly and then i'm going to start reading back what the service says so a little buffer and i've got my little read loop in here and every time i get some bites back i'm going to write them out to standard out i'm going to finish if it	printf	137
and start passing in additional parameters ok so if you've got strings and integer numbers do you want to send to your socket remember d printf can be a useful tool here rather than using right directly and then i'm going to start reading back what the service says so a little buffer and i've got my little read loop in here and every time i get some bites back i'm going to write them out to standard out i'm going to finish if it	string	63
ever fails so if either i read back zero meaning ok there's no more bites for us then i want to stop also if we return to negative one then we're not going to eat anymore so this is the simplest kind of code right but it's not complete i'm not yet handling the case that we got we got interrupted i'm also not handling	code	203
ok the last thing that we're not doing in his code is gracefully shutting down tcp connection so really we should be using shut down	code	46
and also we should polite code should also call clothes on the file descriptor so we should also call socket close on the file descriptor socket	code	26
to say hey let's free up this socket but as this is very simple and short demo code that's going to happen automatically when the process shuts down ok so that's the beginnings about tcp client let's see in the next video let's talk about how to make a tcp server are you ready let's go	code	79
hi ok so let's jump to a different level let's jump back into the c library perhaps you wanna write some very portable code it doesn't require on requires to think about these low level posix interface is we just want to write code that works say in windows as well maybe you kind of other operating systems that support the c library and which is kind of everything so let's have a look at how we can kind of jump around	code	119
hi ok so let's jump to a different level let's jump back into the c library perhaps you wanna write some very portable code it doesn't require on requires to think about these low level posix interface is we just want to write code that works say in windows as well maybe you kind of other operating systems that support the c library and which is kind of everything so let's have a look at how we can kind of jump around	system	300
the trick is to know what is this this whence an what does rewind do ok so we'll get to rewind and a little in a little moment notice it doesn't take any parameters but i'll let you kind of guess what that might do in a moment ok so let's talk about how this fc quirks right so we're going to pass in a a filestream that c based in the fast ring if you try to use this on standard io	parameter	154
and i want to reserve some space for might my file so i'd like to know how big it is now one way you may have seen already is simply to use stat stat tells me all sorts of great things about a file its size which file system is on the number of hard links we haven't talked about yet modification times and all that good stuff but let's just stay within the c library today for the most portable code and figure out how big the file	code	396
and i want to reserve some space for might my file so i'd like to know how big it is now one way you may have seen already is simply to use stat stat tells me all sorts of great things about a file its size which file system is on the number of hard links we haven't talked about yet modification times and all that good stuff but let's just stay within the c library today for the most portable code and figure out how big the file	system	218
right tell on the file k so that tells me my current position so that also tells me then the number of bytes that i would need so i can do things like if i want to have some space on the heap i could say ok malloc	the heap	183
give me that number of bytes now for brevity i'm skipping a whole load of error checking but i just want to kind of sketch out the code so great i've now got a some space and now i can read everything into their ok so how can i start reading my bites well i can use something called fread but i'm not going to do that today instead i'm going to concentrate on this this little problem in here which is	code	131
ok hello welcome to lecture eleven so this is exciting moment we're actually going to make our programs be able to do two things at the same time or as i like to jerk out they can crash twice as fast yes we're going to start looking at threads the ability for our process is to actually make use of all those great cores that are machine has the fact that the cpu today might have two calls for calls or even thirty two cores or higher	thread	236
means that we should be able to write programs to make use of all those order that cpu power perhaps you want one core for example are calculating the next physics step in your simulation perhaps you want another call working on the ui interaction so when the user presses a button we can do something about it immediately perhaps another core is going to be downloading an update perhaps another one is going to be doing a page layout lots and lots of things we should be able to at the same time and so this opens up a wonderful world of concurrency and synchronization as well so as soon as we start to have two threads fighting over the same data structure we've got problems we for example we don't want to we don't want to update a data structure was another thread is trying to update the same data structure so with great power comes great responsibility so we're going to start our journey today just looking at how we can actually do two things at the same time so fasten your seatbelts and off we go right so our first idea is to look at what's it mean for to have the thread of execution so let's have a look at	a page	422
means that we should be able to write programs to make use of all those order that cpu power perhaps you want one core for example are calculating the next physics step in your simulation perhaps you want another call working on the ui interaction so when the user presses a button we can do something about it immediately perhaps another core is going to be downloading an update perhaps another one is going to be doing a page layout lots and lots of things we should be able to at the same time and so this opens up a wonderful world of concurrency and synchronization as well so as soon as we start to have two threads fighting over the same data structure we've got problems we for example we don't want to we don't want to update a data structure was another thread is trying to update the same data structure so with great power comes great responsibility so we're going to start our journey today just looking at how we can actually do two things at the same time so fasten your seatbelts and off we go right so our first idea is to look at what's it mean for to have the thread of execution so let's have a look at	a struct	649
means that we should be able to write programs to make use of all those order that cpu power perhaps you want one core for example are calculating the next physics step in your simulation perhaps you want another call working on the ui interaction so when the user presses a button we can do something about it immediately perhaps another core is going to be downloading an update perhaps another one is going to be doing a page layout lots and lots of things we should be able to at the same time and so this opens up a wonderful world of concurrency and synchronization as well so as soon as we start to have two threads fighting over the same data structure we've got problems we for example we don't want to we don't want to update a data structure was another thread is trying to update the same data structure so with great power comes great responsibility so we're going to start our journey today just looking at how we can actually do two things at the same time so fasten your seatbelts and off we go right so our first idea is to look at what's it mean for to have the thread of execution so let's have a look at	thread	615
about a little bit of code here where i've got zoom in a bit there we go where i've got a little function called f and you can see it takes a whole bunch of parameters that little bit of calculation then then return something so let's think how this actually kind of actually works for machine perspective ok so now i have screwed realize	parameter	157
about a little bit of code here where i've got zoom in a bit there we go where i've got a little function called f and you can see it takes a whole bunch of parameters that little bit of calculation then then return something so let's think how this actually kind of actually works for machine perspective ok so now i have screwed realize	code	22
about is the idea that we have a stack that can actually track what we're doing because when i make a function call i need to remember what i was doing before and i also need to pass parameters into a function may need some extra space for its local variables and then eventually to return and go back to what i was doing before so let's look at this function and think how we might implement it so i'm going to need a stack	parameter	183
there we go right so on my stack i've got an idea in memory will remember we're going to put it high up in memory because we're going to have to heap in low memory right so this other stuff above here presumably for whatever called f right so i'm going to need some space for all these parameters so i'm going to need for bites for a four bytes for v one for boats for v two etc right and we can keep going right so we have a whole load of those up to say v twelve	memory	53
there we go right so on my stack i've got an idea in memory will remember we're going to put it high up in memory because we're going to have to heap in low memory right so this other stuff above here presumably for whatever called f right so i'm going to need some space for all these parameters so i'm going to need for bites for a four bytes for v one for boats for v two etc right and we can keep going right so we have a whole load of those up to say v twelve	parameter	286
ok right so that's the first thing you want to put in our stack now and what else could we put in our stack well when we return we have to tell the cpu what instruction to go back to in other words we're going to change that program counter so we better have some sort of return address so let me make a note of that on this stack as well so the return address when we return where should my program counter be set to ok right so that's enough information to to pass in what about my local variables ok well we can assign some space beneath that so for example we might say i'm going to need four bytes to hold be as well right so that's all kind of basic design a couple quick comments on this first of all that in a real cpu	address	279
decision is perhaps for speed rather than saving to memory all of the parameter values perhaps we should just pass them inside some of the the registers we have so we need a calling convention so for example we might say look the first three there's no point storing them in the stack we can have better performance if we just passed inside or register	memory	52
decision is perhaps for speed rather than saving to memory all of the parameter values perhaps we should just pass them inside some of the the registers we have so we need a calling convention so for example we might say look the first three there's no point storing them in the stack we can have better performance if we just passed inside or register	parameter	70
ok the other things that we might need is additional space so if you are calculating a really complicated expression perhaps you don't have enough registers to keep track of all the intermediate results so there might be additional needs for the stack here to hold some intermediate values ok if during that our calculation not for f but for another function we make another function call then what we're going to do we're going to extend our stack and play the same game again we would put our parameters for the function that we're calling whether it's printf or recursive function or something else we're going to need to put that one on the stack the parameters there and return address for what we're doing etc etc etc so you can this is just a sketch i'm not going to go into the x eighty six sixty four actual conventions today partly because it's actually quite a few of them and there's actually some fun stuff as well like the red zone which gives to a function a hundred and twenty eight extra bytes to play with which is guaranteed not to be changed by anything else so well let's not look at those details but let's just understand that for the currently active function	parameter	495
ok the other things that we might need is additional space so if you are calculating a really complicated expression perhaps you don't have enough registers to keep track of all the intermediate results so there might be additional needs for the stack here to hold some intermediate values ok if during that our calculation not for f but for another function we make another function call then what we're going to do we're going to extend our stack and play the same game again we would put our parameters for the function that we're calling whether it's printf or recursive function or something else we're going to need to put that one on the stack the parameters there and return address for what we're doing etc etc etc so you can this is just a sketch i'm not going to go into the x eighty six sixty four actual conventions today partly because it's actually quite a few of them and there's actually some fun stuff as well like the red zone which gives to a function a hundred and twenty eight extra bytes to play with which is guaranteed not to be changed by anything else so well let's not look at those details but let's just understand that for the currently active function	printf	555
ok the other things that we might need is additional space so if you are calculating a really complicated expression perhaps you don't have enough registers to keep track of all the intermediate results so there might be additional needs for the stack here to hold some intermediate values ok if during that our calculation not for f but for another function we make another function call then what we're going to do we're going to extend our stack and play the same game again we would put our parameters for the function that we're calling whether it's printf or recursive function or something else we're going to need to put that one on the stack the parameters there and return address for what we're doing etc etc etc so you can this is just a sketch i'm not going to go into the x eighty six sixty four actual conventions today partly because it's actually quite a few of them and there's actually some fun stuff as well like the red zone which gives to a function a hundred and twenty eight extra bytes to play with which is guaranteed not to be changed by anything else so well let's not look at those details but let's just understand that for the currently active function	address	683
there we go which is all the stuff that we needed to pass in and also the stack pointer which is	pointer	80
something that we can keep extending anasol stack is going downwards it's going to get low in memory as we need more space and so the total size of the stack actually represents the total number of functions that are currently active and as we return from things for example if you did a deeply nested recursion you're actually going to see your stack going smaller the other thing i wanted to point about this is that of course so called free in these variables when they going to stoke scope is easy is actually look like that memory pool remembered that	memory	94
remember that actually when we return from the function all we need to do is just change our stack pointer to go back to the previous area and change a return value so that's why stack variables are so much faster to allocate and deallocate compared to variables on the heap there's so little work to be done with just change change the pc register and everything 's gone so great we've got an idea of a thread of execution and we could trace this through our program so if i want to make a second thread if i want another cpu core to be running at the same time then i'm going to need space inside my memory for another thread and so each thread then it's going to get its own stack right and these are inside the same memory address space but they're going to be separated by say megabyte or so so they don't collide ok and then the last quite common is why do they call it the thread of execution is because literally you could draw a line you could thread through where my cpu is currently acting so if i had a function called x and inside x we called say f two and inside f two there was a moment that called f the function below we could trace this we could say i look this is the history of my cpu it's common to hear it's currently in this step so literally could paint a picture	memory	602
remember that actually when we return from the function all we need to do is just change our stack pointer to go back to the previous area and change a return value so that's why stack variables are so much faster to allocate and deallocate compared to variables on the heap there's so little work to be done with just change change the pc register and everything 's gone so great we've got an idea of a thread of execution and we could trace this through our program so if i want to make a second thread if i want another cpu core to be running at the same time then i'm going to need space inside my memory for another thread and so each thread then it's going to get its own stack right and these are inside the same memory address space but they're going to be separated by say megabyte or so so they don't collide ok and then the last quite common is why do they call it the thread of execution is because literally you could draw a line you could thread through where my cpu is currently acting so if i had a function called x and inside x we called say f two and inside f two there was a moment that called f the function below we could trace this we could say i look this is the history of my cpu it's common to hear it's currently in this step so literally could paint a picture	the heap	266
remember that actually when we return from the function all we need to do is just change our stack pointer to go back to the previous area and change a return value so that's why stack variables are so much faster to allocate and deallocate compared to variables on the heap there's so little work to be done with just change change the pc register and everything 's gone so great we've got an idea of a thread of execution and we could trace this through our program so if i want to make a second thread if i want another cpu core to be running at the same time then i'm going to need space inside my memory for another thread and so each thread then it's going to get its own stack right and these are inside the same memory address space but they're going to be separated by say megabyte or so so they don't collide ok and then the last quite common is why do they call it the thread of execution is because literally you could draw a line you could thread through where my cpu is currently acting so if i had a function called x and inside x we called say f two and inside f two there was a moment that called f the function below we could trace this we could say i look this is the history of my cpu it's common to hear it's currently in this step so literally could paint a picture	a thread	402
remember that actually when we return from the function all we need to do is just change our stack pointer to go back to the previous area and change a return value so that's why stack variables are so much faster to allocate and deallocate compared to variables on the heap there's so little work to be done with just change change the pc register and everything 's gone so great we've got an idea of a thread of execution and we could trace this through our program so if i want to make a second thread if i want another cpu core to be running at the same time then i'm going to need space inside my memory for another thread and so each thread then it's going to get its own stack right and these are inside the same memory address space but they're going to be separated by say megabyte or so so they don't collide ok and then the last quite common is why do they call it the thread of execution is because literally you could draw a line you could thread through where my cpu is currently acting so if i had a function called x and inside x we called say f two and inside f two there was a moment that called f the function below we could trace this we could say i look this is the history of my cpu it's common to hear it's currently in this step so literally could paint a picture	thread	404
remember that actually when we return from the function all we need to do is just change our stack pointer to go back to the previous area and change a return value so that's why stack variables are so much faster to allocate and deallocate compared to variables on the heap there's so little work to be done with just change change the pc register and everything 's gone so great we've got an idea of a thread of execution and we could trace this through our program so if i want to make a second thread if i want another cpu core to be running at the same time then i'm going to need space inside my memory for another thread and so each thread then it's going to get its own stack right and these are inside the same memory address space but they're going to be separated by say megabyte or so so they don't collide ok and then the last quite common is why do they call it the thread of execution is because literally you could draw a line you could thread through where my cpu is currently acting so if i had a function called x and inside x we called say f two and inside f two there was a moment that called f the function below we could trace this we could say i look this is the history of my cpu it's common to hear it's currently in this step so literally could paint a picture	address	727
remember that actually when we return from the function all we need to do is just change our stack pointer to go back to the previous area and change a return value so that's why stack variables are so much faster to allocate and deallocate compared to variables on the heap there's so little work to be done with just change change the pc register and everything 's gone so great we've got an idea of a thread of execution and we could trace this through our program so if i want to make a second thread if i want another cpu core to be running at the same time then i'm going to need space inside my memory for another thread and so each thread then it's going to get its own stack right and these are inside the same memory address space but they're going to be separated by say megabyte or so so they don't collide ok and then the last quite common is why do they call it the thread of execution is because literally you could draw a line you could thread through where my cpu is currently acting so if i had a function called x and inside x we called say f two and inside f two there was a moment that called f the function below we could trace this we could say i look this is the history of my cpu it's common to hear it's currently in this step so literally could paint a picture	pointer	99
of its current moment and of course with modern debuggers you can actually see that thread of execution both by single stepping it through and actually following it and also by looking through this stack trace the stack trace gives you a moment in time of why you're coming inside this current function who called you and who called them and of course you could trace this all the way back to main but enough of that, now we've got an idea for the sort of execution and the importance of stacks and a little bit of idea of how they work	thread	84
let's now start talking about how we can actually create more than one thread and have more than one thread of execution running are you ready see you in the next video bye	thread	71
ok let's review this one what do you think the following code will print ok so	the following	43
ok let's review this one what do you think the following code will print ok so	code	57
how can we analyze this right so i've got a pizza it create an i'm storing somewhere the fed id 's and i'm going to say ok i want to thread that is going to start functioning and let's start function be and we're going to pass a void pointer the address of the string literals so the address of the capital a and address of the cadillacs to each one right so what will function be do function be then get this pointer and so we're giving it the address of xyz so when this runs and we're not quite sure when it will run it will print out xyz	string	261
how can we analyze this right so i've got a pizza it create an i'm storing somewhere the fed id 's and i'm going to say ok i want to thread that is going to start functioning and let's start function be and we're going to pass a void pointer the address of the string literals so the address of the capital a and address of the cadillacs to each one right so what will function be do function be then get this pointer and so we're giving it the address of xyz so when this runs and we're not quite sure when it will run it will print out xyz	thread	133
how can we analyze this right so i've got a pizza it create an i'm storing somewhere the fed id 's and i'm going to say ok i want to thread that is going to start functioning and let's start function be and we're going to pass a void pointer the address of the string literals so the address of the capital a and address of the cadillacs to each one right so what will function be do function be then get this pointer and so we're giving it the address of xyz so when this runs and we're not quite sure when it will run it will print out xyz	address	246
how can we analyze this right so i've got a pizza it create an i'm storing somewhere the fed id 's and i'm going to say ok i want to thread that is going to start functioning and let's start function be and we're going to pass a void pointer the address of the string literals so the address of the capital a and address of the cadillacs to each one right so what will function be do function be then get this pointer and so we're giving it the address of xyz so when this runs and we're not quite sure when it will run it will print out xyz	pointer	234
now what about function a so functionally when it runs let's see is given the address of abc ok but it doesn't do anything instead it just simply exits this thread and it returns an address so it takes the pointer that we gave it which was a pointer to the string in memory abc and a zero bite if it is	memory	267
now what about function a so functionally when it runs let's see is given the address of abc ok but it doesn't do anything instead it just simply exits this thread and it returns an address so it takes the pointer that we gave it which was a pointer to the string in memory abc and a zero bite if it is	string	257
now what about function a so functionally when it runs let's see is given the address of abc ok but it doesn't do anything instead it just simply exits this thread and it returns an address so it takes the pointer that we gave it which was a pointer to the string in memory abc and a zero bite if it is	thread	157
now what about function a so functionally when it runs let's see is given the address of abc ok but it doesn't do anything instead it just simply exits this thread and it returns an address so it takes the pointer that we gave it which was a pointer to the string in memory abc and a zero bite if it is	address	78
now what about function a so functionally when it runs let's see is given the address of abc ok but it doesn't do anything instead it just simply exits this thread and it returns an address so it takes the pointer that we gave it which was a pointer to the string in memory abc and a zero bite if it is	pointer	206
ok and we take that caster character add one in other words we just calculated a pointer that now points to the b ok an we return that so if and when these two threads run we know that the first first one returns a pointer to bc string and the second one prints are xyz right what is the rest of the code to write so equals p thread join on thread a and grab the result and so in stores that in there area code result ok so what what is going to be put inside this result so this line is going to wait is going to wait until it's able to join p thread so that means we wait until functionary has finished at which point we set this result variable to be a pointer and it's pointing to here we go do that be right there which we print out ok so this will print bc add a new line	code	300
ok and we take that caster character add one in other words we just calculated a pointer that now points to the b ok an we return that so if and when these two threads run we know that the first first one returns a pointer to bc string and the second one prints are xyz right what is the rest of the code to write so equals p thread join on thread a and grab the result and so in stores that in there area code result ok so what what is going to be put inside this result so this line is going to wait is going to wait until it's able to join p thread so that means we wait until functionary has finished at which point we set this result variable to be a pointer and it's pointing to here we go do that be right there which we print out ok so this will print bc add a new line	string	229
ok and we take that caster character add one in other words we just calculated a pointer that now points to the b ok an we return that so if and when these two threads run we know that the first first one returns a pointer to bc string and the second one prints are xyz right what is the rest of the code to write so equals p thread join on thread a and grab the result and so in stores that in there area code result ok so what what is going to be put inside this result so this line is going to wait is going to wait until it's able to join p thread so that means we wait until functionary has finished at which point we set this result variable to be a pointer and it's pointing to here we go do that be right there which we print out ok so this will print bc add a new line	thread	160
ok and we take that caster character add one in other words we just calculated a pointer that now points to the b ok an we return that so if and when these two threads run we know that the first first one returns a pointer to bc string and the second one prints are xyz right what is the rest of the code to write so equals p thread join on thread a and grab the result and so in stores that in there area code result ok so what what is going to be put inside this result so this line is going to wait is going to wait until it's able to join p thread so that means we wait until functionary has finished at which point we set this result variable to be a pointer and it's pointing to here we go do that be right there which we print out ok so this will print bc add a new line	pointer	81
ok right so now we hopefully you can conclude what this code is going to print right so if you said it's going to print bc or the new line then you'd be correct if you said it's going to print bc in a new line and xyz you'd be correct if you said is going to print xyz with a new line and bc you'd be correct yes so what code is actually indeterminate fethard create makes no promises about when these threads now going to stop maybe in a microsecond maybe in a millisecond time there's a very real chance that	code	56
ok right so now we hopefully you can conclude what this code is going to print right so if you said it's going to print bc or the new line then you'd be correct if you said it's going to print bc in a new line and xyz you'd be correct if you said is going to print xyz with a new line and bc you'd be correct yes so what code is actually indeterminate fethard create makes no promises about when these threads now going to stop maybe in a microsecond maybe in a millisecond time there's a very real chance that	thread	402
the first thread thread a could could start up exit and main thread could join on that we could print out an exit before thread b has a chance to start this would be particularly true on sale really busy system or a system that's only got one cpu core are poor threadbear it hasn't had a cpu scheduled yet and so our main thread is done before it he has a chance to start up ok right so all those those as possible if we modified our code so that we included p three exit on the main thread then you know that that means that because we are never returning from maine now our program is going to run until both those threads finish so now we expect both the bc to be printed and the xyz to be printed though we can't actually say definitively what order these two things can print we can make a guess as to which ones more likely but we haven't actually	code	434
the first thread thread a could could start up exit and main thread could join on that we could print out an exit before thread b has a chance to start this would be particularly true on sale really busy system or a system that's only got one cpu core are poor threadbear it hasn't had a cpu scheduled yet and so our main thread is done before it he has a chance to start up ok right so all those those as possible if we modified our code so that we included p three exit on the main thread then you know that that means that because we are never returning from maine now our program is going to run until both those threads finish so now we expect both the bc to be printed and the xyz to be printed though we can't actually say definitively what order these two things can print we can make a guess as to which ones more likely but we haven't actually	thread	10
the first thread thread a could could start up exit and main thread could join on that we could print out an exit before thread b has a chance to start this would be particularly true on sale really busy system or a system that's only got one cpu core are poor threadbear it hasn't had a cpu scheduled yet and so our main thread is done before it he has a chance to start up ok right so all those those as possible if we modified our code so that we included p three exit on the main thread then you know that that means that because we are never returning from maine now our program is going to run until both those threads finish so now we expect both the bc to be printed and the xyz to be printed though we can't actually say definitively what order these two things can print we can make a guess as to which ones more likely but we haven't actually	system	204
so fun stuff with threads fun stuff with thinking about interleaving and i hope you burn his mind as you write your own multithreaded programs	thread	18
hi ok so let's talk about this code right so the challenges is to workout what this is going to print what's going to happen right so do i have my little pin ok great ok so let's do a few quick checks here we've got preset create and yes we are writing it into two different variables and remember at the top here just get out of that mode i've got two thread i ds tid one ti eighty two animal text look ok so let's	code	31
hi ok so let's talk about this code right so the challenges is to workout what this is going to print what's going to happen right so do i have my little pin ok great ok so let's do a few quick checks here we've got preset create and yes we are writing it into two different variables and remember at the top here just get out of that mode i've got two thread i ds tid one ti eighty two animal text look ok so let's	thread	353
see we do with this lot so peter create and we are going to give it the address of this good and no attributes and we're going to say when you start a thread please start it this function and the initial value to pass in will be null right to do that twice and then let's just check for no copy paste errors so good tid one tid too great so we're not going to get down to line nineteen we won't get to the print f until both threads have finished right so now let's have check out their code what do we do well each thread is going to call my folks each thread has his own stack and its own value of i so if you wish you could kind of paint a little picture to say here's one stack and here's another white changes colors exciting so	code	487
see we do with this lot so peter create and we are going to give it the address of this good and no attributes and we're going to say when you start a thread please start it this function and the initial value to pass in will be null right to do that twice and then let's just check for no copy paste errors so good tid one tid too great so we're not going to get down to line nineteen we won't get to the print f until both threads have finished right so now let's have check out their code what do we do well each thread is going to call my folks each thread has his own stack and its own value of i so if you wish you could kind of paint a little picture to say here's one stack and here's another white changes colors exciting so	a thread	149
see we do with this lot so peter create and we are going to give it the address of this good and no attributes and we're going to say when you start a thread please start it this function and the initial value to pass in will be null right to do that twice and then let's just check for no copy paste errors so good tid one tid too great so we're not going to get down to line nineteen we won't get to the print f until both threads have finished right so now let's have check out their code what do we do well each thread is going to call my folks each thread has his own stack and its own value of i so if you wish you could kind of paint a little picture to say here's one stack and here's another white changes colors exciting so	thread	151
see we do with this lot so peter create and we are going to give it the address of this good and no attributes and we're going to say when you start a thread please start it this function and the initial value to pass in will be null right to do that twice and then let's just check for no copy paste errors so good tid one tid too great so we're not going to get down to line nineteen we won't get to the print f until both threads have finished right so now let's have check out their code what do we do well each thread is going to call my folks each thread has his own stack and its own value of i so if you wish you could kind of paint a little picture to say here's one stack and here's another white changes colors exciting so	address	72
so we've gotten inside here and i inside there ok for stack waterstock to thread warning fit two right what do we do when we initialize it to zero we go round like a million times as a million and each time around we increment the counter	thread	74
but hold on inside this loop let's imagine that our first thread starts first and gets to get a list line first ok so what's it do it acquires the mutex lock is the first mutex is the first thread to do so so great it grabs hold of that duck and doesn't let go right so then it increments the counter right what happens next on this very same thread well let's imagine for a moment that thread two is started up ok so thread two gets his own value of i and very soon we'll get to the same peter mutex lock all right so what does it do it goes to grab the duck but the duck has been taken the mutex lock has already been acquired so it will be blocked right so thread too because it's the second thread to try to	block	643
but hold on inside this loop let's imagine that our first thread starts first and gets to get a list line first ok so what's it do it acquires the mutex lock is the first mutex is the first thread to do so so great it grabs hold of that duck and doesn't let go right so then it increments the counter right what happens next on this very same thread well let's imagine for a moment that thread two is started up ok so thread two gets his own value of i and very soon we'll get to the same peter mutex lock all right so what does it do it goes to grab the duck but the duck has been taken the mutex lock has already been acquired so it will be blocked right so thread too because it's the second thread to try to	thread	58
acquire the lock will be blocked all right and it looks like it's gonna be waiting forever because thread one is never going to release that in fact it gets worse than that because what destroyed one do well it carries on so it increments the global counter and then	block	25
acquire the lock will be blocked all right and it looks like it's gonna be waiting forever because thread one is never going to release that in fact it gets worse than that because what destroyed one do well it carries on so it increments the global counter and then	thread	99
goes around the loop again at which point it calls peter mutex lock	the loop	12
and blocks forever because that mutex has already been acquired now you and i know that that mutex ashley held by thread one but we haven't set we haven't created any special kind of meetings log we haven't enable debugging we haven't enabled recursion so in this case thread one is going to go to sleep and will stay asleep until the day that the holder of the lock releases it by calling unlock unfortunately you and i know that that is thread one ok so we've reached called deadlock where both red one and thread to have become stuck and will stay stuck forever right and notice how olympic effects as well if i got something that was waiting for thread two to say finish result right to file print something out then that is going to be waiting forever as well and so is quite often to see an entire system kind of grind to a whole as critical pieces never complete ok so that's what we think is going to happen right do you agree with me because i'm going to run it now and see what really happens are you ready let's go	block	4
and blocks forever because that mutex has already been acquired now you and i know that that mutex ashley held by thread one but we haven't set we haven't created any special kind of meetings log we haven't enable debugging we haven't enabled recursion so in this case thread one is going to go to sleep and will stay asleep until the day that the holder of the lock releases it by calling unlock unfortunately you and i know that that is thread one ok so we've reached called deadlock where both red one and thread to have become stuck and will stay stuck forever right and notice how olympic effects as well if i got something that was waiting for thread two to say finish result right to file print something out then that is going to be waiting forever as well and so is quite often to see an entire system kind of grind to a whole as critical pieces never complete ok so that's what we think is going to happen right do you agree with me because i'm going to run it now and see what really happens are you ready let's go	thread	114
and blocks forever because that mutex has already been acquired now you and i know that that mutex ashley held by thread one but we haven't set we haven't created any special kind of meetings log we haven't enable debugging we haven't enabled recursion so in this case thread one is going to go to sleep and will stay asleep until the day that the holder of the lock releases it by calling unlock unfortunately you and i know that that is thread one ok so we've reached called deadlock where both red one and thread to have become stuck and will stay stuck forever right and notice how olympic effects as well if i got something that was waiting for thread two to say finish result right to file print something out then that is going to be waiting forever as well and so is quite often to see an entire system kind of grind to a whole as critical pieces never complete ok so that's what we think is going to happen right do you agree with me because i'm going to run it now and see what really happens are you ready let's go	system	804
so this is the same code here it is and if i can compile it there we go wait whoops did i did i actually compiled with preferred yes i good ok so now let's run that	code	20
ok and did it crash wait forever no it did not deadlock in fact it finishes and in fact it just prints out an arbitrary number why is that ok so the key thing here is that we forgot to initialize our mutex and so there we have variable is just like a file handle it doesn't actually refer to anything and so rp thread mutex lock call does nothing is a no op we could have discovered that if we'd actually check	thread	311
the return value of rp tape mutex lock so if we were waiting really bulletproof robust code production code we might do that but instead because we forgot it doesn't do anything so let's let's fix that let's go and update this key so i'll ok take my lines off key and	code	87
till i use yeah let's use vim ok so how can do this remember we can do things like by saying ok my mutex is p thread	thread	110
ok so compile it want it again and this time it gets stuck as we hoped it would alright so finally let's fix our code here let's after we finished modifying the data structure there we go mutex lock	the data structure	157
ok so compile it want it again and this time it gets stuck as we hoped it would alright so finally let's fix our code here let's after we finished modifying the data structure there we go mutex lock	a struct	164
ok so compile it want it again and this time it gets stuck as we hoped it would alright so finally let's fix our code here let's after we finished modifying the data structure there we go mutex lock	code	113
where it ok and finally now it does produce the correct value of two million now when we actually ran this earlier when we had an initialized mutex we solve values switch variant and we're certainly not two million so here's an example of a race condition that we can easily detect and the reason of course is that ninety nine point nine percent of the time cpus are modifying this data structure so we go and hit that critical section many many many many times and so likelihood of two threads being inside a critical section is extremely high because that's the only thing we're basically doing is is keep incrementing this ok so that was very different from our kind of	a struct	385
where it ok and finally now it does produce the correct value of two million now when we actually ran this earlier when we had an initialized mutex we solve values switch variant and we're certainly not two million so here's an example of a race condition that we can easily detect and the reason of course is that ninety nine point nine percent of the time cpus are modifying this data structure so we go and hit that critical section many many many many times and so likelihood of two threads being inside a critical section is extremely high because that's the only thing we're basically doing is is keep incrementing this ok so that was very different from our kind of	section	428
where it ok and finally now it does produce the correct value of two million now when we actually ran this earlier when we had an initialized mutex we solve values switch variant and we're certainly not two million so here's an example of a race condition that we can easily detect and the reason of course is that ninety nine point nine percent of the time cpus are modifying this data structure so we go and hit that critical section many many many many times and so likelihood of two threads being inside a critical section is extremely high because that's the only thing we're basically doing is is keep incrementing this ok so that was very different from our kind of	thread	487
hi i've got a challenge for you lets do a code review of the following code and see what errors we can spot in this and how we could improve it ok so get my little pen out here let's choose a new color or go for let's go for this is kind of yeah let's just do dark blue ok try that ok	the following	58
hi i've got a challenge for you lets do a code review of the following code and see what errors we can spot in this and how we could improve it ok so get my little pen out here let's choose a new color or go for let's go for this is kind of yeah let's just do dark blue ok try that ok	code	43
i don't like the fact that this code didn't have any braces in here because my exit then wouldn't be enclosed within the condition there we go so we also want some braces in there ok now we call f open so we're using the c library to pass in an argument and we already are confident that that is a non null pointer because we know now that is going to be at least two items inside argument to read<br> and we're saying ok i just want to open this for read only	code	32
i don't like the fact that this code didn't have any braces in here because my exit then wouldn't be enclosed within the condition there we go so we also want some braces in there ok now we call f open so we're using the c library to pass in an argument and we already are confident that that is a non null pointer because we know now that is going to be at least two items inside argument to read<br> and we're saying ok i just want to open this for read only	pointer	307
great we have little documentation here say maybe turning all but we don't actually ever do anything with that so better code would actually test the result of f open and if it returned null then let's not continue let's print something out and stop at that point ok so now we're going to start reading lines at a time	code	121
and this is pretty cool we actually going to print outline numbers alot like better we have line numbers in the code here and you may have not seen this before but actually you can specify	code	112
the width of the space the number of empty spaces to automatically add to the area for that particular variable right and we're using a side effect of each time to add one to the line number where do we get in these lines from we're using getline alright and we're passing in the address of two variables that's great way to use getline where are they are they up here and we're passing in that file handle as well	address	280
ok and we only escape when we actually read a negative one so we don't know where it's going to be the end of the file or whether it's going to be someone unplug the usb drive was we were printing it out but for whatever reason get line cannot continue and i like the fact that at the end here we are freeing up the memory that line is pointing to so we never explicitly called malloc but you know that get line does called malac internally so great we're filling up the heap memory and were being good citizens and	heap memory	471
ok and we only escape when we actually read a negative one so we don't know where it's going to be the end of the file or whether it's going to be someone unplug the usb drive was we were printing it out but for whatever reason get line cannot continue and i like the fact that at the end here we are freeing up the memory that line is pointing to so we never explicitly called malloc but you know that get line does called malac internally so great we're filling up the heap memory and were being good citizens and	memory	316
ok and we only escape when we actually read a negative one so we don't know where it's going to be the end of the file or whether it's going to be someone unplug the usb drive was we were printing it out but for whatever reason get line cannot continue and i like the fact that at the end here we are freeing up the memory that line is pointing to so we never explicitly called malloc but you know that get line does called malac internally so great we're filling up the heap memory and were being good citizens and	the heap	467
releasing the open file stream that we created earlier alright good so what's missing i'll give you a hint there's two errors still left in this code can you see them i'll give you twenty seconds to see if you can find them are you ready go	code	145
ok right so the first one is that we never initialize the value of our capacity variable so if we look back here we've got a stack variable an stack variables will just take whatever bit pattern happens to be in the stack of that time maybe will be all zero bits but it doesn't have to be the specification does not enforce that so our program has undefined behavior right so what might happen then well imagine for a moment that capacity was was a non zero value then as get line starts reading from standard input it might believe that the pointer we gave to line here actually corresponds to however many capacity bites are available to be written into that that location thus we might actually cause get like to fail ok so what we should have done is to say absolutely not there's nothing there at the current location right so we should have fixed that was the second error	pointer	542
i will show you that when we actually run the program ok so let's get started let's edit r code here right	code	91
we wanted to exit at this point just to remind you that if you're inside main exiting is equivalent to just returning from maine ok and the next thing we wanted to do was to say look if rf open failed so if file it was a null pointer we want to print something out that's useful like could not open or whatever file you said for reading ok and	pointer	226
i need the file name on v one maybe we should put that inside of variable would be cleaner code and we do not continue do not pass go instead return and let's have a different error code just for fun the last thing we wanted to change was to also set our capacity k two	code	91
alright so we get our bikes red we check return value and if it's negative one we stop ok so and we wanted the free in here as well so free the line pointer ok	pointer	149
my cat my cat ok there we go ok and i didn't get my printf white so will fix that my cat dot c k here it is like thirteen	printf	52
course i could always type thirteen g just to go directly to it and w to advance by one word ok there we go i want to insert here so it's a standard dot that right let's run like apollo again great and now will run it so we don't say anything and it	type	22
ok so let's talk about why the nation part of the operating system here that is ass break now if we were to look at the manpage of s break you'd read something like the following s break increases the process is data segment by end bites so when you call s break you can give it a number and you can say hey i'd like ten more bytes please alright so what does that actually mean	the following	165
ok so let's talk about why the nation part of the operating system here that is ass break now if we were to look at the manpage of s break you'd read something like the following s break increases the process is data segment by end bites so when you call s break you can give it a number and you can say hey i'd like ten more bytes please alright so what does that actually mean	system	60
ok so between you and me as big is not actually used anymore instead we're going to use some virtual memory tricks of all the slide this did modern c library uses some virtual memory tricks that we haven't learned yet so s breakers are simply mechanism but we will use it for cs two forty one to implement a simple memory allocator ok so remember how i said that the bottom of the memory i've got the text segment which is the program code and string literals and any other constants we've put in here and	memory	101
ok so between you and me as big is not actually used anymore instead we're going to use some virtual memory tricks of all the slide this did modern c library uses some virtual memory tricks that we haven't learned yet so s breakers are simply mechanism but we will use it for cs two forty one to implement a simple memory allocator ok so remember how i said that the bottom of the memory i've got the text segment which is the program code and string literals and any other constants we've put in here and	code	435
ok so between you and me as big is not actually used anymore instead we're going to use some virtual memory tricks of all the slide this did modern c library uses some virtual memory tricks that we haven't learned yet so s breakers are simply mechanism but we will use it for cs two forty one to implement a simple memory allocator ok so remember how i said that the bottom of the memory i've got the text segment which is the program code and string literals and any other constants we've put in here and	string	444
ok we can put any data we like inside there and by default the total amount of memory allocated to this is g asked sufficient for what we need ok but what about the day you call malloc and say hey my malloc i need another four thousand and ninety six bytes please this point we need need to go back to the operating system to the kernel and beg for some more van back for some more real addresses we don't want to talk to the oblivion we don't want to avoid we actually need those memory addresses now to refer to some actual memory and that's the purpose of s break is to say yes i know i've got my heap possibly say zero bytes at the beginning but that's not enough now i need to extend it so i please i'd like to move this watermark upwards say by two hundred fifty six bytes so that now i've got some more addresses i can play with i can use to hold some data so that's one less pack gives you an ability to turn on like a tap some more some more dresses which are valid ok we just keep extending this space here and we can use that then to implement possibly the world 's worst but simplest allocator so let's have a look in a moment then how we could actually use this to implement malloc are you ready are slow you in the next video bye	memory	79
ok we can put any data we like inside there and by default the total amount of memory allocated to this is g asked sufficient for what we need ok but what about the day you call malloc and say hey my malloc i need another four thousand and ninety six bytes please this point we need need to go back to the operating system to the kernel and beg for some more van back for some more real addresses we don't want to talk to the oblivion we don't want to avoid we actually need those memory addresses now to refer to some actual memory and that's the purpose of s break is to say yes i know i've got my heap possibly say zero bytes at the beginning but that's not enough now i need to extend it so i please i'd like to move this watermark upwards say by two hundred fifty six bytes so that now i've got some more addresses i can play with i can use to hold some data so that's one less pack gives you an ability to turn on like a tap some more some more dresses which are valid ok we just keep extending this space here and we can use that then to implement possibly the world 's worst but simplest allocator so let's have a look in a moment then how we could actually use this to implement malloc are you ready are slow you in the next video bye	address	387
ok we can put any data we like inside there and by default the total amount of memory allocated to this is g asked sufficient for what we need ok but what about the day you call malloc and say hey my malloc i need another four thousand and ninety six bytes please this point we need need to go back to the operating system to the kernel and beg for some more van back for some more real addresses we don't want to talk to the oblivion we don't want to avoid we actually need those memory addresses now to refer to some actual memory and that's the purpose of s break is to say yes i know i've got my heap possibly say zero bytes at the beginning but that's not enough now i need to extend it so i please i'd like to move this watermark upwards say by two hundred fifty six bytes so that now i've got some more addresses i can play with i can use to hold some data so that's one less pack gives you an ability to turn on like a tap some more some more dresses which are valid ok we just keep extending this space here and we can use that then to implement possibly the world 's worst but simplest allocator so let's have a look in a moment then how we could actually use this to implement malloc are you ready are slow you in the next video bye	system	316
oh i forgot to say one little thing about erino down here which is when is it set ok so here's a big idea is that it set to zero when your first program first starts up its value is changed whenever there's an error with a system called and we read the man pages to learn more about that but it's never reset back to zero so if i had a whole lot of calls let's say that i try to read from warm particular file descriptor and then try to write those bites somewhere else to another file descriptor fd two over here if i then check if evan oh zero or not then i can't actually tell you whether where the error curd maybe it happened early on inside my read maybe it happened inside my right or maybe it happened even earlier so just think of is a global variable that if an error occurs we change it	a system call	221
oh i forgot to say one little thing about erino down here which is when is it set ok so here's a big idea is that it set to zero when your first program first starts up its value is changed whenever there's an error with a system called and we read the man pages to learn more about that but it's never reset back to zero so if i had a whole lot of calls let's say that i try to read from warm particular file descriptor and then try to write those bites somewhere else to another file descriptor fd two over here if i then check if evan oh zero or not then i can't actually tell you whether where the error curd maybe it happened early on inside my read maybe it happened inside my right or maybe it happened even earlier so just think of is a global variable that if an error occurs we change it	system	223
so now if you do that and you make some system tools	system	40
in practice of course bulletproof code robust production code would actually check the return values of all of your system calls and that is kind of really good system programming practice to kind of detect when errors go wrong and actually becomes critical when you start writing network code see you in the next video bye	code	34
in practice of course bulletproof code robust production code would actually check the return values of all of your system calls and that is kind of really good system programming practice to kind of detect when errors go wrong and actually becomes critical when you start writing network code see you in the next video bye	system	116
a certain frequency or up down event etc right so we've got to actually defined how we want to transmit individual bits ok above this we now need to describe how we assemble these bits into chunks of information so we've got this data link that maybe i want to describe start and end bits for example that kind of old modems we might actually send ten bits for every kind of eight bits that we actually send in order to including start and stop information right so we're not actually going to talk that much about these kind of low level ideas instead our story starts here with the description of the packet of how we wrap things around the network ok so we've already mentioned ip version four it's the most popular kind of routing today in our network but as you know we're actually running out or have run out of ip version four addresses because our addresses are only limited to those four octets so today we're starting to see a rise in the new version of the ip addressing internet protocol addressing which is ip version six so there are others for example there is still appletalk which you might find possibly in a lab full of apple machines i suppose	address	834
but today most of our packets are using ip four or ip six addressing ok so at this level then we are able to kind of create packets with an address define a particular protocol they're using and send them on their way ok connected with this however is we actually wanted to specify some actual data and the two common ways to do that then are to use tcp and udp and notice that this is at a different level so now we're talking about how we actually transport so when people talk about the transport level this is at the level of ok i've got some data within	address	58
are we done no well ok you just typed a character but how is that character represented we're so used to thinking about the fact that we're writing in say ascii or utf eight that doesn't actually have to be the only way that we can represent our data so for example perhaps you want to store and send pictures using a jpeg format or perhaps you want to send a text using this ebcdic format which is a different way to represent characters or perhaps you want to use png so perhaps you want to do movies etc ok are we done no at the top most level is the idea of the application so at the application level, we get to define our own apis we get to define how we want to access remote files and resources and describe things like directory services as well so this top most level this is where we start talking about ok i want to be able to access web resources using http which itself is a protocol that grew out of a simple file transfer protocol and another well known protocol here is smtp which is a way for us to send emails simple mail transfer protocol so smtp allows you to send very simple messages or to send emails with attachments for example ok so these different levels of abstraction allow us to work independently so for example tomorrow i might decide that as you want to access a web page not over tcp but over udp of course if i do that then my web client better be able to actually handle udp connections and also my web server needs to be able to handle udp connections does it happen today yes surprising it does so if you happen to be a rather large company called google for example you might actually decide that you want to implement your own connections using udp and you can do this because you own both parts of the network you own both the client and the server also tomorrow you might decide that you want to support not only ip four but ip six as well and you might do this because you actually want to start creating new servers and yeah you're unable to get an existing ip four address ok so that's a little bit about the open systems interconnection model or the osi model	a protocol	887
are we done no well ok you just typed a character but how is that character represented we're so used to thinking about the fact that we're writing in say ascii or utf eight that doesn't actually have to be the only way that we can represent our data so for example perhaps you want to store and send pictures using a jpeg format or perhaps you want to send a text using this ebcdic format which is a different way to represent characters or perhaps you want to use png so perhaps you want to do movies etc ok are we done no at the top most level is the idea of the application so at the application level, we get to define our own apis we get to define how we want to access remote files and resources and describe things like directory services as well so this top most level this is where we start talking about ok i want to be able to access web resources using http which itself is a protocol that grew out of a simple file transfer protocol and another well known protocol here is smtp which is a way for us to send emails simple mail transfer protocol so smtp allows you to send very simple messages or to send emails with attachments for example ok so these different levels of abstraction allow us to work independently so for example tomorrow i might decide that as you want to access a web page not over tcp but over udp of course if i do that then my web client better be able to actually handle udp connections and also my web server needs to be able to handle udp connections does it happen today yes surprising it does so if you happen to be a rather large company called google for example you might actually decide that you want to implement your own connections using udp and you can do this because you own both parts of the network you own both the client and the server also tomorrow you might decide that you want to support not only ip four but ip six as well and you might do this because you actually want to start creating new servers and yeah you're unable to get an existing ip four address ok so that's a little bit about the open systems interconnection model or the osi model	type	32
are we done no well ok you just typed a character but how is that character represented we're so used to thinking about the fact that we're writing in say ascii or utf eight that doesn't actually have to be the only way that we can represent our data so for example perhaps you want to store and send pictures using a jpeg format or perhaps you want to send a text using this ebcdic format which is a different way to represent characters or perhaps you want to use png so perhaps you want to do movies etc ok are we done no at the top most level is the idea of the application so at the application level, we get to define our own apis we get to define how we want to access remote files and resources and describe things like directory services as well so this top most level this is where we start talking about ok i want to be able to access web resources using http which itself is a protocol that grew out of a simple file transfer protocol and another well known protocol here is smtp which is a way for us to send emails simple mail transfer protocol so smtp allows you to send very simple messages or to send emails with attachments for example ok so these different levels of abstraction allow us to work independently so for example tomorrow i might decide that as you want to access a web page not over tcp but over udp of course if i do that then my web client better be able to actually handle udp connections and also my web server needs to be able to handle udp connections does it happen today yes surprising it does so if you happen to be a rather large company called google for example you might actually decide that you want to implement your own connections using udp and you can do this because you own both parts of the network you own both the client and the server also tomorrow you might decide that you want to support not only ip four but ip six as well and you might do this because you actually want to start creating new servers and yeah you're unable to get an existing ip four address ok so that's a little bit about the open systems interconnection model or the osi model	resources	693
are we done no well ok you just typed a character but how is that character represented we're so used to thinking about the fact that we're writing in say ascii or utf eight that doesn't actually have to be the only way that we can represent our data so for example perhaps you want to store and send pictures using a jpeg format or perhaps you want to send a text using this ebcdic format which is a different way to represent characters or perhaps you want to use png so perhaps you want to do movies etc ok are we done no at the top most level is the idea of the application so at the application level, we get to define our own apis we get to define how we want to access remote files and resources and describe things like directory services as well so this top most level this is where we start talking about ok i want to be able to access web resources using http which itself is a protocol that grew out of a simple file transfer protocol and another well known protocol here is smtp which is a way for us to send emails simple mail transfer protocol so smtp allows you to send very simple messages or to send emails with attachments for example ok so these different levels of abstraction allow us to work independently so for example tomorrow i might decide that as you want to access a web page not over tcp but over udp of course if i do that then my web client better be able to actually handle udp connections and also my web server needs to be able to handle udp connections does it happen today yes surprising it does so if you happen to be a rather large company called google for example you might actually decide that you want to implement your own connections using udp and you can do this because you own both parts of the network you own both the client and the server also tomorrow you might decide that you want to support not only ip four but ip six as well and you might do this because you actually want to start creating new servers and yeah you're unable to get an existing ip four address ok so that's a little bit about the open systems interconnection model or the osi model	address	2011
are we done no well ok you just typed a character but how is that character represented we're so used to thinking about the fact that we're writing in say ascii or utf eight that doesn't actually have to be the only way that we can represent our data so for example perhaps you want to store and send pictures using a jpeg format or perhaps you want to send a text using this ebcdic format which is a different way to represent characters or perhaps you want to use png so perhaps you want to do movies etc ok are we done no at the top most level is the idea of the application so at the application level, we get to define our own apis we get to define how we want to access remote files and resources and describe things like directory services as well so this top most level this is where we start talking about ok i want to be able to access web resources using http which itself is a protocol that grew out of a simple file transfer protocol and another well known protocol here is smtp which is a way for us to send emails simple mail transfer protocol so smtp allows you to send very simple messages or to send emails with attachments for example ok so these different levels of abstraction allow us to work independently so for example tomorrow i might decide that as you want to access a web page not over tcp but over udp of course if i do that then my web client better be able to actually handle udp connections and also my web server needs to be able to handle udp connections does it happen today yes surprising it does so if you happen to be a rather large company called google for example you might actually decide that you want to implement your own connections using udp and you can do this because you own both parts of the network you own both the client and the server also tomorrow you might decide that you want to support not only ip four but ip six as well and you might do this because you actually want to start creating new servers and yeah you're unable to get an existing ip four address ok so that's a little bit about the open systems interconnection model or the osi model	system	2060
to the buffer so we want to do something like the following they believe about space and we'll see why in a moment we've already got some bikes inside the buffer so here is the buffer and we now want to take this string and append it to the end of the bytes that we're currently using so	the following	46
to the buffer so we want to do something like the following they believe about space and we'll see why in a moment we've already got some bikes inside the buffer so here is the buffer and we now want to take this string and append it to the end of the bytes that we're currently using so	string	213
how about the following let's use mem copy to copy your bites into the buffer so what do we need here let's first of all figure out how many bytes we actually have case so we will actually find the length of the string let's just do this once so let's take a stroll in of the string you've given me you better not give me a null pointer otherwise that will crash	the following	10
how about the following let's use mem copy to copy your bites into the buffer so what do we need here let's first of all figure out how many bytes we actually have case so we will actually find the length of the string let's just do this once so let's take a stroll in of the string you've given me you better not give me a null pointer otherwise that will crash	string	212
how about the following let's use mem copy to copy your bites into the buffer so what do we need here let's first of all figure out how many bytes we actually have case so we will actually find the length of the string let's just do this once so let's take a stroll in of the string you've given me you better not give me a null pointer otherwise that will crash	pointer	329
right and we see we take this destination first alright great ok so back to my code and if i rely on the c compiler i can just there for providing my buffer is either a void pointer or character pointer i just add these two together to calculate the correct address of where we where we want to write to ok so let's do that right	code	79
right and we see we take this destination first alright great ok so back to my code and if i rely on the c compiler i can just there for providing my buffer is either a void pointer or character pointer i just add these two together to calculate the correct address of where we where we want to write to ok so let's do that right	address	258
right and we see we take this destination first alright great ok so back to my code and if i rely on the c compiler i can just there for providing my buffer is either a void pointer or character pointer i just add these two together to calculate the correct address of where we where we want to write to ok so let's do that right	pointer	174
so we want the following we want to copy into	the following	11
ok the buffer but not necessarily the beginning of the buffer because i have already used some of the bytes so let's add the size we can use that as an offset and what am i trying to add ok so i i need the source so that is going to be string	string	236
ok and if this is character pointer then i can write into the correct spot ok so i could write our size	pointer	28
plus the length of my string	string	22
right so what do you think about that is it always going to work ok so we actually have run into some interesting problems here so first of all we've assumed that the string is not going to generate any kind of buffer overflow errors so for example suppose we already exhausted most of the buffer we haven't even checked today the capacity of the buffer	string	167
and so we are just happy calling mem copy and if we were exhausted say there's four thousand and ninety six bytes we're going to start writing arbitrarily into memory ok so what can we do about this well one attempt might be to do the following so you could say let's	the following	231
and so we are just happy calling mem copy and if we were exhausted say there's four thousand and ninety six bytes we're going to start writing arbitrarily into memory ok so what can we do about this well one attempt might be to do the following so you could say let's	memory	160
let's take this line of codes to get up here and	code	24
is less than the length of the string	string	31
then don't even bother trying to copy it into the buffer instead let's just write out the whole thing so we could we could do that so we could write calls inside here to say alright right out to the string directly to the to the far descriptor but what do you think about that what kind of errors are we run into that ok so the problem with that approach is that we still got stuff inside the buffer that we haven't yet actually flushed out and those bites should appear before this string	string	199
ok so actually turns out this is not quite as easy as we first thought instead we need to do things like flush the current buffer and we can only add to it if we are sure that there's enough space so this actually cade of adding to the buffer is the exceptional case where there's enough space and it's the string itself is less than the complete size of the capacity of my buffer here ok so instead we want to do things like before attempting to write	string	307
when do we need to do that ok so couple of ideas here one is if the string you've given me anyways larger the capacity the other one is that in trying to add this string i've exhausted the size of my buffer anyway so the other possibility would be if the length plus the size in other words how big my current buffer is	string	68
also notice that we've had to do a mem copy here so that's the performance cost of of buffering which is now we're copying bytes into memory so if you're so we've traded one performance hick up for another so yes we can improve performance a little bit because we're not making lots and lots of lots of calls to the system for every little character in every little string that we're trying to send out but the expense but the way we paid for it is to now copy things into a single buffer so this is has some performance improvement but i hope you can see that for really specialized cases this distill has some performance penalty and so we could still do even better than that if we wanted to take control over own destiny and not use things like f board s to write truly performant code so yes we've reduced the number of system calls but we've paid for it by copying things into memory so there's an additional cost there alright so that's kind of quick sketch of the things we need to think about when implementing the c library are see you in the next video bye	memory	134
also notice that we've had to do a mem copy here so that's the performance cost of of buffering which is now we're copying bytes into memory so if you're so we've traded one performance hick up for another so yes we can improve performance a little bit because we're not making lots and lots of lots of calls to the system for every little character in every little string that we're trying to send out but the expense but the way we paid for it is to now copy things into a single buffer so this is has some performance improvement but i hope you can see that for really specialized cases this distill has some performance penalty and so we could still do even better than that if we wanted to take control over own destiny and not use things like f board s to write truly performant code so yes we've reduced the number of system calls but we've paid for it by copying things into memory so there's an additional cost there alright so that's kind of quick sketch of the things we need to think about when implementing the c library are see you in the next video bye	code	785
also notice that we've had to do a mem copy here so that's the performance cost of of buffering which is now we're copying bytes into memory so if you're so we've traded one performance hick up for another so yes we can improve performance a little bit because we're not making lots and lots of lots of calls to the system for every little character in every little string that we're trying to send out but the expense but the way we paid for it is to now copy things into a single buffer so this is has some performance improvement but i hope you can see that for really specialized cases this distill has some performance penalty and so we could still do even better than that if we wanted to take control over own destiny and not use things like f board s to write truly performant code so yes we've reduced the number of system calls but we've paid for it by copying things into memory so there's an additional cost there alright so that's kind of quick sketch of the things we need to think about when implementing the c library are see you in the next video bye	string	366
also notice that we've had to do a mem copy here so that's the performance cost of of buffering which is now we're copying bytes into memory so if you're so we've traded one performance hick up for another so yes we can improve performance a little bit because we're not making lots and lots of lots of calls to the system for every little character in every little string that we're trying to send out but the expense but the way we paid for it is to now copy things into a single buffer so this is has some performance improvement but i hope you can see that for really specialized cases this distill has some performance penalty and so we could still do even better than that if we wanted to take control over own destiny and not use things like f board s to write truly performant code so yes we've reduced the number of system calls but we've paid for it by copying things into memory so there's an additional cost there alright so that's kind of quick sketch of the things we need to think about when implementing the c library are see you in the next video bye	system	316
hi take a look at the following code we got quite a few things going on first of all we're actually using fork and remember what fork does focuses hey take this current process and duplicated for kits and now that you've got the original parent process and a child process and these two processes look very similar to one another they have the same variable setup they have they have some stack memory they have heap memory they have all of the program code but there is one little difference one easy way to tell whether you are in the parent on the child and the answer to that is what is your value of fork return	the following	18
hi take a look at the following code we got quite a few things going on first of all we're actually using fork and remember what fork does focuses hey take this current process and duplicated for kits and now that you've got the original parent process and a child process and these two processes look very similar to one another they have the same variable setup they have they have some stack memory they have heap memory they have all of the program code but there is one little difference one easy way to tell whether you are in the parent on the child and the answer to that is what is your value of fork return	heap memory	412
hi take a look at the following code we got quite a few things going on first of all we're actually using fork and remember what fork does focuses hey take this current process and duplicated for kits and now that you've got the original parent process and a child process and these two processes look very similar to one another they have the same variable setup they have they have some stack memory they have heap memory they have all of the program code but there is one little difference one easy way to tell whether you are in the parent on the child and the answer to that is what is your value of fork return	memory	395
hi take a look at the following code we got quite a few things going on first of all we're actually using fork and remember what fork does focuses hey take this current process and duplicated for kits and now that you've got the original parent process and a child process and these two processes look very similar to one another they have the same variable setup they have they have some stack memory they have heap memory they have all of the program code but there is one little difference one easy way to tell whether you are in the parent on the child and the answer to that is what is your value of fork return	code	32
i want the child to wait around a bit so let's just ask the child to sleep for say five seconds ok so only the child is going to execute that code the parent as it's executing this code will have a different value for this variable and an important idea here is just like if you're running gcc and i wanted to see if you want a cat and i'm running cat or ls or whatever right the variables inside that process are not shared so that's what's going on here immediately after that fork	code	142
from for cat that positive integer we now know that process idea pad so meanwhile the parent continued right so here's the parrot talking and saying i've got a two and a nine and if the parent and the child were playing poker at this point i really sure that the power is going to be able to predict what the child is going to say and if outlook here as a child talking now so here's a child with a different with the process id number that we expected saying my number is two and a nine yes so so the parent can actually predict what the child is going to do here even though it's just calling random random function because how does that random number function work yes is actually a pseudorandom number and in order to generate the next number inside our process memory there's a state	memory	766
still you have independent memory we ran the same set of steps aside apparent that the child was also late again i do when it's different piece of memory and therefore we could predict what the child is going "to do all right i hope you enjoyed this fun little example and good way to start thinking about processes and how cool it is to use forked actually kind of completely clone an existing process bye	memory	27
lag of backward back and forth before we can even start making our request so it's only in this last moment we acknowledge the other sequence number and we say ok i actually want to get something now ok but we've already wasted say ten milliseconds in setting up this connection and we need to do this for every new possible resource that we want to load on a page versus if we can negotiate keep alive then after we finished getting one resource we can then say oh and another thing i would like some dessert thank you very much waiter and i will after you brought me back my dessert i might ask for something else as well ok so that is kind of a key idea about why one point one simple protocol change actually we saw a very large increase in the performance of our web right what about a more modern protocol like version two point oh can you think of some advantages here	a page	358
and my tcp pipe now could behaves like walkway in a restaurant where i can have several waiters coming in bringing in different parts of my food all over the same tcp connection so i can ask for multiple things at the same time and they can be delivered piece meal as they ask the kitchen starts to prepare them ok what do we missed oh yes and lastly server push that hey the chef in the kitchen really would like you to have this desert you don't even know that you're going to choose chocolate pudding cake yet or ice cream or whatever that server just has a strong suspicion that you're really going to need this resource so we can actually help you create your web pages faster because when you do suddenly decide that oh yeah i really did need that cat jpeg you've already got it locally right so it's just kind of some of the somebody ventures of two point oh it's still not perfect however we still seeing what's called head of line blocking and the idea here is remember how tcp works that the kernel will reshuffle data so that if there's something missing ok we've received this stuff so far but right now this piece of data is missing we've got these pieces the kernel won't release the future data to us are read calls will block in other words until the day that finally this missing data has arrived and that might take awhile so	block	940
versus what i did it would have happened is that hey are those other resources that javascript file you were trying to download on all the stuff that isn't actually connected with these packets it would be great if we could have given that already to the client and then our web browser would have been faster	resources	69
ok so our game is to determine is that deadlock here right so let's sketch this out i'll start with some black just to put down my process is so i've got process one process to process three and this time a process four was well ok right process one gets a then be right	a process	205
k and you will be requesting being in the future but you haven't quite got there yet ok so what do we got right so is there deadlock well process one can continue as we mentioned that before so at some point in the future process one can release those resources ok so what happens next so now process two we set our locks were going to be so the access to this was going to be fair and so	resources	252
ah i look it almost works is kind of ninety nine percent of the way there most of the lines were rendered correctly unfortunately got a few missing ones but he never mind let's just run it again and maybe eventually we might get something that kind of works k let's try say two thousand does that help ah has made it worse ok so let's see what happened to our code what what caused it alible program bug right so let's go actually do a code review ok so right so here we go right	code	360
you might need a larger value to make it work on your machine that doesn't doesn't fill me with a sense of confidence quite the opposite i can sense of dread now how does this code possibly work that's just try deleting that line ok so i'm going to just comment it out right and will try compiling this	code	176
ah that's even worse ok so it looks like somehow for some reason these delay and there's print f actually useful for let's despairing printf back see what's happens ok right	printf	134
where where we write clearly printf is broken so why is it that this line whether we include print out or not seems to be changing our program whether adding this delay or not since we're changing our program i think it's time to delve into see exactly what this program is doing	printf	29
ok so let's see what it does right it initializes the gui will check out in a little bit we call kelak and we seem to be getting enough memory to hold air these thirty two bit integers and we also going to have another way on the heap for all of our threats that we're going to have a height number of threads and each one is size of p thread t ok so again not a point it looks good so far right now i gotta comment could offer alright this is giving me a suspicion that we might have have a steak inside here somewhere that's how look so we call patty at create we've pass in the address of my thread away	memory	136
ok so let's see what it does right it initializes the gui will check out in a little bit we call kelak and we seem to be getting enough memory to hold air these thirty two bit integers and we also going to have another way on the heap for all of our threats that we're going to have a height number of threads and each one is size of p thread t ok so again not a point it looks good so far right now i gotta comment could offer alright this is giving me a suspicion that we might have have a steak inside here somewhere that's how look so we call patty at create we've pass in the address of my thread away	the heap	226
ok so let's see what it does right it initializes the gui will check out in a little bit we call kelak and we seem to be getting enough memory to hold air these thirty two bit integers and we also going to have another way on the heap for all of our threats that we're going to have a height number of threads and each one is size of p thread t ok so again not a point it looks good so far right now i gotta comment could offer alright this is giving me a suspicion that we might have have a steak inside here somewhere that's how look so we call patty at create we've pass in the address of my thread away	thread	302
ok so let's see what it does right it initializes the gui will check out in a little bit we call kelak and we seem to be getting enough memory to hold air these thirty two bit integers and we also going to have another way on the heap for all of our threats that we're going to have a height number of threads and each one is size of p thread t ok so again not a point it looks good so far right now i gotta comment could offer alright this is giving me a suspicion that we might have have a steak inside here somewhere that's how look so we call patty at create we've pass in the address of my thread away	address	581
and then we say hey please run calculator two and here's the address of y all right so what is the address of why well why is	address	61
ok because we just calling pizza create and then we run through the same code that we saw before we're just going to go through and calculate a whole row why do you think we're running into problems with this code we seen segfaults we've seen missing lines but we've also seen lines which seemed to work correctly	code	73
r codes behavior depends upon lock basically do we feel lucky that we have a race between different threads as to who is going to see what value here's the problem we are giving it the address of why so we're not reading the actual value of white instead we're saying hey here's the address or something you might need and if we go and look at calculator	code	2
r codes behavior depends upon lock basically do we feel lucky that we have a race between different threads as to who is going to see what value here's the problem we are giving it the address of why so we're not reading the actual value of white instead we're saying hey here's the address or something you might need and if we go and look at calculator	thread	100
r codes behavior depends upon lock basically do we feel lucky that we have a race between different threads as to who is going to see what value here's the problem we are giving it the address of why so we're not reading the actual value of white instead we're saying hey here's the address or something you might need and if we go and look at calculator	address	185
here's what we do we say thank you for that void pointer	pointer	49
but i don't want to avoid point i know there's an integer that location so let me cast that argument as an end pointer and the only reason i need to write it like this is just because peter create create requires us to have a void pointer argument and avoid point of return value so great now i've got an integer value at that site interpoint sure i know there's never there so let me read it so that's the purpose of line ninety eight i've got myself that y value from the for loop and then i go ahead and calculate all my pixels	pointer	111
so what do we expect to find that memory location ok and here is the problem that now we're talking about multithreaded programs so i've gotta main thread that is happily going through this little loop as fast as it possibly can it's printing something out is creating a thread is doing a test it's calling sdr delay so this value of y is going to change as fast as it possibly can ok meanwhile we're going to ask to create a new thread so that new thread will read that memory location read the value of y as soon as it can but we don't know when that's going to be	memory	34
so what do we expect to find that memory location ok and here is the problem that now we're talking about multithreaded programs so i've gotta main thread that is happily going through this little loop as fast as it possibly can it's printing something out is creating a thread is doing a test it's calling sdr delay so this value of y is going to change as fast as it possibly can ok meanwhile we're going to ask to create a new thread so that new thread will read that memory location read the value of y as soon as it can but we don't know when that's going to be	a thread	269
so what do we expect to find that memory location ok and here is the problem that now we're talking about multithreaded programs so i've gotta main thread that is happily going through this little loop as fast as it possibly can it's printing something out is creating a thread is doing a test it's calling sdr delay so this value of y is going to change as fast as it possibly can ok meanwhile we're going to ask to create a new thread so that new thread will read that memory location read the value of y as soon as it can but we don't know when that's going to be	thread	111
that was a greater chance that when the thread create when the thread started it would actually see the intended value of y however it was not certain and in practice we were going to see things like two threads seeing the same value of why because of when the increment happened because when the value of y changed	thread	40
and as we saw uh there's no guarantee that that thread will be created before this loop finishes so we could get a completely arbitrary value of y here ok so this kind of pulling in print statements and noticing that our code works or doesn't work because of the side effects and our side effect here is the time it takes to do this print is very common experience when you're trying to debug incorrectly written multithreaded code or can count code even code it has multiple processes even code which runs on two different machines where the fact that it appears to work sometimes is purely down to luck so kind of great example of race conditions and soon we're going to start talking about how we can prevent these how we can actually get a handle on making sure that things happen in the order that we want them to but for now we've seen pthread_create, we've seen pthread_join and this is a great introduction to	code	221
and as we saw uh there's no guarantee that that thread will be created before this loop finishes so we could get a completely arbitrary value of y here ok so this kind of pulling in print statements and noticing that our code works or doesn't work because of the side effects and our side effect here is the time it takes to do this print is very common experience when you're trying to debug incorrectly written multithreaded code or can count code even code it has multiple processes even code which runs on two different machines where the fact that it appears to work sometimes is purely down to luck so kind of great example of race conditions and soon we're going to start talking about how we can prevent these how we can actually get a handle on making sure that things happen in the order that we want them to but for now we've seen pthread_create, we've seen pthread_join and this is a great introduction to	thread	48
incorrect programs like with that i wish you luck with your very first multithreaded programs have fun these examples are available in my github angry of lecture series so download them have a play with them and see what beautiful mountable pictures or even malleable gifs or gifts that you too can create with this code bye for now	code	316
incorrect programs like with that i wish you luck with your very first multithreaded programs have fun these examples are available in my github angry of lecture series so download them have a play with them and see what beautiful mountable pictures or even malleable gifs or gifts that you too can create with this code bye for now	thread	76
ok hi so let's see what happens if we have a hundred threads right so how can we implement this well this is how i've how i've attacked this right i needed an array to capture all of those thread i ds i'm going to hundred of them today and so when i call pthread_create() i need to pass in a pointer to that memory so i could write something like i need the address of my array and i take the i th	memory	308
ok hi so let's see what happens if we have a hundred threads right so how can we implement this well this is how i've how i've attacked this right i needed an array to capture all of those thread i ds i'm going to hundred of them today and so when i call pthread_create() i need to pass in a pointer to that memory so i could write something like i need the address of my array and i take the i th	thread	53
ok hi so let's see what happens if we have a hundred threads right so how can we implement this well this is how i've how i've attacked this right i needed an array to capture all of those thread i ds i'm going to hundred of them today and so when i call pthread_create() i need to pass in a pointer to that memory so i could write something like i need the address of my array and i take the i th	address	358
ok hi so let's see what happens if we have a hundred threads right so how can we implement this well this is how i've how i've attacked this right i needed an array to capture all of those thread i ds i'm going to hundred of them today and so when i call pthread_create() i need to pass in a pointer to that memory so i could write something like i need the address of my array and i take the i th	pointer	292
element but i can simplify that to just the pointer arithmetic on the array name and that gives me the address ten of the element inside that worked so great and then for each thread i'm going to ask you to run little function called shout and he's going to pass to shout when it starts when it finally gets a cpu core to run we're going to pass in the following memory address so what is that well it's a global variable i just want to reinforce the idea that all these threads are running inside one process and they can see memory outside of their own stack space ok so here's that shout function we're going to pass in as something on the stack of the thread this pointer and we do something with that so for example i could print it out as a pointer so arg is now holding a memory address so let's print out that memory address or flush it and what exit	the following	349
element but i can simplify that to just the pointer arithmetic on the array name and that gives me the address ten of the element inside that worked so great and then for each thread i'm going to ask you to run little function called shout and he's going to pass to shout when it starts when it finally gets a cpu core to run we're going to pass in the following memory address so what is that well it's a global variable i just want to reinforce the idea that all these threads are running inside one process and they can see memory outside of their own stack space ok so here's that shout function we're going to pass in as something on the stack of the thread this pointer and we do something with that so for example i could print it out as a pointer so arg is now holding a memory address so let's print out that memory address or flush it and what exit	memory	363
element but i can simplify that to just the pointer arithmetic on the array name and that gives me the address ten of the element inside that worked so great and then for each thread i'm going to ask you to run little function called shout and he's going to pass to shout when it starts when it finally gets a cpu core to run we're going to pass in the following memory address so what is that well it's a global variable i just want to reinforce the idea that all these threads are running inside one process and they can see memory outside of their own stack space ok so here's that shout function we're going to pass in as something on the stack of the thread this pointer and we do something with that so for example i could print it out as a pointer so arg is now holding a memory address so let's print out that memory address or flush it and what exit	thread	176
element but i can simplify that to just the pointer arithmetic on the array name and that gives me the address ten of the element inside that worked so great and then for each thread i'm going to ask you to run little function called shout and he's going to pass to shout when it starts when it finally gets a cpu core to run we're going to pass in the following memory address so what is that well it's a global variable i just want to reinforce the idea that all these threads are running inside one process and they can see memory outside of their own stack space ok so here's that shout function we're going to pass in as something on the stack of the thread this pointer and we do something with that so for example i could print it out as a pointer so arg is now holding a memory address so let's print out that memory address or flush it and what exit	address	103
element but i can simplify that to just the pointer arithmetic on the array name and that gives me the address ten of the element inside that worked so great and then for each thread i'm going to ask you to run little function called shout and he's going to pass to shout when it starts when it finally gets a cpu core to run we're going to pass in the following memory address so what is that well it's a global variable i just want to reinforce the idea that all these threads are running inside one process and they can see memory outside of their own stack space ok so here's that shout function we're going to pass in as something on the stack of the thread this pointer and we do something with that so for example i could print it out as a pointer so arg is now holding a memory address so let's print out that memory address or flush it and what exit	pointer	44
wait and then when i want to wait for all my fears to finish i could just call pizza at exit on my main bird instead less use pizza joint here and comment that well be careful because in the other functions i actually want the thread id not a pointer to that memory we only need to do that before because we're going to change it now then i actually want to refer to to an entry inside murray and which is over here	memory	259
wait and then when i want to wait for all my fears to finish i could just call pizza at exit on my main bird instead less use pizza joint here and comment that well be careful because in the other functions i actually want the thread id not a pointer to that memory we only need to do that before because we're going to change it now then i actually want to refer to to an entry inside murray and which is over here	thread	227
wait and then when i want to wait for all my fears to finish i could just call pizza at exit on my main bird instead less use pizza joint here and comment that well be careful because in the other functions i actually want the thread id not a pointer to that memory we only need to do that before because we're going to change it now then i actually want to refer to to an entry inside murray and which is over here	pointer	243
i could have written i want to dereference tds for my thread i ds plus i	thread	54
there we go but instead i prefer the kind of using the array syntax instead and we want to find out what the thread exited with so here's the address of a variable	thread	109
there we go but instead i prefer the kind of using the array syntax instead and we want to find out what the thread exited with so here's the address of a variable	address	142
wait let's turn it off right so gcc one hundred and don't forget to say oh by the way compiler you were using p threads great it worked less we run it all right and it produces lots and lots of output	thread	112
wait a moment today really did we really get a hundred there let's go and check did i actually write this up might put you know what it would be helpful i saved it yes always a good idea so now let's try it ok alright that looks a lot more like a hundred output will check in a moment notice that yeah it's happily printing out the address of my ray and the address there looks kind of reasonable that it looks like a low number that's going to be part of my global variables so how can i check that really did app print out other things what did i pipe the output into a little program called wc wc will tell me the number of lines	address	332
the number of words and the number of characters as well and if i wish i could actually just say ok only tell me about the number of lines that you see so yeah great we've confirmed that we manage to make a hundred threads and each one of them was responsible for printing out one thing now you might have guessed that my laptop here doesn't actually have a hundred cores so the operating system cheats virtually we can pretend that we have a hundred different cpus running but in reality what happens is that my poor little two or three or four cpus i got inside this machine actually going to be asked to keep changing from one thread to another thread so when a thread makes does something which blocks for example it cause sleep for example it cause read or write and those operations may take a while because there's no data get ready or is unavailable to send the data yet then will assign the cpu	block	699
the number of words and the number of characters as well and if i wish i could actually just say ok only tell me about the number of lines that you see so yeah great we've confirmed that we manage to make a hundred threads and each one of them was responsible for printing out one thing now you might have guessed that my laptop here doesn't actually have a hundred cores so the operating system cheats virtually we can pretend that we have a hundred different cpus running but in reality what happens is that my poor little two or three or four cpus i got inside this machine actually going to be asked to keep changing from one thread to another thread so when a thread makes does something which blocks for example it cause sleep for example it cause read or write and those operations may take a while because there's no data get ready or is unavailable to send the data yet then will assign the cpu	a thread	663
the number of words and the number of characters as well and if i wish i could actually just say ok only tell me about the number of lines that you see so yeah great we've confirmed that we manage to make a hundred threads and each one of them was responsible for printing out one thing now you might have guessed that my laptop here doesn't actually have a hundred cores so the operating system cheats virtually we can pretend that we have a hundred different cpus running but in reality what happens is that my poor little two or three or four cpus i got inside this machine actually going to be asked to keep changing from one thread to another thread so when a thread makes does something which blocks for example it cause sleep for example it cause read or write and those operations may take a while because there's no data get ready or is unavailable to send the data yet then will assign the cpu	thread	215
the number of words and the number of characters as well and if i wish i could actually just say ok only tell me about the number of lines that you see so yeah great we've confirmed that we manage to make a hundred threads and each one of them was responsible for printing out one thing now you might have guessed that my laptop here doesn't actually have a hundred cores so the operating system cheats virtually we can pretend that we have a hundred different cpus running but in reality what happens is that my poor little two or three or four cpus i got inside this machine actually going to be asked to keep changing from one thread to another thread so when a thread makes does something which blocks for example it cause sleep for example it cause read or write and those operations may take a while because there's no data get ready or is unavailable to send the data yet then will assign the cpu	system	389
to something else you could think of this like a cook in the kitchen that is always busy working on different orders and at some point one order well we've gotta wait for the fish to fry or the peas to boil so we'll send our cook off to work on a different order and when at some point that cook has to kind of come back of course our cpu cores will keep switching about every millisecond so from human perception point of view we might believe they've actually we've got many more cpu cores available then we truly have alright that's it for this introduction to threads and i'll see you in a future video in a future lecture thanks bye	thread	564
and for that we really don't need to understand how to work with errors and how to print out errors and how to discover when things don't work so networking is tricky because with things don't work where you actually want to understand what your problem with the client or the server was there a problem in setting up the connection and so dealing with errors becomes quite important areas can be because of code areas we've made but it also can be say because the client has finished the connection before the server had finished saying everything he wanted to say unvoice versa ok so let's start talking about errors that right so	code	408
you want to put out some errors ok so here's first way you've probably seen things like ok i can use p error to print an error to standard error and i can include piece of text here which gets included along with some standard string ok there's also if you prefer a way to get just a simple string and this is it you can say store error and i can ask for a	string	227
the string associated with a particular error number like one two three four five etc etc etc ok but perhaps you want to know what is actually just gone wrong with your program and so if you want to find out the air associated with a recent system call guess what there is something called ever know urdu there we go so i could say please tell me	string	4
the string associated with a particular error number like one two three four five etc etc etc ok but perhaps you want to know what is actually just gone wrong with your program and so if you want to find out the air associated with a recent system call guess what there is something called ever know urdu there we go so i could say please tell me	system	241
the these string associated with the most recent system ever ok so in fact we could re implement pm so if we needed to write kind of piero ourselves we might do something like the following we might say ok so peer error i just want to print out to standard error	the following	176
the these string associated with the most recent system ever ok so in fact we could re implement pm so if we needed to write kind of piero ourselves we might do something like the following we might say ok so peer error i just want to print out to standard error	string	10
the these string associated with the most recent system ever ok so in fact we could re implement pm so if we needed to write kind of piero ourselves we might do something like the following we might say ok so peer error i just want to print out to standard error	system	49
format string to say whatever the user said ok cologne another	string	7
ok and then another string	string	20
right so there's a one big surprising gotcher however with string ever and if the following if we actually read the manpage we discover that let's come back	the following	78
right so there's a one big surprising gotcher however with string ever and if the following if we actually read the manpage we discover that let's come back	string	59
a different color that it is not thread safe	thread	33
video surprise right here we are using this low function inside here and we thought we could do everything we wanted inside our threads it's not thread safe key and if we instead we actually want to write code that is two s dave then	code	205
video surprise right here we are using this low function inside here and we thought we could do everything we wanted inside our threads it's not thread safe key and if we instead we actually want to write code that is two s dave then	thread	128
so the reason for that is that string air itself might return just a hardcoded string literal safer error number one two three four five six etc but if you pass an arbitrary large number it actually constructs	code	73
so the reason for that is that string air itself might return just a hardcoded string literal safer error number one two three four five six etc but if you pass an arbitrary large number it actually constructs	string	31
the string itself and how it might do that well it could call malloc except that stuart air itself doesn't ask you to return anything instead it just returns a pointer so instead internally has some static	string	4
the string itself and how it might do that well it could call malloc except that stuart air itself doesn't ask you to return anything instead it just returns a pointer so instead internally has some static	pointer	160
static memory that it reuses from one call to the next ok so that's our problem that if i'm going to use this in multiple threads i could have one call to store arribe be entered by another call to stuart error	memory	7
static memory that it reuses from one call to the next ok so that's our problem that if i'm going to use this in multiple threads i could have one call to store arribe be entered by another call to stuart error	thread	122
on a different thread an oh dear both of them are now trying to use the same piece of static memory so one hour is going to override the other one right so this kind of common with some of the earlier calls inside posix that they weren't built with with threads in mind and so threat support the ability to work with multiple threads has kind of been reverse engineered back into some of these api calls so stroit error itself with this underscore r will discover actually	memory	93
on a different thread an oh dear both of them are now trying to use the same piece of static memory so one hour is going to override the other one right so this kind of common with some of the earlier calls inside posix that they weren't built with with threads in mind and so threat support the ability to work with multiple threads has kind of been reverse engineered back into some of these api calls so stroit error itself with this underscore r will discover actually	thread	15
doesn't have doesn't take just a simple integer for the integer or no instead you also pass in a pointer to your memory that you would like it to use so here's some memory and typically as well you impasse in how much many as well so we could pull up a terminal window to see the exact order of these things but what i want you to learn yeah there's quite a few of these kind of underscore are variations or variants of existing course and they were added later to posix	memory	113
doesn't have doesn't take just a simple integer for the integer or no instead you also pass in a pointer to your memory that you would like it to use so here's some memory and typically as well you impasse in how much many as well so we could pull up a terminal window to see the exact order of these things but what i want you to learn yeah there's quite a few of these kind of underscore are variations or variants of existing course and they were added later to posix	a terminal	251
doesn't have doesn't take just a simple integer for the integer or no instead you also pass in a pointer to your memory that you would like it to use so here's some memory and typically as well you impasse in how much many as well so we could pull up a terminal window to see the exact order of these things but what i want you to learn yeah there's quite a few of these kind of underscore are variations or variants of existing course and they were added later to posix	pointer	97
in order to make it more thread safe now the last thing you might have been thinking about when i was talking about this is hold on a moment what about earner what is this other thing and wins it set ok so oh no is set by most system calls that can fail so for example read or write set errno to tell you what went wrong so if you call right and it doesn't work	thread	25
in order to make it more thread safe now the last thing you might have been thinking about when i was talking about this is hold on a moment what about earner what is this other thing and wins it set ok so oh no is set by most system calls that can fail so for example read or write set errno to tell you what went wrong so if you call right and it doesn't work	system	227
oh dear it will return negative one but you want to find out more about what went wrong so that information is encoded inside this global variable but wait a moment if i've got a multithreaded program surely it's going to be really hard to figure out which particular thread on which system call caused evernote change	code	113
oh dear it will return negative one but you want to find out more about what went wrong so that information is encoded inside this global variable but wait a moment if i've got a multithreaded program surely it's going to be really hard to figure out which particular thread on which system call caused evernote change	thread	184
oh dear it will return negative one but you want to find out more about what went wrong so that information is encoded inside this global variable but wait a moment if i've got a multithreaded program surely it's going to be really hard to figure out which particular thread on which system call caused evernote change	system	284
yes you are correct and now i'm forced to tell you that actually ok that ever know actually for multithreaded programs	thread	101
is a very special variably behaves like a global variable but actually it's three uses thread local storage which means that each thread gets his own copy thread local storage each thread gets its own copy of error	thread	87
it still behaves like a global variable but the value that each thread reads is actually specific to that thread so now you can confidently say oh yes that most recent call to read	thread	64
or write or say creating a pipe that if it failed then i can read my own value of owner to find out why it fell ok wait so in the next video we're going to talk about what happens when system calls get interrupted i'll see you then bye	system	185
and for that we really don't need to understand how to work with errors and how to print out errors and how to discover when things don't work so networking is tricky because with things don't work where you actually want to understand what your problem with the client or the server was there a problem in setting up the connection and so dealing with errors becomes quite important areas can be because of code areas we've made but it also can be say because the client has finished the connection before the server had finished saying everything he wanted to say unvoice versa ok so let's start talking about errors that right so	code	408
you want to put out some errors ok so here's first way you've probably seen things like ok i can use p error to print an error to standard error and i can include piece of text here which gets included along with some standard string ok there's also if you prefer a way to get just a simple string and this is it you can say store error and i can ask for a	string	227
the string associated with a particular error number like one two three four five etc etc etc ok but perhaps you want to know what is actually just gone wrong with your program and so if you want to find out the air associated with a recent system call guess what there is something called ever know urdu there we go so i could say please tell me	string	4
the string associated with a particular error number like one two three four five etc etc etc ok but perhaps you want to know what is actually just gone wrong with your program and so if you want to find out the air associated with a recent system call guess what there is something called ever know urdu there we go so i could say please tell me	system	241
the these string associated with the most recent system ever ok so in fact we could re implement pm so if we needed to write kind of piero ourselves we might do something like the following we might say ok so peer error i just want to print out to standard error	the following	176
the these string associated with the most recent system ever ok so in fact we could re implement pm so if we needed to write kind of piero ourselves we might do something like the following we might say ok so peer error i just want to print out to standard error	string	10
the these string associated with the most recent system ever ok so in fact we could re implement pm so if we needed to write kind of piero ourselves we might do something like the following we might say ok so peer error i just want to print out to standard error	system	49
format string to say whatever the user said ok cologne another	string	7
ok and then another string	string	20
right so there's a one big surprising gotcher however with string ever and if the following if we actually read the manpage we discover that let's come back	the following	78
right so there's a one big surprising gotcher however with string ever and if the following if we actually read the manpage we discover that let's come back	string	59
a different color that it is not thread safe	thread	33
video surprise right here we are using this low function inside here and we thought we could do everything we wanted inside our threads it's not thread safe key and if we instead we actually want to write code that is two s dave then	code	205
video surprise right here we are using this low function inside here and we thought we could do everything we wanted inside our threads it's not thread safe key and if we instead we actually want to write code that is two s dave then	thread	128
so the reason for that is that string air itself might return just a hardcoded string literal safer error number one two three four five six etc but if you pass an arbitrary large number it actually constructs	code	73
so the reason for that is that string air itself might return just a hardcoded string literal safer error number one two three four five six etc but if you pass an arbitrary large number it actually constructs	string	31
the string itself and how it might do that well it could call malloc except that stuart air itself doesn't ask you to return anything instead it just returns a pointer so instead internally has some static	string	4
the string itself and how it might do that well it could call malloc except that stuart air itself doesn't ask you to return anything instead it just returns a pointer so instead internally has some static	pointer	160
static memory that it reuses from one call to the next ok so that's our problem that if i'm going to use this in multiple threads i could have one call to store arribe be entered by another call to stuart error	memory	7
static memory that it reuses from one call to the next ok so that's our problem that if i'm going to use this in multiple threads i could have one call to store arribe be entered by another call to stuart error	thread	122
on a different thread an oh dear both of them are now trying to use the same piece of static memory so one hour is going to override the other one right so this kind of common with some of the earlier calls inside posix that they weren't built with with threads in mind and so threat support the ability to work with multiple threads has kind of been reverse engineered back into some of these api calls so stroit error itself with this underscore r will discover actually	memory	93
on a different thread an oh dear both of them are now trying to use the same piece of static memory so one hour is going to override the other one right so this kind of common with some of the earlier calls inside posix that they weren't built with with threads in mind and so threat support the ability to work with multiple threads has kind of been reverse engineered back into some of these api calls so stroit error itself with this underscore r will discover actually	thread	15
doesn't have doesn't take just a simple integer for the integer or no instead you also pass in a pointer to your memory that you would like it to use so here's some memory and typically as well you impasse in how much many as well so we could pull up a terminal window to see the exact order of these things but what i want you to learn yeah there's quite a few of these kind of underscore are variations or variants of existing course and they were added later to posix	memory	113
doesn't have doesn't take just a simple integer for the integer or no instead you also pass in a pointer to your memory that you would like it to use so here's some memory and typically as well you impasse in how much many as well so we could pull up a terminal window to see the exact order of these things but what i want you to learn yeah there's quite a few of these kind of underscore are variations or variants of existing course and they were added later to posix	a terminal	251
doesn't have doesn't take just a simple integer for the integer or no instead you also pass in a pointer to your memory that you would like it to use so here's some memory and typically as well you impasse in how much many as well so we could pull up a terminal window to see the exact order of these things but what i want you to learn yeah there's quite a few of these kind of underscore are variations or variants of existing course and they were added later to posix	pointer	97
in order to make it more thread safe now the last thing you might have been thinking about when i was talking about this is hold on a moment what about earner what is this other thing and wins it set ok so oh no is set by most system calls that can fail so for example read or write set errno to tell you what went wrong so if you call right and it doesn't work	thread	25
in order to make it more thread safe now the last thing you might have been thinking about when i was talking about this is hold on a moment what about earner what is this other thing and wins it set ok so oh no is set by most system calls that can fail so for example read or write set errno to tell you what went wrong so if you call right and it doesn't work	system	227
oh dear it will return negative one but you want to find out more about what went wrong so that information is encoded inside this global variable but wait a moment if i've got a multithreaded program surely it's going to be really hard to figure out which particular thread on which system call caused evernote change	code	113
oh dear it will return negative one but you want to find out more about what went wrong so that information is encoded inside this global variable but wait a moment if i've got a multithreaded program surely it's going to be really hard to figure out which particular thread on which system call caused evernote change	thread	184
oh dear it will return negative one but you want to find out more about what went wrong so that information is encoded inside this global variable but wait a moment if i've got a multithreaded program surely it's going to be really hard to figure out which particular thread on which system call caused evernote change	system	284
yes you are correct and now i'm forced to tell you that actually ok that ever know actually for multithreaded programs	thread	101
is a very special variably behaves like a global variable but actually it's three uses thread local storage which means that each thread gets his own copy thread local storage each thread gets its own copy of error	thread	87
it still behaves like a global variable but the value that each thread reads is actually specific to that thread so now you can confidently say oh yes that most recent call to read	thread	64
or write or say creating a pipe that if it failed then i can read my own value of owner to find out why it fell ok wait so in the next video we're going to talk about what happens when system calls get interrupted i'll see you then bye	system	185
right ok so here's some good news the pthread actually already implements barriers for us so this is how a barrier works it's very very simple we won't necessarily use it inside cs two forty one because inside two forty one we're going to ask you to actually write your own barrier but outside of this class now you actually understand the ground rules and how these actually work next time you need to write some code that needs a barrier hey just turn to pthread and you've already got one out of the box ok so what do we got when we create a barrier	code	414
right ok so here's some good news the pthread actually already implements barriers for us so this is how a barrier works it's very very simple we won't necessarily use it inside cs two forty one because inside two forty one we're going to ask you to actually write your own barrier but outside of this class now you actually understand the ground rules and how these actually work next time you need to write some code that needs a barrier hey just turn to pthread and you've already got one out of the box ok so what do we got when we create a barrier	thread	39
then you call pthread barrier initiate you pass in one of these type and you say how many threads need to arrive at this barrier before we let them carry on so for example that let's say that i'm going to say write five threads need to arrive at this barrier and when we finished there's also destroy method as usual so how do you say that my thread should wait and is arrived at the barrier easy call pthread barrier wait and at that point your thread will block and it's going to block until in this case for other threads also called p thread barrier wait on the same object on the same barrier right so now i can start holota threads work on my matrix download different files and as each one continues finishes their little task they can call preferred barrier and will know that they will get stuck in there	block	458
then you call pthread barrier initiate you pass in one of these type and you say how many threads need to arrive at this barrier before we let them carry on so for example that let's say that i'm going to say write five threads need to arrive at this barrier and when we finished there's also destroy method as usual so how do you say that my thread should wait and is arrived at the barrier easy call pthread barrier wait and at that point your thread will block and it's going to block until in this case for other threads also called p thread barrier wait on the same object on the same barrier right so now i can start holota threads work on my matrix download different files and as each one continues finishes their little task they can call preferred barrier and will know that they will get stuck in there	type	64
then you call pthread barrier initiate you pass in one of these type and you say how many threads need to arrive at this barrier before we let them carry on so for example that let's say that i'm going to say write five threads need to arrive at this barrier and when we finished there's also destroy method as usual so how do you say that my thread should wait and is arrived at the barrier easy call pthread barrier wait and at that point your thread will block and it's going to block until in this case for other threads also called p thread barrier wait on the same object on the same barrier right so now i can start holota threads work on my matrix download different files and as each one continues finishes their little task they can call preferred barrier and will know that they will get stuck in there	a thread	628
then you call pthread barrier initiate you pass in one of these type and you say how many threads need to arrive at this barrier before we let them carry on so for example that let's say that i'm going to say write five threads need to arrive at this barrier and when we finished there's also destroy method as usual so how do you say that my thread should wait and is arrived at the barrier easy call pthread barrier wait and at that point your thread will block and it's going to block until in this case for other threads also called p thread barrier wait on the same object on the same barrier right so now i can start holota threads work on my matrix download different files and as each one continues finishes their little task they can call preferred barrier and will know that they will get stuck in there	thread	15
like a little holding pen and will only continue when they all arrive at that point so if you like is like a little kind of party to say ok will get this party started only when all of my friends have actually arrived "at the barrier and the nice thing about pthread barriers is is that they are reusable so after the fifth thread	thread	260
has called barrier wait they'll get released and my barrio reset so now i can call weight again and i'll get stuck until my four other threads for other friends and colleagues have also called p thread barrier wait wait there's one little kind of fun thing by the way about pthread barrier is that one thread will get a magic value here called p thread serial thread and that is useful if you want to do if you want one thread to do something special all of the other threads after returning from p third barrier wait just get a value of o ok so if you want to annotate one particular thread to do some special just take that return value see if it returns this and you can then say ok special thread you can go off and also download this other thing or perhaps save something so for example is quite common that you might have multiple calculation threads and then after they've all finished one thread you'd like to actually save the results to a file and then do more calculation that kind of thing so that allows you to especially choose one thread ok so in the next video we're actually going to implement off our first barrier alright i'll see you then	thread	135
hi so what's the difference between a process anna thread oh answer many things so the first of all let's think about the performance of creating a process versus creating a thread a thread is a very lightweight object we can create one in microseconds that it only takes a few thousand instructions or so to create	a thread	49
hi so what's the difference between a process anna thread oh answer many things so the first of all let's think about the performance of creating a process versus creating a thread a thread is a very lightweight object we can create one in microseconds that it only takes a few thousand instructions or so to create	a process	36
hi so what's the difference between a process anna thread oh answer many things so the first of all let's think about the performance of creating a process versus creating a thread a thread is a very lightweight object we can create one in microseconds that it only takes a few thousand instructions or so to create	thread	51
a thread and then ask it to be scheduled to be run so	a thread	0
a thread and then ask it to be scheduled to be run so	thread	2
a thread is much lighter to create compared to process a process we've got to clone all the memory we've got to prepare for a much larger thing right and realized it self itself the process	memory	92
a thread is much lighter to create compared to process a process we've got to clone all the memory we've got to prepare for a much larger thing right and realized it self itself the process	a thread	0
a thread is much lighter to create compared to process a process we've got to clone all the memory we've got to prepare for a much larger thing right and realized it self itself the process	a process	55
a thread is much lighter to create compared to process a process we've got to clone all the memory we've got to prepare for a much larger thing right and realized it self itself the process	thread	2
has many items we've got we've got security items to talk about we've got signal handles to talk about so a process that was much heavier way object the other thing that you've seen is that a thread can finish but the process itself can continue so let's talk about	a thread	190
has many items we've got we've got security items to talk about we've got signal handles to talk about so a process that was much heavier way object the other thing that you've seen is that a thread can finish but the process itself can continue so let's talk about	a process	106
has many items we've got we've got security items to talk about we've got signal handles to talk about so a process that was much heavier way object the other thing that you've seen is that a thread can finish but the process itself can continue so let's talk about	thread	192
the differences in how how they exit by its so with a process we've seen examples where if i called exit or if i return from main	a process	52
then the whole process is done and of course if the process disappears all of the cpu threads are going to disappear as well because now we don't have any memory for them to run on versus a thread you seen how we create it and then destroy it through either p thread	memory	155
then the whole process is done and of course if the process disappears all of the cpu threads are going to disappear as well because now we don't have any memory for them to run on versus a thread you seen how we create it and then destroy it through either p thread	a thread	188
then the whole process is done and of course if the process disappears all of the cpu threads are going to disappear as well because now we don't have any memory for them to run on versus a thread you seen how we create it and then destroy it through either p thread	thread	86
the we can have many many threads inside one process it doesn't make sense to talk about it the other way	thread	26
also realize that if a process stops for some other reason like one particular thread causes a bus error or a segmentation fault and we decide to destroy the process then all of your threads will disappear as well so watch out agent smith thread if you start making other threads misbehave that might be the end of you ok but the big difference is the idea that all threads live inside the process memory and they can all kind of cooperate and there much faster to create and destroy compared to a process so they are very powerful and multithreaded programs who are very common way to write programs today	memory	398
also realize that if a process stops for some other reason like one particular thread causes a bus error or a segmentation fault and we decide to destroy the process then all of your threads will disappear as well so watch out agent smith thread if you start making other threads misbehave that might be the end of you ok but the big difference is the idea that all threads live inside the process memory and they can all kind of cooperate and there much faster to create and destroy compared to a process so they are very powerful and multithreaded programs who are very common way to write programs today	a process	21
also realize that if a process stops for some other reason like one particular thread causes a bus error or a segmentation fault and we decide to destroy the process then all of your threads will disappear as well so watch out agent smith thread if you start making other threads misbehave that might be the end of you ok but the big difference is the idea that all threads live inside the process memory and they can all kind of cooperate and there much faster to create and destroy compared to a process so they are very powerful and multithreaded programs who are very common way to write programs today	thread	79
with so we're that i'll see you in the next video where we took about p thread cancel already go	thread	72
we need two to the twenty entries because there's a up to two to the twenty pages ok so this gives us a page table of size two to the twenty two	a page	102
we need two to the twenty entries because there's a up to two to the twenty pages ok so this gives us a page table of size two to the twenty two	a page table	102
k two to twenty two bytes right how can we be that off well as usual remember the two to the ten is thousand twenty four so two to the twenty is a megabyte or meg ok so what if i got here there is four megabytes alright as a massive improvement over our first design in other words there's an overhead or four megabytes for every process that we want to create so even if my processes tiny even if it only takes one hundred kb actually i'm going to give four megabytes of space that i need to find inside my real memory to hold this page table and worse it needs to be four megabytes of contiguous memory as well in order for the hardware to do is look up so it's ok but maybe we can do better than this and so a key idea is maybe we should actually make not just a single level page table	memory	513
k two to twenty two bytes right how can we be that off well as usual remember the two to the ten is thousand twenty four so two to the twenty is a megabyte or meg ok so what if i got here there is four megabytes alright as a massive improvement over our first design in other words there's an overhead or four megabytes for every process that we want to create so even if my processes tiny even if it only takes one hundred kb actually i'm going to give four megabytes of space that i need to find inside my real memory to hold this page table and worse it needs to be four megabytes of contiguous memory as well in order for the hardware to do is look up so it's ok but maybe we can do better than this and so a key idea is maybe we should actually make not just a single level page table	a megabyte	145
so here's the plan let's have a top level page table there is only going to be used as input these top most bits so we can think of this like a directory into some other page table look up 's as well so ultimately we're still going to do a mapping from a page number to a physical frame but we're going to do it in two stages these kind of top level ten bits ok will go into this first look up table	a page	253
if each entry is four bytes then the total size of this is going to be two to the twelve in other words four thousand ninety six bytes or in other words four kb ok so that's its size in memory so this little directory will fit really neatly into a single frame isn't that great a single page or look what happened to answer right so anyway so our first invites will give us an enter inside here	memory	186
and our second read then will say ok also in main memory somewhere there is none other entry another table here ok and as input we're going to use these middle unused ten bits here here ok so these ten bits green here so same argument applies we've got two to the ten entries here and as usual each one is should be attend	memory	50
each one is four bytes ok so again this little table will fit snugly inside four thousand ninety six bytes so for example the one i'm currently drawing might just happen to live inside my physical memory just here right and then finally when that when we read that out or other when the hardware but instead out finally it says ok this is the actual physical frame that you'll find the users data in all the user program might go over to this frame here ok and that is why i say the heat bite is all the program bite or whatever it is	memory	197
ok so why are we doing this madness otherwise so one is to notice that these frames no longer need to be contiguous they could be placed anywhere in memory	memory	149
so we only actually need to instantiate limited set of these secondary vlookups ok the ones which actually cause one door ideas valid memory dresses so now i	memory	134
to get me a frame number and then finally we get to actually read the users bite say inside the heap so congratulations it now takes three memory address look up 's in order to do anything so my machine is now three times slower anytime it does a main memory access ok so we need to come up with a way to fix that and how do we do that i'll talk about it in the next video bye	memory	139
to get me a frame number and then finally we get to actually read the users bite say inside the heap so congratulations it now takes three memory address look up 's in order to do anything so my machine is now three times slower anytime it does a main memory access ok so we need to come up with a way to fix that and how do we do that i'll talk about it in the next video bye	the heap	92
to get me a frame number and then finally we get to actually read the users bite say inside the heap so congratulations it now takes three memory address look up 's in order to do anything so my machine is now three times slower anytime it does a main memory access ok so we need to come up with a way to fix that and how do we do that i'll talk about it in the next video bye	address	146
hi ok so we're going to attack the following problem we want to write a function to return of items in it into two away before the value of negative one is found	the following	31
and to make it tricky we're not going to use any counters we're just going to use pointer arithmetic ok so here's the challenge denton right so i'm going to take a memory address which will be the value of where this array starts in memory it's actual memory location and i want to keep walking through that reading each integer until i find negative one so his head will do this then so i'll have another variable my little pointer here and that's what we're going to keep changing and will keep incrementing it until we get to that negative one so it's so i want to see the value of the current address so let's use that point to remember pointers are meant to be used most of the time let's actually dereference him let's actually go and read the stuff at that memory right so once that is not equal to negative one what i want to do is change my pointer what do i want to move it to the next values so i could write pointer equals point oh plus one but i could shorten that two plus plus and with pointer arithmetic if we add one the compilers going today or this pointer points to integers so i need to move it not just one bite forward but enough bytes forward so that it can actually access the next integer so the type is always used with the pointer arithmetic right so we're going to go round and we're going to keep moving forward reading integers hopefully we're going to find that negative one at some point which point how can we discover the integer well so i discovered the number of items we need to read so items into the interval before validated was found so here's kind of the big surprise if i now take that address and subtract off the other address of where we started then that subtraction again is pointer arithmetic which means that the size of the pointers matches so this won't tell me the number of bytes between where we ended up and where we started will actually tell me the number of integers that we needed to advance in order to find that negative one so that's kind of a fun little pointer arithmetic problem and in the next video what are we going to do yes i'm going to challenge for you how could we possibly be that p one and p two actually refer to the same memory location as it did that in the next video bye	memory	164
and to make it tricky we're not going to use any counters we're just going to use pointer arithmetic ok so here's the challenge denton right so i'm going to take a memory address which will be the value of where this array starts in memory it's actual memory location and i want to keep walking through that reading each integer until i find negative one so his head will do this then so i'll have another variable my little pointer here and that's what we're going to keep changing and will keep incrementing it until we get to that negative one so it's so i want to see the value of the current address so let's use that point to remember pointers are meant to be used most of the time let's actually dereference him let's actually go and read the stuff at that memory right so once that is not equal to negative one what i want to do is change my pointer what do i want to move it to the next values so i could write pointer equals point oh plus one but i could shorten that two plus plus and with pointer arithmetic if we add one the compilers going today or this pointer points to integers so i need to move it not just one bite forward but enough bytes forward so that it can actually access the next integer so the type is always used with the pointer arithmetic right so we're going to go round and we're going to keep moving forward reading integers hopefully we're going to find that negative one at some point which point how can we discover the integer well so i discovered the number of items we need to read so items into the interval before validated was found so here's kind of the big surprise if i now take that address and subtract off the other address of where we started then that subtraction again is pointer arithmetic which means that the size of the pointers matches so this won't tell me the number of bytes between where we ended up and where we started will actually tell me the number of integers that we needed to advance in order to find that negative one so that's kind of a fun little pointer arithmetic problem and in the next video what are we going to do yes i'm going to challenge for you how could we possibly be that p one and p two actually refer to the same memory location as it did that in the next video bye	type	1222
and to make it tricky we're not going to use any counters we're just going to use pointer arithmetic ok so here's the challenge denton right so i'm going to take a memory address which will be the value of where this array starts in memory it's actual memory location and i want to keep walking through that reading each integer until i find negative one so his head will do this then so i'll have another variable my little pointer here and that's what we're going to keep changing and will keep incrementing it until we get to that negative one so it's so i want to see the value of the current address so let's use that point to remember pointers are meant to be used most of the time let's actually dereference him let's actually go and read the stuff at that memory right so once that is not equal to negative one what i want to do is change my pointer what do i want to move it to the next values so i could write pointer equals point oh plus one but i could shorten that two plus plus and with pointer arithmetic if we add one the compilers going today or this pointer points to integers so i need to move it not just one bite forward but enough bytes forward so that it can actually access the next integer so the type is always used with the pointer arithmetic right so we're going to go round and we're going to keep moving forward reading integers hopefully we're going to find that negative one at some point which point how can we discover the integer well so i discovered the number of items we need to read so items into the interval before validated was found so here's kind of the big surprise if i now take that address and subtract off the other address of where we started then that subtraction again is pointer arithmetic which means that the size of the pointers matches so this won't tell me the number of bytes between where we ended up and where we started will actually tell me the number of integers that we needed to advance in order to find that negative one so that's kind of a fun little pointer arithmetic problem and in the next video what are we going to do yes i'm going to challenge for you how could we possibly be that p one and p two actually refer to the same memory location as it did that in the next video bye	address	171
and to make it tricky we're not going to use any counters we're just going to use pointer arithmetic ok so here's the challenge denton right so i'm going to take a memory address which will be the value of where this array starts in memory it's actual memory location and i want to keep walking through that reading each integer until i find negative one so his head will do this then so i'll have another variable my little pointer here and that's what we're going to keep changing and will keep incrementing it until we get to that negative one so it's so i want to see the value of the current address so let's use that point to remember pointers are meant to be used most of the time let's actually dereference him let's actually go and read the stuff at that memory right so once that is not equal to negative one what i want to do is change my pointer what do i want to move it to the next values so i could write pointer equals point oh plus one but i could shorten that two plus plus and with pointer arithmetic if we add one the compilers going today or this pointer points to integers so i need to move it not just one bite forward but enough bytes forward so that it can actually access the next integer so the type is always used with the pointer arithmetic right so we're going to go round and we're going to keep moving forward reading integers hopefully we're going to find that negative one at some point which point how can we discover the integer well so i discovered the number of items we need to read so items into the interval before validated was found so here's kind of the big surprise if i now take that address and subtract off the other address of where we started then that subtraction again is pointer arithmetic which means that the size of the pointers matches so this won't tell me the number of bytes between where we ended up and where we started will actually tell me the number of integers that we needed to advance in order to find that negative one so that's kind of a fun little pointer arithmetic problem and in the next video what are we going to do yes i'm going to challenge for you how could we possibly be that p one and p two actually refer to the same memory location as it did that in the next video bye	pointer	82
ok my recording yes great ok right so what do we got we have this time we're going to have three processes so let me kind of sketched out again alright so i'm going to have process one over here and then process two process three ok an we sketched out a timeline of events that we'd like to simulate and we're going to see if we run into deadlock at some point ok or if we manage to go through all of this without running into any issues so process one requests ea ok so here's my resource a this nice chocolate inside the middle of the box here ok so process one yeah you could have the chocolate ok no one needs it right now ok so there you go right and then process two requests be ok so yes you get sure where my lines are so curvy today right they should i wanted to draw straight lines i know that's why yeah let's do that so put three request see ok which places although it's only about right i want to go back there we go right to there we go right so process three gets gets see in fact i like that that line so much i'm going to order them like that ok so process one yeah you get a process to you get be processed three you get see ok so we've done the first three now it starts to get interesting so process two is going to ask for c but you can see that's not going to happen ok so let's start during these in different colours came so process to you wanted see we're doing this line here key	a process	1092
itching to get that block but unable to ok so we've done that and now process worn requests see ok so process one alright let's we have done blue yet so let's do that right process one you request see ok so write down you go	block	20
so let's see if i can choose a new color will go for say this line color here right so right so where is my cycle right so we can see that i actually have this this kind of cross figure here that my process wall is looking at see ok but see is held by process three which is but process three is waiting for a which is hereby process one which isn't going to go anywhere because it's waiting for c which is held by process three so i've got this little kind of boat i'm not here where i've got these two processes unable to continue their both hungrily staring at each others resources in order to continue and what about process to process to actually is the innocent bystander in this there is also waiting for resource see but itself is not	resources	576
the reason for the deadlock ok yeah it's waiting for c but if we were to delete process two right now it wouldn't help us with any of the other problems ok versus if was to delete process three or process one then the remaining forces could continue so it kind of isn't important idea that that you'll see this kind of chain reaction that now because i've got two stuck processes which will never get there give up their resources if i now have other processes which also dependa pawn those resources they get stuck as well so for example suppose i now had something else which was relate waiting for this resource be	resources	421
actually occurs definitely depends upon the order in which our process is request a resources for example suppose the ordering had been that process one had obtained all of its resources that it needed so if for example we made process one obtain see up here right so suppose the interleaving of these operations was different then process one would have got everything it needed would have this chocolate and that chocolate ok and then it could have completed its task and then process one wouldn't need these resources anymore and so then process three could have continued as well so yeah the ordering of how our process is request resources is criticals to whether we're going to actually generate a cycle in the wait for graph or not	resources	84
hi welcome ok so we're going to do two fun things unless made a program that is self aware and prints himself out and a second one which is the most powerful program world are you ready let's go so here's here's my first [test] challenge to you is we want to change this program so that it actually can print itself out how can we do that well you might be tempted to do the following let's change the argument to cat to be ok i need the program name here it's just exact demo dot c like what do you think about that will that work ok and the answer is let's find out so we want to compile gcc exact demo and we run it and it does not work instead not hello it can tell it back to me that's not the desired behavior what did we do wrong what we forgot was that when you use exec the very first argument you give to your process is what	the following	371
i have a little program that can print itself out print out it's his own source code so i think it's kind of cute but let's not stop there how about a version of a program that is just powerful as anything you write you can write any program on my machine and my program will be just as powerful as yours and shorter two here's why my little program all is going to do is run your program and i need to generate to do that so what we're going to do is we're going to use a version of exec where we can specify less you want to look for the path and we also want to care about the	code	80
here we go when we when we call maine maine is called for us what's going on with the argv well remember that i have a little variable this holds the address	address	150
there we go right some memory here it's divided up k into pointers each of those pointers is going to be looking at different strings except for the last one where this point is going to not be looking at anything it doesn't but i have a variable my argv and it's pointing to the very first entry the very first point two in there and inside that pointer is what that's right the name of the conferences so what i want to give to exec is not that pointer i actually wanted to give to exact a pointer that is looking at the next	memory	23
there we go right some memory here it's divided up k into pointers each of those pointers is going to be looking at different strings except for the last one where this point is going to not be looking at anything it doesn't but i have a variable my argv and it's pointing to the very first entry the very first point two in there and inside that pointer is what that's right the name of the conferences so what i want to give to exec is not that pointer i actually wanted to give to exact a pointer that is looking at the next	string	126
there we go right some memory here it's divided up k into pointers each of those pointers is going to be looking at different strings except for the last one where this point is going to not be looking at anything it doesn't but i have a variable my argv and it's pointing to the very first entry the very first point two in there and inside that pointer is what that's right the name of the conferences so what i want to give to exec is not that pointer i actually wanted to give to exact a pointer that is looking at the next	pointer	58
we will have a nice program which prints out little useless message so if you didn't tell me what program to run let's print something out right so if we go see that arc see it needs to be at least two items because will have the process name and the argument give me if you're doing that then we got problems services if it's less than two then let's print usage message so&nbsp; fprintf to standard error or little uses message ok so i don't hard code the program name in here let me actually find it out from the process name so i can say percent s	code	449
we will have a nice program which prints out little useless message so if you didn't tell me what program to run let's print something out right so if we go see that arc see it needs to be at least two items because will have the process name and the argument give me if you're doing that then we got problems services if it's less than two then let's print usage message so&nbsp; fprintf to standard error or little uses message ok so i don't hard code the program name in here let me actually find it out from the process name so i can say percent s	printf	382
and program to run and maybe you want to specify some optional arguments to pass that program ok let's have a new line at the end ok watch that percent sp it should be the string at that very first entry of that little table we drew ok after that do not continue do not collect two hundred dollars etc do not play monopoly instead exit with an error code right so down here now we want to call exec so i'm going to call exec and i want to use your version i want to use a path please so you don't have to specify the exact location on the file system ok so in here i need to program dayton let's have a variable that does that and then what about my array well i don't want to start at the beginning i don't want to give it the address of that little table the beginning i want to move forward by one i want to give my process name i wanted to pass in whatever i want to pass in where my table starts and the first thing is give me the program we want to run ok so we do argv plus one we want to move advance to that second pointer in that away and let's hope it fails i'm sorry succeeds if it fails then we're going to get to line eleven time to print something out so we can say exact failed and maybe going to find out a little bit more about why and then again let's exit with an error value k	code	350
and program to run and maybe you want to specify some optional arguments to pass that program ok let's have a new line at the end ok watch that percent sp it should be the string at that very first entry of that little table we drew ok after that do not continue do not collect two hundred dollars etc do not play monopoly instead exit with an error code right so down here now we want to call exec so i'm going to call exec and i want to use your version i want to use a path please so you don't have to specify the exact location on the file system ok so in here i need to program dayton let's have a variable that does that and then what about my array well i don't want to start at the beginning i don't want to give it the address of that little table the beginning i want to move forward by one i want to give my process name i wanted to pass in whatever i want to pass in where my table starts and the first thing is give me the program we want to run ok so we do argv plus one we want to move advance to that second pointer in that away and let's hope it fails i'm sorry succeeds if it fails then we're going to get to line eleven time to print something out so we can say exact failed and maybe going to find out a little bit more about why and then again let's exit with an error value k	string	172
and program to run and maybe you want to specify some optional arguments to pass that program ok let's have a new line at the end ok watch that percent sp it should be the string at that very first entry of that little table we drew ok after that do not continue do not collect two hundred dollars etc do not play monopoly instead exit with an error code right so down here now we want to call exec so i'm going to call exec and i want to use your version i want to use a path please so you don't have to specify the exact location on the file system ok so in here i need to program dayton let's have a variable that does that and then what about my array well i don't want to start at the beginning i don't want to give it the address of that little table the beginning i want to move forward by one i want to give my process name i wanted to pass in whatever i want to pass in where my table starts and the first thing is give me the program we want to run ok so we do argv plus one we want to move advance to that second pointer in that away and let's hope it fails i'm sorry succeeds if it fails then we're going to get to line eleven time to print something out so we can say exact failed and maybe going to find out a little bit more about why and then again let's exit with an error value k	address	728
and program to run and maybe you want to specify some optional arguments to pass that program ok let's have a new line at the end ok watch that percent sp it should be the string at that very first entry of that little table we drew ok after that do not continue do not collect two hundred dollars etc do not play monopoly instead exit with an error code right so down here now we want to call exec so i'm going to call exec and i want to use your version i want to use a path please so you don't have to specify the exact location on the file system ok so in here i need to program dayton let's have a variable that does that and then what about my array well i don't want to start at the beginning i don't want to give it the address of that little table the beginning i want to move forward by one i want to give my process name i wanted to pass in whatever i want to pass in where my table starts and the first thing is give me the program we want to run ok so we do argv plus one we want to move advance to that second pointer in that away and let's hope it fails i'm sorry succeeds if it fails then we're going to get to line eleven time to print something out so we can say exact failed and maybe going to find out a little bit more about why and then again let's exit with an error value k	system	544
and program to run and maybe you want to specify some optional arguments to pass that program ok let's have a new line at the end ok watch that percent sp it should be the string at that very first entry of that little table we drew ok after that do not continue do not collect two hundred dollars etc do not play monopoly instead exit with an error code right so down here now we want to call exec so i'm going to call exec and i want to use your version i want to use a path please so you don't have to specify the exact location on the file system ok so in here i need to program dayton let's have a variable that does that and then what about my array well i don't want to start at the beginning i don't want to give it the address of that little table the beginning i want to move forward by one i want to give my process name i wanted to pass in whatever i want to pass in where my table starts and the first thing is give me the program we want to run ok so we do argv plus one we want to move advance to that second pointer in that away and let's hope it fails i'm sorry succeeds if it fails then we're going to get to line eleven time to print something out so we can say exact failed and maybe going to find out a little bit more about why and then again let's exit with an error value k	pointer	1024
right so what do we think about this well i'm using exec here so better include i think it's c string send liberal standard dodge ok and i didn't declare what program dangerous so can you guess what how i should declare a little viable here program name or should be looking at if you said argv not quite actually we need the second entry inside that table the second string ok so let's save that and compile it clear gcc exact	string	95
record powerful ok and we got a little problem here oh yes so fix our pointers ok so i moved to the second entry but actually i want to follow that i actually want to pull out the i don't want just that address i actually want to follow that as a pointer so how can i write that well you might say k let's dereference it like this calculate one and then move forward but you and i know that we can write that more simply	address	203
record powerful ok and we got a little problem here oh yes so fix our pointers ok so i moved to the second entry but actually i want to follow that i actually want to pull out the i don't want just that address i actually want to follow that as a pointer so how can i write that well you might say k let's dereference it like this calculate one and then move forward but you and i know that we can write that more simply	pointer	70
we can use the square brackets to say ok argv is look at the beginning of a ray let's move forward what you shouldn't do in these situations is simply say you know what i'm just going to cast something until it appears to compile know the compiler type information is actually there for not just the compilers benefit but our benefit as well and if there's a type mismatch	type	248
there's a strong hint that perhaps we didn't dereference a pointer or were not working with the correct variable	pointer	59
for three seconds there is glorious silence for yes what happened are little process here stop running my code and became the sleep program instead so just the last kind of fun there with this is what do you think will happen if i run	code	106
let's see what else has changed secondly is because i'm not going to try to go out to connect to a remote machine when i call get address info i don't need to specify "a remote address i'm not passing in illinois.edu here	address	130
listening on a particular port for particular socket type ok so if this succeeds we've got everything we now need to create a socket but here's a here's the new cool thing that we're going to need now which is this bind call so bind says right so far what have we done you've made an abstract socket and we did that much earlier at the top of the code here we said i need just an ip4 tcp style socket thank you very much now we actually want to make that be on a particular port number on a particular network card on our local machine and that's the purpose of bind right so you can think handcuffs or whatever to say hey we're going to actually bind our abstract socket to actual port number an actual end point on my machine	type	53
listening on a particular port for particular socket type ok so if this succeeds we've got everything we now need to create a socket but here's a here's the new cool thing that we're going to need now which is this bind call so bind says right so far what have we done you've made an abstract socket and we did that much earlier at the top of the code here we said i need just an ip4 tcp style socket thank you very much now we actually want to make that be on a particular port number on a particular network card on our local machine and that's the purpose of bind right so you can think handcuffs or whatever to say hey we're going to actually bind our abstract socket to actual port number an actual end point on my machine	code	347
if we wanted to write a high performance server perhaps i want a backlog of up to a hundred connections but realize of course that all of this is going to take some resources to build again handle those one hundred conversations	resources	165
ok so so far none of these calls will block but we have now set up a valid server if i've got this far then calling netcat on this connection or calling telnet or calling using firefox or chrome etc will make a valid connection and then i'll start to want to send back to us so we better actually start processing our clients ok so how do we do that and the answer is with accept ok so accept means please block and till there's a customer for me to serve ok and of course we pass in our server socket now the big important idea here is that now is that that server socket is the front door to your shop but it's not actually going to be the way that you talk to your clients instead when accept returns you get a new file descriptor one for each customer which is the private communication channel between you and that client so with this new file descriptor that's how we're going to be calling read and write	block	38
so accept will return immediately if there's customers which have completed their handshake and waiting to talk to you or it will block if there's no new customers ready to talk so you might for example write code where we'll put this accept inside a loop and will process one customer at a time and there is exactly what we're doing here perhaps in the future will write a multithreaded version where as soon as we get a valid return from accept we know we can start say a thread just to process that particular customer	block	130
so accept will return immediately if there's customers which have completed their handshake and waiting to talk to you or it will block if there's no new customers ready to talk so you might for example write code where we'll put this accept inside a loop and will process one customer at a time and there is exactly what we're doing here perhaps in the future will write a multithreaded version where as soon as we get a valid return from accept we know we can start say a thread just to process that particular customer	code	209
so accept will return immediately if there's customers which have completed their handshake and waiting to talk to you or it will block if there's no new customers ready to talk so you might for example write code where we'll put this accept inside a loop and will process one customer at a time and there is exactly what we're doing here perhaps in the future will write a multithreaded version where as soon as we get a valid return from accept we know we can start say a thread just to process that particular customer	a thread	472
so accept will return immediately if there's customers which have completed their handshake and waiting to talk to you or it will block if there's no new customers ready to talk so you might for example write code where we'll put this accept inside a loop and will process one customer at a time and there is exactly what we're doing here perhaps in the future will write a multithreaded version where as soon as we get a valid return from accept we know we can start say a thread just to process that particular customer	thread	379
ok so let me read up to nine hundred and ninety nine bytes and if they give me something valid then i'll just print it out but remember what i get is not a c string it's up to me to terminate what what we received with the zero byte ok and will print it up and then i can say something back to them ok so let me now use either write or dprintf ok and so i can only say hello i could if i wanted to say something fancy with %d if i can use formatted strings	printf	337
ok so let me read up to nine hundred and ninety nine bytes and if they give me something valid then i'll just print it out but remember what i get is not a c string it's up to me to terminate what what we received with the zero byte ok and will print it up and then i can say something back to them ok so let me now use either write or dprintf ok and so i can only say hello i could if i wanted to say something fancy with %d if i can use formatted strings	string	158
so let's edit my code to say we're all done with this connection but the file descriptors still exists so that's taking up unnecessary resources so now actually let me kind of reset that ok alright so now i've got my little server finished	code	17
so let's edit my code to say we're all done with this connection but the file descriptors still exists so that's taking up unnecessary resources so now actually let me kind of reset that ok alright so now i've got my little server finished	resources	135
returning web web content not something that's a real web page ok and it's not actually truly talking http instead so let's modify it just use kind of dprintf and talk about some other things that this thing is doing as well	printf	152
right so there we go now is dprintf	printf	29
if i break out this point in trying to run it again i'll be in for a bit of a nasty shock here that my bind call failed that i get an address already in use oh what's gone wrong with my code did i make an error let me try running again and it's still failing ok so let me look at my code figure out why bind might be failing here ok so this is actually why it's useful to check every	code	186
if i break out this point in trying to run it again i'll be in for a bit of a nasty shock here that my bind call failed that i get an address already in use oh what's gone wrong with my code did i make an error let me try running again and it's still failing ok so let me look at my code figure out why bind might be failing here ok so this is actually why it's useful to check every	address	134
things fail and in fact my code is correct the problem however is that even after my process has finished passively listeningor one two three four there's a timeout there's a grace period of about two minutes where we can't make a new new passive socket on the same port number that was actually previously used so if we wait for a little bit longer they go see now it's actually working again i didn't even touch the code ok so that's one kind of fun surprised it will have with networking will talk about how we can reduce that timeout period to zero seconds in a future lecture but realize that that time out is deliberate it's actually there for security purpose so more about that in the future so anyway we've got a little thing working here we should now try to connect to it let me now try using say netcat so netcat which is netcat or sometimes or some systems is just nc it's a netcat i wanted to talk to my localhost ok and i'm now on port one two three four ok right so i can say let's say	code	27
things fail and in fact my code is correct the problem however is that even after my process has finished passively listeningor one two three four there's a timeout there's a grace period of about two minutes where we can't make a new new passive socket on the same port number that was actually previously used so if we wait for a little bit longer they go see now it's actually working again i didn't even touch the code ok so that's one kind of fun surprised it will have with networking will talk about how we can reduce that timeout period to zero seconds in a future lecture but realize that that time out is deliberate it's actually there for security purpose so more about that in the future so anyway we've got a little thing working here we should now try to connect to it let me now try using say netcat so netcat which is netcat or sometimes or some systems is just nc it's a netcat i wanted to talk to my localhost ok and i'm now on port one two three four ok right so i can say let's say	system	862
hello right and you'll see that my server got the hello there and complete with a new line and it sent back this server code was written in year two thousand and eighteen it's a whole year old ok right	code	120
which is the following which is this ntohs calls so let's talk about that in the next video ok so i'm going to reset my code to a valid number explicit number like one two three four and we'll see how this code	the following	9
which is the following which is this ntohs calls so let's talk about that in the next video ok so i'm going to reset my code to a valid number explicit number like one two three four and we'll see how this code	code	120
ok so yeah we talked about race conditions what i meant to say is let's talk about a critical section	section	94
so here's here's an important idea that there's possible code that is necessary that only one thread at a time should be executing because in that moment inside part of that code is where we are updating some resource for example updating some data structure or updating a file in a critical way and it's important that no are the process or thread updates at resource at the same time so it's critical that we prevent other threads or processes from also being inside a critical section at the same time so lots of kind of examples and in the real world where there's there's moments in time where we only want kind of one person to be working on something at a time or save as a database you might implement a database so it's critical that only one process updates particular row at a time ok so you can imagine that if we were doing code review you might say hold on a moment there i've got a race condition here between say my implement incrementing i and when we actually reading the value of i in our previous code when we were taking the value of this pointer	a struct	247
so here's here's an important idea that there's possible code that is necessary that only one thread at a time should be executing because in that moment inside part of that code is where we are updating some resource for example updating some data structure or updating a file in a critical way and it's important that no are the process or thread updates at resource at the same time so it's critical that we prevent other threads or processes from also being inside a critical section at the same time so lots of kind of examples and in the real world where there's there's moments in time where we only want kind of one person to be working on something at a time or save as a database you might implement a database so it's critical that only one process updates particular row at a time ok so you can imagine that if we were doing code review you might say hold on a moment there i've got a race condition here between say my implement incrementing i and when we actually reading the value of i in our previous code when we were taking the value of this pointer	code	57
so here's here's an important idea that there's possible code that is necessary that only one thread at a time should be executing because in that moment inside part of that code is where we are updating some resource for example updating some data structure or updating a file in a critical way and it's important that no are the process or thread updates at resource at the same time so it's critical that we prevent other threads or processes from also being inside a critical section at the same time so lots of kind of examples and in the real world where there's there's moments in time where we only want kind of one person to be working on something at a time or save as a database you might implement a database so it's critical that only one process updates particular row at a time ok so you can imagine that if we were doing code review you might say hold on a moment there i've got a race condition here between say my implement incrementing i and when we actually reading the value of i in our previous code when we were taking the value of this pointer	section	480
so here's here's an important idea that there's possible code that is necessary that only one thread at a time should be executing because in that moment inside part of that code is where we are updating some resource for example updating some data structure or updating a file in a critical way and it's important that no are the process or thread updates at resource at the same time so it's critical that we prevent other threads or processes from also being inside a critical section at the same time so lots of kind of examples and in the real world where there's there's moments in time where we only want kind of one person to be working on something at a time or save as a database you might implement a database so it's critical that only one process updates particular row at a time ok so you can imagine that if we were doing code review you might say hold on a moment there i've got a race condition here between say my implement incrementing i and when we actually reading the value of i in our previous code when we were taking the value of this pointer	thread	94
so here's here's an important idea that there's possible code that is necessary that only one thread at a time should be executing because in that moment inside part of that code is where we are updating some resource for example updating some data structure or updating a file in a critical way and it's important that no are the process or thread updates at resource at the same time so it's critical that we prevent other threads or processes from also being inside a critical section at the same time so lots of kind of examples and in the real world where there's there's moments in time where we only want kind of one person to be working on something at a time or save as a database you might implement a database so it's critical that only one process updates particular row at a time ok so you can imagine that if we were doing code review you might say hold on a moment there i've got a race condition here between say my implement incrementing i and when we actually reading the value of i in our previous code when we were taking the value of this pointer	pointer	1060
so we have synchronization bug and it would have been solved if we identified a critical section and said ok we need to divide a moment in time so that define a moment in time so that the value can be read independently of the update	section	89
ok so we'll talk more about critical sections in the future but like i said the big idea is that only one thread at a time should be inside a critical section if our program is to behave correctly	section	37
ok so we'll talk more about critical sections in the future but like i said the big idea is that only one thread at a time should be inside a critical section if our program is to behave correctly	thread	106
so how can we identify what can we do to ensure this and one way to do that is to put locks around our critical section code for example suppose you had some code from cs two twenty five that is going to say insert a link right on a data structure and this price is going to work in the linked list price is going to work on a vector and inside that code you realize that there's a moment in time where you're going to say of mess with the pointers or you're going to copy the entire data structure from us one sized piece of resource to say a doubling of the resources some other piece of memory over there ok so that's a critical section what we need to do then is to block any other threads that want to do a similar operation we want to somehow say right i want to give you exclusive access to this right now so the only you this comment thread is executing in this code gets too	memory	590
so how can we identify what can we do to ensure this and one way to do that is to put locks around our critical section code for example suppose you had some code from cs two twenty five that is going to say insert a link right on a data structure and this price is going to work in the linked list price is going to work on a vector and inside that code you realize that there's a moment in time where you're going to say of mess with the pointers or you're going to copy the entire data structure from us one sized piece of resource to say a doubling of the resources some other piece of memory over there ok so that's a critical section what we need to do then is to block any other threads that want to do a similar operation we want to somehow say right i want to give you exclusive access to this right now so the only you this comment thread is executing in this code gets too	block	670
so how can we identify what can we do to ensure this and one way to do that is to put locks around our critical section code for example suppose you had some code from cs two twenty five that is going to say insert a link right on a data structure and this price is going to work in the linked list price is going to work on a vector and inside that code you realize that there's a moment in time where you're going to say of mess with the pointers or you're going to copy the entire data structure from us one sized piece of resource to say a doubling of the resources some other piece of memory over there ok so that's a critical section what we need to do then is to block any other threads that want to do a similar operation we want to somehow say right i want to give you exclusive access to this right now so the only you this comment thread is executing in this code gets too	a struct	236
so how can we identify what can we do to ensure this and one way to do that is to put locks around our critical section code for example suppose you had some code from cs two twenty five that is going to say insert a link right on a data structure and this price is going to work in the linked list price is going to work on a vector and inside that code you realize that there's a moment in time where you're going to say of mess with the pointers or you're going to copy the entire data structure from us one sized piece of resource to say a doubling of the resources some other piece of memory over there ok so that's a critical section what we need to do then is to block any other threads that want to do a similar operation we want to somehow say right i want to give you exclusive access to this right now so the only you this comment thread is executing in this code gets too	code	120
so how can we identify what can we do to ensure this and one way to do that is to put locks around our critical section code for example suppose you had some code from cs two twenty five that is going to say insert a link right on a data structure and this price is going to work in the linked list price is going to work on a vector and inside that code you realize that there's a moment in time where you're going to say of mess with the pointers or you're going to copy the entire data structure from us one sized piece of resource to say a doubling of the resources some other piece of memory over there ok so that's a critical section what we need to do then is to block any other threads that want to do a similar operation we want to somehow say right i want to give you exclusive access to this right now so the only you this comment thread is executing in this code gets too	section	112
so how can we identify what can we do to ensure this and one way to do that is to put locks around our critical section code for example suppose you had some code from cs two twenty five that is going to say insert a link right on a data structure and this price is going to work in the linked list price is going to work on a vector and inside that code you realize that there's a moment in time where you're going to say of mess with the pointers or you're going to copy the entire data structure from us one sized piece of resource to say a doubling of the resources some other piece of memory over there ok so that's a critical section what we need to do then is to block any other threads that want to do a similar operation we want to somehow say right i want to give you exclusive access to this right now so the only you this comment thread is executing in this code gets too	thread	686
so how can we identify what can we do to ensure this and one way to do that is to put locks around our critical section code for example suppose you had some code from cs two twenty five that is going to say insert a link right on a data structure and this price is going to work in the linked list price is going to work on a vector and inside that code you realize that there's a moment in time where you're going to say of mess with the pointers or you're going to copy the entire data structure from us one sized piece of resource to say a doubling of the resources some other piece of memory over there ok so that's a critical section what we need to do then is to block any other threads that want to do a similar operation we want to somehow say right i want to give you exclusive access to this right now so the only you this comment thread is executing in this code gets too	resources	560
so how can we identify what can we do to ensure this and one way to do that is to put locks around our critical section code for example suppose you had some code from cs two twenty five that is going to say insert a link right on a data structure and this price is going to work in the linked list price is going to work on a vector and inside that code you realize that there's a moment in time where you're going to say of mess with the pointers or you're going to copy the entire data structure from us one sized piece of resource to say a doubling of the resources some other piece of memory over there ok so that's a critical section what we need to do then is to block any other threads that want to do a similar operation we want to somehow say right i want to give you exclusive access to this right now so the only you this comment thread is executing in this code gets too	pointer	440
gets to modify this data structure anybody else that wants to insert something into my data structure or iterate over the linked list or get a value that just going to have to wait until i finished operating on my data structure ok so only one surgeon at a time is the mantra here and how we're going to do that well i'm going to introduce you to our first synchronization primitive in a moment and that is going to be called a mutex alright so i'll see you in the next video when we start talking about new taxes in particular p three music clocks rp thread mutex	a struct	23
gets to modify this data structure anybody else that wants to insert something into my data structure or iterate over the linked list or get a value that just going to have to wait until i finished operating on my data structure ok so only one surgeon at a time is the mantra here and how we're going to do that well i'm going to introduce you to our first synchronization primitive in a moment and that is going to be called a mutex alright so i'll see you in the next video when we start talking about new taxes in particular p three music clocks rp thread mutex	a mutex	426
gets to modify this data structure anybody else that wants to insert something into my data structure or iterate over the linked list or get a value that just going to have to wait until i finished operating on my data structure ok so only one surgeon at a time is the mantra here and how we're going to do that well i'm going to introduce you to our first synchronization primitive in a moment and that is going to be called a mutex alright so i'll see you in the next video when we start talking about new taxes in particular p three music clocks rp thread mutex	thread	552
and as you know they are necessary and sufficient we need all fall to be true and exactly or for them to be true and then we know that we've met the conditions for deadlock so what are they let's actually look at some definitions here so here's the first wanna process is currently holding at least one resource and requesting additional resources which are being held by other processes ok so it is holding and waiting so that's a hold and wait condition	a process	259
and as you know they are necessary and sufficient we need all fall to be true and exactly or for them to be true and then we know that we've met the conditions for deadlock so what are they let's actually look at some definitions here so here's the first wanna process is currently holding at least one resource and requesting additional resources which are being held by other processes ok so it is holding and waiting so that's a hold and wait condition	resources	338
my process is all threads only needed to actually hold on to say just one mutex lock at a time that deadlock would be impossible	thread	18
and the process or thread wait for graph	thread	19
no pre emption right that we cannot force a task or thread to put down a lot or something that is acquired exclusively ok no pre are going to say pre emptive but let's change that to know preemption	thread	52
ok let's review this one what do you think the following code will print ok so	the following	43
ok let's review this one what do you think the following code will print ok so	code	57
how can we analyze this right so i've got a pizza it create an i'm storing somewhere the fed id 's and i'm going to say ok i want to thread that is going to start functioning and let's start function be and we're going to pass a void pointer the address of the string literals so the address of the capital a and address of the capital x to each one right so what will function be do function be then get this pointer and so we're giving it the address of xyz so when this runs and we're not quite sure when it will run it will print out xyz	string	261
how can we analyze this right so i've got a pizza it create an i'm storing somewhere the fed id 's and i'm going to say ok i want to thread that is going to start functioning and let's start function be and we're going to pass a void pointer the address of the string literals so the address of the capital a and address of the capital x to each one right so what will function be do function be then get this pointer and so we're giving it the address of xyz so when this runs and we're not quite sure when it will run it will print out xyz	thread	133
how can we analyze this right so i've got a pizza it create an i'm storing somewhere the fed id 's and i'm going to say ok i want to thread that is going to start functioning and let's start function be and we're going to pass a void pointer the address of the string literals so the address of the capital a and address of the capital x to each one right so what will function be do function be then get this pointer and so we're giving it the address of xyz so when this runs and we're not quite sure when it will run it will print out xyz	address	246
how can we analyze this right so i've got a pizza it create an i'm storing somewhere the fed id 's and i'm going to say ok i want to thread that is going to start functioning and let's start function be and we're going to pass a void pointer the address of the string literals so the address of the capital a and address of the capital x to each one right so what will function be do function be then get this pointer and so we're giving it the address of xyz so when this runs and we're not quite sure when it will run it will print out xyz	pointer	234
now what about function a so functionally when it runs let's see is given the address of abc ok but it doesn't do anything instead it just simply exits this thread and it returns an address so it takes the pointer that we gave it which was a pointer to the string in memory abc and a zero bite if it is	memory	267
now what about function a so functionally when it runs let's see is given the address of abc ok but it doesn't do anything instead it just simply exits this thread and it returns an address so it takes the pointer that we gave it which was a pointer to the string in memory abc and a zero bite if it is	string	257
now what about function a so functionally when it runs let's see is given the address of abc ok but it doesn't do anything instead it just simply exits this thread and it returns an address so it takes the pointer that we gave it which was a pointer to the string in memory abc and a zero bite if it is	thread	157
now what about function a so functionally when it runs let's see is given the address of abc ok but it doesn't do anything instead it just simply exits this thread and it returns an address so it takes the pointer that we gave it which was a pointer to the string in memory abc and a zero bite if it is	address	78
now what about function a so functionally when it runs let's see is given the address of abc ok but it doesn't do anything instead it just simply exits this thread and it returns an address so it takes the pointer that we gave it which was a pointer to the string in memory abc and a zero bite if it is	pointer	206
ok and we take that caster character add one in other words we just calculated a pointer that now points to the b ok an we return that so if and when these two threads run we know that the first first one returns a pointer to bc string and the second one prints are xyz right what is the rest of the code to write so equals p thread join on thread a and grab the result and so in stores that in there area code result ok so what what is going to be put inside this result so this line is going to wait is going to wait until it's able to join p thread so that means we wait until functionary has finished at which point we set this result variable to be a pointer and it's pointing to here we go do that be right there which we print out ok so this will print bc add a new line	code	300
ok and we take that caster character add one in other words we just calculated a pointer that now points to the b ok an we return that so if and when these two threads run we know that the first first one returns a pointer to bc string and the second one prints are xyz right what is the rest of the code to write so equals p thread join on thread a and grab the result and so in stores that in there area code result ok so what what is going to be put inside this result so this line is going to wait is going to wait until it's able to join p thread so that means we wait until functionary has finished at which point we set this result variable to be a pointer and it's pointing to here we go do that be right there which we print out ok so this will print bc add a new line	string	229
ok and we take that caster character add one in other words we just calculated a pointer that now points to the b ok an we return that so if and when these two threads run we know that the first first one returns a pointer to bc string and the second one prints are xyz right what is the rest of the code to write so equals p thread join on thread a and grab the result and so in stores that in there area code result ok so what what is going to be put inside this result so this line is going to wait is going to wait until it's able to join p thread so that means we wait until functionary has finished at which point we set this result variable to be a pointer and it's pointing to here we go do that be right there which we print out ok so this will print bc add a new line	thread	160
ok and we take that caster character add one in other words we just calculated a pointer that now points to the b ok an we return that so if and when these two threads run we know that the first first one returns a pointer to bc string and the second one prints are xyz right what is the rest of the code to write so equals p thread join on thread a and grab the result and so in stores that in there area code result ok so what what is going to be put inside this result so this line is going to wait is going to wait until it's able to join p thread so that means we wait until functionary has finished at which point we set this result variable to be a pointer and it's pointing to here we go do that be right there which we print out ok so this will print bc add a new line	pointer	81
ok right so now we hopefully you can conclude what this code is going to print right so if you said it's going to print bc or the new line then you'd be correct if you said it's going to print bc in a new line and xyz you'd be correct if you said is going to print xyz with a new line and bc you'd be correct yes so what code is actually indeterminate pthread create makes no promises about when these threads are going to stop maybe in a microsecond maybe in a millisecond time there's a very real chance that	code	56
ok right so now we hopefully you can conclude what this code is going to print right so if you said it's going to print bc or the new line then you'd be correct if you said it's going to print bc in a new line and xyz you'd be correct if you said is going to print xyz with a new line and bc you'd be correct yes so what code is actually indeterminate pthread create makes no promises about when these threads are going to stop maybe in a microsecond maybe in a millisecond time there's a very real chance that	thread	353
the first thread, thread a, could could start up exit and main thread could join on that we could print out an exit before thread b has a chance to start this would be particularly true on sale really busy system or a system that's only got one cpu core. our poor thread b it hasn't had a cpu scheduled yet and so our main thread is done before it he has a chance to start up ok right so all those those as possible if we modified our code so that we included pthread_exit() on the main thread then you know that that means that because we are never returning from maine now our program is going to run until both those threads finish so now we expect both the bc to be printed and the xyz to be printed though we can't actually say definitively what order these two things can print we can make a guess as to which ones more likely but we haven't actually	code	435
the first thread, thread a, could could start up exit and main thread could join on that we could print out an exit before thread b has a chance to start this would be particularly true on sale really busy system or a system that's only got one cpu core. our poor thread b it hasn't had a cpu scheduled yet and so our main thread is done before it he has a chance to start up ok right so all those those as possible if we modified our code so that we included pthread_exit() on the main thread then you know that that means that because we are never returning from maine now our program is going to run until both those threads finish so now we expect both the bc to be printed and the xyz to be printed though we can't actually say definitively what order these two things can print we can make a guess as to which ones more likely but we haven't actually	thread	10
the first thread, thread a, could could start up exit and main thread could join on that we could print out an exit before thread b has a chance to start this would be particularly true on sale really busy system or a system that's only got one cpu core. our poor thread b it hasn't had a cpu scheduled yet and so our main thread is done before it he has a chance to start up ok right so all those those as possible if we modified our code so that we included pthread_exit() on the main thread then you know that that means that because we are never returning from maine now our program is going to run until both those threads finish so now we expect both the bc to be printed and the xyz to be printed though we can't actually say definitively what order these two things can print we can make a guess as to which ones more likely but we haven't actually	system	206
so fun stuff with threads fun stuff with thinking about interleaving and i hope you bear this in mind as you write your own multithreaded programs	thread	18
ok great sir let's start talking about manafort says so here's a great wonderful idea i wanted to choose something which was it was called embarrassingly parallel meaning that we can just set all cpus off calculating something and then we don't need to think about any communication between those cpus we don't need to think about them trying to update the same piece of memory at the same time so this is a very easy problem for us to parallelize into play with do understand how to use pizza is before we move on to more complicated examples ok so we're going to put together a lot of ideas first of all let's talk about a little bit of math so here's the plan i want you to think of a number right now i'd like you to square that number	memory	371
going to stay around zero but for much larger numbers they're very quickly exponent get away because we are squaring our current number so that's why we're actually going to look at here this is our sdr code for calculating the manager set and it's something we can do very nicely on distant kind of ten lines of code here it is especially as see actually support sir complex numbers so you didn't think of a complex number or shame on you right so here we go for it we can we see so let's pass in a screen position so that will be of x and y and we will turn that into a complex number somewhere close to the origin somewhere close to zero so will convert are those into some real number and some imaginary component as well right so i've now i've got my constant but i'm going to keep adding around each time now i just want to play my think of a number game so will start off with a value of zero will tried playing this game for say like a thousand times also so we'll go around this little loop but will quit if my value of my complex number z here gets too large so once it's greater than two we know we're going to lose anyway we know we're on the path some exponentially large number ok so we're only gonna keep this plate keep playing this game then if we stay close to the origin and we haven't exhausted the number of maximum iterations were prepared to play this game so here's our game right so just update busy with squaring with z adding the complex number we first thought of wait so when we finished playing this game it would be nice to play this display this in a nice colorful way so here's what we've got if i manage to stay close to the origin i'm going to use a white color so my rg and b values are going to be large as possible otherwise i've got a fun little multiplication function here	code	203
and i want to store the results somewhere so let's get some memory let's use calloc right and this time	memory	60
i wanted to say how many bytes exactly i want ansi supports these wonderful things here where we actually say the number of bits we want so today i would like this unsigned buster you hear unsigned integer through two bits please so i know i'm definitely talking about a four byte integer and right so use that in my car lock as well to to declare that's a total number of bytes so i'm going to need per element right so that's my code the last thing will do is somewhere for loop here is don't forget to update the ui so after calculating sixteen rose we want to	code	431
update the ui somehow in other words take my array of pixels which is just a big block of memory inside the heap and displayed on the screen so how do i do that i do the following let's take a tape why mask it with the value fifteen so in other words i only care about the lowest four bits and if those lowest four bits are equal to fifteen then display the ui ok so providing my screen size is actually some multiple of sixteen then i'll make sure that i update this every sixteen roads and i also updated at the end if it's not some multiple of sixteen then i should call update gui a one more time before exiting or before finishing right so let's have a look at this this actually have a play with this ok so i've compiled already i've got a little make file here	the following	166
update the ui somehow in other words take my array of pixels which is just a big block of memory inside the heap and displayed on the screen so how do i do that i do the following let's take a tape why mask it with the value fifteen so in other words i only care about the lowest four bits and if those lowest four bits are equal to fifteen then display the ui ok so providing my screen size is actually some multiple of sixteen then i'll make sure that i update this every sixteen roads and i also updated at the end if it's not some multiple of sixteen then i should call update gui a one more time before exiting or before finishing right so let's have a look at this this actually have a play with this ok so i've compiled already i've got a little make file here	memory	90
update the ui somehow in other words take my array of pixels which is just a big block of memory inside the heap and displayed on the screen so how do i do that i do the following let's take a tape why mask it with the value fifteen so in other words i only care about the lowest four bits and if those lowest four bits are equal to fifteen then display the ui ok so providing my screen size is actually some multiple of sixteen then i'll make sure that i update this every sixteen roads and i also updated at the end if it's not some multiple of sixteen then i should call update gui a one more time before exiting or before finishing right so let's have a look at this this actually have a play with this ok so i've compiled already i've got a little make file here	the heap	104
update the ui somehow in other words take my array of pixels which is just a big block of memory inside the heap and displayed on the screen so how do i do that i do the following let's take a tape why mask it with the value fifteen so in other words i only care about the lowest four bits and if those lowest four bits are equal to fifteen then display the ui ok so providing my screen size is actually some multiple of sixteen then i'll make sure that i update this every sixteen roads and i also updated at the end if it's not some multiple of sixteen then i should call update gui a one more time before exiting or before finishing right so let's have a look at this this actually have a play with this ok so i've compiled already i've got a little make file here	block	81
k so we just look we look at the make fall you see i've got ok let's do my initial manda brought no thread	thread	100
ok so let's have a look at this code which tries to have some push and pop methods so we can push on a value and later pop it out ok let's see what we think of this right so we have a capacity and it looks like later if we've pushed too many things on why can't i draw i want to draw there we go great later once we reach that capacity we're going to double our capacity in use reality	code	32
and also if we pop from things we will just decrement size k and pre decrement size and then read that as our result so in this implementation the value the thing that we're putting on and the thing that we would later return at the same thing it's not like we're actually going to duplicate this string being passed it was simply going to say oh thanks for that memory pointer later on i will give you back exactly the same memory pointer so it's up to the calling code to make sure that the	memory	363
and also if we pop from things we will just decrement size k and pre decrement size and then read that as our result so in this implementation the value the thing that we're putting on and the thing that we would later return at the same thing it's not like we're actually going to duplicate this string being passed it was simply going to say oh thanks for that memory pointer later on i will give you back exactly the same memory pointer so it's up to the calling code to make sure that the	code	466
and also if we pop from things we will just decrement size k and pre decrement size and then read that as our result so in this implementation the value the thing that we're putting on and the thing that we would later return at the same thing it's not like we're actually going to duplicate this string being passed it was simply going to say oh thanks for that memory pointer later on i will give you back exactly the same memory pointer so it's up to the calling code to make sure that the	string	297
and also if we pop from things we will just decrement size k and pre decrement size and then read that as our result so in this implementation the value the thing that we're putting on and the thing that we would later return at the same thing it's not like we're actually going to duplicate this string being passed it was simply going to say oh thanks for that memory pointer later on i will give you back exactly the same memory pointer so it's up to the calling code to make sure that the	pointer	370
item that's being passed on paskin will actually continue to exist later when when pop is called if that's not true if you actually wanted to make a duplicate of this string then there's a nice little function in c called string duplication so strdup so it stands for those duplicate string so you pass in one string	string	167
compute string literal could be appointed to some string memory and it will call malloc get some heat can we add and create a string with the same character sequence but it is a different part of memory so that's a neat way of duplicating strings and then later when you finish with it of course it's on the heap so you can call three here right so let's back go back to our code here so i've got capacity excites the number of items are comedy in it and my data right so it's a pointer to a pointer to a character does that make sense well we know that it should be a pointer and yes each one of those entries of my way i expect to be able to store character pointers so that type is correct but hold on a moment what about this capacity ok so we've just ask for sixty four bytes the rest of the code assumes that capacity is related to the number of items which are actually stored there that's why we're doing this comparison here and why we use use the data as an array so this is not correct this should have said capacity times size of and then the thing that we're storing inside each entry so we're storing inside eat entry you might be tempted to write character but don't 'cause that's not correct and we know the thing we're actually storing is character pointers ok so right now we've got a better idea about size what do we do here right so i mentioned great we're going to double the capacity when we went out of space and then we call realloc is this a good use of real ac no this is a classic error here too we made two classic errors here first of all the real ac might be able to bust through a wall and just give us more space where the data is currently stored but maybe not	memory	57
compute string literal could be appointed to some string memory and it will call malloc get some heat can we add and create a string with the same character sequence but it is a different part of memory so that's a neat way of duplicating strings and then later when you finish with it of course it's on the heap so you can call three here right so let's back go back to our code here so i've got capacity excites the number of items are comedy in it and my data right so it's a pointer to a pointer to a character does that make sense well we know that it should be a pointer and yes each one of those entries of my way i expect to be able to store character pointers so that type is correct but hold on a moment what about this capacity ok so we've just ask for sixty four bytes the rest of the code assumes that capacity is related to the number of items which are actually stored there that's why we're doing this comparison here and why we use use the data as an array so this is not correct this should have said capacity times size of and then the thing that we're storing inside each entry so we're storing inside eat entry you might be tempted to write character but don't 'cause that's not correct and we know the thing we're actually storing is character pointers ok so right now we've got a better idea about size what do we do here right so i mentioned great we're going to double the capacity when we went out of space and then we call realloc is this a good use of real ac no this is a classic error here too we made two classic errors here first of all the real ac might be able to bust through a wall and just give us more space where the data is currently stored but maybe not	the heap	304
compute string literal could be appointed to some string memory and it will call malloc get some heat can we add and create a string with the same character sequence but it is a different part of memory so that's a neat way of duplicating strings and then later when you finish with it of course it's on the heap so you can call three here right so let's back go back to our code here so i've got capacity excites the number of items are comedy in it and my data right so it's a pointer to a pointer to a character does that make sense well we know that it should be a pointer and yes each one of those entries of my way i expect to be able to store character pointers so that type is correct but hold on a moment what about this capacity ok so we've just ask for sixty four bytes the rest of the code assumes that capacity is related to the number of items which are actually stored there that's why we're doing this comparison here and why we use use the data as an array so this is not correct this should have said capacity times size of and then the thing that we're storing inside each entry so we're storing inside eat entry you might be tempted to write character but don't 'cause that's not correct and we know the thing we're actually storing is character pointers ok so right now we've got a better idea about size what do we do here right so i mentioned great we're going to double the capacity when we went out of space and then we call realloc is this a good use of real ac no this is a classic error here too we made two classic errors here first of all the real ac might be able to bust through a wall and just give us more space where the data is currently stored but maybe not	type	677
compute string literal could be appointed to some string memory and it will call malloc get some heat can we add and create a string with the same character sequence but it is a different part of memory so that's a neat way of duplicating strings and then later when you finish with it of course it's on the heap so you can call three here right so let's back go back to our code here so i've got capacity excites the number of items are comedy in it and my data right so it's a pointer to a pointer to a character does that make sense well we know that it should be a pointer and yes each one of those entries of my way i expect to be able to store character pointers so that type is correct but hold on a moment what about this capacity ok so we've just ask for sixty four bytes the rest of the code assumes that capacity is related to the number of items which are actually stored there that's why we're doing this comparison here and why we use use the data as an array so this is not correct this should have said capacity times size of and then the thing that we're storing inside each entry so we're storing inside eat entry you might be tempted to write character but don't 'cause that's not correct and we know the thing we're actually storing is character pointers ok so right now we've got a better idea about size what do we do here right so i mentioned great we're going to double the capacity when we went out of space and then we call realloc is this a good use of real ac no this is a classic error here too we made two classic errors here first of all the real ac might be able to bust through a wall and just give us more space where the data is currently stored but maybe not	code	375
compute string literal could be appointed to some string memory and it will call malloc get some heat can we add and create a string with the same character sequence but it is a different part of memory so that's a neat way of duplicating strings and then later when you finish with it of course it's on the heap so you can call three here right so let's back go back to our code here so i've got capacity excites the number of items are comedy in it and my data right so it's a pointer to a pointer to a character does that make sense well we know that it should be a pointer and yes each one of those entries of my way i expect to be able to store character pointers so that type is correct but hold on a moment what about this capacity ok so we've just ask for sixty four bytes the rest of the code assumes that capacity is related to the number of items which are actually stored there that's why we're doing this comparison here and why we use use the data as an array so this is not correct this should have said capacity times size of and then the thing that we're storing inside each entry so we're storing inside eat entry you might be tempted to write character but don't 'cause that's not correct and we know the thing we're actually storing is character pointers ok so right now we've got a better idea about size what do we do here right so i mentioned great we're going to double the capacity when we went out of space and then we call realloc is this a good use of real ac no this is a classic error here too we made two classic errors here first of all the real ac might be able to bust through a wall and just give us more space where the data is currently stored but maybe not	string	8
compute string literal could be appointed to some string memory and it will call malloc get some heat can we add and create a string with the same character sequence but it is a different part of memory so that's a neat way of duplicating strings and then later when you finish with it of course it's on the heap so you can call three here right so let's back go back to our code here so i've got capacity excites the number of items are comedy in it and my data right so it's a pointer to a pointer to a character does that make sense well we know that it should be a pointer and yes each one of those entries of my way i expect to be able to store character pointers so that type is correct but hold on a moment what about this capacity ok so we've just ask for sixty four bytes the rest of the code assumes that capacity is related to the number of items which are actually stored there that's why we're doing this comparison here and why we use use the data as an array so this is not correct this should have said capacity times size of and then the thing that we're storing inside each entry so we're storing inside eat entry you might be tempted to write character but don't 'cause that's not correct and we know the thing we're actually storing is character pointers ok so right now we've got a better idea about size what do we do here right so i mentioned great we're going to double the capacity when we went out of space and then we call realloc is this a good use of real ac no this is a classic error here too we made two classic errors here first of all the real ac might be able to bust through a wall and just give us more space where the data is currently stored but maybe not	pointer	479
ok catch pointers so anytime you ate real ac check for those two bugs	pointer	9
ok is that the full story well ok in really large allocations realloc might fail and so robust production code would actually check as well to see if realloc failed if it did then actually the old value of data would still be valid and simply production code would check to see if malloc actually failed as well but we won't worry about those details today	code	106
ok so what do we do then right let's write in today to the value wait so now we kind of got code that actually is kind of work let's think about how we can make this thread safe and we have to think about ok what the critical sections and	code	92
ok so what do we do then right let's write in today to the value wait so now we kind of got code that actually is kind of work let's think about how we can make this thread safe and we have to think about ok what the critical sections and	section	226
ok so what do we do then right let's write in today to the value wait so now we kind of got code that actually is kind of work let's think about how we can make this thread safe and we have to think about ok what the critical sections and	thread	166
that's not very orange is more yellow now as tricky potato which ok so stopped ok so let's think about when do we need it so that only one third of the time it is running ok so some things we already know is first of all this size plus plus that's not an atomic operation certainly one thread that time should only do that but a little bit more to it than that we want to make sure if two threads are running say push at the same time we don't want their values to end up inside the same spot in our ray like structure we want them to come one after each other we want them to form an orderly queue as a lineup for the salad bar ok so this line where we use the value of size is critical that only one thread at a time runs data time ok what about comparing with capacity and re allocating	thread	286
not only happens again in one thread otherwise i might have two threads calling real look at the same time so that's not that would not be good one of them would be incorrect so in practice then this is also critical section here ok so what will do is actually we will put rp said lock and unlock	section	217
not only happens again in one thread otherwise i might have two threads calling real look at the same time so that's not that would not be good one of them would be incorrect so in practice then this is also critical section here ok so what will do is actually we will put rp said lock and unlock	thread	30
ok and then for the pop case same idea if i had two threads calling pop at the same time i don't want them to read from the same position this predicament and then read from data should occur in one thread and then the other fit ok so that means that i need to declare that this is my critical section those those two results that we put into two different variables remember each ted would have its own stack so in practice right my lock is going to be at the top and unlock just before i return the results so so inside here will be an unlock	section	294
ok and then for the pop case same idea if i had two threads calling pop at the same time i don't want them to read from the same position this predicament and then read from data should occur in one thread and then the other fit ok so that means that i need to declare that this is my critical section those those two results that we put into two different variables remember each ted would have its own stack so in practice right my lock is going to be at the top and unlock just before i return the results so so inside here will be an unlock	thread	52
what so now we've got a multithreaded stack fantastic right now you can write programs which run really fast on your entire lore you're andy chip with four eight sixteen thirty two cores etc ok so i hope you understand the principle here the process that we walked through the reasoning about the code this is relatively simple little two examples we could fit them in just a few lines of code but the ideas about saying ok which part of my code is it critical that only one thread at the time can actually access to data structure that's that's the defining idea about how to make your code thread safe if your code only ran pushing pop then you might actually not see that much speed up because now everybody is trying to use the salad bar but in practice real code tends to go off and do other things as well so that's the whole joy multithreaded programming but we can now release all threads they can go and do exciting things and it's only when they want to come back and read that data structure pull evaluator or push a value in do we need to implement palm mutex locks and i'll see you in next video and we start talking about lock contention ok bye	a struct	520
what so now we've got a multithreaded stack fantastic right now you can write programs which run really fast on your entire lore you're andy chip with four eight sixteen thirty two cores etc ok so i hope you understand the principle here the process that we walked through the reasoning about the code this is relatively simple little two examples we could fit them in just a few lines of code but the ideas about saying ok which part of my code is it critical that only one thread at the time can actually access to data structure that's that's the defining idea about how to make your code thread safe if your code only ran pushing pop then you might actually not see that much speed up because now everybody is trying to use the salad bar but in practice real code tends to go off and do other things as well so that's the whole joy multithreaded programming but we can now release all threads they can go and do exciting things and it's only when they want to come back and read that data structure pull evaluator or push a value in do we need to implement palm mutex locks and i'll see you in next video and we start talking about lock contention ok bye	code	297
what so now we've got a multithreaded stack fantastic right now you can write programs which run really fast on your entire lore you're andy chip with four eight sixteen thirty two cores etc ok so i hope you understand the principle here the process that we walked through the reasoning about the code this is relatively simple little two examples we could fit them in just a few lines of code but the ideas about saying ok which part of my code is it critical that only one thread at the time can actually access to data structure that's that's the defining idea about how to make your code thread safe if your code only ran pushing pop then you might actually not see that much speed up because now everybody is trying to use the salad bar but in practice real code tends to go off and do other things as well so that's the whole joy multithreaded programming but we can now release all threads they can go and do exciting things and it's only when they want to come back and read that data structure pull evaluator or push a value in do we need to implement palm mutex locks and i'll see you in next video and we start talking about lock contention ok bye	thread	29
ok right so how do we read half a file? right, so let's go. well first of all let's open the file handle so will do this all at the c library level ok and next time you write a piece of python code or c++ code realize that many of those functions actually ultimately written using the c library as kind of intermediary between the python code that we write and the actual kind of kernel level calls like open etc ok so we want to fopen this file name and ok	code	193
now good code would actually check to see if that failed so if that was equal to null let's do something but i'm not going to write	code	9
so i know the size of the first half and i remember to go back now i need to read or write that into some memory so great i need some memory at this point ok so let's	memory	106
get some memory is my result and i'll say ok i don't need to set any of this memory to zero so let's just use malloc and how much memory i want ok i could have half however if i want to return it as a c string maybe that's not quite enough let's get back to the moment ok so will call every to say ok fread	memory	9
get some memory is my result and i'll say ok i don't need to set any of this memory to zero so let's just use malloc and how much memory i want ok i could have half however if i want to return it as a c string maybe that's not quite enough let's get back to the moment ok so will call every to say ok fread	string	203
now are we done so kind of except is not a c string ok so now we have to say right ok whereas let's advance forward half bites and put in our terminating zero byte at that point there we go	string	45
ok and finally returned with so what do you think about that if you test this likely it will appear to work however if you gave it gave me this is at a code review i would be unhappy why would i be unhappy	code	152
ok just as kind of best practice so that clear that that file that variable no longer points to a valid resource ok the other thing i don't like about by code right now is that i didn't check that malloc might fail now is a good fair bet that malloc very small numbers is unlikely to fail but if this was a kind of very large file then it's reasonable that malloc might fail so better code would actually check to see if the result felt so if the result failed here so if there is no memory then i better handle that error case and	memory	484
ok just as kind of best practice so that clear that that file that variable no longer points to a valid resource ok the other thing i don't like about by code right now is that i didn't check that malloc might fail now is a good fair bet that malloc very small numbers is unlikely to fail but if this was a kind of very large file then it's reasonable that malloc might fail so better code would actually check to see if the result felt so if the result failed here so if there is no memory then i better handle that error case and	code	154
ok right so we've got something which kind of works if i wanted to i could replace my second f seek with rewind makes a code a little bit easier to read	code	120
in your spare time next time you're having drifting off to sleep chatting with friends and an algorithm or an idea pops into your head think about oh how would i apply what i'm learning inside cs two forty one to make that run faster to make it actually run concurrently so as a worked example remember some of the sorting algorithms you might have seen before like merge sort has suppose you wanted to make your merge sort run faster how would you implement that in parallel ok so kind of let's do this as a little worse example but again there my suggestion to you is is think about your css life and start thinking about well how can i use multiple threads to make this or how can i use multiple processes ok so remember how merge sort works we say if i've got say an array of data here	thread	652
ok so think of like to parcel cards so this number is smaller great i'll take this now we build the next number ok so now this number is not as small as the number might from my right hand pile so i'll take that and repeat and eventually we managed to merge these altogether and notice i relied on the recursion fairy to do most of the work so of course this happens at all levels so if i've started with nice big block of data say mb of data then first of all we call recursion ok and so on and so on and that has to be cursively run these ok so how can i now	block	414
and my calls here wouldn't be able to continue until say these two have completed and then i can start doing the merge simile this merge can happen once these two have finished so it's kind of fun to sketch out how you might actually implement this so how would you use condition way to how to use p threaded barrier to make your code run nice and fast	code	330
and my calls here wouldn't be able to continue until say these two have completed and then i can start doing the merge simile this merge can happen once these two have finished so it's kind of fun to sketch out how you might actually implement this so how would you use condition way to how to use p threaded barrier to make your code run nice and fast	thread	300
close our file descriptions or we close all those places as well but the same is true for open file open files as well ok so when you call say f open underneath you know that actually is going to call open to give us a little file descriptor and that file descriptor is shared if we call fork so let's just draw a little model here that if i've got my parent process just here with file descriptor here it is say file descriptor number three that is actually of course referring to an actual object inside the kernel that we indirectly talk to by either calling read or write seek right so if i then call fork to make a child process then the same number child process over here the same integer number here we go right refers to the same kernel objects so here's the wonderful kernel up here with its view on the world its view of all the peripherals view on what it needs to send out of the network code to the disk etc etc so i've got my idea of a file over here the kernel itself has buffers and also it will have a file position as well so for random access files	code	901
ok nothing happened but now we have a little file called data dot csv and there it is ok so we've got our god data being saved inside there right so now let's start to play with fc can all that good stuff so we've talked a little bit about ftl let's play without first so let's look at the position in the file currently ok so please turn my position of this current file let's print it out so print f right my position is ok right and we can we need a long so will will guess what that might be let's let's deliberately get it wrong see if their warnings will tell us right so here's my type k and will deliberately try to compile that	type	588
right so please put out the following long variable	the following	24
go flush ok then will close it now this last flush i just did i could type there we go is technically unnecessary because in closing the file handle we will flush anyway	type	70
is a hint to the c library to say hey we know you like to buffer everything we know that you don't want to make system calls unnecessarily but no really now it's time to actually tell the kernel that we want to change the position so we change conceptually the position of where future read and writes will occur here but by default the c library will kind of cache that internally	system	112
ok right now it's time to start talking about some deep gnarly bits of system programming and in particular what happens when system calls get interrupted ok so many system calls are very fast for example if you want to find your pid that will return immediately but some things might be slow for example if you call write and it's to something which might block like a network socket or a pipe then it is possible that this right called might be interrupted before it completes so posix has the idea of fast and slow devices local disk is considered fast but for slow devices possible than not little bites maybe actually be written so it's important that we find out what actually happened ok so it's important that we actually get store the result of our write call and then check to see what happens ok so let's just see what are man pages at least on my mac says about to the write call here it is and you'll see that k we've got our standard right we've got p right we talked about a little bit which allows us to include an offset there's even another version which allows us to assemble write using different bits of memories so rather than requiring all of your data to be in one contiguous area you can use this more complicated version to say ok take these bits over there and those bits over there	block	357
ok right now it's time to start talking about some deep gnarly bits of system programming and in particular what happens when system calls get interrupted ok so many system calls are very fast for example if you want to find your pid that will return immediately but some things might be slow for example if you call write and it's to something which might block like a network socket or a pipe then it is possible that this right called might be interrupted before it completes so posix has the idea of fast and slow devices local disk is considered fast but for slow devices possible than not little bites maybe actually be written so it's important that we find out what actually happened ok so it's important that we actually get store the result of our write call and then check to see what happens ok so let's just see what are man pages at least on my mac says about to the write call here it is and you'll see that k we've got our standard right we've got p right we talked about a little bit which allows us to include an offset there's even another version which allows us to assemble write using different bits of memories so rather than requiring all of your data to be in one contiguous area you can use this more complicated version to say ok take these bits over there and those bits over there	system	71
then it will just return doesn't actually do any writing for usok what a lazy kernel that is so ok will keep scrolling down and you can see here there's more and more stuff there's other ones as well for when we start talking about asynchronous writes so you probably heard of node dot js which is kind of taking the server world by storm but we can make javascript on the server that uses asynchronous io and so it uses epoll to figure out which file descriptors ready and it uses things like these e again and he would block to figure out which file descriptors ready for more bites so as you can see there's plenty and plenty of errors that we might want to deal with at some point ok right but we are just going to think about this what this idea about oh i was interrupted key so if we don't handle this then	block	521
exciting things might happen so perhaps you've written code that uses semwait right so semwait is supposed to actually wait until there was a piece of pizza available in the pizza box for as to eat but it just got interrupted and just returned as it off so i can be bothered to wait anymore right and so then we let our code continue	code	55
oh dear so we've been oversimplifying things at this point we haven't been writing high quality code instead what we need to do is we need to check the return value of semwait and read and write and even sleep if we actually want to write production worthy code because semwait might be say oh i failed and it might fail simply because it got into up to due to a signal so we can check this and then we can just re run it again so typically you'll see the following kind of code that	the following	452
oh dear so we've been oversimplifying things at this point we haven't been writing high quality code instead what we need to do is we need to check the return value of semwait and read and write and even sleep if we actually want to write production worthy code because semwait might be say oh i failed and it might fail simply because it got into up to due to a signal so we can check this and then we can just re run it again so typically you'll see the following kind of code that	code	96
and we're going to call semwait on a particular counting semaphore ok like ok here's a pointer to my structure there but it could be that that returns a negative one meaning it failed ok so we could store that inside a little variable here it is	pointer	87
k is equal to ok you just interrupted then go round the loop again so here's our trick that's all big expression for awhile and notice it as a side effect of evaluating this while we actually call sam wait ok so put all that inside there and dropped a t t inside and for the actual body of the while loop don't do anything	the loop	52
ok right so that would be more production quality code we might as well log any other errors as well so that if we get out of this loop and we see that we didn't get zero value here then maybe we actually want to	code	50
for example that would that would help us catch if the counting semaphore was not properly initialized ok so this is a lot of annoying code to write each time and actually makes it harder for us to generally read our code so also people tend to kind of put this code inside a little function calls so you might want something called say same way reentrant or my same weight which kind of does this error checking as well and does this	code	135
oh i must have right to thirty seven bytes but that's not enough so let's keep account of the true number of bites that we've actually sent so far and then go round the loop to try to send the remainder obviously we don't start from the beginning we want to start from whatever offset that we've counted up so far or maybe we've now got to the point where total bytes sent is everything which case we can finish and return say yeah we sent all the bytes ok we're done we're done with this return so we've actually got to write code that copes correctly with all four of these situations	the loop	165
oh i must have right to thirty seven bytes but that's not enough so let's keep account of the true number of bites that we've actually sent so far and then go round the loop to try to send the remainder obviously we don't start from the beginning we want to start from whatever offset that we've counted up so far or maybe we've now got to the point where total bytes sent is everything which case we can finish and return say yeah we sent all the bytes ok we're done we're done with this return so we've actually got to write code that copes correctly with all four of these situations	code	527
for read we also have the possibility that it would return zero which means ok that's it you've read anything and there's no more bites coming through this pipe is now closed for business i can tell you no one is going to read anymore or this stream safer the terminal is not getting any more bites or this file you've reached the end of it ok so again we have to write sophisticated code to think about these possible different states	code	384
right i finally was sleep so we sleep we say please sleep for so many seconds but it is possible to be interrupted so let's have a quick look at sleep this one is going to be a little bit easier so we see we probably want section two let's try that section three ten	section	222
k so will put that in there and will know that sleep return zero if the if it's actually manage to sleep number of seconds otherwise for sleep it will never return negative one so we don't have to worry about that for sleep so life is a bit simpler for sleep we just need to keep a running tally the total number of seconds slept so far so ok done plus equals are so that's a lot simpler in the right code again after right but gives you the same idea that we keep keep track of how much progress we've made towards completing our goal so if we now put this	code	401
into the earlier code where we played with process is you'd now notice that sleep now would works a lot better even when i have child processes that existing and causing c chart events which interrupt our sleep	code	17
hey class so let's talk about why anyone would use sig action instead of signal so signal is great is a great introduction to signals and it does have some limitations however first off we shouldn't use signal with multithreaded programs sig action is far more portable way to do this correctly the	thread	220
example you might say ok i'm going to install something for sigpipe instead of just directly passing in a pointer to the functioning want to call instead you set up one of these structs called sig action so the same name as the actual system we're going to use and justice before guess what if you really want to you can get the old value as well right so what are we find inside a cig action alright so several things here first of all some flags we should talk about we can give some hints about what should happen when a signal handler is fired sekli here's the masks are these going to be extra	the mask	561
example you might say ok i'm going to install something for sigpipe instead of just directly passing in a pointer to the functioning want to call instead you set up one of these structs called sig action so the same name as the actual system we're going to use and justice before guess what if you really want to you can get the old value as well right so what are we find inside a cig action alright so several things here first of all some flags we should talk about we can give some hints about what should happen when a signal handler is fired sekli here's the masks are these going to be extra	system	235
example you might say ok i'm going to install something for sigpipe instead of just directly passing in a pointer to the functioning want to call instead you set up one of these structs called sig action so the same name as the actual system we're going to use and justice before guess what if you really want to you can get the old value as well right so what are we find inside a cig action alright so several things here first of all some flags we should talk about we can give some hints about what should happen when a signal handler is fired sekli here's the masks are these going to be extra	pointer	106
access extra thread masks or process masks was we inside the signal handler so here's a justification suppose you were handling a real time signal and you	a thread	11
access extra thread masks or process masks was we inside the signal handler so here's a justification suppose you were handling a real time signal and you	thread	13
and it's critical that you do this quickly so you do not want to be interrupted this code is time sensitive you don't want to be interrupted steering the car is someone is button jamming control c on your keyboard at the time so let's let's turn off those signals that a lower priority to us the other thing to notice is that look this looks exactly like a function to a signal handler that we've seen before we wrote this kind of function here's the name of function i'm a pointer to something that takes an int and returns avoid that's just like our signal functions before	code	85
and it's critical that you do this quickly so you do not want to be interrupted this code is time sensitive you don't want to be interrupted steering the car is someone is button jamming control c on your keyboard at the time so let's let's turn off those signals that a lower priority to us the other thing to notice is that look this looks exactly like a function to a signal handler that we've seen before we wrote this kind of function here's the name of function i'm a pointer to something that takes an int and returns avoid that's just like our signal functions before	pointer	474
there is an option however to say he actually i want to know a lot more about the signal that actually happened so when you work with real time signals and other signals you can actually get a lot more information from the kernel about why this signal was created and what was going on at the time then door so there's a void pointer you can use yourself as well ok so this more complicated function is called a cig action	pointer	326
and by default is not used you have to specify a flag a flag to say hey kernel i'm going to install a special function called sing action not the handler so we're not going to look at it anymore inside two s forty one just but just realize that we're scratching the surface here a little bit with skipping over some of these more fast details so let's actually have a look at how we can set this up and you'll see then that the code is a few lot more lines longer than using a signal before so what do we do let's create one of these struts like the one above today i'm just going to make my regular handler code so that will be my little callback function it says hey stop pressing ctrl c or hey sigpipe happened or sick child happened now we need to set the mask and we have to decide to do we want to be interrupted worse my signal handler is running so for example i can simply say yeah i don't need to set any more bits i don't need to actually prevent that set alarm from going up and from interrupting my signal handler but if i wanted to be more conservative and say no was my handle is running don't let anybody else run i could change this to fill set for example right so i set up the mask there is one more fun thing you can do here you can auto start realtor start your posits course so do you remember things like read like right can return early let me turn negative one and then you have to check to see if ever know was set to be the special value of retry so	the mask	756
and by default is not used you have to specify a flag a flag to say hey kernel i'm going to install a special function called sing action not the handler so we're not going to look at it anymore inside two s forty one just but just realize that we're scratching the surface here a little bit with skipping over some of these more fast details so let's actually have a look at how we can set this up and you'll see then that the code is a few lot more lines longer than using a signal before so what do we do let's create one of these struts like the one above today i'm just going to make my regular handler code so that will be my little callback function it says hey stop pressing ctrl c or hey sigpipe happened or sick child happened now we need to set the mask and we have to decide to do we want to be interrupted worse my signal handler is running so for example i can simply say yeah i don't need to set any more bits i don't need to actually prevent that set alarm from going up and from interrupting my signal handler but if i wanted to be more conservative and say no was my handle is running don't let anybody else run i could change this to fill set for example right so i set up the mask there is one more fun thing you can do here you can auto start realtor start your posits course so do you remember things like read like right can return early let me turn negative one and then you have to check to see if ever know was set to be the special value of retry so	code	428
so this is what this restart option will do is that if the if the system called being interrupted supports it and it's being interrupted by a signal then it will automatically restart the kernel call for us automatically so if the handle is run because we're so what if we took over a thread that's currently in the kernel then this will automatically recall the system core force isn't that great isn't that kind of great so why do we have that for a little bit of a vapor performance game right so and then finally so we set up our struct and then great finally we can call it to say right i want to install this signal handler for sig in for example	a thread	283
so this is what this restart option will do is that if the if the system called being interrupted supports it and it's being interrupted by a signal then it will automatically restart the kernel call for us automatically so if the handle is run because we're so what if we took over a thread that's currently in the kernel then this will automatically recall the system core force isn't that great isn't that kind of great so why do we have that for a little bit of a vapor performance game right so and then finally so we set up our struct and then great finally we can call it to say right i want to install this signal handler for sig in for example	thread	285
so this is what this restart option will do is that if the if the system called being interrupted supports it and it's being interrupted by a signal then it will automatically restart the kernel call for us automatically so if the handle is run because we're so what if we took over a thread that's currently in the kernel then this will automatically recall the system core force isn't that great isn't that kind of great so why do we have that for a little bit of a vapor performance game right so and then finally so we set up our struct and then great finally we can call it to say right i want to install this signal handler for sig in for example	system	66
hi ok so let's make it a little bit more complicated now let's have a whole load of data structures ok so in this case i'm actually going to have eight different data structures here we go right and so for each one of these i'm going to use a condition variable to block when things are not ready and i'm going to need eight different locks now i probably could implement this code with just a single lock but then i might have unnecessary lock contention so lock contention is when one thread would like to continue but it can't because another thread is currently holding the lock and so of course that effects performance sometimes we actually need that behavior when another field is kind of into the same critical section but we could probably in this problem get by with a fewer number of locks sorry a few more locks in order to reduce lock contention so so in this case we have we've got eight condition variables and eight locks plus here's my data structure is actually is going to be of eight integers but i want you to imagine that this actually could be a lot more complicated ok right so i've got some initialization to initialize all my condition variables and locks as you can see all i'm doing is using the array name	block	265
hi ok so let's make it a little bit more complicated now let's have a whole load of data structures ok so in this case i'm actually going to have eight different data structures here we go right and so for each one of these i'm going to use a condition variable to block when things are not ready and i'm going to need eight different locks now i probably could implement this code with just a single lock but then i might have unnecessary lock contention so lock contention is when one thread would like to continue but it can't because another thread is currently holding the lock and so of course that effects performance sometimes we actually need that behavior when another field is kind of into the same critical section but we could probably in this problem get by with a fewer number of locks sorry a few more locks in order to reduce lock contention so so in this case we have we've got eight condition variables and eight locks plus here's my data structure is actually is going to be of eight integers but i want you to imagine that this actually could be a lot more complicated ok right so i've got some initialization to initialize all my condition variables and locks as you can see all i'm doing is using the array name	a struct	87
hi ok so let's make it a little bit more complicated now let's have a whole load of data structures ok so in this case i'm actually going to have eight different data structures here we go right and so for each one of these i'm going to use a condition variable to block when things are not ready and i'm going to need eight different locks now i probably could implement this code with just a single lock but then i might have unnecessary lock contention so lock contention is when one thread would like to continue but it can't because another thread is currently holding the lock and so of course that effects performance sometimes we actually need that behavior when another field is kind of into the same critical section but we could probably in this problem get by with a fewer number of locks sorry a few more locks in order to reduce lock contention so so in this case we have we've got eight condition variables and eight locks plus here's my data structure is actually is going to be of eight integers but i want you to imagine that this actually could be a lot more complicated ok right so i've got some initialization to initialize all my condition variables and locks as you can see all i'm doing is using the array name	code	377
hi ok so let's make it a little bit more complicated now let's have a whole load of data structures ok so in this case i'm actually going to have eight different data structures here we go right and so for each one of these i'm going to use a condition variable to block when things are not ready and i'm going to need eight different locks now i probably could implement this code with just a single lock but then i might have unnecessary lock contention so lock contention is when one thread would like to continue but it can't because another thread is currently holding the lock and so of course that effects performance sometimes we actually need that behavior when another field is kind of into the same critical section but we could probably in this problem get by with a fewer number of locks sorry a few more locks in order to reduce lock contention so so in this case we have we've got eight condition variables and eight locks plus here's my data structure is actually is going to be of eight integers but i want you to imagine that this actually could be a lot more complicated ok right so i've got some initialization to initialize all my condition variables and locks as you can see all i'm doing is using the array name	section	719
hi ok so let's make it a little bit more complicated now let's have a whole load of data structures ok so in this case i'm actually going to have eight different data structures here we go right and so for each one of these i'm going to use a condition variable to block when things are not ready and i'm going to need eight different locks now i probably could implement this code with just a single lock but then i might have unnecessary lock contention so lock contention is when one thread would like to continue but it can't because another thread is currently holding the lock and so of course that effects performance sometimes we actually need that behavior when another field is kind of into the same critical section but we could probably in this problem get by with a fewer number of locks sorry a few more locks in order to reduce lock contention so so in this case we have we've got eight condition variables and eight locks plus here's my data structure is actually is going to be of eight integers but i want you to imagine that this actually could be a lot more complicated ok right so i've got some initialization to initialize all my condition variables and locks as you can see all i'm doing is using the array name	thread	487
so that will decay to a simple pointer type and then i can use pointer arithmetic to make sure i point to	type	39
so that will decay to a simple pointer type and then i can use pointer arithmetic to make sure i point to	pointer	31
now let's actually look look at the code that i want to be need to be thread safe i'm going to have two methods here i've got a very simple modify method this is going to allow me to externally add some resources to a particular data structure so you can see all i'm doing is just modify one of the entries inside that away ok and then i've got this other function which actually i'm going to run multiple times with multiple threads so i'm going to have in fact seven threads running	a struct	232
now let's actually look look at the code that i want to be need to be thread safe i'm going to have two methods here i've got a very simple modify method this is going to allow me to externally add some resources to a particular data structure so you can see all i'm doing is just modify one of the entries inside that away ok and then i've got this other function which actually i'm going to run multiple times with multiple threads so i'm going to have in fact seven threads running	code	36
now let's actually look look at the code that i want to be need to be thread safe i'm going to have two methods here i've got a very simple modify method this is going to allow me to externally add some resources to a particular data structure so you can see all i'm doing is just modify one of the entries inside that away ok and then i've got this other function which actually i'm going to run multiple times with multiple threads so i'm going to have in fact seven threads running	thread	70
now let's actually look look at the code that i want to be need to be thread safe i'm going to have two methods here i've got a very simple modify method this is going to allow me to externally add some resources to a particular data structure so you can see all i'm doing is just modify one of the entries inside that away ok and then i've got this other function which actually i'm going to run multiple times with multiple threads so i'm going to have in fact seven threads running	resources	203
the particular index that i care about because i'm going to keep checking to see if that value is sufficiently large and in this case well other than just requesting for one resource what i'm going to say is that actually i need to wait for two resources so as soon as two resources are available on that particular entry i'm going to steal them away so this code is not yet thread safe but it's heading in this direction	code	359
the particular index that i care about because i'm going to keep checking to see if that value is sufficiently large and in this case well other than just requesting for one resource what i'm going to say is that actually i need to wait for two resources so as soon as two resources are available on that particular entry i'm going to steal them away so this code is not yet thread safe but it's heading in this direction	thread	375
the particular index that i care about because i'm going to keep checking to see if that value is sufficiently large and in this case well other than just requesting for one resource what i'm going to say is that actually i need to wait for two resources so as soon as two resources are available on that particular entry i'm going to steal them away so this code is not yet thread safe but it's heading in this direction	resources	245
and then one stack condition is true once we know that our data value is at least two then modify that data structure here we go we're actually going to remov two things from that ok so now we've pulled who things off that data structure we do a bit of processing and we've constructed a brand new toy and we put it into the next data structure so that's what this is going to do i'm going to increment my data structure to my right and i'm going to add one thing to it so we're actually going to run this code like i said for multiple values of i we're going to run it in fact for all except the very very last entry	a struct	106
and then one stack condition is true once we know that our data value is at least two then modify that data structure here we go we're actually going to remov two things from that ok so now we've pulled who things off that data structure we do a bit of processing and we've constructed a brand new toy and we put it into the next data structure so that's what this is going to do i'm going to increment my data structure to my right and i'm going to add one thing to it so we're actually going to run this code like i said for multiple values of i we're going to run it in fact for all except the very very last entry	code	506
inside my data because i don't want to have a buffer overflow here i don't want to be on the end of my way ok so let's think about how we can now turn this into something which is thread safe we don't want to sleep for a bit this is where we should call p thread conditioned	thread	180
kay right and let's sleep on a particular condition variable associated with this particular data structure so that would be cvs plus i here we go	a struct	96
right so what will declare then is to anytime you want to read the value inside a data structure and you want to make sure that no one else can change it then you better get the lock for the data structure right so	the data structure	187
right so what will declare then is to anytime you want to read the value inside a data structure and you want to make sure that no one else can change it then you better get the lock for the data structure right so	a struct	85
up inside here before we do anything we read a kalpi threadlock p thread mutex lock on lock plus i	thread	53
and then when we finished with that we can release it so we might as well release it as soon as possible let's do it right here so will now we can porp call p thread mutex unlock on that same locks are locked plus i ok right you'll notice that we are modifying a different data structure down here so before we do it before we do that we should surround this with our lock and unlock calls for for the other mutex lock associated with that data structure so that is going to be locks	a struct	276
and then when we finished with that we can release it so we might as well release it as soon as possible let's do it right here so will now we can porp call p thread mutex unlock on that same locks are locked plus i ok right you'll notice that we are modifying a different data structure down here so before we do it before we do that we should surround this with our lock and unlock calls for for the other mutex lock associated with that data structure so that is going to be locks	thread	159
plus one ok and i've forgotten ass down here so it's actually locks plus i ok so this is kind of sketching out what we're going to do will look at some real code in the moment and simply down here before i modify this ok i actually want to make sure that i will require the right lock so we're going to be for here called please i want to lock the white mutex locks that's going to be locks plus index	code	157
and then a corresponding unlock call down here right all we done new we've forgotten a few things first of all if i was writing this code i would certainly using assert to check that my index is between zero and less than n otherwise i'm going to be looking at	code	133
an illegal or invalid piece of memory when i do this i had put in a certain at that point	memory	31
right what else have we forgotten we have forgotten to do any podcasting so we're sending our threats to sleep but we never wake them up oh dear ok so let's think about when we should wake them up well we should wait things up whenever we whenever it might be that another waiting thread can continue so we've seen how are threads go to sleep if there's less than two items so if i've i've incremented my value here and it's now above two maybe i should be broadcasting and waking somebody up so i could put some additional logic in here or i could just say hey bring the building the fire bell and let them go round there loop so the latest code i can write with bp thread condition broadcast and then	code	642
right what else have we forgotten we have forgotten to do any podcasting so we're sending our threats to sleep but we never wake them up oh dear ok so let's think about when we should wake them up well we should wait things up whenever we whenever it might be that another waiting thread can continue so we've seen how are threads go to sleep if there's less than two items so if i've i've incremented my value here and it's now above two maybe i should be broadcasting and waking somebody up so i could put some additional logic in here or i could just say hey bring the building the fire bell and let them go round there loop so the latest code i can write with bp thread condition broadcast and then	thread	281
if there's anybody sleeping inside this condition variable if they're blocked let's wake them up and send them around there while loop again so we would wake anybody up inside cvs plus index	block	70
thread will go back into peter condition wait and block again so that's what we're doing is we're just say i don't want to repeat any additional logic in here just wake up somebody who might care and simply we need to do that down here where after we've dated the i plus once data structure we better call p thread condition broadcast ok so enough of sketching this out let's actually have a look at some code ok and here is my code you'll see that it's actually littered with a few extra things that now i actually got another thread that is actually going to be displaying what is going on and we can see whether particular i thread has managed to lock mutex locks so if it gets dark inside this moment here it will be stuck on lock	block	50
thread will go back into peter condition wait and block again so that's what we're doing is we're just say i don't want to repeat any additional logic in here just wake up somebody who might care and simply we need to do that down here where after we've dated the i plus once data structure we better call p thread condition broadcast ok so enough of sketching this out let's actually have a look at some code ok and here is my code you'll see that it's actually littered with a few extra things that now i actually got another thread that is actually going to be displaying what is going on and we can see whether particular i thread has managed to lock mutex locks so if it gets dark inside this moment here it will be stuck on lock	a struct	279
thread will go back into peter condition wait and block again so that's what we're doing is we're just say i don't want to repeat any additional logic in here just wake up somebody who might care and simply we need to do that down here where after we've dated the i plus once data structure we better call p thread condition broadcast ok so enough of sketching this out let's actually have a look at some code ok and here is my code you'll see that it's actually littered with a few extra things that now i actually got another thread that is actually going to be displaying what is going on and we can see whether particular i thread has managed to lock mutex locks so if it gets dark inside this moment here it will be stuck on lock	code	405
thread will go back into peter condition wait and block again so that's what we're doing is we're just say i don't want to repeat any additional logic in here just wake up somebody who might care and simply we need to do that down here where after we've dated the i plus once data structure we better call p thread condition broadcast ok so enough of sketching this out let's actually have a look at some code ok and here is my code you'll see that it's actually littered with a few extra things that now i actually got another thread that is actually going to be displaying what is going on and we can see whether particular i thread has managed to lock mutex locks so if it gets dark inside this moment here it will be stuck on lock	thread	0
if it is about to go into peter condition wait you will see that it will see nap here ok so if the value is less than two we're going to nap the other thing you might notice is that i've now updated the code so that if my quick variable has been set	code	203
very first thread here let's have a look queso unlock unlock all right here it is so i eventually unlock down here but i could actually cause unlock earlier here so let's let's put that now in turkey a more reasonable order i would like to unlock much earlier so there's no point unlocking so late ok and	thread	11
so convention let's always put our broadcasting signals inside my lock and unlock code for case and now i'm only going to call signal inside	code	82
in last i am holding the relevant lock so remember p taking signal is just going to wake up one fit and in this case is perfectly fine because actually my application is only using one thread for each data structure ok so just for fun i use pthread broadcast here but let's skin down see what we've got right i've got some other code calls get char we keep going until you press q all this normal characters left ok when we want to quit let's call quit and i'm going to just call broadcast on the very first thread so right let's let's let's run this	a struct	204
in last i am holding the relevant lock so remember p taking signal is just going to wake up one fit and in this case is perfectly fine because actually my application is only using one thread for each data structure ok so just for fun i use pthread broadcast here but let's skin down see what we've got right i've got some other code calls get char we keep going until you press q all this normal characters left ok when we want to quit let's call quit and i'm going to just call broadcast on the very first thread so right let's let's let's run this	code	329
in last i am holding the relevant lock so remember p taking signal is just going to wake up one fit and in this case is perfectly fine because actually my application is only using one thread for each data structure ok so just for fun i use pthread broadcast here but let's skin down see what we've got right i've got some other code calls get char we keep going until you press q all this normal characters left ok when we want to quit let's call quit and i'm going to just call broadcast on the very first thread so right let's let's let's run this	thread	185
ok i've got my binary game right so gcc if we want p thread please ok find me game	thread	53
let's do this right so as you can see elma threads of nat right so let's start adding a few things to this i'm going to add going to call that modify method on just zero and i can start sending items in right and if you notice what i've actually got is a binary counter because i'm able to eat two two cookies and then generate one cookie to my rights i've actually got something which is going to count the total number of resources or cookies that i've added here to my o th entry there we go and each time i press zero looks like i'm i'm adding about four cookies maybe	a thread	41
let's do this right so as you can see elma threads of nat right so let's start adding a few things to this i'm going to add going to call that modify method on just zero and i can start sending items in right and if you notice what i've actually got is a binary counter because i'm able to eat two two cookies and then generate one cookie to my rights i've actually got something which is going to count the total number of resources or cookies that i've added here to my o th entry there we go and each time i press zero looks like i'm i'm adding about four cookies maybe	thread	43
let's do this right so as you can see elma threads of nat right so let's start adding a few things to this i'm going to add going to call that modify method on just zero and i can start sending items in right and if you notice what i've actually got is a binary counter because i'm able to eat two two cookies and then generate one cookie to my rights i've actually got something which is going to count the total number of resources or cookies that i've added here to my o th entry there we go and each time i press zero looks like i'm i'm adding about four cookies maybe	resources	424
well even ate cookies so one there's one yeah it looks like eight cookies right so i can so each time this runs as its adding more each thread will get a signal to wake up so the last thing is let's press q here	thread	136
and the funny thing is that it all quits let's understand why because we only called p thread where's where's my quit we only called this broadcast here on the very first condition variable ok so what are we doing here	thread	87
right so when it quits then that first red quits it is going to call peter condition signal on the next thread ok so if that thread is sleeping we wake it up and then it will notice that the quick variable has been set and so that will quit as well now this code perfect no there's actually a small race condition is actually very small possibility that we intend to call peter condition	code	258
right so when it quits then that first red quits it is going to call peter condition signal on the next thread ok so if that thread is sleeping we wake it up and then it will notice that the quick variable has been set and so that will quit as well now this code perfect no there's actually a small race condition is actually very small possibility that we intend to call peter condition	thread	104
signal here but we do it just before a thread is actually	a thread	37
signal here but we do it just before a thread is actually	thread	39
let's also put this inside a mutex locks so p thread mutex lock an i want to look on my locks plus i plus one ok so now we can say strong statements about where the code must be in if we have if we are able to hold the mutex lock ok so we want to change this to plus one ok so right so that's it that's kind of fun little kind of counter game as usual this code is inside github if you want to play with it ok bye	code	165
let's also put this inside a mutex locks so p thread mutex lock an i want to look on my locks plus i plus one ok so now we can say strong statements about where the code must be in if we have if we are able to hold the mutex lock ok so we want to change this to plus one ok so right so that's it that's kind of fun little kind of counter game as usual this code is inside github if you want to play with it ok bye	a mutex	27
let's also put this inside a mutex locks so p thread mutex lock an i want to look on my locks plus i plus one ok so now we can say strong statements about where the code must be in if we have if we are able to hold the mutex lock ok so we want to change this to plus one ok so right so that's it that's kind of fun little kind of counter game as usual this code is inside github if you want to play with it ok bye	thread	46
and as you know they are necessary and sufficient we need all fall to be true and exactly or for them to be true and then we know that we've met the conditions for deadlock so what are they let's actually look at some definitions here so here's the first wanna process is currently holding at least one resource and requesting additional resources which are being held by other processes ok so it is holding and waiting so that's a hold and wait condition	a process	259
and as you know they are necessary and sufficient we need all fall to be true and exactly or for them to be true and then we know that we've met the conditions for deadlock so what are they let's actually look at some definitions here so here's the first wanna process is currently holding at least one resource and requesting additional resources which are being held by other processes ok so it is holding and waiting so that's a hold and wait condition	resources	338
my process is all threads only needed to actually hold on to say just one mutex lock at a time that deadlock would be impossible	thread	18
and the process or thread wait for graph	thread	19
no pre emption right that we cannot force a task or thread to put down a lot or something that is acquired exclusively ok no pre are going to say pre emptive but let's change that to know preemption	thread	52
oh i forgot to say one little thing about errno down here which is when is it set ok so here's a big idea is that it set to zero when your first program first starts up its value is changed whenever there's an error with a system call and we read the man pages to learn more about that but it's never reset back to zero so if i had a whole lot of calls let's say that i try to read from one particular file descriptor and then try to write those bytes somewhere else to another file descriptor fd two over here if i then check if errno zero or not then i can't actually tell you whether where the error curd maybe it happened early on inside my read maybe it happened inside my right or maybe it happened even earlier so just think of is a global variable that if an error occurs we change it	a system call	221
oh i forgot to say one little thing about errno down here which is when is it set ok so here's a big idea is that it set to zero when your first program first starts up its value is changed whenever there's an error with a system call and we read the man pages to learn more about that but it's never reset back to zero so if i had a whole lot of calls let's say that i try to read from one particular file descriptor and then try to write those bytes somewhere else to another file descriptor fd two over here if i then check if errno zero or not then i can't actually tell you whether where the error curd maybe it happened early on inside my read maybe it happened inside my right or maybe it happened even earlier so just think of is a global variable that if an error occurs we change it	system	223
so now if you do that and you make some system calls	system	40
in practice of course bulletproof code robust production code would actually check the return values of all of your system calls and that is kind of really good system programming practice to kind of detect when errors go wrong and actually becomes critical when you start writing network code c in the next video bye	code	34
in practice of course bulletproof code robust production code would actually check the return values of all of your system calls and that is kind of really good system programming practice to kind of detect when errors go wrong and actually becomes critical when you start writing network code c in the next video bye	system	116
colon and then the port number so off we go and what what do we see we actually see that this little module by by python gives me a directory listing and then i can click on a link here ok and actually see the code that we just wrote today which is kind of fun	code	210
ok and if i wanted i could have a little website here as well so now let's do let's do our web client in c so here we go one of the same thing now from our c code	code	158
we'll see that my python server's been happily reporting all the things that firefox has been requesting so let me break out of that now an run it in the background ok so off it goes because now i want to start compiling my code right so compile the client and run it and we see the beginnings of this yes it connects we see a status message of two hundred which means the server liked our request and it tells me the content length is four hundred and eighteen bytes but for some reason we don't see the content our problem right now is that we just called read once and so we got back the header but that wasn't enough to see the rest of the information so time to wrap this inside a loop ok so let's keep on reading read until we don't want to case so let's think about first of all we want to escape this if if read returned a zero or negative value so zero remember for read means that there's no more bytes so zero would mean the end it's the end of the line no more bytes for you negative one would be failure so in either case we'll stop so	the header	587
we'll see that my python server's been happily reporting all the things that firefox has been requesting so let me break out of that now an run it in the background ok so off it goes because now i want to start compiling my code right so compile the client and run it and we see the beginnings of this yes it connects we see a status message of two hundred which means the server liked our request and it tells me the content length is four hundred and eighteen bytes but for some reason we don't see the content our problem right now is that we just called read once and so we got back the header but that wasn't enough to see the rest of the information so time to wrap this inside a loop ok so let's keep on reading read until we don't want to case so let's think about first of all we want to escape this if if read returned a zero or negative value so zero remember for read means that there's no more bytes so zero would mean the end it's the end of the line no more bytes for you negative one would be failure so in either case we'll stop so	code	224
we'll see that my python server's been happily reporting all the things that firefox has been requesting so let me break out of that now an run it in the background ok so off it goes because now i want to start compiling my code right so compile the client and run it and we see the beginnings of this yes it connects we see a status message of two hundred which means the server liked our request and it tells me the content length is four hundred and eighteen bytes but for some reason we don't see the content our problem right now is that we just called read once and so we got back the header but that wasn't enough to see the rest of the information so time to wrap this inside a loop ok so let's keep on reading read until we don't want to case so let's think about first of all we want to escape this if if read returned a zero or negative value so zero remember for read means that there's no more bytes so zero would mean the end it's the end of the line no more bytes for you negative one would be failure so in either case we'll stop so	background	154
compile run it again and now we see our web server is actually giving back the very code that was used to request it which i think is kind of cool alright that's enough for this lecture i will see you on friday ok bye	code	84
hi ok so i want to talk about a classic problem called producer consumer and in particular we're going to implement this using a fixed sized ring buffer so here's the game you might have multiple threads or even processes that produce a lot of things and then consumers which consume a lot of things and we need a way to couple these together so let's put some kind of queue between them and in cs two twenty five you might have implemented a queue that could grow arbitrarily large but what we'd like to do instead is to say ok producer please stop right now i don't want to just exhaust all my memory holding onto these things that you're giving me i'd actually like to block you until i'm ready to consume these things	memory	596
hi ok so i want to talk about a classic problem called producer consumer and in particular we're going to implement this using a fixed sized ring buffer so here's the game you might have multiple threads or even processes that produce a lot of things and then consumers which consume a lot of things and we need a way to couple these together so let's put some kind of queue between them and in cs two twenty five you might have implemented a queue that could grow arbitrarily large but what we'd like to do instead is to say ok producer please stop right now i don't want to just exhaust all my memory holding onto these things that you're giving me i'd actually like to block you until i'm ready to consume these things	block	672
hi ok so i want to talk about a classic problem called producer consumer and in particular we're going to implement this using a fixed sized ring buffer so here's the game you might have multiple threads or even processes that produce a lot of things and then consumers which consume a lot of things and we need a way to couple these together so let's put some kind of queue between them and in cs two twenty five you might have implemented a queue that could grow arbitrarily large but what we'd like to do instead is to say ok producer please stop right now i don't want to just exhaust all my memory holding onto these things that you're giving me i'd actually like to block you until i'm ready to consume these things	thread	196
simply for the consumer we want that thread or process to be blocked if there's nothing available to consume	block	61
simply for the consumer we want that thread or process to be blocked if there's nothing available to consume	thread	37
ok so here's what we're going to do between the producer and a consumer we are going to put a little ring buffer in here so let me try to draw a perfect circle that some powers best you're going to get today which will hold all of my values so we'll go out to amazon buy ourselves some circular memory	memory	295
right now one thing to understand is that often we distort kind of bits inside here or pointers etc and it's probably reasonable to not bother to actually going to delete these things if it's just a simple kind of bit copy so these values might actually hang	pointer	87
around inside this memory so what is important though is is to understand that where we are reading and writing from this ring buffer is controlled by these two little pointers or there's two little indices ok now in practice we're not actually going to write	memory	19
around inside this memory so what is important though is is to understand that where we are reading and writing from this ring buffer is controlled by these two little pointers or there's two little indices ok now in practice we're not actually going to write	pointer	168
buy some some circular memory instead our memory is linear ok here it is an so let me put aside some memory for example sixteen sixteen little slots in here so i can keep dividing this up ok so now i've got sixteen memory locations	memory	23
and my trick for making certain memory will just simply be if i fall off the end here then start at the beginning so it's perfect for all the people that believe in flat earth etc so right i've had i do that well i could use modulo with matich but i'm going to use bitmasking ok so if i've got a little index here let's call it in a little integer here then as i incremented i asked you only want the lowest bits so if my ring buffer it says of size sixteen then i need to just take the lowest for bits and how can i do that i can say bitmask please with fifteen or if i want to write that in text decimal of x f so that will just ensure that each time i use this my end pointer in here will keep going around here and when i fall off the end i will start at the beginning now we need to make sure that the ring buffer never gets never allows me to push things in if it's already full and never allows me to pull things from it if it's already empty otherwise i will start to either off see a buffer overflow issues or buffer underflow issues so underflow is when you try to read something from a memory structure and there's nothing actually there ok so in these situations we actually want to block	memory	32
and my trick for making certain memory will just simply be if i fall off the end here then start at the beginning so it's perfect for all the people that believe in flat earth etc so right i've had i do that well i could use modulo with matich but i'm going to use bitmasking ok so if i've got a little index here let's call it in a little integer here then as i incremented i asked you only want the lowest bits so if my ring buffer it says of size sixteen then i need to just take the lowest for bits and how can i do that i can say bitmask please with fifteen or if i want to write that in text decimal of x f so that will just ensure that each time i use this my end pointer in here will keep going around here and when i fall off the end i will start at the beginning now we need to make sure that the ring buffer never gets never allows me to push things in if it's already full and never allows me to pull things from it if it's already empty otherwise i will start to either off see a buffer overflow issues or buffer underflow issues so underflow is when you try to read something from a memory structure and there's nothing actually there ok so in these situations we actually want to block	block	1195
and my trick for making certain memory will just simply be if i fall off the end here then start at the beginning so it's perfect for all the people that believe in flat earth etc so right i've had i do that well i could use modulo with matich but i'm going to use bitmasking ok so if i've got a little index here let's call it in a little integer here then as i incremented i asked you only want the lowest bits so if my ring buffer it says of size sixteen then i need to just take the lowest for bits and how can i do that i can say bitmask please with fifteen or if i want to write that in text decimal of x f so that will just ensure that each time i use this my end pointer in here will keep going around here and when i fall off the end i will start at the beginning now we need to make sure that the ring buffer never gets never allows me to push things in if it's already full and never allows me to pull things from it if it's already empty otherwise i will start to either off see a buffer overflow issues or buffer underflow issues so underflow is when you try to read something from a memory structure and there's nothing actually there ok so in these situations we actually want to block	pointer	671
which is going to add things in here so here's my kind of value we definitely care about the type and i'll need some kind of buffer in here so will say some kind of buffer let's imagine it's a size sixteen if it's a buffer and it's just great to be int here if it's a buffer of character pointers how character pointers if it's a buffer of tasks for example 'cause i want to give each threads different tasks to do it might look something like that pointed at tasks ok so let's think about how we can implement this so	type	93
which is going to add things in here so here's my kind of value we definitely care about the type and i'll need some kind of buffer in here so will say some kind of buffer let's imagine it's a size sixteen if it's a buffer and it's just great to be int here if it's a buffer of character pointers how character pointers if it's a buffer of tasks for example 'cause i want to give each threads different tasks to do it might look something like that pointed at tasks ok so let's think about how we can implement this so	thread	385
which is going to add things in here so here's my kind of value we definitely care about the type and i'll need some kind of buffer in here so will say some kind of buffer let's imagine it's a size sixteen if it's a buffer and it's just great to be int here if it's a buffer of character pointers how character pointers if it's a buffer of tasks for example 'cause i want to give each threads different tasks to do it might look something like that pointed at tasks ok so let's think about how we can implement this so	pointer	288
make it a circular little world here and loops and then later return result ok so there's actually two basic concurrency we need to think about here first of all let's do the blocking ok so the blocking we actually want to block if there's not enough space so i'll use a counting semaphore to say please take his pizza slice and i'll have account semaphore before which represents the amount of space available so the number of empty slots in my data structure so the number of spaces	block	175
make it a circular little world here and loops and then later return result ok so there's actually two basic concurrency we need to think about here first of all let's do the blocking ok so the blocking we actually want to block if there's not enough space so i'll use a counting semaphore to say please take his pizza slice and i'll have account semaphore before which represents the amount of space available so the number of empty slots in my data structure so the number of spaces	a struct	449
i will have the similar when i want to remove things let's have a counting semaphore that represents the number of items actually inside my data structure	a struct	143
ok after we have dequeued something let's make a note of the number of spaces has now increased can now be increased by one notice we only do this after we've modified the data structure we don't want another thread to immediately to continue until after there truly is what item that has been written ok so only after we've actually pushed it in there do we actually want waiting dequeue to continue	the data structure	168
ok after we have dequeued something let's make a note of the number of spaces has now increased can now be increased by one notice we only do this after we've modified the data structure we don't want another thread to immediately to continue until after there truly is what item that has been written ok so only after we've actually pushed it in there do we actually want waiting dequeue to continue	a struct	175
ok after we have dequeued something let's make a note of the number of spaces has now increased can now be increased by one notice we only do this after we've modified the data structure we don't want another thread to immediately to continue until after there truly is what item that has been written ok so only after we've actually pushed it in there do we actually want waiting dequeue to continue	thread	209
ok so are we done yes this would work if we have just one thread and curing on one thread dequeuing	thread	58
across multiple processes using shared memory but more about that in the future also notice that my counting semaphores here number spaces and numb items i'm afraid works on linux but does not work on os x so if you in turn apple maybe think about this as a summer project ok so great we've got something which works providing only one thread at a time is calling nq if i have multiple threads then they could both get past this line but my changing of the buffer here is actually critical section i don't want two threads to see the same value of in here so first of all declare these right and so i better have a mutex lock inside here so pthread mutex look	memory	39
across multiple processes using shared memory but more about that in the future also notice that my counting semaphores here number spaces and numb items i'm afraid works on linux but does not work on os x so if you in turn apple maybe think about this as a summer project ok so great we've got something which works providing only one thread at a time is calling nq if i have multiple threads then they could both get past this line but my changing of the buffer here is actually critical section i don't want two threads to see the same value of in here so first of all declare these right and so i better have a mutex lock inside here so pthread mutex look	a mutex	613
across multiple processes using shared memory but more about that in the future also notice that my counting semaphores here number spaces and numb items i'm afraid works on linux but does not work on os x so if you in turn apple maybe think about this as a summer project ok so great we've got something which works providing only one thread at a time is calling nq if i have multiple threads then they could both get past this line but my changing of the buffer here is actually critical section i don't want two threads to see the same value of in here so first of all declare these right and so i better have a mutex lock inside here so pthread mutex look	section	490
across multiple processes using shared memory but more about that in the future also notice that my counting semaphores here number spaces and numb items i'm afraid works on linux but does not work on os x so if you in turn apple maybe think about this as a summer project ok so great we've got something which works providing only one thread at a time is calling nq if i have multiple threads then they could both get past this line but my changing of the buffer here is actually critical section i don't want two threads to see the same value of in here so first of all declare these right and so i better have a mutex lock inside here so pthread mutex look	thread	336
i can unlock that ok now this is actually one example where the encoding in decoding happens at different points in my data structure and so i could actually have two different locks there we go so i could have a second mutex lock	a struct	122
there we go for my dequeue event ok so right that's the somewhere you've got lots of concurrency going on here this idea that i protected the critical section using a mutex lock and i'm using a counting semaphore to make sure that i don't get buffer underflow or buffer overflow alright that's it bye	a mutex	165
there we go for my dequeue event ok so right that's the somewhere you've got lots of concurrency going on here this idea that i protected the critical section using a mutex lock and i'm using a counting semaphore to make sure that i don't get buffer underflow or buffer overflow alright that's it bye	section	151
ok so let's have a look at his code right so for main() we are going to call this directory listing so right let's let's jump in there and see what this is supposed to do so the idea is that we can print out all of the files inside that directory and also recurse into any subdirectories 'ok so let's start kind of working through this and see what we want to change	code	31
right so we're kind of call opendir a great that might fail so we really need a test in here to say if dirp is zero is there is null then we couldn't open the current path as a directory maybe that's because we didn't have permission to go into that subdirectory maybe the very first directory we were given wasn't valid anyway so we should make that code little bit more	code	351
right so now we've printed that, sorry, now we've calculated that we can print it out so in this case this print formatted string is clearly wrong we could reduce it down to just printing out the name or we could print out say the new path and then finally let's recurse so right now this is going to happily recurse into everything even regular files at some point we should fix this and use what we've learned about using stat and the mode bits and macro to actually only recurse if we come across a comic con cos a directory ok so let's have a go at fixing this right so let's turn it off and ok so i've got my starting point here	string	123
we can have an error as well so ok so the path and strerror of oh no ok so if that happens that do not pass go do not collect two hundred dollars but immediately return ok so the next thing is we're going to keep going around and we want to construct our strings so let's have a new path alternatively we could of course have said new path of max path	string	255
did i not type it correctly ok let's try one more time	type	10
ok so now when we run it says failed to open null bad address why because we didn't give it any arguments so a slightly better program here would at least print out a usage string here so let's let's improve this a little bit that says look if you didn't give me one argument so i expect argosy to be too	string	173
ok so now when we run it says failed to open null bad address why because we didn't give it any arguments so a slightly better program here would at least print out a usage string here so let's let's improve this a little bit that says look if you didn't give me one argument so i expect argosy to be too	address	54
it's a double dot so if that is true then great we want to just skip these entries so how can i do that i can just say continue continue around the loop ok right so let's compile this and this time ok now it's looking a lot better right so now we've got the problem that it's trying to recurse into every single entry that it finds i think it's time to add our stack code so we'll only call directory list recurse in the case that it truly is a directory so i wanted to say i need	the loop	144
it's a double dot so if that is true then great we want to just skip these entries so how can i do that i can just say continue continue around the loop ok right so let's compile this and this time ok now it's looking a lot better right so now we've got the problem that it's trying to recurse into every single entry that it finds i think it's time to add our stack code so we'll only call directory list recurse in the case that it truly is a directory so i wanted to say i need	code	367
a struct	a struct	0
let's type a little bit struct stat s ok and i can say alright stat	type	6
and only then do i actually trust the values inside that struct otherwise it's arbitrary it's just whatever happens to be on the stack at this point right so if we win great let's recurse ok right so now let's have a go right so we'll compile it and i can't type let's fix that little s ok right	type	258
so what do you notice is wrong now so let's run it and it appears to work how ever however however however we've forgot to do something very important which is we forgot to close the directory after we finished using ok so before any of my return paths so we need to make sure we've freed up all resources so this one ok there is no open directory but down here i do have an open directory ok so close directory like and i'm going to say here's my dirp there we go	resources	296
all right and you'll see that it's happily going into a whole load of directories that i made earlier right so for example if i said ok let's make some directories and make all the parent ones which don't exist i could say right one two three abc d ok so now if i look at start from the beginning you'll see that it made abc and d so i've got all these directions and it would happily went into all of these different directories isn't that cool right so great we can now recurse through directories we learned quite a bit we've used stat and the mode bits we've used asprintf to construct strings and we've used opendir reader in order to read each entry of directory ok great so is it working yeah it looks pretty good there's is it perfect no 'cause now we can do some pretty exciting things so	printf	570
all right and you'll see that it's happily going into a whole load of directories that i made earlier right so for example if i said ok let's make some directories and make all the parent ones which don't exist i could say right one two three abc d ok so now if i look at start from the beginning you'll see that it made abc and d so i've got all these directions and it would happily went into all of these different directories isn't that cool right so great we can now recurse through directories we learned quite a bit we've used stat and the mode bits we've used asprintf to construct strings and we've used opendir reader in order to read each entry of directory ok great so is it working yeah it looks pretty good there's is it perfect no 'cause now we can do some pretty exciting things so	string	590
ok do i have sound yes ok so last thing we do today is actually kind of put everything together that we've seen so far and talk about how to make a real auto grader so today if you would write an order greater say in python you wouldn't necessarily to make your own pipes but guess what python itself is making pipes for you so here we go let's see how it works and this is actually based on real cs two forty one code here that we used to test some programs and i want to kind of notice that there's some kind of production quality inside here that we do ashley things like check the return value of our system calls so let's check the pipe work now if it fails or we're	code	414
ok do i have sound yes ok so last thing we do today is actually kind of put everything together that we've seen so far and talk about how to make a real auto grader so today if you would write an order greater say in python you wouldn't necessarily to make your own pipes but guess what python itself is making pipes for you so here we go let's see how it works and this is actually based on real cs two forty one code here that we used to test some programs and i want to kind of notice that there's some kind of production quality inside here that we do ashley things like check the return value of our system calls so let's check the pipe work now if it fails or we're	system	605
going to do is just quit this little kind of error function error message but at least we're checking to make sure that everything is truly truly working now when i'm going to create a greater i actually need three pipes i need one for standard in one percent without one for standard error ok so to create all those pipes here's what would do you give me an integer array of six entries so here in fact is the six integers they were going to play with and then that's past the address of this little away into my create pipes and each time we are going to call my pipe command back up here ok so i end up with now three pipes	address	478
ok sue now my alternator has to use fork so will do the same thing again here so let's call fork but if fork fails don't just try again now we want to quit with some kind of error message so that's the same kind of idea as my piper quit let's just rap the system call with quick test	system	256
hi welcome to the last video of lecture seven ok so what do we got right spot some so first thing i don't like is the formatting in this these really should be indented and better laid out ok so villa function returns a pointer character and see on the stack i'm going to have sixteen bytes called result and i struck out into result high so we're giving it the address of the edge ok here's the first thing i don't like stroke at says concatenate in other words walk along the bikes which are already there until you find that zero bite but we never initially results so it would just be whatever happens to be on the stack memory is completely arbitrary so that should have been stewart cat but what should have been through a copy	memory	625
hi welcome to the last video of lecture seven ok so what do we got right spot some so first thing i don't like is the formatting in this these really should be indented and better laid out ok so villa function returns a pointer character and see on the stack i'm going to have sixteen bytes called result and i struck out into result high so we're giving it the address of the edge ok here's the first thing i don't like stroke at says concatenate in other words walk along the bikes which are already there until you find that zero bite but we never initially results so it would just be whatever happens to be on the stack memory is completely arbitrary so that should have been stewart cat but what should have been through a copy	address	362
hi welcome to the last video of lecture seven ok so what do we got right spot some so first thing i don't like is the formatting in this these really should be indented and better laid out ok so villa function returns a pointer character and see on the stack i'm going to have sixteen bytes called result and i struck out into result high so we're giving it the address of the edge ok here's the first thing i don't like stroke at says concatenate in other words walk along the bikes which are already there until you find that zero bite but we never initially results so it would just be whatever happens to be on the stack memory is completely arbitrary so that should have been stewart cat but what should have been through a copy	pointer	220
ok right and then we say ok i've got a pointer and it point in 's right is the address of a not equal to know	address	79
ok right and then we say ok i've got a pointer and it point in 's right is the address of a not equal to know	pointer	39
i am extremely confident that will always be true even though we haven't initialized adb anything hey itself is on the stack and that's what i'm asking for where is my age and it's it's a little stack variable some automatic variable here it is we declared it right here so i know for sure that actually ok it's just useless code so that is definitely valid code and always true so we will print yes ok i'll present d here is going to be forty two ok now what do we do make some linked lists in see ok this can be trickier than it first appears ok so i've got my first link list i've got some struck somewhere now when you see the word struck don't panic just consider that a bit like a class in c plus plus except there's no constructive 's no code is going to run a tool all we're doing is simply saying hey i've got a memory layout i'm going to define somewhere else inside my code so the compiler knows how many bytes i need to represent this particular struct and for now all i'm doing is to say i've got a variable that can point to this struct going to call it first	memory	821
i am extremely confident that will always be true even though we haven't initialized adb anything hey itself is on the stack and that's what i'm asking for where is my age and it's it's a little stack variable some automatic variable here it is we declared it right here so i know for sure that actually ok it's just useless code so that is definitely valid code and always true so we will print yes ok i'll present d here is going to be forty two ok now what do we do make some linked lists in see ok this can be trickier than it first appears ok so i've got my first link list i've got some struck somewhere now when you see the word struck don't panic just consider that a bit like a class in c plus plus except there's no constructive 's no code is going to run a tool all we're doing is simply saying hey i've got a memory layout i'm going to define somewhere else inside my code so the compiler knows how many bytes i need to represent this particular struct and for now all i'm doing is to say i've got a variable that can point to this struct going to call it first	code	325
and in the future maybe i want to kind of reader right parts of that memory structure so it's laid out in a certain way and so things like if there's a pointer stored inside that struct then i can actually get to that value so if you tell me where that that's trucked is because you've got appointed to it like we do first then i can start reading out different parts of that struck ok so what do we do right we call first and we say size of struck link ok alarm bells should go off at this moment first of all they were using malloc we better slow down and check to see if we're allocating enough bites and are we no of course not we made a mistake we asked for the size of strut link pointer which is going to be four by eight or eight bytes probably not enough bytes to actually hold a real struct so how do we fix this we do not need the astrex here we actually need the size of the real memory structure	memory	69
and in the future maybe i want to kind of reader right parts of that memory structure so it's laid out in a certain way and so things like if there's a pointer stored inside that struct then i can actually get to that value so if you tell me where that that's trucked is because you've got appointed to it like we do first then i can start reading out different parts of that struck ok so what do we do right we call first and we say size of struck link ok alarm bells should go off at this moment first of all they were using malloc we better slow down and check to see if we're allocating enough bites and are we no of course not we made a mistake we asked for the size of strut link pointer which is going to be four by eight or eight bytes probably not enough bytes to actually hold a real struct so how do we fix this we do not need the astrex here we actually need the size of the real memory structure	pointer	152
ok and then we free it ok so now we go back to the heap that memory is available for other things we certainly shouldn't use any of that memory but that's exactly what we now do we now say ok first i want to go into that struck an look at the next pointer and then free that as well ok so at this point we are on very dangerous ground because this piece of memory that we are now trying to use that were pointing to is no longer hours is no longer guaranteed to hold any values that we might have put in there	memory	61
ok and then we free it ok so now we go back to the heap that memory is available for other things we certainly shouldn't use any of that memory but that's exactly what we now do we now say ok first i want to go into that struck an look at the next pointer and then free that as well ok so at this point we are on very dangerous ground because this piece of memory that we are now trying to use that were pointing to is no longer hours is no longer guaranteed to hold any values that we might have put in there	the heap	47
ok and then we free it ok so now we go back to the heap that memory is available for other things we certainly shouldn't use any of that memory but that's exactly what we now do we now say ok first i want to go into that struck an look at the next pointer and then free that as well ok so at this point we are on very dangerous ground because this piece of memory that we are now trying to use that were pointing to is no longer hours is no longer guaranteed to hold any values that we might have put in there	pointer	248
and secondly what value do you think might be in there were malik for performance makes no guarantees about the contents of the memory that it gives you it could be all zeros because you put your nice new fresh process and for security the kernel is giving you piece of ramp that it is personally zeroed out just for you or it could be that you been calling malloc and free a lot and so now you're malloc your heat memory looks like an old dirty sock drawer where bits of memory a cold hole arbitrary values from previous malloc calls and so we are just treating it as a struct but actually all the memory is just a whole lot of zeros and ones so the value that you're going to see for this next pointer it's completely arbitrary even if we hadn't freed it so that's several mistakes here if we actually want to use things then don't freedom first only freedom after you've finished using them and better code would then set this next pointer to zero after after freeing it but so so this is a good good example of how not to write link this code with that let's finish this lecture have a great time thank you and goodbye	memory	128
and secondly what value do you think might be in there were malik for performance makes no guarantees about the contents of the memory that it gives you it could be all zeros because you put your nice new fresh process and for security the kernel is giving you piece of ramp that it is personally zeroed out just for you or it could be that you been calling malloc and free a lot and so now you're malloc your heat memory looks like an old dirty sock drawer where bits of memory a cold hole arbitrary values from previous malloc calls and so we are just treating it as a struct but actually all the memory is just a whole lot of zeros and ones so the value that you're going to see for this next pointer it's completely arbitrary even if we hadn't freed it so that's several mistakes here if we actually want to use things then don't freedom first only freedom after you've finished using them and better code would then set this next pointer to zero after after freeing it but so so this is a good good example of how not to write link this code with that let's finish this lecture have a great time thank you and goodbye	a struct	569
and secondly what value do you think might be in there were malik for performance makes no guarantees about the contents of the memory that it gives you it could be all zeros because you put your nice new fresh process and for security the kernel is giving you piece of ramp that it is personally zeroed out just for you or it could be that you been calling malloc and free a lot and so now you're malloc your heat memory looks like an old dirty sock drawer where bits of memory a cold hole arbitrary values from previous malloc calls and so we are just treating it as a struct but actually all the memory is just a whole lot of zeros and ones so the value that you're going to see for this next pointer it's completely arbitrary even if we hadn't freed it so that's several mistakes here if we actually want to use things then don't freedom first only freedom after you've finished using them and better code would then set this next pointer to zero after after freeing it but so so this is a good good example of how not to write link this code with that let's finish this lecture have a great time thank you and goodbye	code	905
and secondly what value do you think might be in there were malik for performance makes no guarantees about the contents of the memory that it gives you it could be all zeros because you put your nice new fresh process and for security the kernel is giving you piece of ramp that it is personally zeroed out just for you or it could be that you been calling malloc and free a lot and so now you're malloc your heat memory looks like an old dirty sock drawer where bits of memory a cold hole arbitrary values from previous malloc calls and so we are just treating it as a struct but actually all the memory is just a whole lot of zeros and ones so the value that you're going to see for this next pointer it's completely arbitrary even if we hadn't freed it so that's several mistakes here if we actually want to use things then don't freedom first only freedom after you've finished using them and better code would then set this next pointer to zero after after freeing it but so so this is a good good example of how not to write link this code with that let's finish this lecture have a great time thank you and goodbye	pointer	696
what we can say about this is that my little variable pdr here stanley for pointer points to something and i'm just going to look at that very last asterix to say ok great i know that ptr is a pointer and at that point i can just simply stop i can just treat the rest of the information there's a pointer pointer pointer pointer etc etc as useful information for the day that i actually decide to follow my pointer in other words the day that i actually decide to use it and go to memory to actually read what's in there and as you can see we can what we find that now the memory address and so on and so on and so on and eventually if we followed all of those memory pointers we would get to actually reading an integer but we are not going to worry about that right now we can start just simply by saying my little variable here is going to be four bytes or eight bytes or however many bytes i need to hold a pointer so don't don't get too crazy when it	memory	481
what we can say about this is that my little variable pdr here stanley for pointer points to something and i'm just going to look at that very last asterix to say ok great i know that ptr is a pointer and at that point i can just simply stop i can just treat the rest of the information there's a pointer pointer pointer pointer etc etc as useful information for the day that i actually decide to follow my pointer in other words the day that i actually decide to use it and go to memory to actually read what's in there and as you can see we can what we find that now the memory address and so on and so on and so on and eventually if we followed all of those memory pointers we would get to actually reading an integer but we are not going to worry about that right now we can start just simply by saying my little variable here is going to be four bytes or eight bytes or however many bytes i need to hold a pointer so don't don't get too crazy when it	address	580
what we can say about this is that my little variable pdr here stanley for pointer points to something and i'm just going to look at that very last asterix to say ok great i know that ptr is a pointer and at that point i can just simply stop i can just treat the rest of the information there's a pointer pointer pointer pointer etc etc as useful information for the day that i actually decide to follow my pointer in other words the day that i actually decide to use it and go to memory to actually read what's in there and as you can see we can what we find that now the memory address and so on and so on and so on and eventually if we followed all of those memory pointers we would get to actually reading an integer but we are not going to worry about that right now we can start just simply by saying my little variable here is going to be four bytes or eight bytes or however many bytes i need to hold a pointer so don't don't get too crazy when it	pointer	75
asterisks pointer you're basically taking one pointer off the type here or if we if we write ampersand pointer then we're finding out the address of our current variable so what would that do that to the type ads and other aspects we now have another pointer to our	type	62
asterisks pointer you're basically taking one pointer off the type here or if we if we write ampersand pointer then we're finding out the address of our current variable so what would that do that to the type ads and other aspects we now have another pointer to our	address	138
asterisks pointer you're basically taking one pointer off the type here or if we if we write ampersand pointer then we're finding out the address of our current variable so what would that do that to the type ads and other aspects we now have another pointer to our	pointer	10
pointer pointer point etc etc etc so that's it kind "of little trick is don't panic if you see pointers to pointers to pointers we can just like recursion we can hide those details and the only think about either precise variable we have or possibly more likely what is actually pointing to when we actually want to read or write that piece of memory alright bye for now	memory	344
pointer pointer point etc etc etc so that's it kind "of little trick is don't panic if you see pointers to pointers to pointers we can just like recursion we can hide those details and the only think about either precise variable we have or possibly more likely what is actually pointing to when we actually want to read or write that piece of memory alright bye for now	pointer	0
hi! ok, so let's talk about how we can actually write write() correctly. ok so here's the game that when we actually use write() it doesn't necessarily send all of the bytes that we request. ok so we're going to have to keep track of how many bytes we've sent so far so when we first start we have some kind of pointers to some memory but if we call right again then we don't necessarily start from the very beginning of the buffer you can kind of sketch this out to say alright if this is order the bites you want to send ok initially great we're going to say hey why sender all all of these bytes but if right returns to say ok i sense a four hundred of them then when we call right again will say ok well actually i want to start from this point here because we've already sent these and don't send say four thousand bytes but now saying three thousand eight hundred and if that succeeds but only succeed by sending say one hundred bytes then we're going to call write again and again we're going to say alright well now we sent	memory	328
hi! ok, so let's talk about how we can actually write write() correctly. ok so here's the game that when we actually use write() it doesn't necessarily send all of the bytes that we request. ok so we're going to have to keep track of how many bytes we've sent so far so when we first start we have some kind of pointers to some memory but if we call right again then we don't necessarily start from the very beginning of the buffer you can kind of sketch this out to say alright if this is order the bites you want to send ok initially great we're going to say hey why sender all all of these bytes but if right returns to say ok i sense a four hundred of them then when we call right again will say ok well actually i want to start from this point here because we've already sent these and don't send say four thousand bytes but now saying three thousand eight hundred and if that succeeds but only succeed by sending say one hundred bytes then we're going to call write again and again we're going to say alright well now we sent	pointer	311
ok and let's keep going around the loop then so	the loop	31
so ok right here zafar descriptor but i don't want to start from the beginning of the buffer let me just use pointer arithmetic on a void pointer here ok we know compilers today will accept so well but take buffer plus let me add an offset ok	pointer	109
ok now it's up to 's you could write more sophisticated code here perhaps you want to say oh we managed to also send a few bytes but today we're just going to treat this as ok a big problem we failed at sending orders bites to the buffer right what else can happen well it can be for right that we've actually managed to send some bites ok so now let's treat all the other values as a reason to celebrate that we've managed to actually send a few bytes ok and so now we just want to kind of go round the loop again	the loop	500
ok now it's up to 's you could write more sophisticated code here perhaps you want to say oh we managed to also send a few bytes but today we're just going to treat this as ok a big problem we failed at sending orders bites to the buffer right what else can happen well it can be for right that we've actually managed to send some bites ok so now let's treat all the other values as a reason to celebrate that we've managed to actually send a few bytes ok and so now we just want to kind of go round the loop again	code	56
ok so the last thing to mention here is that right now we're working with read and write which work in a blocking format so if you call right for example and is not possible immediately to send those bites perhaps for example the pipe is full	block	105
then these calls were block they won't return until they're able to complete however you can also set in future reading right to work asynchronously	block	22
which is an advanced use of read and write and if you do that then that's a newcondition that you'll have to work inside here where you'll say ok it couldn't complete rather than blocking it just returned a special air condition which point you'll want to handle that appropriately but this today is enough to be able to accept the fact that we may not send or bites and also	block	179
deal with window right calls are interrupted with an interrupt and when you see this interrupt you know that no bites were actually sent that because it returned negative one it means that we can be guaranteed that that nothing actually happened right so you will definitely need this kind of code when you have slow devices such as a network and i think it's time to start finding talking about some basic network principles	code	293
hi welcome to the next lecture we all elected twenty nine so let's get started alright first of all a quick review then of chaining the mod bits which allows us to change the access let's have a look at some of these and also notice that we're actually going to play with two things here chmod and chown ok so what do you think the following do chmod on the six hundred file a ok so remember how to read these this is going to be the owner the group and everybody else ok so what permissions do we have well remember that the permissions we're talking about our read write execute so read is four write is two and execute is one so in other words we are giving read and write execute to the owner but everybody else don't have any permissions so we've set our access control so that only the owner can actually read or write this file this might be appropriate for example for a file called secret dot text where we don't want to execute it but we do want to read and write it ok so what about this chown so this allows us to change the owner	the following	328
hi ok so let's have a look at how we can write some code which is non deterministic and then fix it up in different ways so here we go let's get started right i've got a little main method down here and i'm going to create ten threads and each time i go to store the address inside my little ray here of thread i ds and then i call pizza at exit so we know that at that point the main thread is done ok but the rest of the process lives on our ten little fence live on ok what do they do case so here's our game plan let's	code	52
hi ok so let's have a look at how we can write some code which is non deterministic and then fix it up in different ways so here we go let's get started right i've got a little main method down here and i'm going to create ten threads and each time i go to store the address inside my little ray here of thread i ds and then i call pizza at exit so we know that at that point the main thread is done ok but the rest of the process lives on our ten little fence live on ok what do they do case so here's our game plan let's	thread	227
hi ok so let's have a look at how we can write some code which is non deterministic and then fix it up in different ways so here we go let's get started right i've got a little main method down here and i'm going to create ten threads and each time i go to store the address inside my little ray here of thread i ds and then i call pizza at exit so we know that at that point the main thread is done ok but the rest of the process lives on our ten little fence live on ok what do they do case so here's our game plan let's	address	267
there's pass in the address of my little iterate available	address	20
so we'll find out its address not as valuable 's address	address	22
and then here's an expression to read that value how does this work ok so we know when finally were assigned a new cpu to start this function that we're given address what do i want to do with that address well i know something is stored there and i know that that's something isn't is just so in fact i want to treat that address as an integer pointer great so now i have that integer pointer i actually want to read whatsapp their contents so let me dereference it with little ass tricks there ok so we've got the value now we've been seeing how we can create p thread i ds	thread	564
and then here's an expression to read that value how does this work ok so we know when finally were assigned a new cpu to start this function that we're given address what do i want to do with that address well i know something is stored there and i know that that's something isn't is just so in fact i want to treat that address as an integer pointer great so now i have that integer pointer i actually want to read whatsapp their contents so let me dereference it with little ass tricks there ok so we've got the value now we've been seeing how we can create p thread i ds	address	159
and then here's an expression to read that value how does this work ok so we know when finally were assigned a new cpu to start this function that we're given address what do i want to do with that address well i know something is stored there and i know that that's something isn't is just so in fact i want to treat that address as an integer pointer great so now i have that integer pointer i actually want to read whatsapp their contents so let me dereference it with little ass tricks there ok so we've got the value now we've been seeing how we can create p thread i ds	pointer	345
every time we call pisode create but what if you wanted to know your own idea what if you said what's my id how would how would i determine that so there should be a way to do this and there is so we say my id is p thread itself so that's the other way of getting a thread id if you want to know who you are something which represents a particular thread then you call peter itself right less for fun printed out which is not normal behaviour normally don't print out these i ds one way to do this we will just treat it as a pointer to some memory so let's say that this id represents some integer type thing which is some address type things or just print it out and now i've got a void pointer i can use percent p to say right treat this doesn't address ok so will pick that up and if we wanted we could play the same trick down here we put this out but	memory	541
every time we call pisode create but what if you wanted to know your own idea what if you said what's my id how would how would i determine that so there should be a way to do this and there is so we say my id is p thread itself so that's the other way of getting a thread id if you want to know who you are something which represents a particular thread then you call peter itself right less for fun printed out which is not normal behaviour normally don't print out these i ds one way to do this we will just treat it as a pointer to some memory so let's say that this id represents some integer type thing which is some address type things or just print it out and now i've got a void pointer i can use percent p to say right treat this doesn't address ok so will pick that up and if we wanted we could play the same trick down here we put this out but	type	598
every time we call pisode create but what if you wanted to know your own idea what if you said what's my id how would how would i determine that so there should be a way to do this and there is so we say my id is p thread itself so that's the other way of getting a thread id if you want to know who you are something which represents a particular thread then you call peter itself right less for fun printed out which is not normal behaviour normally don't print out these i ds one way to do this we will just treat it as a pointer to some memory so let's say that this id represents some integer type thing which is some address type things or just print it out and now i've got a void pointer i can use percent p to say right treat this doesn't address ok so will pick that up and if we wanted we could play the same trick down here we put this out but	a thread	264
every time we call pisode create but what if you wanted to know your own idea what if you said what's my id how would how would i determine that so there should be a way to do this and there is so we say my id is p thread itself so that's the other way of getting a thread id if you want to know who you are something which represents a particular thread then you call peter itself right less for fun printed out which is not normal behaviour normally don't print out these i ds one way to do this we will just treat it as a pointer to some memory so let's say that this id represents some integer type thing which is some address type things or just print it out and now i've got a void pointer i can use percent p to say right treat this doesn't address ok so will pick that up and if we wanted we could play the same trick down here we put this out but	thread	215
every time we call pisode create but what if you wanted to know your own idea what if you said what's my id how would how would i determine that so there should be a way to do this and there is so we say my id is p thread itself so that's the other way of getting a thread id if you want to know who you are something which represents a particular thread then you call peter itself right less for fun printed out which is not normal behaviour normally don't print out these i ds one way to do this we will just treat it as a pointer to some memory so let's say that this id represents some integer type thing which is some address type things or just print it out and now i've got a void pointer i can use percent p to say right treat this doesn't address ok so will pick that up and if we wanted we could play the same trick down here we put this out but	address	623
every time we call pisode create but what if you wanted to know your own idea what if you said what's my id how would how would i determine that so there should be a way to do this and there is so we say my id is p thread itself so that's the other way of getting a thread id if you want to know who you are something which represents a particular thread then you call peter itself right less for fun printed out which is not normal behaviour normally don't print out these i ds one way to do this we will just treat it as a pointer to some memory so let's say that this id represents some integer type thing which is some address type things or just print it out and now i've got a void pointer i can use percent p to say right treat this doesn't address ok so will pick that up and if we wanted we could play the same trick down here we put this out but	pointer	525
ok alright so it looks like it's kind of working but not as well as we hoped we certainly got different thread ideas appearing and they do look like addresses i'll give you that but look at this we've got very strange values over here and even the last value is ten and if i run it again i get different values again if i run it again i get different values again ok so i get in all sorts of values here what is going on clearly we've got a program which is not deterministic we don't know what it's going to print out ok so why did that happen well hopefully you can see that we passed in the address of i and so actually what we have here is called a race condition it depends upon the exact interleaving in time of the instructions that are going to be executed i've got one thread that immediately after calling pizza it could create is going to increment the value by and then test to see if i is less than ten i have not go around again so we've got one threat doing that as fast as fast as i can and i got another thread that as soon as it starts will gas that pointer to an end pointer and then try to read it so it's a value that it sees depends upon the relative timing of these operations and that can change from one run to the next you might be surprised we even saw the value of ten even though our loop says is i less than ten yes so that's why our threads can start at some point in the future maybe few microseconds but maybe a millisecond maybe much longer ok and some point we're going to escape out of this for loop so at that point the value of i will be equal to ten because that was our exit condition but it gets worse than that because formally the value of this variable is not defined outside of this loop and in fact when we call pizza at exit we don't even need the stack anymore for maine so the memory that we might be reading at that point is no longer really hours to be looking at so we've got a pretty badly formed program here	memory	1826
ok alright so it looks like it's kind of working but not as well as we hoped we certainly got different thread ideas appearing and they do look like addresses i'll give you that but look at this we've got very strange values over here and even the last value is ten and if i run it again i get different values again if i run it again i get different values again ok so i get in all sorts of values here what is going on clearly we've got a program which is not deterministic we don't know what it's going to print out ok so why did that happen well hopefully you can see that we passed in the address of i and so actually what we have here is called a race condition it depends upon the exact interleaving in time of the instructions that are going to be executed i've got one thread that immediately after calling pizza it could create is going to increment the value by and then test to see if i is less than ten i have not go around again so we've got one threat doing that as fast as fast as i can and i got another thread that as soon as it starts will gas that pointer to an end pointer and then try to read it so it's a value that it sees depends upon the relative timing of these operations and that can change from one run to the next you might be surprised we even saw the value of ten even though our loop says is i less than ten yes so that's why our threads can start at some point in the future maybe few microseconds but maybe a millisecond maybe much longer ok and some point we're going to escape out of this for loop so at that point the value of i will be equal to ten because that was our exit condition but it gets worse than that because formally the value of this variable is not defined outside of this loop and in fact when we call pizza at exit we don't even need the stack anymore for maine so the memory that we might be reading at that point is no longer really hours to be looking at so we've got a pretty badly formed program here	thread	104
ok alright so it looks like it's kind of working but not as well as we hoped we certainly got different thread ideas appearing and they do look like addresses i'll give you that but look at this we've got very strange values over here and even the last value is ten and if i run it again i get different values again if i run it again i get different values again ok so i get in all sorts of values here what is going on clearly we've got a program which is not deterministic we don't know what it's going to print out ok so why did that happen well hopefully you can see that we passed in the address of i and so actually what we have here is called a race condition it depends upon the exact interleaving in time of the instructions that are going to be executed i've got one thread that immediately after calling pizza it could create is going to increment the value by and then test to see if i is less than ten i have not go around again so we've got one threat doing that as fast as fast as i can and i got another thread that as soon as it starts will gas that pointer to an end pointer and then try to read it so it's a value that it sees depends upon the relative timing of these operations and that can change from one run to the next you might be surprised we even saw the value of ten even though our loop says is i less than ten yes so that's why our threads can start at some point in the future maybe few microseconds but maybe a millisecond maybe much longer ok and some point we're going to escape out of this for loop so at that point the value of i will be equal to ten because that was our exit condition but it gets worse than that because formally the value of this variable is not defined outside of this loop and in fact when we call pizza at exit we don't even need the stack anymore for maine so the memory that we might be reading at that point is no longer really hours to be looking at so we've got a pretty badly formed program here	address	149
ok alright so it looks like it's kind of working but not as well as we hoped we certainly got different thread ideas appearing and they do look like addresses i'll give you that but look at this we've got very strange values over here and even the last value is ten and if i run it again i get different values again if i run it again i get different values again ok so i get in all sorts of values here what is going on clearly we've got a program which is not deterministic we don't know what it's going to print out ok so why did that happen well hopefully you can see that we passed in the address of i and so actually what we have here is called a race condition it depends upon the exact interleaving in time of the instructions that are going to be executed i've got one thread that immediately after calling pizza it could create is going to increment the value by and then test to see if i is less than ten i have not go around again so we've got one threat doing that as fast as fast as i can and i got another thread that as soon as it starts will gas that pointer to an end pointer and then try to read it so it's a value that it sees depends upon the relative timing of these operations and that can change from one run to the next you might be surprised we even saw the value of ten even though our loop says is i less than ten yes so that's why our threads can start at some point in the future maybe few microseconds but maybe a millisecond maybe much longer ok and some point we're going to escape out of this for loop so at that point the value of i will be equal to ten because that was our exit condition but it gets worse than that because formally the value of this variable is not defined outside of this loop and in fact when we call pizza at exit we don't even need the stack anymore for maine so the memory that we might be reading at that point is no longer really hours to be looking at so we've got a pretty badly formed program here	pointer	1068
right so how can we fix it we need to address this race condition but will do it in two different ways first of all how about we turn this into a task that we give each one and my task right now is just no little integer so let's have some memory for each thread so i'll call it say starting values and you can see i'm using a global here right and it will be let's see i'll have ten am and i can initialize these which i could do as part of this loop or i could do it earlier ok so you can be let's say hundred plus i today just so we can prove that we're running this program ok	memory	240
right so how can we fix it we need to address this race condition but will do it in two different ways first of all how about we turn this into a task that we give each one and my task right now is just no little integer so let's have some memory for each thread so i'll call it say starting values and you can see i'm using a global here right and it will be let's see i'll have ten am and i can initialize these which i could do as part of this loop or i could do it earlier ok so you can be let's say hundred plus i today just so we can prove that we're running this program ok	thread	256
right so how can we fix it we need to address this race condition but will do it in two different ways first of all how about we turn this into a task that we give each one and my task right now is just no little integer so let's have some memory for each thread so i'll call it say starting values and you can see i'm using a global here right and it will be let's see i'll have ten am and i can initialize these which i could do as part of this loop or i could do it earlier ok so you can be let's say hundred plus i today just so we can prove that we're running this program ok	address	38
and then i don't want to pass in the address if i instead i want to pass in my pointer to one of these you introduce i've just created so starting values and i could say take the ice warren i want the address of that but you know that we can also write that is just ok here's the start of the array i want the offset of ips and will use integer arithmetic ok so we've initialized array let's give this ago and off we go so will compile it ok	address	37
and then i don't want to pass in the address if i instead i want to pass in my pointer to one of these you introduce i've just created so starting values and i could say take the ice warren i want the address of that but you know that we can also write that is just ok here's the start of the array i want the offset of ips and will use integer arithmetic ok so we've initialized array let's give this ago and off we go so will compile it ok	pointer	79
we know deterministically that we're going to get the values between a hundred and a hundred and nine those threads can run in an arbitrary order so the output is not guaranteed to be in exactly the same app or ordering that we actually defined it inside the code so let's have a look at kind of one more alternative here to make a program completely deterministic here's what i'm going to do i'm going to say p thread	code	259
we know deterministically that we're going to get the values between a hundred and a hundred and nine those threads can run in an arbitrary order so the output is not guaranteed to be in exactly the same app or ordering that we actually defined it inside the code so let's have a look at kind of one more alternative here to make a program completely deterministic here's what i'm going to do i'm going to say p thread	thread	108
join an i want to join on not the address of thread id but the actual value itself and i don't care about the exit value so don't write that anywhere ok alright so what's going to happen now first of all let me run it and then you can tell me why ok so let's clear this clear that's compiled let's run ok and this time i'm extremely confident we're going to see the same same output for the integers and they will be in order why am i so confident	thread	45
join an i want to join on not the address of thread id but the actual value itself and i don't care about the exit value so don't write that anywhere ok alright so what's going to happen now first of all let me run it and then you can tell me why ok so let's clear this clear that's compiled let's run ok and this time i'm extremely confident we're going to see the same same output for the integers and they will be in order why am i so confident	address	34
so let's have a look at the code we vote we created a thread and the main thread can return and carry on there's no requirement for it to wait for that thread to get started but what do we do we immediately say ok now i want to block i want to wait until i'm able to join on the other thread so that means before we get to go around the loop before we add two hundred dollars and go round the when opoly board again right before we get to say i plus plus in his eye lesson ten we have to run and complete the code inside my funk we have to read the value we print out we get the thread id self we print something out and return null and those steps have to occur in order for pizza joint to letters out of jail so we are extremely confident that i know for certain that my funk will finish this execution before we get to use another loop ok so we've made shell program completely terministic but at what cost yes ladies and gentlemen we've written the most complicated version of printing out the numbers from zero to nine by creating threads and each waiting for each thread in turn to finish so now we've lost the performance of having a multi threats because we've only actually ever got one thread doing anything useful at a time either the main thread is running or is created in new thread to do one simple action and then that finishes and back goes the main thread in it or something again and so on so we had this kind of a hand over which is a	the loop	333
so let's have a look at the code we vote we created a thread and the main thread can return and carry on there's no requirement for it to wait for that thread to get started but what do we do we immediately say ok now i want to block i want to wait until i'm able to join on the other thread so that means before we get to go around the loop before we add two hundred dollars and go round the when opoly board again right before we get to say i plus plus in his eye lesson ten we have to run and complete the code inside my funk we have to read the value we print out we get the thread id self we print something out and return null and those steps have to occur in order for pizza joint to letters out of jail so we are extremely confident that i know for certain that my funk will finish this execution before we get to use another loop ok so we've made shell program completely terministic but at what cost yes ladies and gentlemen we've written the most complicated version of printing out the numbers from zero to nine by creating threads and each waiting for each thread in turn to finish so now we've lost the performance of having a multi threats because we've only actually ever got one thread doing anything useful at a time either the main thread is running or is created in new thread to do one simple action and then that finishes and back goes the main thread in it or something again and so on so we had this kind of a hand over which is a	block	228
so let's have a look at the code we vote we created a thread and the main thread can return and carry on there's no requirement for it to wait for that thread to get started but what do we do we immediately say ok now i want to block i want to wait until i'm able to join on the other thread so that means before we get to go around the loop before we add two hundred dollars and go round the when opoly board again right before we get to say i plus plus in his eye lesson ten we have to run and complete the code inside my funk we have to read the value we print out we get the thread id self we print something out and return null and those steps have to occur in order for pizza joint to letters out of jail so we are extremely confident that i know for certain that my funk will finish this execution before we get to use another loop ok so we've made shell program completely terministic but at what cost yes ladies and gentlemen we've written the most complicated version of printing out the numbers from zero to nine by creating threads and each waiting for each thread in turn to finish so now we've lost the performance of having a multi threats because we've only actually ever got one thread doing anything useful at a time either the main thread is running or is created in new thread to do one simple action and then that finishes and back goes the main thread in it or something again and so on so we had this kind of a hand over which is a	code	28
so let's have a look at the code we vote we created a thread and the main thread can return and carry on there's no requirement for it to wait for that thread to get started but what do we do we immediately say ok now i want to block i want to wait until i'm able to join on the other thread so that means before we get to go around the loop before we add two hundred dollars and go round the when opoly board again right before we get to say i plus plus in his eye lesson ten we have to run and complete the code inside my funk we have to read the value we print out we get the thread id self we print something out and return null and those steps have to occur in order for pizza joint to letters out of jail so we are extremely confident that i know for certain that my funk will finish this execution before we get to use another loop ok so we've made shell program completely terministic but at what cost yes ladies and gentlemen we've written the most complicated version of printing out the numbers from zero to nine by creating threads and each waiting for each thread in turn to finish so now we've lost the performance of having a multi threats because we've only actually ever got one thread doing anything useful at a time either the main thread is running or is created in new thread to do one simple action and then that finishes and back goes the main thread in it or something again and so on so we had this kind of a hand over which is a	a thread	52
so let's have a look at the code we vote we created a thread and the main thread can return and carry on there's no requirement for it to wait for that thread to get started but what do we do we immediately say ok now i want to block i want to wait until i'm able to join on the other thread so that means before we get to go around the loop before we add two hundred dollars and go round the when opoly board again right before we get to say i plus plus in his eye lesson ten we have to run and complete the code inside my funk we have to read the value we print out we get the thread id self we print something out and return null and those steps have to occur in order for pizza joint to letters out of jail so we are extremely confident that i know for certain that my funk will finish this execution before we get to use another loop ok so we've made shell program completely terministic but at what cost yes ladies and gentlemen we've written the most complicated version of printing out the numbers from zero to nine by creating threads and each waiting for each thread in turn to finish so now we've lost the performance of having a multi threats because we've only actually ever got one thread doing anything useful at a time either the main thread is running or is created in new thread to do one simple action and then that finishes and back goes the main thread in it or something again and so on so we had this kind of a hand over which is a	thread	54
ok so html looks a bit like this i've got inside html tag i've gotta head tag and inside that i've got things like title and caching information and then i've got body tag and inside that body tag i'm going to have say a background image or say an image tag to say ok here's an image here i might give a hint about its size but the source of that image is some other http request so make a new request to some server may be the same server blah blah blah blah blah and then here's a picture of my cat or whatever i want to load now for this calculation we are going to calculate the minimum time required so we're going to assume that the resources both this actual text document the html document and the cat picture can be sent in a single byte and we're not going to worry about single packets and we're not going to worry about the fact that as the packet gets larger it takes longer to send we're just going to do a back of the envelope calculation here and say hey it takes ten milliseconds to send a request and get better request sue naive idea might be well i tell you what i just asked for both and ten milliseconds later great i'm done except life isn't quite that simple we skipped over the tcp handshaking plus website doesn't even know about the cat jpeg it is to learn it needs to load until it's got the html back from the server so let's think about the packets which are actually going to occur	background	221
ok so html looks a bit like this i've got inside html tag i've gotta head tag and inside that i've got things like title and caching information and then i've got body tag and inside that body tag i'm going to have say a background image or say an image tag to say ok here's an image here i might give a hint about its size but the source of that image is some other http request so make a new request to some server may be the same server blah blah blah blah blah and then here's a picture of my cat or whatever i want to load now for this calculation we are going to calculate the minimum time required so we're going to assume that the resources both this actual text document the html document and the cat picture can be sent in a single byte and we're not going to worry about single packets and we're not going to worry about the fact that as the packet gets larger it takes longer to send we're just going to do a back of the envelope calculation here and say hey it takes ten milliseconds to send a request and get better request sue naive idea might be well i tell you what i just asked for both and ten milliseconds later great i'm done except life isn't quite that simple we skipped over the tcp handshaking plus website doesn't even know about the cat jpeg it is to learn it needs to load until it's got the html back from the server so let's think about the packets which are actually going to occur	resources	639
to be set so we won't worry about that instead we look at the minimum time so now you can see why this actually takes more than just ten milliseconds to get all this information and you'll see that actually everything happened in pairs so we have ten milliseconds ten milliseconds ten milliseconds and ten milliseconds is going to take a minimum of forty milliseconds to display our picture and if we had multiple cat thumbnails then each connection is going to take more time so the very earliest web browsers said well you know what we need to do better than this is taking a long time to display all these adverts we have on a page what will do is will we took cs two forty one will have say some multiple threads and we will make up to four connections at a time to each web browser so that once we've loaded the html i can load four thumbnails in parallel wife or you might ask well this is a compromise because we didn't want to overload the servers if everybody allowed one hundred connections	a page	628
to be set so we won't worry about that instead we look at the minimum time so now you can see why this actually takes more than just ten milliseconds to get all this information and you'll see that actually everything happened in pairs so we have ten milliseconds ten milliseconds ten milliseconds and ten milliseconds is going to take a minimum of forty milliseconds to display our picture and if we had multiple cat thumbnails then each connection is going to take more time so the very earliest web browsers said well you know what we need to do better than this is taking a long time to display all these adverts we have on a page what will do is will we took cs two forty one will have say some multiple threads and we will make up to four connections at a time to each web browser so that once we've loaded the html i can load four thumbnails in parallel wife or you might ask well this is a compromise because we didn't want to overload the servers if everybody allowed one hundred connections	thread	709
ok so we've we've talked about e x t two and how we can represent a smaller large files efficiently so what does x t three nxd four givers so i've already mentioned one thing which is that they were expanded to allow much larger files but e x t through gavers are journaling which is the ability to make sure that our file system is always in a good state so a file system of course has to keep track of unused disk blocks so we want to make sure that even if there's a power failure we don't accidentally start relying on bad information that if our idea of which disk blocks were available was incorrect that oh we might start overwriting valid files so xt through xt three implement this idea called journaling which is that i can consider in time all of my rights to disk to be modifications to my disk so i can have checkpoints where i can have an idea that ok a certain time my disk is in a well known state whatever is actually physically stored on the disk surface is in a consistent well	block	416
ok so we've we've talked about e x t two and how we can represent a smaller large files efficiently so what does x t three nxd four givers so i've already mentioned one thing which is that they were expanded to allow much larger files but e x t through gavers are journaling which is the ability to make sure that our file system is always in a good state so a file system of course has to keep track of unused disk blocks so we want to make sure that even if there's a power failure we don't accidentally start relying on bad information that if our idea of which disk blocks were available was incorrect that oh we might start overwriting valid files so xt through xt three implement this idea called journaling which is that i can consider in time all of my rights to disk to be modifications to my disk so i can have checkpoints where i can have an idea that ok a certain time my disk is in a well known state whatever is actually physically stored on the disk surface is in a consistent well	system	323
the data i've made modifications to my directory to say there's a new file that exists here but i haven't yet updated say the disk blocks which are no longer available that kind of thing so i've got multiple rights i need to my disk and it's only when i get to second checkpoint do i know that all of the changes have been complete so if a power outage occurs or some other	block	131
let's have a look at a common pattern that people used inside existing programs so our code might be written inside the sea layer but we know that ultimately that gets translated into low level system calls so let's have a look at kind of a standard standard pattern	code	87
let's have a look at a common pattern that people used inside existing programs so our code might be written inside the sea layer but we know that ultimately that gets translated into low level system calls so let's have a look at kind of a standard standard pattern	system	194
so if we looked in times kind of ghost and stuff so there's a problem with this which is that if the power went out between say my right corner make clothes and the actual data being written to disk then tomorrow when i restart my machine i would discover that hey my entire files gone because the only thing that's happened was i managed to truncate it so many programs instead of opted for a kind of a safer version of this which is the following ok so let's	the following	435
the actual data for the new file was written later than the updates to the directory so in e x t four if there was a power outage we might suddenly find that or when we restart this we've managed to rename the file yes but the data that we thought we'd written was not actually on the disk yet so there was still a small corner case where we could lose all of the contents ok so this wasn't unhappy situation for awhile and the fix was to actually to provide a new option for xt four where we could disable delayed data right so there was a trade off in performance to say actually we want to make sure that all of our data content happens before we update kind of directory information so that's kind of kind of cute little example of how in the quest for better performance we hope we expose ourselves to two today to los in these kind of difficult corner cases so kind of hope you like that little kind of little confirmed case study of why creating file systems that are performed and secure is difficult the last thing i will mention is here's another when we started this section when we just brainstormed a list of features that we would like ok let's have a look at a real list of features of a real modern filesystems and this is just kind of a high level feature list	this section	1073
the actual data for the new file was written later than the updates to the directory so in e x t four if there was a power outage we might suddenly find that or when we restart this we've managed to rename the file yes but the data that we thought we'd written was not actually on the disk yet so there was still a small corner case where we could lose all of the contents ok so this wasn't unhappy situation for awhile and the fix was to actually to provide a new option for xt four where we could disable delayed data right so there was a trade off in performance to say actually we want to make sure that all of our data content happens before we update kind of directory information so that's kind of kind of cute little example of how in the quest for better performance we hope we expose ourselves to two today to los in these kind of difficult corner cases so kind of hope you like that little kind of little confirmed case study of why creating file systems that are performed and secure is difficult the last thing i will mention is here's another when we started this section when we just brainstormed a list of features that we would like ok let's have a look at a real list of features of a real modern filesystems and this is just kind of a high level feature list	section	1078
the actual data for the new file was written later than the updates to the directory so in e x t four if there was a power outage we might suddenly find that or when we restart this we've managed to rename the file yes but the data that we thought we'd written was not actually on the disk yet so there was still a small corner case where we could lose all of the contents ok so this wasn't unhappy situation for awhile and the fix was to actually to provide a new option for xt four where we could disable delayed data right so there was a trade off in performance to say actually we want to make sure that all of our data content happens before we update kind of directory information so that's kind of kind of cute little example of how in the quest for better performance we hope we expose ourselves to two today to los in these kind of difficult corner cases so kind of hope you like that little kind of little confirmed case study of why creating file systems that are performed and secure is difficult the last thing i will mention is here's another when we started this section when we just brainstormed a list of features that we would like ok let's have a look at a real list of features of a real modern filesystems and this is just kind of a high level feature list	system	958
of two two file systems that you'll probably hear about one is zfs and this support things like raid what's raid ok will talk about raid in the future we actually want to be able to work with different pools of files so we want to be able to have kind of enterprising features to make it easy to manage all of our different file systems so we had this idea of different storage pools so we've introduced abstraction layers between the physical disks and the actual kind of virtual disks disk pools that we actually might want to manipulate for applications	system	16
we want to implement things like copy on write an make it transactional we want snapshots we want clones we want to be able to send these snapshots from one disk to a different disk we want to be able to stripe physically i'm store our our data across different parts of a disk we want to have variable block size is we want to make it lightweight we want to be able to modify our cash we want even potentially different endianness for performance and of course you want things like deduplication encryption right so that's going to take awhile to write all the code to support about that and here's another one which another file system that then exports today yeah we want space efficient indices and packing of very small files while being able to support very large files we don't want to have to make choices at format time how many i knows we want again we want snapshot beat your vest has checksums to make sure that the data and the metadata or can still correct we want different compression algorithms	block	303
we want to implement things like copy on write an make it transactional we want snapshots we want clones we want to be able to send these snapshots from one disk to a different disk we want to be able to stripe physically i'm store our our data across different parts of a disk we want to have variable block size is we want to make it lightweight we want to be able to modify our cash we want even potentially different endianness for performance and of course you want things like deduplication encryption right so that's going to take awhile to write all the code to support about that and here's another one which another file system that then exports today yeah we want space efficient indices and packing of very small files while being able to support very large files we don't want to have to make choices at format time how many i knows we want again we want snapshot beat your vest has checksums to make sure that the data and the metadata or can still correct we want different compression algorithms	code	562
we want to implement things like copy on write an make it transactional we want snapshots we want clones we want to be able to send these snapshots from one disk to a different disk we want to be able to stripe physically i'm store our our data across different parts of a disk we want to have variable block size is we want to make it lightweight we want to be able to modify our cash we want even potentially different endianness for performance and of course you want things like deduplication encryption right so that's going to take awhile to write all the code to support about that and here's another one which another file system that then exports today yeah we want space efficient indices and packing of very small files while being able to support very large files we don't want to have to make choices at format time how many i knows we want again we want snapshot beat your vest has checksums to make sure that the data and the metadata or can still correct we want different compression algorithms	system	631
copacetic with our actual physical storage mechanisms so for example it should work well with ssd and have other optimizations associated with physical hardware we want to have incremental backup that works efficiently	optimizations	113
we want to be able to kind of scrub our disk for and look for errors in the background and so on and so on and so on and so on and so on so that i just want to go blow your mind or expand your mind in terms of ok this is all that cool stuff that are real modern day file system can kind of give to us ok and unfortunately however beta office is still only beginning to be used for real enterprise systems because realize that these features can start to bite you in the corner cases that we've just seen even with relatively simple file systems like e x two three n x t four if the corner cases that case for example where your disk is now full or suddenly you've got one disk going down and a quota changing plays and something else happening at the same time that people are paranoid about that the last thing you want to do is how to lose all of our data or worse have a data corruption that were not even aware of if we lost all our data then ok in the worst case we've last saturday of business and we can hopefully restore it but what is scary is to say we've got a bad piece of data and we don't even aware of this so overtime we will just simply copy that to bad data into our backups and now we cannot trust the data that our business is built on so	background	76
we want to be able to kind of scrub our disk for and look for errors in the background and so on and so on and so on and so on and so on so that i just want to go blow your mind or expand your mind in terms of ok this is all that cool stuff that are real modern day file system can kind of give to us ok and unfortunately however beta office is still only beginning to be used for real enterprise systems because realize that these features can start to bite you in the corner cases that we've just seen even with relatively simple file systems like e x two three n x t four if the corner cases that case for example where your disk is now full or suddenly you've got one disk going down and a quota changing plays and something else happening at the same time that people are paranoid about that the last thing you want to do is how to lose all of our data or worse have a data corruption that were not even aware of if we lost all our data then ok in the worst case we've last saturday of business and we can hopefully restore it but what is scary is to say we've got a bad piece of data and we don't even aware of this so overtime we will just simply copy that to bad data into our backups and now we cannot trust the data that our business is built on so	system	271
it for file changes if you really want to make make strong difficult c code your life then i said yes do you make your own file system right that's it for now and the end of this lecture by	code	71
it for file changes if you really want to make make strong difficult c code your life then i said yes do you make your own file system right that's it for now and the end of this lecture by	system	128
ok so let's start talking about how we can improve a free so first of all just a reminder that now you can see that with realloc if we could actually access that link list when real work is called we can start writing a real lock which is faster but what can we do about free how can we make free faster right now we had an implication of free that walk through the linked list looking for that user pointer but had to be unallocated can we do better yes so here's how we can do it using an order one approach what we need to realize is that if we put in the metadata directly inside the heap as well then the following is always true that if this is the heap memory that the user is going to see then geass before to the different colour there we go	the following	606
ok so let's start talking about how we can improve a free so first of all just a reminder that now you can see that with realloc if we could actually access that link list when real work is called we can start writing a real lock which is faster but what can we do about free how can we make free faster right now we had an implication of free that walk through the linked list looking for that user pointer but had to be unallocated can we do better yes so here's how we can do it using an order one approach what we need to realize is that if we put in the metadata directly inside the heap as well then the following is always true that if this is the heap memory that the user is going to see then geass before to the different colour there we go	heap memory	655
ok so let's start talking about how we can improve a free so first of all just a reminder that now you can see that with realloc if we could actually access that link list when real work is called we can start writing a real lock which is faster but what can we do about free how can we make free faster right now we had an implication of free that walk through the linked list looking for that user pointer but had to be unallocated can we do better yes so here's how we can do it using an order one approach what we need to realize is that if we put in the metadata directly inside the heap as well then the following is always true that if this is the heap memory that the user is going to see then geass before to the different colour there we go	memory	660
ok so let's start talking about how we can improve a free so first of all just a reminder that now you can see that with realloc if we could actually access that link list when real work is called we can start writing a real lock which is faster but what can we do about free how can we make free faster right now we had an implication of free that walk through the linked list looking for that user pointer but had to be unallocated can we do better yes so here's how we can do it using an order one approach what we need to realize is that if we put in the metadata directly inside the heap as well then the following is always true that if this is the heap memory that the user is going to see then geass before to the different colour there we go	the heap	584
ok so let's start talking about how we can improve a free so first of all just a reminder that now you can see that with realloc if we could actually access that link list when real work is called we can start writing a real lock which is faster but what can we do about free how can we make free faster right now we had an implication of free that walk through the linked list looking for that user pointer but had to be unallocated can we do better yes so here's how we can do it using an order one approach what we need to realize is that if we put in the metadata directly inside the heap as well then the following is always true that if this is the heap memory that the user is going to see then geass before to the different colour there we go	pointer	400
just just before the address that the user sees there is always going to be the metadata i just need to therefore subtract off some magic number to get to the start of the metadata so if you give me a void pointer that i perhaps just need to go back sixteen bytes or sixty four bytes or however big the size of this metadata is and how can i determine the size well guess what there's something called size off so i just need to write size of the metadata i'm not about metadata out in full but the metadata entry type will tell me how many bytes that is so i can use that to walk backwards ok so let's have a an attempt at writing this then right so here we go	type	514
just just before the address that the user sees there is always going to be the metadata i just need to therefore subtract off some magic number to get to the start of the metadata so if you give me a void pointer that i perhaps just need to go back sixteen bytes or sixty four bytes or however big the size of this metadata is and how can i determine the size well guess what there's something called size off so i just need to write size of the metadata i'm not about metadata out in full but the metadata entry type will tell me how many bytes that is so i can use that to walk backwards ok so let's have a an attempt at writing this then right so here we go	address	21
just just before the address that the user sees there is always going to be the metadata i just need to therefore subtract off some magic number to get to the start of the metadata so if you give me a void pointer that i perhaps just need to go back sixteen bytes or sixty four bytes or however big the size of this metadata is and how can i determine the size well guess what there's something called size off so i just need to write size of the metadata i'm not about metadata out in full but the metadata entry type will tell me how many bytes that is so i can use that to walk backwards ok so let's have a an attempt at writing this then right so here we go	pointer	206
right so i given the use of pointer here and for that i now need to walk backwards ok so there's actually some interesting ways we can do this his here's the first way let's get those c standards people unhappy and put the compiler people are happy so if you give me a user pointer that's non null i know where the metadata is it's going to be the following location so it my	the following	344
right so i given the use of pointer here and for that i now need to walk backwards ok so there's actually some interesting ways we can do this his here's the first way let's get those c standards people unhappy and put the compiler people are happy so if you give me a user pointer that's non null i know where the metadata is it's going to be the following location so it my	pointer	28
type	type	0
ok is my pointer right i'll take my	pointer	9
ok and then that type so a metadata	type	17
entry type	type	6
but you're saying hold on a moment this pointer you're starting with this user pointer it's avoid type that means that we're not declaring anything about what's actually at that memory location and if you read the c standard you're not allowed to do pointer arithmetic on that type because we don't know what's there would be absolutely correct however or modern compilers gcc clang and others do support this is the following extension which is you can add and subtract avoid pointers and if you do that then they behave like character pointers and in particular you are adding subtracting bytes off this memory location so we're walking back exactly the right number of bytes in this case because of this type ok so now i've got that now i can immediately say things like alright point p i know you're looking at my meta data entry so now let me declare that this entry is now free and then i would write my code to the block coalesce sing by checking my neighbors left and right to see if either of those are free and if so then i would assume they exist and if so i would collect them into one alright so that's one way of doing it but you and i also know about pointer arithmetic so here's a different way of doing it so	the following	413
but you're saying hold on a moment this pointer you're starting with this user pointer it's avoid type that means that we're not declaring anything about what's actually at that memory location and if you read the c standard you're not allowed to do pointer arithmetic on that type because we don't know what's there would be absolutely correct however or modern compilers gcc clang and others do support this is the following extension which is you can add and subtract avoid pointers and if you do that then they behave like character pointers and in particular you are adding subtracting bytes off this memory location so we're walking back exactly the right number of bytes in this case because of this type ok so now i've got that now i can immediately say things like alright point p i know you're looking at my meta data entry so now let me declare that this entry is now free and then i would write my code to the block coalesce sing by checking my neighbors left and right to see if either of those are free and if so then i would assume they exist and if so i would collect them into one alright so that's one way of doing it but you and i also know about pointer arithmetic so here's a different way of doing it so	memory	178
but you're saying hold on a moment this pointer you're starting with this user pointer it's avoid type that means that we're not declaring anything about what's actually at that memory location and if you read the c standard you're not allowed to do pointer arithmetic on that type because we don't know what's there would be absolutely correct however or modern compilers gcc clang and others do support this is the following extension which is you can add and subtract avoid pointers and if you do that then they behave like character pointers and in particular you are adding subtracting bytes off this memory location so we're walking back exactly the right number of bytes in this case because of this type ok so now i've got that now i can immediately say things like alright point p i know you're looking at my meta data entry so now let me declare that this entry is now free and then i would write my code to the block coalesce sing by checking my neighbors left and right to see if either of those are free and if so then i would assume they exist and if so i would collect them into one alright so that's one way of doing it but you and i also know about pointer arithmetic so here's a different way of doing it so	block	922
but you're saying hold on a moment this pointer you're starting with this user pointer it's avoid type that means that we're not declaring anything about what's actually at that memory location and if you read the c standard you're not allowed to do pointer arithmetic on that type because we don't know what's there would be absolutely correct however or modern compilers gcc clang and others do support this is the following extension which is you can add and subtract avoid pointers and if you do that then they behave like character pointers and in particular you are adding subtracting bytes off this memory location so we're walking back exactly the right number of bytes in this case because of this type ok so now i've got that now i can immediately say things like alright point p i know you're looking at my meta data entry so now let me declare that this entry is now free and then i would write my code to the block coalesce sing by checking my neighbors left and right to see if either of those are free and if so then i would assume they exist and if so i would collect them into one alright so that's one way of doing it but you and i also know about pointer arithmetic so here's a different way of doing it so	type	98
but you're saying hold on a moment this pointer you're starting with this user pointer it's avoid type that means that we're not declaring anything about what's actually at that memory location and if you read the c standard you're not allowed to do pointer arithmetic on that type because we don't know what's there would be absolutely correct however or modern compilers gcc clang and others do support this is the following extension which is you can add and subtract avoid pointers and if you do that then they behave like character pointers and in particular you are adding subtracting bytes off this memory location so we're walking back exactly the right number of bytes in this case because of this type ok so now i've got that now i can immediately say things like alright point p i know you're looking at my meta data entry so now let me declare that this entry is now free and then i would write my code to the block coalesce sing by checking my neighbors left and right to see if either of those are free and if so then i would assume they exist and if so i would collect them into one alright so that's one way of doing it but you and i also know about pointer arithmetic so here's a different way of doing it so	code	910
but you're saying hold on a moment this pointer you're starting with this user pointer it's avoid type that means that we're not declaring anything about what's actually at that memory location and if you read the c standard you're not allowed to do pointer arithmetic on that type because we don't know what's there would be absolutely correct however or modern compilers gcc clang and others do support this is the following extension which is you can add and subtract avoid pointers and if you do that then they behave like character pointers and in particular you are adding subtracting bytes off this memory location so we're walking back exactly the right number of bytes in this case because of this type ok so now i've got that now i can immediately say things like alright point p i know you're looking at my meta data entry so now let me declare that this entry is now free and then i would write my code to the block coalesce sing by checking my neighbors left and right to see if either of those are free and if so then i would assume they exist and if so i would collect them into one alright so that's one way of doing it but you and i also know about pointer arithmetic so here's a different way of doing it so	pointer	40
why did we take that user pointer	pointer	26
is the following so take that user point and cast it first into a metadata entry type	the following	3
is the following so take that user point and cast it first into a metadata entry type	type	81
entry point every job and put enough parentheses in here so thank you for your user pointer but i want to cast it and put in that parentheses in here to do that first case a great i've now got pointed the right type and now i just need to go back one ok so now i can just subtract one	type	211
entry point every job and put enough parentheses in here so thank you for your user pointer but i want to cast it and put in that parentheses in here to do that first case a great i've now got pointed the right type and now i just need to go back one ok so now i can just subtract one	pointer	84
what you say really how does that work ok well imagine for a moment that our memory no longer is of bites but imagine you could put some transparent paper down on this with shows enough spacing enough bytes where each one of these entries is a major data entry type in other words is enough space for two integers and avoid pointer so and you start off with a pointer that is looking at the beginning of the user area but i've just casted it so i can walk backwards by one and so i get now to the real metadata entry and now i can free it up and do that all that other good stuff so that's kind of a different way of doing it	memory	77
what you say really how does that work ok well imagine for a moment that our memory no longer is of bites but imagine you could put some transparent paper down on this with shows enough spacing enough bytes where each one of these entries is a major data entry type in other words is enough space for two integers and avoid pointer so and you start off with a pointer that is looking at the beginning of the user area but i've just casted it so i can walk backwards by one and so i get now to the real metadata entry and now i can free it up and do that all that other good stuff so that's kind of a different way of doing it	type	261
what you say really how does that work ok well imagine for a moment that our memory no longer is of bites but imagine you could put some transparent paper down on this with shows enough spacing enough bytes where each one of these entries is a major data entry type in other words is enough space for two integers and avoid pointer so and you start off with a pointer that is looking at the beginning of the user area but i've just casted it so i can walk backwards by one and so i get now to the real metadata entry and now i can free it up and do that all that other good stuff so that's kind of a different way of doing it	pointer	324
the trick of course is not to confuse these not to mix these up and to be very very sure about your pointer types because we don't want to accidentally subtract minus size of something when i'm fat you're working with the pointer that is not a void pointer or character pointer if i had for example accidentally instead of writing minus one here i'd written minus size off blah blah blah i would have gone back to a an arbiter location in memory and	memory	439
the trick of course is not to confuse these not to mix these up and to be very very sure about your pointer types because we don't want to accidentally subtract minus size of something when i'm fat you're working with the pointer that is not a void pointer or character pointer if i had for example accidentally instead of writing minus one here i'd written minus size off blah blah blah i would have gone back to a an arbiter location in memory and	type	108
the trick of course is not to confuse these not to mix these up and to be very very sure about your pointer types because we don't want to accidentally subtract minus size of something when i'm fat you're working with the pointer that is not a void pointer or character pointer if i had for example accidentally instead of writing minus one here i'd written minus size off blah blah blah i would have gone back to a an arbiter location in memory and	pointer	100
how when if you have code that calls free with an invalid value then the very instructions that we've just written here will start to write into arbitrary pieces of memory similarly if you have code which accidentally rights into an invalid place in the buffer so for example if you've got an array in heap and you start writing before that away then you're probably could be writing into the metadata that malloc is using to keep track of all the allocations which is why your program will	memory	165
how when if you have code that calls free with an invalid value then the very instructions that we've just written here will start to write into arbitrary pieces of memory similarly if you have code which accidentally rights into an invalid place in the buffer so for example if you've got an array in heap and you start writing before that away then you're probably could be writing into the metadata that malloc is using to keep track of all the allocations which is why your program will	code	21
crash in interesting and exciting and unexpected ways later on alright so great we've got ourselves are faster the allocator is that the end of it haha no but it's enough for you to get started with the cs two forty one mp so let's just kind of review what we just talked about we talked about block splitting and block coalesce sing we've talked about making a fast allocator maybe if we're actually looking for just three blocks maybe we should have yet another linked list which contains only the blocks which are actually available so i imagine you walk into the apartment manager and you say i like like in an apartment please of this size ideally want them to only look at the list of apartments which are actually available today you don't want to go through every single entry of every single apartment because most of those are actually in use and will be a waste of time to checking so perhaps we should have a link list to make it faster to find apartment blocks for it's ok	block	294
and i can also even look at how many allocation is performed inside the kernel as well and the kernel uses something called a slab allocator which builds upon a memory pool	memory	161
another version of a memory pool is where the objects don't need to be the same size but we can discard the entire memory pool in one go so for example we might say ok let me temporarily put aside a gigabyte of space right now for sale account game level or some processing unit and then when i'm done i don't need to rewind and call free on all of these objects i don't need to kind of start jumping around and	memory	21
hunting through my lists and doing block coalesce thing i can just simply declare that the whole memory pool has been wiped clean and reset my linked list back to nothing so so memory pools can be very very useful when you know the lifetime of all of the objects is finite and you want to clear them all all in one go	memory	97
hunting through my lists and doing block coalesce thing i can just simply declare that the whole memory pool has been wiped clean and reset my linked list back to nothing so so memory pools can be very very useful when you know the lifetime of all of the objects is finite and you want to clear them all all in one go	block	35
the wasted space in memory between the actual use of the shoe box so i'm going to say that my shoe takes up this amount of space but my boxes any come in certain sizes so there's going to be wasted space	memory	20
to how we should do block coalesce sing and here's his the basic idea	block	20
one of these blocks is freed let's choose the block eighteen ok so what do we start off with we start off with a memory pointer to the user space of free is going to be called with this address	memory	113
one of these blocks is freed let's choose the block eighteen ok so what do we start off with we start off with a memory pointer to the user space of free is going to be called with this address	block	13
one of these blocks is freed let's choose the block eighteen ok so what do we start off with we start off with a memory pointer to the user space of free is going to be called with this address	address	186
one of these blocks is freed let's choose the block eighteen ok so what do we start off with we start off with a memory pointer to the user space of free is going to be called with this address	pointer	120
and we would like to do block come coalesce sing so we need to jump forward to see if the block in front of us is also free ok how can i do that or just before this is rest is the size of this allocation and so is eighteen units so if i jump forward eighteen units in a bit more he i can now go and investigate whether this my neighbor is is available or not is free or not	block	24
but here's the cool trick i'd like to actually also try to carl s with information so with a potential block immediately before month before that so how do i do that well just before this eighteen is another number which is the size of the block before me and so i can use this to workout how to jump back to check whether this block is available or not what do we do about whether deciding whether the block is free or not so you might store a second number alongside this but there's another trick as well which is that if we make our allocations always an even number then we can actually store the free or	block	103
hi welcome to lecture twenty so let's have a code review where we're going to talk about a little bit of code that uses condition variables are you ready ok so my little application is very simple it's just got two threads one thread some point is going to modify this value of x and then call signal another thread is waiting for x d b positive so we can think of this basically like a latch and only after it's become positive do we continue right so what do we think about this code	code	45
hi welcome to lecture twenty so let's have a code review where we're going to talk about a little bit of code that uses condition variables are you ready ok so my little application is very simple it's just got two threads one thread some point is going to modify this value of x and then call signal another thread is waiting for x d b positive so we can think of this basically like a latch and only after it's become positive do we continue right so what do we think about this code	thread	215
right so what do we notice first of all that my code over here on the right really does need a mutex lock before we change value of x and we signal ok let's see why the problem occurs is when we call change at the same time that our second thread is actually called in this wait for positive x let's see where the problem could occur	code	48
right so what do we notice first of all that my code over here on the right really does need a mutex lock before we change value of x and we signal ok let's see why the problem occurs is when we call change at the same time that our second thread is actually called in this wait for positive x let's see where the problem could occur	a mutex	93
right so what do we notice first of all that my code over here on the right really does need a mutex lock before we change value of x and we signal ok let's see why the problem occurs is when we call change at the same time that our second thread is actually called in this wait for positive x let's see where the problem could occur	thread	240
we've got this test here and then later maybe a few nanoseconds later but it might be a bit longer eventually by calling peter condition wait my thread is going to block so here's the problem scenario what if we had an interleaving of these operations such that changing the value of x here happens after this test	block	164
we've got this test here and then later maybe a few nanoseconds later but it might be a bit longer eventually by calling peter condition wait my thread is going to block so here's the problem scenario what if we had an interleaving of these operations such that changing the value of x here happens after this test	thread	145
and calling peter condition signal happens before the thread blocks and waits for signals ok so now what's happened our second thread is going to deadlock it's now waiting for a signal that is never going to happen	block	61
and calling peter condition signal happens before the thread blocks and waits for signals ok so now what's happened our second thread is going to deadlock it's now waiting for a signal that is never going to happen	thread	54
so right now yes we have a small opportunity a chance that our second thread will deadlock how do we fix it by locking on the same mutex because then the only way that you can continue is after the threat has acquired the mutex so another thread will have to wait so now if we do that it becomes impossible to be executing these two lines of code at the same time that these two lines are being executed	code	342
so right now yes we have a small opportunity a chance that our second thread will deadlock how do we fix it by locking on the same mutex because then the only way that you can continue is after the threat has acquired the mutex so another thread will have to wait so now if we do that it becomes impossible to be executing these two lines of code at the same time that these two lines are being executed	thread	70
right the second thing that we'd like to change is this if inside here so in practice this can bite you in two different ways first of all maybe in other applications you have multiple threads calling this and we really just want to ensure their x really is positive before we continue and other things may change value x the second problem with this code is the actual deep condition wait is occasionally may suffer from what's called a spurious wake up it never truly went to sleep ok right so why does that occur well let's let's go back and talk about the implications for how conditioned weight is actually implemented right so we've just seen this problem of change in value of x and then signaling too early before they thread is actually blocking and waiting for that signal to arrive so in practice what does this mean it means that unlocking the mutex	block	746
right the second thing that we'd like to change is this if inside here so in practice this can bite you in two different ways first of all maybe in other applications you have multiple threads calling this and we really just want to ensure their x really is positive before we continue and other things may change value x the second problem with this code is the actual deep condition wait is occasionally may suffer from what's called a spurious wake up it never truly went to sleep ok right so why does that occur well let's let's go back and talk about the implications for how conditioned weight is actually implemented right so we've just seen this problem of change in value of x and then signaling too early before they thread is actually blocking and waiting for that signal to arrive so in practice what does this mean it means that unlocking the mutex	code	351
right the second thing that we'd like to change is this if inside here so in practice this can bite you in two different ways first of all maybe in other applications you have multiple threads calling this and we really just want to ensure their x really is positive before we continue and other things may change value x the second problem with this code is the actual deep condition wait is occasionally may suffer from what's called a spurious wake up it never truly went to sleep ok right so why does that occur well let's let's go back and talk about the implications for how conditioned weight is actually implemented right so we've just seen this problem of change in value of x and then signaling too early before they thread is actually blocking and waiting for that signal to arrive so in practice what does this mean it means that unlocking the mutex	thread	185
blocking a waiting for that signal has to be it has to behave as if it is an a single atomic operation in other words there is no clock cycle no moment in time between between these two events otherwise the very same argument that we just gave hear about these two operations happening just within that now window would apply to all of our cause to p three condition wait ok so we have to ensure that these behave can instantaneously together now in practice that may be impossible there could be a very narrow window between when we unlock the window unlock the mutex and block so in practice if that may occur for example because i really do have multiple cpus running on different pieces of silicon then what will happen is rather than blocking forever rp threat condition variable instead will suffer a spurious wake up to say i'm sorry maybe i missed a single maybe it just happened so that is why we always need to write this using a while so that	block	0
we can only continue if condition is met in this case the taxes become positive ok right so that's it for code review in next video let's talk about life lock by	code	106
right great ok so unless some implement a stack and will implement stack but is bounded by two things first of all you'll see that i data store here my little array here can only handle ten items also we can't pull anything from the stack if my stack is empty so now push and pop methods need to block if they are unable to continue right so let's let's have a good figure out how we're going to implement this first of all let's just pretend that with i cs two twenty five or some other course right and right than on the single threaded version ok so what are we going to have we're going to have things like the push method will be take my data structure my ray and after i've used the value of n increment it and density equal to be ok right what else you want to do so for multithreaded code i need to make sure that i'm the only person using this value of end otherwise two threads might call this code at the same time and both right into the same slot the same entry inside the away so less using mutex lock for that so we're definitely going to need mutex lock	block	296
right great ok so unless some implement a stack and will implement stack but is bounded by two things first of all you'll see that i data store here my little array here can only handle ten items also we can't pull anything from the stack if my stack is empty so now push and pop methods need to block if they are unable to continue right so let's let's have a good figure out how we're going to implement this first of all let's just pretend that with i cs two twenty five or some other course right and right than on the single threaded version ok so what are we going to have we're going to have things like the push method will be take my data structure my ray and after i've used the value of n increment it and density equal to be ok right what else you want to do so for multithreaded code i need to make sure that i'm the only person using this value of end otherwise two threads might call this code at the same time and both right into the same slot the same entry inside the away so less using mutex lock for that so we're definitely going to need mutex lock	a struct	646
right great ok so unless some implement a stack and will implement stack but is bounded by two things first of all you'll see that i data store here my little array here can only handle ten items also we can't pull anything from the stack if my stack is empty so now push and pop methods need to block if they are unable to continue right so let's let's have a good figure out how we're going to implement this first of all let's just pretend that with i cs two twenty five or some other course right and right than on the single threaded version ok so what are we going to have we're going to have things like the push method will be take my data structure my ray and after i've used the value of n increment it and density equal to be ok right what else you want to do so for multithreaded code i need to make sure that i'm the only person using this value of end otherwise two threads might call this code at the same time and both right into the same slot the same entry inside the away so less using mutex lock for that so we're definitely going to need mutex lock	code	792
right great ok so unless some implement a stack and will implement stack but is bounded by two things first of all you'll see that i data store here my little array here can only handle ten items also we can't pull anything from the stack if my stack is empty so now push and pop methods need to block if they are unable to continue right so let's let's have a good figure out how we're going to implement this first of all let's just pretend that with i cs two twenty five or some other course right and right than on the single threaded version ok so what are we going to have we're going to have things like the push method will be take my data structure my ray and after i've used the value of n increment it and density equal to be ok right what else you want to do so for multithreaded code i need to make sure that i'm the only person using this value of end otherwise two threads might call this code at the same time and both right into the same slot the same entry inside the away so less using mutex lock for that so we're definitely going to need mutex lock	thread	530
soapy said mutex lock and as luck would have it i've already got my variables up here ready to go right so let me call peter mutex lock on my mutex there we go so that might block for a short while if someone else is currently acquired the lock which is why a later on we are going to release it	block	174
so now we've got code which where only one third of the time can push things what about if our array is full of what if i stack is full so remember stepping	code	17
busy checking this right so while while n is equal to the maximum number go round the loop now we know we could put a sleeping here if we wanted to we know that right now this is a terrible test because we're holding the lock if all of our code uses a lot no one else will be able to do this fortunately for us we're going to be using p thread condition wait	the loop	82
busy checking this right so while while n is equal to the maximum number go round the loop now we know we could put a sleeping here if we wanted to we know that right now this is a terrible test because we're holding the lock if all of our code uses a lot no one else will be able to do this fortunately for us we're going to be using p thread condition wait	code	240
busy checking this right so while while n is equal to the maximum number go round the loop now we know we could put a sleeping here if we wanted to we know that right now this is a terrible test because we're holding the lock if all of our code uses a lot no one else will be able to do this fortunately for us we're going to be using p thread condition wait	thread	337
and that will release the lock whilst it's blocking ok so here's our condition variable that were going to sleep in and watched was sleeping unlock that mutex and then before returning lock it again so the big idea here is that in all the code that we write let's do i make a highlighter well let's do it like like a yellow ok it all this code every single piece of this	block	43
and that will release the lock whilst it's blocking ok so here's our condition variable that were going to sleep in and watched was sleeping unlock that mutex and then before returning lock it again so the big idea here is that in all the code that we write let's do i make a highlighter well let's do it like like a yellow ok it all this code every single piece of this	code	239
that we are in the matrix log so we could reason that we are the only thread that continue to run so great i've got all these other threads running at the same time but my head doesn't need to explode thinking about the possible interleavings of all of these expressions from this thread and another third because we own the mutex lock right and anybody else has to wait until we finished so it simplifies reasoning about this back down to just simple single threaded code again alright so great we've got our push method to work	code	468
that we are in the matrix log so we could reason that we are the only thread that continue to run so great i've got all these other threads running at the same time but my head doesn't need to explode thinking about the possible interleavings of all of these expressions from this thread and another third because we own the mutex lock right and anybody else has to wait until we finished so it simplifies reasoning about this back down to just simple single threaded code again alright so great we've got our push method to work	thread	70
if anything else we need to do yeah well we're writing a method which both to push and pop can can block so if i just put something onto this onto my way it could be that there's another thread waiting to pop things from the data structure so after i've modified it i'm going to call p threat condition broadcast	block	99
if anything else we need to do yeah well we're writing a method which both to push and pop can can block so if i just put something onto this onto my way it could be that there's another thread waiting to pop things from the data structure so after i've modified it i'm going to call p threat condition broadcast	the data structure	221
if anything else we need to do yeah well we're writing a method which both to push and pop can can block so if i just put something onto this onto my way it could be that there's another thread waiting to pop things from the data structure so after i've modified it i'm going to call p threat condition broadcast	a struct	228
if anything else we need to do yeah well we're writing a method which both to push and pop can can block so if i just put something onto this onto my way it could be that there's another thread waiting to pop things from the data structure so after i've modified it i'm going to call p threat condition broadcast	thread	187
there we go so if there happens to be someone sleeping in on this condition variable because that waiting to pop then now they can wake up so we could for performance reasons a little bit more about this and say the only time we need to do this the only possible time that someone could be blocked while popping from this away would be if the value of n was zero so in other words we have just increased it up to one otherwise there's no way that anyone could be sleeping right now so we could weight using about that and we could also reason that we've just added one thing	block	290
then maybe we could call pizza hut conditions signal as well but i would have to be a lot more careful about reasoning about that so i'm going to use p thread condition broadcast just in case there were multiple threads gone to sleep we want to make sure that if we're only going to wake up in that transition that we work them all up so	thread	152
so the pop ok so what should my pop method look like ok so first of all let's write the code which is going to	code	88
k so we turned my v where does become from i'm going to have something like double v equals so i go to my way now i want to pre decrement my value of n there we go alright so what about the blocking all right so we need something like look if my value of n is zero then go to sleep ok right so i'm going to have my p thread conditioned wait ok did you do today and here is my condition variable i'd like to sleep in and don't forget that mutex lock ok what is the mutex lock code look like are right so we've seen this before that's just	block	190
k so we turned my v where does become from i'm going to have something like double v equals so i go to my way now i want to pre decrement my value of n there we go alright so what about the blocking all right so we need something like look if my value of n is zero then go to sleep ok right so i'm going to have my p thread conditioned wait ok did you do today and here is my condition variable i'd like to sleep in and don't forget that mutex lock ok what is the mutex lock code look like are right so we've seen this before that's just	code	475
k so we turned my v where does become from i'm going to have something like double v equals so i go to my way now i want to pre decrement my value of n there we go alright so what about the blocking all right so we need something like look if my value of n is zero then go to sleep ok right so i'm going to have my p thread conditioned wait ok did you do today and here is my condition variable i'd like to sleep in and don't forget that mutex lock ok what is the mutex lock code look like are right so we've seen this before that's just	thread	317
right are we done no we might need to wake up some threads so let's put that code in as well about this kind of	code	77
right are we done no we might need to wake up some threads so let's put that code in as well about this kind of	thread	51
dark published right so let's in here wake up any thread switch might be sleeping on the condition variable so p thread condition broadcast	thread	50
all right and again we could reason about this we could say if there's if there's any locks if there's any threads sleeping on this waiting to push the only time that that can occur is if the reached the maximum number so if any is equal to now nine then i know that	thread	107
time to broadcast however this is kind of a optimization it's very easy to get these wrong it's very tricky to start modeling thinking about this when you've got multiple threads which might call pop of multiple threads which might call push gets a little bit easier to think about if you've only got one thread of each kind so my advice is treat these optimizations with extreme caution you're introducing possible edge cases which not easy to discover or think about and so if in doubt	optimizations	353
time to broadcast however this is kind of a optimization it's very easy to get these wrong it's very tricky to start modeling thinking about this when you've got multiple threads which might call pop of multiple threads which might call push gets a little bit easier to think about if you've only got one thread of each kind so my advice is treat these optimizations with extreme caution you're introducing possible edge cases which not easy to discover or think about and so if in doubt	thread	171
if you don't care about absolute performance just called prefect ingram forecast that performance head is not that great ok so we've got some working code we think let's actually have a go at testing this	code	150
ok so here's my code	code	16
that is going to actually run this and i've got some testing code where my producer is going to call the	code	61
push say ten thousand times but we're actually going to do that with two threads and then i've got a consumer method that is going to call pop twenty thousand times is just one of those today so let's check that we actually get all values of all the double values that we pushed in so we know that we know that we're going to push in the	thread	73
help for help in the background ok great so we know we're going to push in the values zero up to nine hundred and ninety nine nine have enough ninth ok right and so if we're just going to some these so we have the sum of values from zero up to that number there ok but in fact we're having two threads actually push all those values in so	thread	294
help for help in the background ok great so we know we're going to push in the values zero up to nine hundred and ninety nine nine have enough ninth ok right and so if we're just going to some these so we have the sum of values from zero up to that number there ok but in fact we're having two threads actually push all those values in so	background	21
i'm going to sum up the integers and if you know i'm sure you've seen this inside once every three right or you can do it recursively you can do this inductively or you can do it with lego as well you know that the sum is equal to n times n plus one over two right so in other words we expect a total of that right by the way i said you could do it with lego blocks here's the reasoning with lego blocks if you still some lego blocks from your younger sibling	block	359
lego block proved there right so let's let's actually have a go at running this ok so do we have code right so we called it block and let's let's run this thing ok you'll notice that we only exit after we managed to join all three threats so will compile it stop the cake monster stop consuming cake	block	5
lego block proved there right so let's let's actually have a go at running this ok so do we have code right so we called it block and let's let's run this thing ok you'll notice that we only exit after we managed to join all three threats so will compile it stop the cake monster stop consuming cake	code	97
compile ok block right so let's do that	block	11
ok gcc minus p thread block	block	22
ok gcc minus p thread block	thread	15
alright and great we got the correct some who are so are we convinced that our code works or like i said we've firmed given it a fair shake we called the	code	79
push and pop in a tight loop and we called it for ten thousand times so empirically we've shown that maybe if there's a likelihood of it failing we've at least tested it to the kind of point one percent level but is that is that is that does that give me confidence to put this into production no i'd actually want to kind of actually do a code review and think carefully about how my code works so so in multithreaded code it's a very important we have strong understanding about how our code works and rather than just simple going to lightweight testing and say oh yeah great pistol work if we actually want to use this code and trust it on our game or driving a car or an aircraft or website which is going to make our livelihood we actually want to be confident that we've got this multithreaded coding correct ok that's it for now bye	code	340
push and pop in a tight loop and we called it for ten thousand times so empirically we've shown that maybe if there's a likelihood of it failing we've at least tested it to the kind of point one percent level but is that is that is that does that give me confidence to put this into production no i'd actually want to kind of actually do a code review and think carefully about how my code works so so in multithreaded code it's a very important we have strong understanding about how our code works and rather than just simple going to lightweight testing and say oh yeah great pistol work if we actually want to use this code and trust it on our game or driving a car or an aircraft or website which is going to make our livelihood we actually want to be confident that we've got this multithreaded coding correct ok that's it for now bye	thread	410
as part of a judicial review of the c code written inside	code	38
we could look at the complexity of that code and decide how like it is that might be a bug inside that code right so let's have a look at then at the toyota camry are very popular model and will look at a particular particular system of this called the tcs which is the electronic throttle control system ok so toyota has been making cars for a long time and writing code for these cars for a long time so is there any surprise down the code that they discovered actually had over eleven thousand global variables good luck keeping track of that good luck trying to make sure that you understand your system sufficiently well	code	40
we could look at the complexity of that code and decide how like it is that might be a bug inside that code right so let's have a look at then at the toyota camry are very popular model and will look at a particular particular system of this called the tcs which is the electronic throttle control system ok so toyota has been making cars for a long time and writing code for these cars for a long time so is there any surprise down the code that they discovered actually had over eleven thousand global variables good luck keeping track of that good luck trying to make sure that you understand your system sufficiently well	system	227
also the code in this case was described professionally as just spaghetti code right so why was this code so bad right	code	9
ok so one thing we can look at is for any piece of code that you give me is something called the cyclomatic complexity metric and the idea here is look as a programmer if you want to have confidence you understand water code might do then you better understand all the possible paths that are code might take so for example you might have an if condition here and it might be true or false or you might have an expression here that could be true or false and so you need to be able to understand and potentially test every possible path of your code so every time there's a branch in your code you are potentially doubling the number of of paths depending of course how their code is structured right so	code	51
the in this case for the the toyota code we had sixty seven functions which were rated as completely une taps untestable that it was impossible to write test cases because they had more than fifty possible paths and that the swaddle code had a score of more than one hundred ios maintainable and so why is this relevant well this actually stem civil lawsuit where toyota was being accused of uncontrolled acceleration in their cars and this is just regular cars were not even talking about self driving cars this is just a c code designed to control the engine they're designed to control exactly what happens on every millisecond and every step of that engine be so	code	36
well if you were thinking along the lines that recursion unbounded can lead to a stackoverflow then congratulations you start to think like a security person here yeah so one problem with recursion is that if we never had a base case then our code will start to overwrite random pieces of memory that may be all crash but on these smaller systems it might just our stack might just keep going and start overwriting kind of critical values inside the heap	memory	289
well if you were thinking along the lines that recursion unbounded can lead to a stackoverflow then congratulations you start to think like a security person here yeah so one problem with recursion is that if we never had a base case then our code will start to overwrite random pieces of memory that may be all crash but on these smaller systems it might just our stack might just keep going and start overwriting kind of critical values inside the heap	the heap	446
well if you were thinking along the lines that recursion unbounded can lead to a stackoverflow then congratulations you start to think like a security person here yeah so one problem with recursion is that if we never had a base case then our code will start to overwrite random pieces of memory that may be all crash but on these smaller systems it might just our stack might just keep going and start overwriting kind of critical values inside the heap	code	243
well if you were thinking along the lines that recursion unbounded can lead to a stackoverflow then congratulations you start to think like a security person here yeah so one problem with recursion is that if we never had a base case then our code will start to overwrite random pieces of memory that may be all crash but on these smaller systems it might just our stack might just keep going and start overwriting kind of critical values inside the heap	system	339
and realize that any language can be good or bad but ultimately it's up to you as a software engineer to write good testable code and without going to finish this later ok bye	code	125
so let's go actually have a look at some code that does that another kind of useful trick is if actually don't care about using a particular port number just that you actually want to listen on any port that happens to be free then you can always pass in a port number of zero here remember that it's a string not a zero pointer to memory address zero	memory	332
so let's go actually have a look at some code that does that another kind of useful trick is if actually don't care about using a particular port number just that you actually want to listen on any port that happens to be free then you can always pass in a port number of zero here remember that it's a string not a zero pointer to memory address zero	code	41
so let's go actually have a look at some code that does that another kind of useful trick is if actually don't care about using a particular port number just that you actually want to listen on any port that happens to be free then you can always pass in a port number of zero here remember that it's a string not a zero pointer to memory address zero	string	303
so let's go actually have a look at some code that does that another kind of useful trick is if actually don't care about using a particular port number just that you actually want to listen on any port that happens to be free then you can always pass in a port number of zero here remember that it's a string not a zero pointer to memory address zero	address	339
so let's go actually have a look at some code that does that another kind of useful trick is if actually don't care about using a particular port number just that you actually want to listen on any port that happens to be free then you can always pass in a port number of zero here remember that it's a string not a zero pointer to memory address zero	pointer	321
and that will later bind will actually find the right free report for port for you but if you do that then it's time to actually figure out which port it is happy to do that where you can use get socket name but if you just simply attempt to read this struct this simple straight here then you're being for surprised a port number that you get there is in network byte ordering so that integer is not very useful to us when we actually want to print out we've gotta remember to use do remember what hopefully you said well i want to go from network to host and it's a short ok so i've got a rap that integer with that and then it will print out the right number for me ok another quick note here is hey what's going on here why do i have to cast this stuff well is because see does not have inheritance and this socket address in is kind of one extended type of socket address information and so that needs to be cast to the kind of the base type the simplest type which is just a socket address here	type	854
and that will later bind will actually find the right free report for port for you but if you do that then it's time to actually figure out which port it is happy to do that where you can use get socket name but if you just simply attempt to read this struct this simple straight here then you're being for surprised a port number that you get there is in network byte ordering so that integer is not very useful to us when we actually want to print out we've gotta remember to use do remember what hopefully you said well i want to go from network to host and it's a short ok so i've got a rap that integer with that and then it will print out the right number for me ok another quick note here is hey what's going on here why do i have to cast this stuff well is because see does not have inheritance and this socket address in is kind of one extended type of socket address information and so that needs to be cast to the kind of the base type the simplest type which is just a socket address here	address	819
so that's why we do the cast it's in order to have this kind of fake inheritance model here right so let's go actually have a look at some real code now where we're going to implement an actual actual web server	code	144
and yeah let's just go jump straight into code ok so will still the top ok	code	42
ok right so some code you're very welcome to use this to actually kind of print out your own ip address but i don't care about that today what do you want to show you is some things we have to do inside a good web server even a simple one here so for starters we need to handle sigpipe because maybe we want to send some bites down a socket but the other end is already closed it if we do that we'll get a sigpipe and the default behavior is seek pipe is to close up process so we better do something about that ok secondly a good web server will have to implement a better version of right because remember right can return just the negative wall and say oh i'm sorry i got interrupted by signal such as sick pipe case so we better keep track of that so if right returns negative wall and our error is interrupted then hey just restart right attempt otherwise let's keep track of the number of bytes that we've sent so far and keep calling right until we've exhausted all the bytes that we want to send ok so will just need to keep track of how far along we are in terms of the buffer that we're trying to send out an make sure that we don't send too many bytes so just take the total number of bytes minus the number of bytes sent so far	code	17
ok right so some code you're very welcome to use this to actually kind of print out your own ip address but i don't care about that today what do you want to show you is some things we have to do inside a good web server even a simple one here so for starters we need to handle sigpipe because maybe we want to send some bites down a socket but the other end is already closed it if we do that we'll get a sigpipe and the default behavior is seek pipe is to close up process so we better do something about that ok secondly a good web server will have to implement a better version of right because remember right can return just the negative wall and say oh i'm sorry i got interrupted by signal such as sick pipe case so we better keep track of that so if right returns negative wall and our error is interrupted then hey just restart right attempt otherwise let's keep track of the number of bytes that we've sent so far and keep calling right until we've exhausted all the bytes that we want to send ok so will just need to keep track of how far along we are in terms of the buffer that we're trying to send out an make sure that we don't send too many bytes so just take the total number of bytes minus the number of bytes sent so far	address	96
we need to be able to read what the client is sending us so will do something similar with weed in the request headers except we don't try to read the entire request from the user instead we're looking for the magic slash r slash n slash r slash end mean great we've read enough to see the end of the headers of the request	the header	297
ok so here comes my main method where i'm going to set up my signal handler straightaway will print out the ip address and we actually want to serve up this meme image as well so how could i figure out how many bytes well i could use stat but remember there's another way for files less than two gigabytes which is to call f seek so let's go to the end of the file find out where we are by calling f tell and then go back to the beginning	address	111
so by doing that great i'm now going to read all the bytes but also i can get some heap memory as well so if taylors told me how big my picture is and i can read all of those bytes in one go just by calling fread hey if read this is the number of bytes i want please read it from that file so great i've read that file into memory and now i can write that as many clients as possible so we now know how to set up our socket remember we want a socket passive socket we're going to listen ip four address today and here's the new bit of code though just talking about we need set socket opt to be able to say you know what if i restart my process i want to be able to immediately connect to the same port number so how do we do that we can use this particular circle option called reuse address	heap memory	83
so by doing that great i'm now going to read all the bytes but also i can get some heap memory as well so if taylors told me how big my picture is and i can read all of those bytes in one go just by calling fread hey if read this is the number of bytes i want please read it from that file so great i've read that file into memory and now i can write that as many clients as possible so we now know how to set up our socket remember we want a socket passive socket we're going to listen ip four address today and here's the new bit of code though just talking about we need set socket opt to be able to say you know what if i restart my process i want to be able to immediately connect to the same port number so how do we do that we can use this particular circle option called reuse address	memory	88
so by doing that great i'm now going to read all the bytes but also i can get some heap memory as well so if taylors told me how big my picture is and i can read all of those bytes in one go just by calling fread hey if read this is the number of bytes i want please read it from that file so great i've read that file into memory and now i can write that as many clients as possible so we now know how to set up our socket remember we want a socket passive socket we're going to listen ip four address today and here's the new bit of code though just talking about we need set socket opt to be able to say you know what if i restart my process i want to be able to immediately connect to the same port number so how do we do that we can use this particular circle option called reuse address	code	535
so by doing that great i'm now going to read all the bytes but also i can get some heap memory as well so if taylors told me how big my picture is and i can read all of those bytes in one go just by calling fread hey if read this is the number of bytes i want please read it from that file so great i've read that file into memory and now i can write that as many clients as possible so we now know how to set up our socket remember we want a socket passive socket we're going to listen ip four address today and here's the new bit of code though just talking about we need set socket opt to be able to say you know what if i restart my process i want to be able to immediately connect to the same port number so how do we do that we can use this particular circle option called reuse address	address	495
i'll read their request at that point i might process which kind of what they want but today i'm just going to send the meme if that's what they request that particular image then i'll send the picture so i need to say is the first thing my response hey everything is ok i understood what you wanted and then i need to say the mind type as well so this case we're sending back a jpeg mind type not ee is important	type	332
the image the meme images well course if they request something else then let's have a response code to say four oh four i'm sorry i do not know what you want at the end of this it's time to say goodbye we can say hey client it was great talking to you but i've got	code	96
ok so we've got a concept of i nodes let's actually design our own file system so we're going to base our little design on the ext3 file system which has been around for a long time but it was the parent of the third generation ext3 which came out in two thousand and one which added journaling so journaling is very useful if you want to support file system crashes when the file	system	72
ok so we can sort of say support power failures so this idea that i can resurrect my file system back to a good well known state where all of the data and the links inside my file system is correct and all the blocks that i refer to as being currently unused is correct that they're not kind of dual purpose for anything and i do that by keeping a journal of what actions i have been completed and then today your laptop your linux laptop is probably using ext4 and that added a lot of performance and also support for large files increased from sixteen terabytes which should have been big enough for everybody up to today ext4 now supports want etabyte of storage so that should be big enough for everybody we are not	block	210
ok so we can sort of say support power failures so this idea that i can resurrect my file system back to a good well known state where all of the data and the links inside my file system is correct and all the blocks that i refer to as being currently unused is correct that they're not kind of dual purpose for anything and i do that by keeping a journal of what actions i have been completed and then today your laptop your linux laptop is probably using ext4 and that added a lot of performance and also support for large files increased from sixteen terabytes which should have been big enough for everybody up to today ext4 now supports want etabyte of storage so that should be big enough for everybody we are not	system	90
going to look in detail at at ext3 weeks to four we're going to concentrate on this simpler model of ext2 right so here's our plan remember my disk drive has a lot of spinning parts or if it's an ssd will have a three dimensional geometry and i want to ignore all of that geometry for now because i would have a very abstract view of my disk namely that i can read and write blocks	block	375
that's my hardware is going to support the idea of saying please read this block one or please write this block two and that's all i need is a very very simple kind of block read or block write and i'd like random access if possible please ok so how should we do use all of these disk blocks ok so we will take the zero block here and will declare that as super block there it is so that is going to hold some meta information	block	75
so that's going to hold some meta information about how we've decided to organize the the rest of the disk so before we can actually start talking about that inode and where the actual data is going to be stored we better read superblock ok but after that super block we're going to use the rest of this space here to store the inode so it's just a simple linear way so i can easily calculate where our particular i know it is in relation to a particular this block	block	232
and inodes themselves are going to be pretty small let's think about what we need to store inside them so we have things like not the filename we're not going to store that inside an inode nstead we have things like who is the owner read write execute permissions where on the disk will find some of the blocks to do the size of the total file in bytes and maybe a few other things but typically i know is going to be of the order of one hundred and twenty eight bytes or sixty four bytes a pretty small so we can actually fit a lot of them in per disk block, per foyr kb chunk ok so they're actually very very small here right so we'll set aside some space for all of these inodes in my very very simple model of a file system here will say that you get one opportunity to decide how many inodes you would like to be able to store on this disk so you make that choice when you format it when you say right this is going to be the layout of my disk i'm going to set aside so many disk blocks for the i nodes here we go and the remainder will be used for all of the data that i want to store so that's my initial very simple model it's not very accurate in the sense that modern file systems allow me to have more than one area of memory set aside for on it but it's a good representation of how we started with early file systems ok so make that choice when you when you first formatted an we'll store that your choice inside the super block let's hope you don't under estimate about the number of files that you intend to store because then you'll run out of inode entries	memory	1230
and inodes themselves are going to be pretty small let's think about what we need to store inside them so we have things like not the filename we're not going to store that inside an inode nstead we have things like who is the owner read write execute permissions where on the disk will find some of the blocks to do the size of the total file in bytes and maybe a few other things but typically i know is going to be of the order of one hundred and twenty eight bytes or sixty four bytes a pretty small so we can actually fit a lot of them in per disk block, per foyr kb chunk ok so they're actually very very small here right so we'll set aside some space for all of these inodes in my very very simple model of a file system here will say that you get one opportunity to decide how many inodes you would like to be able to store on this disk so you make that choice when you format it when you say right this is going to be the layout of my disk i'm going to set aside so many disk blocks for the i nodes here we go and the remainder will be used for all of the data that i want to store so that's my initial very simple model it's not very accurate in the sense that modern file systems allow me to have more than one area of memory set aside for on it but it's a good representation of how we started with early file systems ok so make that choice when you when you first formatted an we'll store that your choice inside the super block let's hope you don't under estimate about the number of files that you intend to store because then you'll run out of inode entries	block	304
and inodes themselves are going to be pretty small let's think about what we need to store inside them so we have things like not the filename we're not going to store that inside an inode nstead we have things like who is the owner read write execute permissions where on the disk will find some of the blocks to do the size of the total file in bytes and maybe a few other things but typically i know is going to be of the order of one hundred and twenty eight bytes or sixty four bytes a pretty small so we can actually fit a lot of them in per disk block, per foyr kb chunk ok so they're actually very very small here right so we'll set aside some space for all of these inodes in my very very simple model of a file system here will say that you get one opportunity to decide how many inodes you would like to be able to store on this disk so you make that choice when you format it when you say right this is going to be the layout of my disk i'm going to set aside so many disk blocks for the i nodes here we go and the remainder will be used for all of the data that i want to store so that's my initial very simple model it's not very accurate in the sense that modern file systems allow me to have more than one area of memory set aside for on it but it's a good representation of how we started with early file systems ok so make that choice when you when you first formatted an we'll store that your choice inside the super block let's hope you don't under estimate about the number of files that you intend to store because then you'll run out of inode entries	system	721
ok and the rest of the space we're going to actually use to store the contents of my cat pictures ok so the first block of cat dot jpeg will be here if it's of a detailed jpeg picture then i'm going to need some other blocks ok and so for performance i probably put out, i'll try to use blocks which are contiguous which are next to each other but if my disk becomes very fragmented because i keep changing my mind about the kinds of cat pictures that i want to store its overtime i might say that ok so now a new cat picture uses these three blocks but also i had to put the fourth block way over here and so let's come back right so if this is a spinning disk it might take quite awhile for the physical part of the disk to read these blocks and then jump over here to read these blocks ok so we might want to make sure that if possible we keep our disk blocks together so we can quickly load my cat picture	block	114
ok so one thing that you might notice right now is that what would happen if a disk block got slightly corrupted so for example let's say that some dust or for some reason the surface here got corrupted now is unable to read these bites so right now you know you've lost a particular cat picture or maybe the cat cat picture won't display exactly correct now what about if we actually instead had some damage over here in our super block ok so now this potentially renders the whole disk unusable ok because inside the super block we said where does the number of inodes kind of finishe and which blocks are going to use for the data so in practice the super block is actually often replicated multiple times throughout the disk surface	block	84
right so what we haven't talked about yet is how we actually reference the blocks we need to actually read my cat so right now you'll see that say the cat is using say block seventeen eighteen nineteen twenty twenty one maybe it's using these ones of over well so maybe this is like nine hundred forty three and nine hundred forty four where am i going to store these numbers so for that let's actually look at a model of how we can do that	block	75
and for that we really need to understand how to work with errors and how to print out errors and how to discover when things don't work so networking is tricky because with things don't work where you actually want to understand what your problem with the client or the server was there a problem in setting up the connection and so dealing with errors becomes quite important areas can be because of code areas we've made but it also can be say because the client has finished the connection before the server had finished saying everything he wanted to say unvoice versa ok so let's start talking about errors that right so	code	402
you want to put out some errors ok so here's first way you've probably seen things like ok i can use p error to print an error to standard error and i can include piece of text here which gets included along with some standard string ok there's also if you prefer a way to get just a simple string and this is it you can say store error and i can ask for a	string	227
the string associated with a particular error number like one two three four five etc etc etc ok but perhaps you want to know what is actually just gone wrong with your program and so if you want to find out the air associated with a recent system call guess what there is something called ever know urdu there we go so i could say please tell me	string	4
the string associated with a particular error number like one two three four five etc etc etc ok but perhaps you want to know what is actually just gone wrong with your program and so if you want to find out the air associated with a recent system call guess what there is something called ever know urdu there we go so i could say please tell me	system	241
the these string associated with the most recent system ever ok so in fact we could re implement pm so if we needed to write kind of piero ourselves we might do something like the following we might say ok so peer error i just want to print out to standard error	the following	176
the these string associated with the most recent system ever ok so in fact we could re implement pm so if we needed to write kind of piero ourselves we might do something like the following we might say ok so peer error i just want to print out to standard error	string	10
the these string associated with the most recent system ever ok so in fact we could re implement pm so if we needed to write kind of piero ourselves we might do something like the following we might say ok so peer error i just want to print out to standard error	system	49
format string to say whatever the user said ok cologne another	string	7
ok and then another string	string	20
right so there's a one big surprising gotcher however with string ever and if the following if we actually read the manpage we discover that let's come back	the following	78
right so there's a one big surprising gotcher however with string ever and if the following if we actually read the manpage we discover that let's come back	string	59
a different color that it is not thread safe	thread	33
bit of a surprise right here we are using this low function inside here and we thought we could do everything we wanted inside our threads it's not thread safe key and if we instead we actually want to write code that is two s dave then	code	208
bit of a surprise right here we are using this low function inside here and we thought we could do everything we wanted inside our threads it's not thread safe key and if we instead we actually want to write code that is two s dave then	thread	131
so the reason for that is that string air itself might return just a hardcoded string literal say error number one two three four five six etc but if you pass an arbitrary large number it actually constructs	code	73
so the reason for that is that string air itself might return just a hardcoded string literal say error number one two three four five six etc but if you pass an arbitrary large number it actually constructs	string	31
the string itself and how it might do that well it could call malloc except that stuart air itself doesn't ask you to return anything instead it just returns a pointer so instead internally has some static	string	4
the string itself and how it might do that well it could call malloc except that stuart air itself doesn't ask you to return anything instead it just returns a pointer so instead internally has some static	pointer	160
static memory that it reuses from one call to the next ok so that's our problem that if i'm going to use this in multiple threads i could have one call to store arribe be entered by another call to stuart error	memory	7
static memory that it reuses from one call to the next ok so that's our problem that if i'm going to use this in multiple threads i could have one call to store arribe be entered by another call to stuart error	thread	122
on a different thread an oh dear both of them are now trying to use the same piece of static memory so one error is going to override the other one right so this kind of common with some of the earlier calls inside posix that they weren't built with with threads in mind and so threat support the ability to work with multiple threads has kind of been reverse engineered back into some of these api calls so stroit error itself with this underscore r will discover actually	memory	93
on a different thread an oh dear both of them are now trying to use the same piece of static memory so one error is going to override the other one right so this kind of common with some of the earlier calls inside posix that they weren't built with with threads in mind and so threat support the ability to work with multiple threads has kind of been reverse engineered back into some of these api calls so stroit error itself with this underscore r will discover actually	thread	15
doesn't have doesn't take just a simple integer for the integer or no instead you also pass in a pointer to your memory that you would like it to use so here's some memory and typically as well you impasse in how much many as well so we could pull up a terminal window to see the exact order of these things but what i want you to learn yeah there's quite a few of these kind of underscore are variations or variants of existing course and they were added later to posix	memory	113
doesn't have doesn't take just a simple integer for the integer or no instead you also pass in a pointer to your memory that you would like it to use so here's some memory and typically as well you impasse in how much many as well so we could pull up a terminal window to see the exact order of these things but what i want you to learn yeah there's quite a few of these kind of underscore are variations or variants of existing course and they were added later to posix	a terminal	251
doesn't have doesn't take just a simple integer for the integer or no instead you also pass in a pointer to your memory that you would like it to use so here's some memory and typically as well you impasse in how much many as well so we could pull up a terminal window to see the exact order of these things but what i want you to learn yeah there's quite a few of these kind of underscore are variations or variants of existing course and they were added later to posix	pointer	97
in order to make it more thread safe now the last thing you might have been thinking about when i was talking about this is hold on a moment what about errno what is this other thing and wins it set ok so oh no is set by most system calls that can fail so for example read or write set errno to tell you what went wrong so if you call right and it doesn't work	thread	25
in order to make it more thread safe now the last thing you might have been thinking about when i was talking about this is hold on a moment what about errno what is this other thing and wins it set ok so oh no is set by most system calls that can fail so for example read or write set errno to tell you what went wrong so if you call right and it doesn't work	system	226
oh dear it will return negative one but you want to find out more about what went wrong so that information is encoded inside this global variable but wait a moment if i've got a multithreaded program surely it's going to be really hard to figure out which particular thread on which system call caused errno to change	code	113
oh dear it will return negative one but you want to find out more about what went wrong so that information is encoded inside this global variable but wait a moment if i've got a multithreaded program surely it's going to be really hard to figure out which particular thread on which system call caused errno to change	thread	184
oh dear it will return negative one but you want to find out more about what went wrong so that information is encoded inside this global variable but wait a moment if i've got a multithreaded program surely it's going to be really hard to figure out which particular thread on which system call caused errno to change	system	284
yes you are correct and now i'm forced to tell you that actually ok that ever know actually for multithreaded programs	thread	101
is a very special variably behaves like a global variable but actually it uses thread local storage which means that each thread gets its own copy thread local storage each thread gets its own copy of error	thread	79
it still behaves like a global variable but the value that each thread reads is actually specific to that thread so now you can confidently say oh yes that most recent call to read	thread	64
or write or say creating a pipe that if it failed then i can read my own value of owner to find out why it fell ok wait so in the next video we're going to talk about what happens when system calls get interrupted i'll see you then bye	system	185
ok i want to talk about the dirty bit so let's keep track of which pages have been modified and so this is the function of the dirty bit so the dirty bit means that my page has been modified; and what do we mean by modified the idea that the copy that we have on secondary storage i file system is no longer accurate so if we need to page this physical frame out we actually need to do a copy process we don't have a current copy outside of the physical ram so	system	288
ok so by keeping track of whether our copy is fresh or the or the rams been dirted allows us to choose page frames efficiently if we're going to choose a particular frame efficiently ideally we're not going to choose one which is dirty because if we have to choose a page frame which is dirty it's going to take his even more time before we can assign that page to a different duty we need to copy those bites and store them out onto the disk	a page	265
right so in addition then to the mapping from a logical page number two physical frame number will keep track of these pages which have been modified but some other things that we can store as well why don't we store weather some memory is read only	memory	230
that has a couple of uses first of all as a security idea if i've loaded in say some program code i usually don't want my program to be self modifying and so for security let's make sure that that code cannot be changed once it's loaded into ram the other ones do is share all come back to read only in a moment another one which is really useful is to say whether a page of memory is executable	a page	365
that has a couple of uses first of all as a security idea if i've loaded in say some program code i usually don't want my program to be self modifying and so for security let's make sure that that code cannot be changed once it's loaded into ram the other ones do is share all come back to read only in a moment another one which is really useful is to say whether a page of memory is executable	memory	375
that has a couple of uses first of all as a security idea if i've loaded in say some program code i usually don't want my program to be self modifying and so for security let's make sure that that code cannot be changed once it's loaded into ram the other ones do is share all come back to read only in a moment another one which is really useful is to say whether a page of memory is executable	code	93
which is exciting because now i can put actual program code in there so we can help prevent these kinds of deliberate buffer overflow form immediately executing code by declaring that my stack is not executable assembly this things i put inside the heap are not executable so that's kind of default behavior that only some parts of my memory executable only some parts of writable the rest of it is readable	memory	335
which is exciting because now i can put actual program code in there so we can help prevent these kinds of deliberate buffer overflow form immediately executing code by declaring that my stack is not executable assembly this things i put inside the heap are not executable so that's kind of default behavior that only some parts of my memory executable only some parts of writable the rest of it is readable	the heap	245
which is exciting because now i can put actual program code in there so we can help prevent these kinds of deliberate buffer overflow form immediately executing code by declaring that my stack is not executable assembly this things i put inside the heap are not executable so that's kind of default behavior that only some parts of my memory executable only some parts of writable the rest of it is readable	code	55
you can change this this might be useful for example if you're writing a hot spot compiler because now the things you right into memory you actually do want to compile and run as executable code so we'll talk about how we can use this later on in the course when we start talking about memory mapped files and memory mappings	memory	129
you can change this this might be useful for example if you're writing a hot spot compiler because now the things you right into memory you actually do want to compile and run as executable code so we'll talk about how we can use this later on in the course when we start talking about memory mapped files and memory mappings	code	190
i want to come back to however to this idea of making parts of my memory read only this actually allows us to use our memory really efficiently i want you to for example imagine that you're currently running a compiler let's say it's clang	memory	66
right and so your address space yes you have your own heap yes you have your own stack etc but you also have a whole lot of memory dedicated to the executable code of client so there it is but guess what there i'm also on the same machine also running clang so i need the same pieces of code loaded into memory now if we didn't care about using memory efficiently	memory	124
right and so your address space yes you have your own heap yes you have your own stack etc but you also have a whole lot of memory dedicated to the executable code of client so there it is but guess what there i'm also on the same machine also running clang so i need the same pieces of code loaded into memory now if we didn't care about using memory efficiently	code	159
right and so your address space yes you have your own heap yes you have your own stack etc but you also have a whole lot of memory dedicated to the executable code of client so there it is but guess what there i'm also on the same machine also running clang so i need the same pieces of code loaded into memory now if we didn't care about using memory efficiently	address	18
we could say fine will just duplicate all the stuff we're loading from disk into memory twice so inside my expensive ram	memory	81
is all my expensive ram now k will be a copy of clang for you and a copy of clang for maine we can do better than this let's let's share these piece of memory so if you agree to never be able to change this so if this is read only ok for you and read only for me then both of us can believe that we've actually got our own copy of clang but in fact	memory	152
they they are actually sharing the same physical piece of memory and that's pretty cool so now we have many users thinking that they've got access to more random we actually have because they're sharing things and there's an example with clang but it's very true for things like the c library and other dynamic libraries that are shared across multiple processes	memory	58
right so sharing is caring and kind of allows us to use our memory efficiently the last thing will be able to do is to be able to say right i'm going to take a frame of memory here and map it into my address space and then also map it into another processes address space so now i can have two processes which can communicate extremely quickly	memory	60
right so sharing is caring and kind of allows us to use our memory efficiently the last thing will be able to do is to be able to say right i'm going to take a frame of memory here and map it into my address space and then also map it into another processes address space so now i can have two processes which can communicate extremely quickly	address	200
then you consider immediately there is no memory copying required why because we're both actually looking at the same physical piece of ram let that sink in for a moment that is really really cool so there's an instantaneous copy if you like for instance appearance of this value inside your memory space because we're both actually looking at the same piece of silicon	memory	42
and so we're going to see how to do that later when we talk about mmap	mmap	66
and it's a very fast way to do what's called ipc or inter process communication and allows us to share bits of memory it's very very kind standard practice today with more complicated pieces of machinery like browsers where i might have different processes involved with different aspects of my browsing so i might have one for example that is working with fonts another one that's doing the ui layout another one which is doing that download another which is the javascript interpreter etc and i need an extremely fast mechanism to be able to communicate between all of these different processes right so that's all to come when we start talking about mmap in the future but it ultimately relies on the very page tables that we've been talking about as how we implement virtual memory so what's the big takeaways first of all realized every page has these bits we've got things like the modified bit we've got to read only and whether it's executable you get some of these settings for free	memory	111
and it's a very fast way to do what's called ipc or inter process communication and allows us to share bits of memory it's very very kind standard practice today with more complicated pieces of machinery like browsers where i might have different processes involved with different aspects of my browsing so i might have one for example that is working with fonts another one that's doing the ui layout another one which is doing that download another which is the javascript interpreter etc and i need an extremely fast mechanism to be able to communicate between all of these different processes right so that's all to come when we start talking about mmap in the future but it ultimately relies on the very page tables that we've been talking about as how we implement virtual memory so what's the big takeaways first of all realized every page has these bits we've got things like the modified bit we've got to read only and whether it's executable you get some of these settings for free	mmap	653
later or control them when we talked about memory mapped files they give us an advantage of being able to share things and they give us some security is not a hundred percent if you are interested then go and read up on return oriented programming which is an extremely kind of clever way of misusing the stack when all you can control is the return addresses that are actually present on the stack	memory	43
later or control them when we talked about memory mapped files they give us an advantage of being able to share things and they give us some security is not a hundred percent if you are interested then go and read up on return oriented programming which is an extremely kind of clever way of misusing the stack when all you can control is the return addresses that are actually present on the stack	address	350
and we've talked about page tables which allow us to actually implement virtual memory so we can do this mapping and then finally we talked about the tlb which allowed us to actually have some performance	memory	80
ok and along the way we talked about paging in an paging out an page faults right there's multiple decide the course book but i hope you have a good understanding now of how the mechanics of virtual memory by	memory	199
engineering work station here and let's go into a virtual file system i'm going to go into one called proc to tell us all about various processes so realize that none of these files exist right they're all coming from the kernel but the kernel is faking the results	system	63
it's just giving me a directory listing which to me looks like real files but actually none of this stuff exists so right now i don't have much running here i've got a process called two five six five which is bash and i just started another one for ps let me go into one to the batches i know that's still around ok so let me cd into two five six five you'll notice that there it is it was listed earlier and inside this directory	a process	166
process i can find out how is using memory i can look at it's page map i can see how it got started i can look at its environment variables let's just try that ok so these are all the environment variables that it got started with i can look at it say command line how it how it's initially random we didn't start it with just bash i can look at say what limits we have ok right so say how much memory is allowed to use how many processes it's allowed to start etc etc etc so we are peeking inside the kernel as it's running and it's giving us all this kind of great information so now we can build little tools for example we could build a little tool called ps which looks at proc and maybe some other virtual file systems in order to tell us more about what the system is doing or for example we could look at the current set of users which and what are they doing where they're going where they come from all again from these virtual file systems ok so all great stuff and we'll talk more about that in s future lecture before that for now does it for this letter bye	memory	36
process i can find out how is using memory i can look at it's page map i can see how it got started i can look at its environment variables let's just try that ok so these are all the environment variables that it got started with i can look at it say command line how it how it's initially random we didn't start it with just bash i can look at say what limits we have ok right so say how much memory is allowed to use how many processes it's allowed to start etc etc etc so we are peeking inside the kernel as it's running and it's giving us all this kind of great information so now we can build little tools for example we could build a little tool called ps which looks at proc and maybe some other virtual file systems in order to tell us more about what the system is doing or for example we could look at the current set of users which and what are they doing where they're going where they come from all again from these virtual file systems ok so all great stuff and we'll talk more about that in s future lecture before that for now does it for this letter bye	system	717
oh i forgot to say one little thing about erino down here which is when is it set ok so here's a big idea is that it set to zero when your first program first starts up its value is changed whenever there's an error with a system called and we read the man pages to learn more about that but it's never reset back to zero so if i had a whole lot of calls let's say that i try to read from warm particular file descriptor and then try to write those bites somewhere else to another file descriptor fd two over here if i then check if evan oh zero or not then i can't actually tell you whether where the error curd maybe it happened early on inside my read maybe it happened inside my right or maybe it happened even earlier so just think of is a global variable that if an error occurs we change it	a system call	221
oh i forgot to say one little thing about erino down here which is when is it set ok so here's a big idea is that it set to zero when your first program first starts up its value is changed whenever there's an error with a system called and we read the man pages to learn more about that but it's never reset back to zero so if i had a whole lot of calls let's say that i try to read from warm particular file descriptor and then try to write those bites somewhere else to another file descriptor fd two over here if i then check if evan oh zero or not then i can't actually tell you whether where the error curd maybe it happened early on inside my read maybe it happened inside my right or maybe it happened even earlier so just think of is a global variable that if an error occurs we change it	system	223
so now if you do that and you make some system tools	system	40
in practice of course bulletproof code robust production code would actually check the return values of all of your system calls and that is kind of really good system programming practice to kind of detect when errors go wrong and actually becomes critical when you start writing network code c in the next video bye	code	34
in practice of course bulletproof code robust production code would actually check the return values of all of your system calls and that is kind of really good system programming practice to kind of detect when errors go wrong and actually becomes critical when you start writing network code c in the next video bye	system	116
ok so we didn't need a definition for deadlock and this idea that our our threads are frozen up maybe one thread is waiting for a mutex lock that is never going to be unlocked maybe we're waiting for something from a data structure which is never going to be given to us so here's a general definition for dead log key	a struct	220
ok so we didn't need a definition for deadlock and this idea that our our threads are frozen up maybe one thread is waiting for a mutex lock that is never going to be unlocked maybe we're waiting for something from a data structure which is never going to be given to us so here's a general definition for dead log key	a mutex	128
ok so we didn't need a definition for deadlock and this idea that our our threads are frozen up maybe one thread is waiting for a mutex lock that is never going to be unlocked maybe we're waiting for something from a data structure which is never going to be given to us so here's a general definition for dead log key	thread	74
well ok can i type so i put in some in there ok	type	14
make this thread exit it's never going to happen ok so our poor poor little fair door process is waiting some for an event maybe we're going to signal that event using a variable or some other method and it's just never going to happen so it doesn't get to complete it doesn't get to kind of run its activity or run the code and of course debugging deadlock is tricky it's often there as pairs that i could a thread maybe it's stuck inside p threat condition wait and we don't know why why that event doesn't hasn't hasn't fired hasn't occured	code	320
make this thread exit it's never going to happen ok so our poor poor little fair door process is waiting some for an event maybe we're going to signal that event using a variable or some other method and it's just never going to happen so it doesn't get to complete it doesn't get to kind of run its activity or run the code and of course debugging deadlock is tricky it's often there as pairs that i could a thread maybe it's stuck inside p threat condition wait and we don't know why why that event doesn't hasn't hasn't fired hasn't occured	a thread	407
make this thread exit it's never going to happen ok so our poor poor little fair door process is waiting some for an event maybe we're going to signal that event using a variable or some other method and it's just never going to happen so it doesn't get to complete it doesn't get to kind of run its activity or run the code and of course debugging deadlock is tricky it's often there as pairs that i could a thread maybe it's stuck inside p threat condition wait and we don't know why why that event doesn't hasn't hasn't fired hasn't occured	thread	10
ok so we've got this general definition of deadlock now actually let's see if we can kind of construct some examples where we actually cause it so let's use team mutex locks and two threads to create an example of deadlock ok bye i'm going to actually do this in a text editor ok	thread	182
let's go right do i have so if i've got thread one imagine my thread first red make the coda bigger right has called	thread	40
p thread mutex lock k and we're going to say please lock on this first mutex and then after you've done that please lock on this other mutex right so it will do some work ok do something and then after that we want to at least ok so we will call p thread unlock on both of these mutex is ok	thread	2
so for example maybe we want to take some data out of out of data store one stick it into data structure to ok it doesn't matter particular which order that we released them in just for symmetry i'm going to do it this way but let's let's think about what happens if we lock these in a different sequence inside another thread so i'm going to have now another thread that does the same sequence of operations accept ha we have swapped these around the case so we swap these two lights ok so is this a problem	a struct	93
so for example maybe we want to take some data out of out of data store one stick it into data structure to ok it doesn't matter particular which order that we released them in just for symmetry i'm going to do it this way but let's let's think about what happens if we lock these in a different sequence inside another thread so i'm going to have now another thread that does the same sequence of operations accept ha we have swapped these around the case so we swap these two lights ok so is this a problem	thread	320
like most of the time no most of the time my threads are perfectly happy doing what they need to do until the following happens until one unfortunate day thread one has called preferred mutex lock on get this choose a new color	the following	106
like most of the time no most of the time my threads are perfectly happy doing what they need to do until the following happens until one unfortunate day thread one has called preferred mutex lock on get this choose a new color	thread	45
called prefix lock on the first one case is completed that at the same time my other thread which is curiously called thread one so let's fix that thread	thread	85
so now they were both able to do this but what happens next ok i think we should choose a new color for this let's go for yes it's kinda extreme pinky purple thing let's try that ok right so now what happens thread one says i'd like to lock this mutex but of course what	thread	208
does this do it blocks ok why because another thread has that new texts between you and me we know it's thread two meanwhile thread two tries to look	block	16
does this do it blocks ok why because another thread has that new texts between you and me we know it's thread two meanwhile thread two tries to look	thread	46
it takes one and that of course blocks	block	32
it's not yet available another thread is currently quite that musics lock ok so when will we escape out of this and the answer is never ok we can read the code and see that eventually we're going to release these locks but we're never going to get to that that piece of code that thread one is waiting for thread two and thread two is waiting for thread one so it's kind of stuck for stuck forever	code	155
it's not yet available another thread is currently quite that musics lock ok so when will we escape out of this and the answer is never ok we can read the code and see that eventually we're going to release these locks but we're never going to get to that that piece of code that thread one is waiting for thread two and thread two is waiting for thread one so it's kind of stuck for stuck forever	thread	31
ok i am not occured because we constructed this with the locks being acquired in a different order if they were in the same order it would have been fine let's just kind of quickly sketch that out to see that let's imagine that i had my first thread doing mutex worn and then mute x two and then mutex wanna mutex two down here for thread two then if they both try to acquire mutex in at the same time then we can imagine that thread one would acquire the mutex lock here which would mean thread two will be forced to block	block	518
ok i am not occured because we constructed this with the locks being acquired in a different order if they were in the same order it would have been fine let's just kind of quickly sketch that out to see that let's imagine that i had my first thread doing mutex worn and then mute x two and then mutex wanna mutex two down here for thread two then if they both try to acquire mutex in at the same time then we can imagine that thread one would acquire the mutex lock here which would mean thread two will be forced to block	a mutex	306
ok i am not occured because we constructed this with the locks being acquired in a different order if they were in the same order it would have been fine let's just kind of quickly sketch that out to see that let's imagine that i had my first thread doing mutex worn and then mute x two and then mutex wanna mutex two down here for thread two then if they both try to acquire mutex in at the same time then we can imagine that thread one would acquire the mutex lock here which would mean thread two will be forced to block	thread	243
so it doesn't get to go to step two which means thread one can continue and then when it's finished it will release those locks so now thread two can finish so	thread	48
if we'd actually written our code like this in the same order it would have been impossible to get deadlock	code	29
ok so that was with a mutex lock now that's actually think about could we do something similar with counting semaphores sure ok so let's do something similar with counting semaphores where thread one calls say sam weights on counting center four as well	a mutex	20
ok so that was with a mutex lock now that's actually think about could we do something similar with counting semaphores sure ok so let's do something similar with counting semaphores where thread one calls say sam weights on counting center four as well	thread	189
i'll have another thread that does something similar or key	thread	18
and another thread does something similar ok so do we see any problems right now nope we could imagine that these counting semaphore 's my kind except for has been initialized just account of one ok so same initiate here go let's have one pizza slice in there	thread	12
there's no possibility of deadlock right now that for every same weight called we call assam post ok right so what if we could have made it a little bit more complicated though and we said that same weight here is going to in order to continue i'm going to wait on this thread and then i'm going to post on some samples to an meanwhile thread two i'm going to wait on counting semaphore two and then i'm going to post on counting semaphore three ok and then some weight three i'm going to then post inseminate one ok if all my counties are forced to started off with a value of zero you can see that no one gets to play that all of my threads have got stuck that my first thread is blocked here waiting for the value for sale wanted change well someone will change down here but unfortunately thread three is blocked waiting for the count for sam three is waiting for pizza slice and were able to get that piece of sliced form it is waiting for sam post to be called by thread two but thread two is not going to give it that pizza slice until it gets a piece of slice out of counting semaphores s two and where will i get that only from thread one when thread one finally called stem post but that's not going to happen because thread what is still waiting for the pizza slice from thread three so now you see we've got this love triangle here between our three threads they'll never going to continue that always waiting for an event that's never going to happen so that's all example of deadlock we can construct lots of these varying bits of complexity usually we don't artificial construct them like this usually were scratching go ahead go why did my system come to a grinding halt and the other thing i want you to notice is that	block	682
there's no possibility of deadlock right now that for every same weight called we call assam post ok right so what if we could have made it a little bit more complicated though and we said that same weight here is going to in order to continue i'm going to wait on this thread and then i'm going to post on some samples to an meanwhile thread two i'm going to wait on counting semaphore two and then i'm going to post on counting semaphore three ok and then some weight three i'm going to then post inseminate one ok if all my counties are forced to started off with a value of zero you can see that no one gets to play that all of my threads have got stuck that my first thread is blocked here waiting for the value for sale wanted change well someone will change down here but unfortunately thread three is blocked waiting for the count for sam three is waiting for pizza slice and were able to get that piece of sliced form it is waiting for sam post to be called by thread two but thread two is not going to give it that pizza slice until it gets a piece of slice out of counting semaphores s two and where will i get that only from thread one when thread one finally called stem post but that's not going to happen because thread what is still waiting for the pizza slice from thread three so now you see we've got this love triangle here between our three threads they'll never going to continue that always waiting for an event that's never going to happen so that's all example of deadlock we can construct lots of these varying bits of complexity usually we don't artificial construct them like this usually were scratching go ahead go why did my system come to a grinding halt and the other thing i want you to notice is that	thread	270
there's no possibility of deadlock right now that for every same weight called we call assam post ok right so what if we could have made it a little bit more complicated though and we said that same weight here is going to in order to continue i'm going to wait on this thread and then i'm going to post on some samples to an meanwhile thread two i'm going to wait on counting semaphore two and then i'm going to post on counting semaphore three ok and then some weight three i'm going to then post inseminate one ok if all my counties are forced to started off with a value of zero you can see that no one gets to play that all of my threads have got stuck that my first thread is blocked here waiting for the value for sale wanted change well someone will change down here but unfortunately thread three is blocked waiting for the count for sam three is waiting for pizza slice and were able to get that piece of sliced form it is waiting for sam post to be called by thread two but thread two is not going to give it that pizza slice until it gets a piece of slice out of counting semaphores s two and where will i get that only from thread one when thread one finally called stem post but that's not going to happen because thread what is still waiting for the pizza slice from thread three so now you see we've got this love triangle here between our three threads they'll never going to continue that always waiting for an event that's never going to happen so that's all example of deadlock we can construct lots of these varying bits of complexity usually we don't artificial construct them like this usually were scratching go ahead go why did my system come to a grinding halt and the other thing i want you to notice is that	system	1656
i might have a thread that say forgets to call sam post or for some other forget or some bug causes some event not to occur and then you get all of this fall out where other threads and other processes are unable to continue because they are also waiting for that for that thread or the other process so you'll see this occasionally on your phone or on your laptop where one little issue say with their gui process or gui thread now starts to have cascading problems and your deadlock starts to affect other systems as well because everything else grinds to a halt and there's multiple dependencies between all of our threads and processes ok so that's deadlock what what we'd like to be able to do is ensure	a thread	13
i might have a thread that say forgets to call sam post or for some other forget or some bug causes some event not to occur and then you get all of this fall out where other threads and other processes are unable to continue because they are also waiting for that for that thread or the other process so you'll see this occasionally on your phone or on your laptop where one little issue say with their gui process or gui thread now starts to have cascading problems and your deadlock starts to affect other systems as well because everything else grinds to a halt and there's multiple dependencies between all of our threads and processes ok so that's deadlock what what we'd like to be able to do is ensure	thread	15
i might have a thread that say forgets to call sam post or for some other forget or some bug causes some event not to occur and then you get all of this fall out where other threads and other processes are unable to continue because they are also waiting for that for that thread or the other process so you'll see this occasionally on your phone or on your laptop where one little issue say with their gui process or gui thread now starts to have cascading problems and your deadlock starts to affect other systems as well because everything else grinds to a halt and there's multiple dependencies between all of our threads and processes ok so that's deadlock what what we'd like to be able to do is ensure	system	508
first of all maybe you could have any more efficient representation if you only allocated blocks which were always the same size say you only ever allocated blocks in one kilobyte chunks now you could keep track of your allocation just using one bit of information for each chunk ok which is a lot more efficient than are linked list implementation	block	90
all of the entries inside are linked list included the allocated and unallocated entries perhaps you can write a faster version over heap allocator if you had a second link list of only the ones which were actually free so you basically have what's called a free list maybe you could efficiently find an entry based on the size so perhaps you want to handle small allocations like a hundred and twenty eight bites very different form say four thousand bytes or a megabyte so maybe you want to partition up your memory into different parts	memory	511
all of the entries inside are linked list included the allocated and unallocated entries perhaps you can write a faster version over heap allocator if you had a second link list of only the ones which were actually free so you basically have what's called a free list maybe you could efficiently find an entry based on the size so perhaps you want to handle small allocations like a hundred and twenty eight bites very different form say four thousand bytes or a megabyte so maybe you want to partition up your memory into different parts	a megabyte	461
then we've got the overhead of how we recycle blocks so are you do you need to do in order n search is it order order order one perhaps you don't want to do this until you've got a lot of fragments or only do it up on demand so this is a tradeoff esta how many cycles you want to spend trying to kind of recycle and ublock coalesce sing versus perhaps you want to be able to see inside a separate thread	block	46
then we've got the overhead of how we recycle blocks so are you do you need to do in order n search is it order order order one perhaps you don't want to do this until you've got a lot of fragments or only do it up on demand so this is a tradeoff esta how many cycles you want to spend trying to kind of recycle and ublock coalesce sing versus perhaps you want to be able to see inside a separate thread	thread	397
and then the last thing which of course is always important is how well do we actually utilize our memory have led to a lot of wasted space do we have space fragmented into lots of different areas in memory or perhaps worse fragmented into lots of tiny tiny shards of wasted of sort of very very small allocations which we could make but there's no way we could satisfy larger allocations without having to go back to the kernel	memory	99
and maybe when we do go back to the kernel do we ask for just a small amount or a very large amount of memory so that we don't have to keep came back saying hey please colonel can i have another sixteen bytes so that's just some ideas there are other algorithms which have not talked about which you can find online	memory	103
but let's not go down there instead let's actually think about kind of one possibility ok so the story so far i've got myself an inode remember that i inodes themselves or fixed size say one hundred and twenty eight bytes or so we don't have much space on them so definitely we want to store the meta information on it like say when this file was created or modified etc but then we actually want to say ok but if you actually want the bytes of this cat picture i bet it can tell you where to load them so if my content of cat dot jpeg is on disk block kind of three seven fifty nine etc i need to store these numbers somewhere ok so our first idea then is to say look for very small files why don't i actually store the actual disk block numbers so say three	block	547
ten direct disk blocks ok so providing my file is not too big right so what does it mean to be too big right so how big is each disk block well is dis block remember we said it's going to be four kb ok so for files which	block	16
instead it passes the buck and says well if you actually want to read the fourth thousands the ninety seventh byte or higher i'm not going to tell you but i know someone who can why don't you go to this particular dis block let's say on disk this happens to be a some arbitrary location like say this block number one hundred thirty seven go and read that and from that you can find out where the contents of the fourth thousand and ninety seventh byte is so for these larger files the beginnings of the file you can still access immediately right you still know exactly where to go on the disk right we can get these straight away but as you progress into the file you're going to have to work a little bit harder so after forty kilobytes this is what you're going to have to do you read one extra disk block so you're going to go back to the disk and say hey i need four kb please and this will tell you where the next set of disk blocks are ok so they will be somewhat on the disk and where on disk will be stored inside this little table so let's talk about this little table	block	218
if my disk block numbers can be represented using four bytes	block	11
entries that i can store inside of this block so this diagram is very very incomplete there's actually many many many many more of these so there's a thousand and twenty four so called indirect blocks and they are called indirect blocks because i had to load this indirect table i had a performance hit whilst i	block	40
so now we can actually read the next quantity of one thousand and twenty four so wonderful great now i can start working with much larger files like i'm going to repeat myself again the first forty kilobytes of every file does matter is small or large we don't need to play this trick ok that we get this directly from the inode but for the forty first bite we can workout that i should go to the very first entry inside my indirect block table so i need to load this block and then follow the first entry and great i've now got myself another four kb	block	433
as i keep reading the file i'm going to workout which entries inside here i need to go to and each time will give you another disk block number to read from disk and i can keep reading the next four kb again for performance hopefully these are next door neighbors but they don't have to be they in fact it could be anywhere on the disk right so that's pretty good how big a file can we actually represent with this system so if my indirect table here is full	block	131
as i keep reading the file i'm going to workout which entries inside here i need to go to and each time will give you another disk block number to read from disk and i can keep reading the next four kb again for performance hopefully these are next door neighbors but they don't have to be they in fact it could be anywhere on the disk right so that's pretty good how big a file can we actually represent with this system so if my indirect table here is full	system	415
in other words my indirect blocks can hold four megabytes worth of information so this scheme will work providing i don't exceed four megabytes plus my direct blocks which i said there's ten of them so i've got forty kb ok that should be big enough for everybody i can't imagine why anybody would want to store more information than that except when they do so what happens when we have files even larger than that well for these now huge files the initial part of the file again is stored as direct inside direct blocks the thinking being is quite often you would just want fast access to the beginning of the file after that we'll use this in director scheme but after that after we've exceeded this limit that we've just calculated we're going to play a new trick so now there's another entry inside the inode which says you know what i can't tell you where the next bite is going to be stored but i know someone that knows someone about where to go so great we read a disc lock off four kilobyte read here and again we have a little table thousand and twenty four entries inside it	block	27
but those entries themselves are not the answer and look this we're doing a second look up so we have to go back to our disk to read another little table and so this is a lot like kind of the page table tricks that we saw with virtual memory and finally this gives us the actual disk block that will actually hold the data so finally we can meet the next four kilobytes of data ok so how much can we store with this double indirection scheme here ok so	memory	235
but those entries themselves are not the answer and look this we're doing a second look up so we have to go back to our disk to read another little table and so this is a lot like kind of the page table tricks that we saw with virtual memory and finally this gives us the actual disk block that will actually hold the data so finally we can meet the next four kilobytes of data ok so how much can we store with this double indirection scheme here ok so	block	284
so for my double indirect blocks i've actually got	block	26
i need to be able to do math to say why is it less than four kilobytes in which case which one of these disk blocks is it direct blocks is it in the next range in which case which one of these thousand and twenty four entries do i need to read ok and therefore where inside a particular this block do i need to read and what's the offset inside that particular block and finally if it's using this double indirect trick i need to read one table block and then a second one as well before i can finally find out where the actual data is stored ok are we done well actually it turns out there are triple indirect blocks as well but after that we stop so actually there's one more entry inside here there we go i'll just write it now but the last entry here gives me a data block but sorry i block a table which doesn't give me the answer i had to use that to read one of one thousand and twenty four entries that doesn't give me the answer either and that itself gives me another block over thousand twenty four and that finally will actually lead me to the real data so one way we could have taken a static picture here i want you to imagine how as you were making a larger larger file how this might actually fill up kind of initially we're just working on this very first this block as we make our file greater than four kb now we start writing bytes into this disk block as we keep going we need to find a new disk block which is available so we started writing bytes in there and so on and so on and so on and keep doing for the first forty kb and then what happens well now we need to find	block	109
a indirect table so we find space on disk for that and then we start writing our data into the boat first indirect block here once that's filled up after four kb we need a second one of course will update our little table and we can keep playing this trick for thousand twenty four times and then we start making work as we kind of create these double indirect blocks and	block	115
you can see how there is some overhead here that have all of these blocks which don't actually hold any data over any cats or any other actually useful content but the good thing about this scheme is that access to the beginning of the file is very very fast and i only pay for the overhead of all of these additional blocks for very large files so that's the inode addressing scheme i imagine that will have an assignment kind of based on this where you actually kind of can implement this scheme in order to read or write some exist some files onto an actual file system with us it i'll see in the next video bye	block	67
you can see how there is some overhead here that have all of these blocks which don't actually hold any data over any cats or any other actually useful content but the good thing about this scheme is that access to the beginning of the file is very very fast and i only pay for the overhead of all of these additional blocks for very large files so that's the inode addressing scheme i imagine that will have an assignment kind of based on this where you actually kind of can implement this scheme in order to read or write some exist some files onto an actual file system with us it i'll see in the next video bye	address	366
you can see how there is some overhead here that have all of these blocks which don't actually hold any data over any cats or any other actually useful content but the good thing about this scheme is that access to the beginning of the file is very very fast and i only pay for the overhead of all of these additional blocks for very large files so that's the inode addressing scheme i imagine that will have an assignment kind of based on this where you actually kind of can implement this scheme in order to read or write some exist some files onto an actual file system with us it i'll see in the next video bye	system	566
ok so let's stop thinking about implementing the c library and instead get the stack and instead think about actually working with real data now you could store a whole lot of data using scan f and printf etc but what about the day that you decide to work with binary data ok so with binary data there's lots of advantages the most ones being that it's quicker to read in and also it takes up less space	printf	198
right so here's my plan then my data structure is going to be very simple all i care about is the number of points ok so let's in my program have a variable a global variable which is the number of points loaded and then for each point i'm going to have one of these structs which is really just three floating point values ok so i have a pointer here called points to my three d points so it's going to point two	a struct	35
right so here's my plan then my data structure is going to be very simple all i care about is the number of points ok so let's in my program have a variable a global variable which is the number of points loaded and then for each point i'm going to have one of these structs which is really just three floating point values ok so i have a pointer here called points to my three d points so it's going to point two	pointer	339
the variable name here or i could give you the type of just int	type	47
and that will evaluate to save four bytes on this particular system and please read just one of these integers ok and please read it from this file that we've just opened ok and of course we're skipping any error checking for brevity him so once that completes i now know how many files are going to load from this file so great	system	61
put aside some memory so let me get some heap memory hey calloc give me and then how much memory do i need well i'm going to read number of points and the size of each point is the size of my struct here done fantastic see how easy that was compared to messing around with scanf and trying to read floating point numbers i'm going to directly just work with these points so now i've got my memory again i can use fread directly so hey fread please read into the following location	the following	458
put aside some memory so let me get some heap memory hey calloc give me and then how much memory do i need well i'm going to read number of points and the size of each point is the size of my struct here done fantastic see how easy that was compared to messing around with scanf and trying to read floating point numbers i'm going to directly just work with these points so now i've got my memory again i can use fread directly so hey fread please read into the following location	heap memory	41
put aside some memory so let me get some heap memory hey calloc give me and then how much memory do i need well i'm going to read number of points and the size of each point is the size of my struct here done fantastic see how easy that was compared to messing around with scanf and trying to read floating point numbers i'm going to directly just work with these points so now i've got my memory again i can use fread directly so hey fread please read into the following location	memory	15
so i don't want the address of my variable now because my points variable actually points to some heat memory	memory	103
so i don't want the address of my variable now because my points variable actually points to some heat memory	address	20
and how much memory do i want well again just like calloc i'm going to say the size of each entry	memory	13
ok great so if we did this and if we work similar code for saving the place as well now i can very quickly read in my lighter data or my other three d data and now now start working with all of these three d points fantastic ok if i truly wanted to write some very quick fast code without any error checking this might be the code i worked right today however we have some problems so let's start talking about how things can go wrong ok so the first problem is that my code is actually not very portable at all i've made some big assumptions let's talk about some of the assumptions that i'd made in writing this code so the first assumption was that whenever i read or write my data that my integer representation is always going to be the same number of bytes and also always use the same representation in other words we are	code	50
just assuming that the data representation for one machine to the next day it's gonna stay the same because when we read in the number of points here we just going to directly read the bit pattern we're going to read those four bytes or whatever it is directly into my variable and so that is a big assumption we've assumed that when i compile this tomorrow on yet another machine the number of bytes has stayed the same that my integers aren't say suddenly eight bytes wide or two bites and the actual bit patterns to represent those numbers stays the same that's a very dangerous assumption today so it turns out that cpus can choose to store their integers using different representations just as obvious one is should you store the high bite or the low byte first which one would you like to put into the very first of those four bytes for example that hold your entity value and the way that intel does it can be different from say the way that a power pc cpu can do it so we haven't addressed any of those representation problems second we just mentioned that it can be	address	989
type ok to ensure that at least we always going to be working with four bytes another problem with our choice of	type	0
so yeah let's let's use a an unsigned type here ok what else we got going on right again we've assumed that the floating point representation of our numbers is always going to be the same that's not necessarily true it's a good bet because most machines will use the standard ieee representation of afloat but it's not actually guaranteed so again we've got these concerns about just arbitrarily saying that the representation of our data on disk is exactly the same as the reputation of my numbers on this particular machine	type	38
ok so better code would actually check that would actually check that we successfully read that number of items and then do some error handling in the case that it doesn't so for example if we didn't actually successfully managed to read one item into here then we can't even trust that none points is correct maybe if we didn't manage to read non points in our second second call maybe we should truncate the number of points that are going to deal with down to the number of points that we successfully managed to read or maybe we should just exit with an error ok so as you can see reading writing binary data is not as trivial as it first appears and it's important to kind of if we actually really want to write something which is cross platform is important for us to actually specify the exactly	code	13
how we're going to use each and every bite of our binary format right so we've talked about some of the useful things and also some of the difficulties of using a reading writing binary data but the day that you do that and the day that you want to start to read away cross platform code remember that you have f read and f right at your disposal to be able to easily read and write binary data i mean easily read and write bytes to inform disk	code	283
ok right in the next video we are going to talk about the following challenge can you read in half a file so try pausing the video and just using what you currently know see if you could write code that just reads in	the following	54
ok right in the next video we are going to talk about the following challenge can you read in half a file so try pausing the video and just using what you currently know see if you could write code that just reads in	code	193
0 to mean it succeeded ok so if that is zero then great we know that the memory structure actually has some valid values right and how can i determine if it's a regular file or directory or something else ok so that information is stored in the bit patterns of the mode bits so we could start pulling out the specific bits if we happen to know for example that i should mask it with just one binary number so let's say say sixty four hundred and twenty eight then i can read the value of a single binary digit but instead rather than hardcoding that and doing a bitwise and let's chop that out there's some macros that do this for me so i can delete all that an instead these macros turn it off ok look a bit like this s for stat and then i've got one calledis there right so that will return a non zero value if we are looking at a directory ok what else is there right let's go and take a look alright surpass suppose you want to know if it's a regular file so there we go we'll pass in again our mode bits and that will return a non zero value if m was a regular file	memory	73
you probably won't need is a character device or block device if you've made a named pipe perhaps by calling make fifo for example then these kinds of pipes actually	block	49
exist on your file system they have file names so this would be a way to actually check to see whether that filename corresponds to one of these pipes and lastly here's a useful one is something a symbolic link there's a big gotcha with this one or big secret about having to use it correctly so we'll talk about that a little bit	system	19
ok so let's go actually look at some code that does this all right so here we go let's find that come back	code	37
here we go so we can always print out an error number to see what happened otherwise great we now know that we actually have some information inside our little struct so let's see if it's a directory ok so let's run this so i see is clang and called his dirt right so now we will run it and we can say ok what about the current directory so yes it's a directory ok what about there we have some other files in here ok before we got suba subb so let's try those what about suba ok that's a directory what about say this file is d i r dot c like no that is not a directory so great now we can tell whether things are directories or not so that is going to be useful say if we want to write something recursive for example suppose we wanted to write our own version of chamod to recursively change everything from c code then we could quickly use stat to see whether something is a directory or not and the last thing we should try let's give it a fictitious file doesn't exist so no	code	813
starting from the current directory and it will list me everything there but i can do a lot more with find i can say things like find me things with a certain modification time or find me things which are a certain type so for example only display things which are type directory or only display things which type of a regular file	type	215
or find me things which have the name or a case insensitive name say that has the word ok let's try say anything with python ok so find is a kind of swiss army knife of abilities to kinda find matching files and it searches recursively so let's think about how we might kind of write that ok so this is my first attempt but maybe there's some problems with it and that's where you come in we're trying to figure out where we can how we can fix this ok why is this not gonna work ok you'll see that i'm using sprintf waste sprintf works is bit like printf except that rather than printing something else it's going to write the result into this memory location so hey let's get some memory and we'll print into that so what do you think of all this code it's obviously some mistakes in it	memory	644
or find me things which have the name or a case insensitive name say that has the word ok let's try say anything with python ok so find is a kind of swiss army knife of abilities to kinda find matching files and it searches recursively so let's think about how we might kind of write that ok so this is my first attempt but maybe there's some problems with it and that's where you come in we're trying to figure out where we can how we can fix this ok why is this not gonna work ok you'll see that i'm using sprintf waste sprintf works is bit like printf except that rather than printing something else it's going to write the result into this memory location so hey let's get some memory and we'll print into that so what do you think of all this code it's obviously some mistakes in it	code	748
or find me things which have the name or a case insensitive name say that has the word ok let's try say anything with python ok so find is a kind of swiss army knife of abilities to kinda find matching files and it searches recursively so let's think about how we might kind of write that ok so this is my first attempt but maybe there's some problems with it and that's where you come in we're trying to figure out where we can how we can fix this ok why is this not gonna work ok you'll see that i'm using sprintf waste sprintf works is bit like printf except that rather than printing something else it's going to write the result into this memory location so hey let's get some memory and we'll print into that so what do you think of all this code it's obviously some mistakes in it	printf	509
hey welcome to lecture thirty six so in this lecture we get that start talking about protocols and handshaking so the protocols we're going to look at are going to be tcp protocols and a little bit beyond will look at http as well right so remember tcp is transmission control portable it allows us to hide the fact that we are sending packets and so to the application it just looks like a stream a pipe that we can push bites into anas bites will appear out the other side right so let's have a look at some of the protocol magic with actually supports that first of all we know that when we start making a tcp connection we first initiate one the handshaking needs to occur meaning that we're going to send a few packets backwards and forwards just to initialize that connection and in fact this is often known as the since in ach ag pattern right so there's three packets we've got to talk about where first of all the client sends a	the protocol	114
network resources ok right and just for reference like i said this is going too far from what we really need inside cs two forty one but if you truly wanted to construct your own raw packets from first principles you can see the reference for for which bit you would need to set for the tcp packets to say alright yes this is a synchronization packet or for example if it's a very last packet to say you know what i'm done talking to you this is the last thing i'm going to say here's the finished packet here's the finished bit here as well	resources	8
so that's why it's initial values random it's a security measure and in fact if you read a lot of the tcp spec and see how it's evolved overtime it's a protocol that does best efforts to try to prevent malicious actors from either preventing delivery of packets or masquerading as as the other end we're not going to go into all those details but understand the tcp makes best efforts but it's not perfect and actually we have continued to find vulnerabilities inside tcp over over many decades alright so that's enough for this video except for one little last question we saw the tcp header and here it is but where's the ip address what happened to that we've only got the port information why is the ip address missing here so to answer that realize that we've actually to see real packets we've actually got two protocols wrapped up as one that this is the tcp header but on a real packet we're going to have the ip address in front of it so we actually have protocols wrapped up inside other protocols a real packet would have ip information so for example if it's ip for we would have a thirty two bit source ip at a thirty two bit by my packets are thirty two bits wide i should win for the full length ok i would have like the source and target in here ok so so is the source and destination ip for ip six of course there are many more bits so my source ip four which is why network engineers don't tend to say it's a tcp packet will send to say things like it's a tcp slash ip packet which is more technically correct because the whole packet that arrives my machine has his ip header in front of it that's it for this little video in the exact next video this took about how tcp can go wrong let's talk about some basic ideas about denial of service by	a protocol	150
so that's why it's initial values random it's a security measure and in fact if you read a lot of the tcp spec and see how it's evolved overtime it's a protocol that does best efforts to try to prevent malicious actors from either preventing delivery of packets or masquerading as as the other end we're not going to go into all those details but understand the tcp makes best efforts but it's not perfect and actually we have continued to find vulnerabilities inside tcp over over many decades alright so that's enough for this video except for one little last question we saw the tcp header and here it is but where's the ip address what happened to that we've only got the port information why is the ip address missing here so to answer that realize that we've actually to see real packets we've actually got two protocols wrapped up as one that this is the tcp header but on a real packet we're going to have the ip address in front of it so we actually have protocols wrapped up inside other protocols a real packet would have ip information so for example if it's ip for we would have a thirty two bit source ip at a thirty two bit by my packets are thirty two bits wide i should win for the full length ok i would have like the source and target in here ok so so is the source and destination ip for ip six of course there are many more bits so my source ip four which is why network engineers don't tend to say it's a tcp packet will send to say things like it's a tcp slash ip packet which is more technically correct because the whole packet that arrives my machine has his ip header in front of it that's it for this little video in the exact next video this took about how tcp can go wrong let's talk about some basic ideas about denial of service by	address	627
different clients and servers and it's easier to debug the actual connections which are happening over i'll tcp or udp connection and it's easier to write a specification which uses a simple text based protocol so for example if you want to get a web resource today you would make a connection to a server and you'd say hey server can you get me the following so let me get resource so if i just care about the home page then that is just slash if for example i want a particular subreddit page	the following	346
would actually have to write code to cope with the fact that packets might go missing but this is useful if you want for example to provide an interactive feedback as soon as the user starts typing something into the search part you want to be able to display immediately some potential results so that sounds to me like udp might be a great course so if you're prepared to employ a lots of great system programmers from say from illinois then if you don't mind that expense then udp gives you a lower latency response and besides if you're doing this just for incremental search is you don't care anyway if you drop a packet because in a moment the user is going to be typing another character anyway and so you can reissue a new search based on that new information right but most packets today for http are using tcp	code	29
would actually have to write code to cope with the fact that packets might go missing but this is useful if you want for example to provide an interactive feedback as soon as the user starts typing something into the search part you want to be able to display immediately some potential results so that sounds to me like udp might be a great course so if you're prepared to employ a lots of great system programmers from say from illinois then if you don't mind that expense then udp gives you a lower latency response and besides if you're doing this just for incremental search is you don't care anyway if you drop a packet because in a moment the user is going to be typing another character anyway and so you can reissue a new search based on that new information right but most packets today for http are using tcp	system	397
ok so that's a very short introduction to http we wrote in fact our very first piece of http right here where we request a picture of a cat and will be seeing more examples of this in the future but for now let's actually stop talking about conceptual stuff actually let's actually now make our own http so our own client inside some c code so let's actually start looking to see what network code looks like for real ok bye	code	336
with only zero or few modifications on your linux system my linux system maybe a bsd like mac as well right the other thing i noticed about scripts is that to give a hint to the kernel that it is actually just a script is that they have this two magic characters at the beginning the hashtag or pound is also called and exclamation point right so	system	50
and let's have kind of brief look at this script that so it's written in the bash syntax and we have variables inside of bash script we can talk about the arguments given to this so if i wanted to specify say an argument to this it's going to appear inside dollar one it's quite standard actually to see variables and arguments like this with lots of quotes around them all the time in order to ensure that things work with spaces as well so kind of later on you'll see here that hey we've got when we want to actually use this variable and variables always start with the dollar we've put double quotes about it just in case of spaces in there right so we've got is this variable you have nothing ok notice actually lots of spaces in here are important that if here is actually a token understood by bash but if we had no space it wouldn't see that as a single token right similarly the double square brackets is actually another kind of complete token also notice that there's a little semi colon are hiding in here which is critical to be able to say this is a little expression or program we want to run and we care about is that exit value and of course by default zero means success right so if will print out little usage string if something worked or failed so	string	1229
something to my device here ok there we go because slash dev is a virtual file system and slash dev slash null has an amazing amount of compression you can put as many files you can copy as much output you want to this file and it doesn't take any space it is the wastepaper basket of our file system so what we're saying is look you might generate a message because a loadout doesn't exist that error message i don't care i don't want to see that error message so i'm just going to send it to that circular wastepaper basket right then will compile i think of my real program i change this to hell for example and then i want to change the ownership of that program to say potato bob right and lastly let's run ls so that's the kind of useful little script it's useful when you want to write bits of bash we can do a lot more with bash we can tell it for example to quit as soon as an error we can tell it to print out one line at a time but i just want to appreciate the things you do	system	79
in a shell you can script as well however this is kind of these scripts are fairly fragile and as soon as you want to do anything more complicated i would definitely encourage you to use something else like node or python for example or rust or c or some other language which is not bash or shell right so the next video let's go return to making directories and symbolic links in code i'll see you then bye	a shell	3
in a shell you can script as well however this is kind of these scripts are fairly fragile and as soon as you want to do anything more complicated i would definitely encourage you to use something else like node or python for example or rust or c or some other language which is not bash or shell right so the next video let's go return to making directories and symbolic links in code i'll see you then bye	code	381
ok hi right so let's think about lock contention and also how this also relates to discovering race conditions ok so here's the scenario that we're going to think about that i've got a thread that most of the time is not inside the critical section and in fact if we sketch this out you'll see that initially i just got one single thread and only for a short period of time just one millisecond it's actually doing something inside a critical section that we haven't yet protected with any mutex locks but for the other nine hundred and ninety nine milliseconds	a thread	183
ok hi right so let's think about lock contention and also how this also relates to discovering race conditions ok so here's the scenario that we're going to think about that i've got a thread that most of the time is not inside the critical section and in fact if we sketch this out you'll see that initially i just got one single thread and only for a short period of time just one millisecond it's actually doing something inside a critical section that we haven't yet protected with any mutex locks but for the other nine hundred and ninety nine milliseconds	section	241
ok hi right so let's think about lock contention and also how this also relates to discovering race conditions ok so here's the scenario that we're going to think about that i've got a thread that most of the time is not inside the critical section and in fact if we sketch this out you'll see that initially i just got one single thread and only for a short period of time just one millisecond it's actually doing something inside a critical section that we haven't yet protected with any mutex locks but for the other nine hundred and ninety nine milliseconds	thread	185
is doing something else so this thing runs for one second and then it's some random type there's one second ok some random sign inside that just for one day second it goes and visits a critical section may be updates or reads a particular data structure ok so now that's fine but now we have two threads so here's another fit that also is going to run for the same second	type	84
is doing something else so this thing runs for one second and then it's some random type there's one second ok some random sign inside that just for one day second it goes and visits a critical section may be updates or reads a particular data structure ok so now that's fine but now we have two threads so here's another fit that also is going to run for the same second	a struct	242
is doing something else so this thing runs for one second and then it's some random type there's one second ok some random sign inside that just for one day second it goes and visits a critical section may be updates or reads a particular data structure ok so now that's fine but now we have two threads so here's another fit that also is going to run for the same second	section	194
is doing something else so this thing runs for one second and then it's some random type there's one second ok some random sign inside that just for one day second it goes and visits a critical section may be updates or reads a particular data structure ok so now that's fine but now we have two threads so here's another fit that also is going to run for the same second	thread	296
there we go and inside this it also might visit the critical section	section	61
ok of time where is ashley inside the the critical section so as we know everything will find our programs deterministic our program or function as expected provided these two don't meet another words providing they don't actually overlap right so could we estimate this will sure we could set up a full integral and think about how we think about these two random times as a whole bunch of times where they don't overlap and then there's times when they start overlap fully overlap and then only overlap a little bit again and then other times when we don't so we could set it up to set this up as a as a two dimensional integral but we just want to estimate this today so we're not going to worry about things like edge effects where where the very first thread goes into the critical section at the very end so it's not possible to overlap full or very visits critical section at the very end where it's not possible to overlap afterwards so let's not worry about that let's just concentrate on the idea that ninety nine point nine percent of the time my first date is not inside the critical section so we're going to look at the majority case an ignore the edge cases so right i thought and playing battleships with you now so i've thought of one moment in time where it is inside the critical section now you get to think of a number where you get to say ok right i'm going to choose my second thread to be inside this critical section what's the chances that we sunk the battleship what's the chances that they've overlapped	section	51
ok of time where is ashley inside the the critical section so as we know everything will find our programs deterministic our program or function as expected provided these two don't meet another words providing they don't actually overlap right so could we estimate this will sure we could set up a full integral and think about how we think about these two random times as a whole bunch of times where they don't overlap and then there's times when they start overlap fully overlap and then only overlap a little bit again and then other times when we don't so we could set it up to set this up as a as a two dimensional integral but we just want to estimate this today so we're not going to worry about things like edge effects where where the very first thread goes into the critical section at the very end so it's not possible to overlap full or very visits critical section at the very end where it's not possible to overlap afterwards so let's not worry about that let's just concentrate on the idea that ninety nine point nine percent of the time my first date is not inside the critical section so we're going to look at the majority case an ignore the edge cases so right i thought and playing battleships with you now so i've thought of one moment in time where it is inside the critical section now you get to think of a number where you get to say ok right i'm going to choose my second thread to be inside this critical section what's the chances that we sunk the battleship what's the chances that they've overlapped	thread	757
ok right so how can we analyze this i've got a one millisecond air slot here so there is actually a window of just two milliseconds where your choose a different color let's go for say loop again where your timing of your thread might overlap my critical window ok so we might be exactly the same or we might be just afterwards	thread	222
or percentage wise that is a very small number so we've got right so we were point two percent chance of this occurring right so that sounds actually pretty good or pretty bad depending on whether you truly want to try to discover this problem or you're hoping that your code works so even though we know that we gotta race condition even though we know we didn't actually implement the locks we have a problem here which is a two percent chance that all code will fail	code	271
because two threads of enter the critical section at the same time right so if we test our code once twice three times ten times as are very strong chance that we won't notice this effect we've only going to see this one time out of five hundred approximately like i said we didn't do the exact integral but this means that actually make race conditions to occur can be quite hard now we went for figures that said	code	91
because two threads of enter the critical section at the same time right so if we test our code once twice three times ten times as are very strong chance that we won't notice this effect we've only going to see this one time out of five hundred approximately like i said we didn't do the exact integral but this means that actually make race conditions to occur can be quite hard now we went for figures that said	section	42
because two threads of enter the critical section at the same time right so if we test our code once twice three times ten times as are very strong chance that we won't notice this effect we've only going to see this one time out of five hundred approximately like i said we didn't do the exact integral but this means that actually make race conditions to occur can be quite hard now we went for figures that said	thread	12
the race the critical section one millisecond dirt to run if you're critical section was much smaller than that for example in the code that we've just looked at with the push in the pop or adding another part that might only be orders of say ten microseconds so now the chances of that of of threads being inside a critical section is actually slimmer so discovering problems just by testing is hard and that is why we do things like locate don't want it with two threads but when it with four threads now it's much more likely to occur or test it with a brute force loop trying to go into the critical section as often as possible and now you've increased the chances significantly this also applies to the idea	code	131
the race the critical section one millisecond dirt to run if you're critical section was much smaller than that for example in the code that we've just looked at with the push in the pop or adding another part that might only be orders of say ten microseconds so now the chances of that of of threads being inside a critical section is actually slimmer so discovering problems just by testing is hard and that is why we do things like locate don't want it with two threads but when it with four threads now it's much more likely to occur or test it with a brute force loop trying to go into the critical section as often as possible and now you've increased the chances significantly this also applies to the idea	section	22
the race the critical section one millisecond dirt to run if you're critical section was much smaller than that for example in the code that we've just looked at with the push in the pop or adding another part that might only be orders of say ten microseconds so now the chances of that of of threads being inside a critical section is actually slimmer so discovering problems just by testing is hard and that is why we do things like locate don't want it with two threads but when it with four threads now it's much more likely to occur or test it with a brute force loop trying to go into the critical section as often as possible and now you've increased the chances significantly this also applies to the idea	thread	293
of lock contention so lock contention is not a good thing it means that one thread is being forced to wait for another now we did this because we want to programs to function correctly	thread	76
and unnecessary performance impact so right now we saw with our little rough back of the envelope calculation calculation there was only one point two percent chance of the two threads asking for the lock at the	thread	177
so one one of the thousand basically so we don't expect the see significant performance impact because of two threads updating this however if our code was different if we had threads which say wanted to update the data structure ten milliseconds out of one hundred million seconds so now there's a one in ten chance that the lock that we asked for is is already in use	the data structure	211
so one one of the thousand basically so we don't expect the see significant performance impact because of two threads updating this however if our code was different if we had threads which say wanted to update the data structure ten milliseconds out of one hundred million seconds so now there's a one in ten chance that the lock that we asked for is is already in use	a struct	218
so one one of the thousand basically so we don't expect the see significant performance impact because of two threads updating this however if our code was different if we had threads which say wanted to update the data structure ten milliseconds out of one hundred million seconds so now there's a one in ten chance that the lock that we asked for is is already in use	code	147
so one one of the thousand basically so we don't expect the see significant performance impact because of two threads updating this however if our code was different if we had threads which say wanted to update the data structure ten milliseconds out of one hundred million seconds so now there's a one in ten chance that the lock that we asked for is is already in use	thread	110
we don't want lock attention but on the other hand we want to be able to discover our race conditions as soon as possible for me during our testing before we put it into production before we start relying on this code to save lives or to move money or to give demos etc so so race conditions are tricky is the big takeaway message and you could do back of the envelope calculation to see why it's difficult to detect these	code	213
ok right so with that in mind that means that our debugging skills are understanding of how code can interleave	code	92
can is important are believed to actually reason about our code is just as important as being up to test	code	59
test it ok so here's here's the code we've got i'd like you to kind of look at this code and tell me what do you think it's going to do right so i've got i've got a couple of threads in a mutex as global variables up here ok	code	32
test it ok so here's here's the code we've got i'd like you to kind of look at this code and tell me what do you think it's going to do right so i've got i've got a couple of threads in a mutex as global variables up here ok	a mutex	186
test it ok so here's here's the code we've got i'd like you to kind of look at this code and tell me what do you think it's going to do right so i've got i've got a couple of threads in a mutex as global variables up here ok	thread	175
right and i've got a public counter global variable you can see i'm incrementing it inside this function and each thread that i'm going to create down here inside my main is going to run this code for a million times right so with that in mind what do you think it's going to do it i will tell you the answer that in the next lecture but why don't you pause this right now and make your prediction by	code	192
right and i've got a public counter global variable you can see i'm incrementing it inside this function and each thread that i'm going to create down here inside my main is going to run this code for a million times right so with that in mind what do you think it's going to do it i will tell you the answer that in the next lecture but why don't you pause this right now and make your prediction by	thread	114
so a datagram is just a fancy word for a packet you can think of it like a telegram so user ground data critical " the key characteristics of this protocol is that it is connectionless just like a telegram you can say oh i want to send it to this ip address and on this port and you can fire it off and off it goes so let's create our little message and send it and let it fly away right so we're not going to track it we don't get a notification when it gets there there's no there's no protocol to set up in terms of say bring them up first and the querying that we're going to send this message now we simply fire off this packet	address	250
if we're on a very high bandwidth connection tcp will ramp up the speed at which it sends information if you want a very low low bandwidth connection tcp will not attempt to send gigabytes of information per second there are tunable different parameters inside this but the the cool idea is that tcp does this for us ok that ultimately because it's a connection based it behaves like a pipe in fact to be precise it is stream based	parameter	243
there is actually a way to make udp pretend to work with read and write but it's faking it is not really a stream based protocol which one requires more system sort resources i think you can guess this is also tcp our system needs to keep track of any packets that arrive early so you can imagine that we could have a buffer here which represents all of the data that's arriving and if i get a packet with this piece of information and then this piece of information i can't give that to the client program because i'm still waiting for this part of the stream to arrive and maybe it's late simply because that packet is taking a long way long way round to get to us or maybe that packet got lost either way the kernel has to keep track of how much of the stream has arrived so far and which parts are currently missing	resources	165
there is actually a way to make udp pretend to work with read and write but it's faking it is not really a stream based protocol which one requires more system sort resources i think you can guess this is also tcp our system needs to keep track of any packets that arrive early so you can imagine that we could have a buffer here which represents all of the data that's arriving and if i get a packet with this piece of information and then this piece of information i can't give that to the client program because i'm still waiting for this part of the stream to arrive and maybe it's late simply because that packet is taking a long way long way round to get to us or maybe that packet got lost either way the kernel has to keep track of how much of the stream has arrived so far and which parts are currently missing	system	153
ok which one uses handshaking ok we see that tcp uses a handshake mechanism so part of the protocol is to "actually initialize this connection initialize the stream and so there's a handshake that needs to occur when we first connect the client to the server	the protocol	87
then we would choose udp ourselves and say ok we're going to have to write our own code to accept the fact that udp packet may never arrive	code	83
ok so let's figure out which of the following are correct and incorrect ok so so we've got a function called f one and wait what are we doing here so we've declared in all type of variable called blah and do i have a squiggly line helps about called blah and it's an array so the surprising thing here is that	the following	32
ok so let's figure out which of the following are correct and incorrect ok so so we've got a function called f one and wait what are we doing here so we've declared in all type of variable called blah and do i have a squiggly line helps about called blah and it's an array so the surprising thing here is that	type	172
as an array, the compiler actually write extra code force to copy in memory	memory	69
as an array, the compiler actually write extra code force to copy in memory	code	47
this constant this little string so if i was to pause my process i would actually discover the upon running f one there's a memory copy that happens i read from this read only memory that's part of my text segment the actual things i've loaded from disk and i've copied that into the stack so there's one two three four five or six six bytes including the zero bite that have been copied into the stack and blah if i asked him as an address as a pointer would actually be hey i'm beginning of the stack memory where you'll find this this h so as a as an array i cannot change blood to point to other things it is disarray but i can use it as if it's a pointer but the downside however is that in this code but i'm returning blah and i'm returning it as a pointer so great we will find out the address of blob but the contents of that address is no longer about it it was on the stack and that stack value that stagnant is only valid while we were inside f one so that's the kind of common error in beginner c programmers is to accidentally give addresses or variables that are no longer in scope and are no longer valid	memory	124
this constant this little string so if i was to pause my process i would actually discover the upon running f one there's a memory copy that happens i read from this read only memory that's part of my text segment the actual things i've loaded from disk and i've copied that into the stack so there's one two three four five or six six bytes including the zero bite that have been copied into the stack and blah if i asked him as an address as a pointer would actually be hey i'm beginning of the stack memory where you'll find this this h so as a as an array i cannot change blood to point to other things it is disarray but i can use it as if it's a pointer but the downside however is that in this code but i'm returning blah and i'm returning it as a pointer so great we will find out the address of blob but the contents of that address is no longer about it it was on the stack and that stack value that stagnant is only valid while we were inside f one so that's the kind of common error in beginner c programmers is to accidentally give addresses or variables that are no longer in scope and are no longer valid	code	701
this constant this little string so if i was to pause my process i would actually discover the upon running f one there's a memory copy that happens i read from this read only memory that's part of my text segment the actual things i've loaded from disk and i've copied that into the stack so there's one two three four five or six six bytes including the zero bite that have been copied into the stack and blah if i asked him as an address as a pointer would actually be hey i'm beginning of the stack memory where you'll find this this h so as a as an array i cannot change blood to point to other things it is disarray but i can use it as if it's a pointer but the downside however is that in this code but i'm returning blah and i'm returning it as a pointer so great we will find out the address of blob but the contents of that address is no longer about it it was on the stack and that stack value that stagnant is only valid while we were inside f one so that's the kind of common error in beginner c programmers is to accidentally give addresses or variables that are no longer in scope and are no longer valid	string	26
this constant this little string so if i was to pause my process i would actually discover the upon running f one there's a memory copy that happens i read from this read only memory that's part of my text segment the actual things i've loaded from disk and i've copied that into the stack so there's one two three four five or six six bytes including the zero bite that have been copied into the stack and blah if i asked him as an address as a pointer would actually be hey i'm beginning of the stack memory where you'll find this this h so as a as an array i cannot change blood to point to other things it is disarray but i can use it as if it's a pointer but the downside however is that in this code but i'm returning blah and i'm returning it as a pointer so great we will find out the address of blob but the contents of that address is no longer about it it was on the stack and that stack value that stagnant is only valid while we were inside f one so that's the kind of common error in beginner c programmers is to accidentally give addresses or variables that are no longer in scope and are no longer valid	address	433
this constant this little string so if i was to pause my process i would actually discover the upon running f one there's a memory copy that happens i read from this read only memory that's part of my text segment the actual things i've loaded from disk and i've copied that into the stack so there's one two three four five or six six bytes including the zero bite that have been copied into the stack and blah if i asked him as an address as a pointer would actually be hey i'm beginning of the stack memory where you'll find this this h so as a as an array i cannot change blood to point to other things it is disarray but i can use it as if it's a pointer but the downside however is that in this code but i'm returning blah and i'm returning it as a pointer so great we will find out the address of blob but the contents of that address is no longer about it it was on the stack and that stack value that stagnant is only valid while we were inside f one so that's the kind of common error in beginner c programmers is to accidentally give addresses or variables that are no longer in scope and are no longer valid	pointer	446
in the sense that foo itself is a pointer so there's no memory copying it going on here it's actually fruit holds the address of high	memory	56
in the sense that foo itself is a pointer so there's no memory copying it going on here it's actually fruit holds the address of high	address	118
in the sense that foo itself is a pointer so there's no memory copying it going on here it's actually fruit holds the address of high	pointer	34
and that will be the read only memory this part of our text segment so it's perfectly ok to return foo and in fact in this case we're returning the value of food we're just returning an address the address being	memory	31
and that will be the read only memory this part of our text segment so it's perfectly ok to return foo and in fact in this case we're returning the value of food we're just returning an address the address being	address	186
where in memory to find are readonly string so it will return the actual address of that that capital age what about f three so f three says ok let's call malloc and get ourselves two bites and store that address inside a variable according yo and we're now telling the compiler that this this	memory	9
where in memory to find are readonly string so it will return the actual address of that that capital age what about f three so f three says ok let's call malloc and get ourselves two bites and store that address inside a variable according yo and we're now telling the compiler that this this	string	37
where in memory to find are readonly string so it will return the actual address of that that capital age what about f three so f three says ok let's call malloc and get ourselves two bites and store that address inside a variable according yo and we're now telling the compiler that this this	address	73
now ok now we're breaking some rules here because they were passing this into a str cat and we might get a warning or error to say hey it looks like you're getting a variable but that is a constant so it it may or may not compile at that point but we got some other problems as well which is that we're actually passing a pointer to a string	string	335
now ok now we're breaking some rules here because they were passing this into a str cat and we might get a warning or error to say hey it looks like you're getting a variable but that is a constant so it it may or may not compile at that point but we got some other problems as well which is that we're actually passing a pointer to a string	pointer	322
and that string is at least three bites we've actually only got memory assigned for two bytes also recording str cat and what the store cat do it tries to concatenate the existing string with the string that we're giving it so what string is currently at yo the answer is who knows my luck makes no guarantee about the memory that you asked for it may or may not be initialized it may be initialized to zero but it doesn't have to	memory	64
and that string is at least three bites we've actually only got memory assigned for two bytes also recording str cat and what the store cat do it tries to concatenate the existing string with the string that we're giving it so what string is currently at yo the answer is who knows my luck makes no guarantee about the memory that you asked for it may or may not be initialized it may be initialized to zero but it doesn't have to	string	9
asked for two bites so this code is almost certainly guaranteed to overwrite some bites which may be being used for a different purpose ok so this code even if we can get it to compile will lead to undefined behavior exciting stuff right and in our last problem we're going to	code	28
figure out how can we do the following how can we make it so that i can actually change an existing variable the point to something else the answers of that will be in our next video bye	the following	25
in your spare time next time you're having drifting off to sleep chatting with friends and an algorithm or an idea pops into your head think about oh how would i apply what i'm learning inside cs two forty one to make that run faster to make it actually run concurrently so as a worked example remember some of the sorting algorithms you might have seen before like merge sort has suppose you wanted to make your merge sort run faster how would you implement that in parallel ok so kind of let's do this as a little worse example but again there my suggestion to you is is think about your css life and start thinking about well how can i use multiple threads to make this or how can i use multiple processes ok so remember how merge sort works we say if i've got say an array of data here	thread	652
ok so think of like to parcel cards so this number is smaller great i'll take this now we build the next number ok so now this number is not as small as the number might from my right hand pile so i'll take that and repeat and eventually we managed to merge these altogether and notice i relied on the recursion fairy to do most of the work so of course this happens at all levels so if i've started with nice big block of data say mb of data then first of all we call recursion ok and so on and so on and that has to be cursively run these ok so how can i now	block	414
and my calls here wouldn't be able to continue until say these two have completed and then i can start doing the merge simile this merge can happen once these two have finished so it's kind of fun to sketch out how you might actually implement this so how would you use condition way to how to use p threaded barrier to make your code run nice and fast	code	330
and my calls here wouldn't be able to continue until say these two have completed and then i can start doing the merge simile this merge can happen once these two have finished so it's kind of fun to sketch out how you might actually implement this so how would you use condition way to how to use p threaded barrier to make your code run nice and fast	thread	300
it's outside our castle but unable to cross the moat because we have blocked it on all of our process or all of the threads so if you wish you can check for a signal to see if it's pending like literally calling sick pending and that will fill in one of these signal sets for you so now great you can actually see if there's a say a sigint that is hasn't been processed someone press control c awhile ago and maybe you want to print out a useful message so that's what this little program does here let's check the actual see which bits are set inside my signal set here so once i grab that i can say ok is the following signal a member of this so will take the address of my pending result an see if cig and has been set inside there and if it is we will print a friendly message back to the user to say hey thanks for pressing ctrl c but is no cookies for you today right so let's	the following	607
it's outside our castle but unable to cross the moat because we have blocked it on all of our process or all of the threads so if you wish you can check for a signal to see if it's pending like literally calling sick pending and that will fill in one of these signal sets for you so now great you can actually see if there's a say a sigint that is hasn't been processed someone press control c awhile ago and maybe you want to print out a useful message so that's what this little program does here let's check the actual see which bits are set inside my signal set here so once i grab that i can say ok is the following signal a member of this so will take the address of my pending result an see if cig and has been set inside there and if it is we will print a friendly message back to the user to say hey thanks for pressing ctrl c but is no cookies for you today right so let's	block	69
it's outside our castle but unable to cross the moat because we have blocked it on all of our process or all of the threads so if you wish you can check for a signal to see if it's pending like literally calling sick pending and that will fill in one of these signal sets for you so now great you can actually see if there's a say a sigint that is hasn't been processed someone press control c awhile ago and maybe you want to print out a useful message so that's what this little program does here let's check the actual see which bits are set inside my signal set here so once i grab that i can say ok is the following signal a member of this so will take the address of my pending result an see if cig and has been set inside there and if it is we will print a friendly message back to the user to say hey thanks for pressing ctrl c but is no cookies for you today right so let's	thread	116
it's outside our castle but unable to cross the moat because we have blocked it on all of our process or all of the threads so if you wish you can check for a signal to see if it's pending like literally calling sick pending and that will fill in one of these signal sets for you so now great you can actually see if there's a say a sigint that is hasn't been processed someone press control c awhile ago and maybe you want to print out a useful message so that's what this little program does here let's check the actual see which bits are set inside my signal set here so once i grab that i can say ok is the following signal a member of this so will take the address of my pending result an see if cig and has been set inside there and if it is we will print a friendly message back to the user to say hey thanks for pressing ctrl c but is no cookies for you today right so let's	address	662
let's grab this code why don't we run it for fun like	code	16
ok i will just check to see if i got the code already so let's do grep will look for pending in all things ok yes so here it is is member right so	code	41
oh i can't type we want to run with her ok so it didn't print anything this time but now we can run our do not interrupt me let's run one heart ok and	type	11
hi so if you start reading through the p thread documentation	thread	41
you will come across something called p thread cancel great you say fantastic away from me to gracefully shut down my threads well yes and no my advice is don't use it unless you really understand what is doing there is often better ways to do it so p thread cancel looks like it's going to say excuse me thread i want you to stop and yes that is true but there's no guarantee on how fast and when that's going to happen so you might have a p thread that you've assigned to do a long calculation and even if you call peter cancel on that then the thread might continue to run deep inside some deeply nested for loops was do you say invert a massive matrix or mine your next bitcoin or something like that so there are better ways to do this and one common way to do this is to create a global variable for example	thread	40
and when you want your threats to finish then you just change this to one and you in your other threads you occasionally poll meaning you occasionally check the value of this variable and if it's been changed to a true value then you know it's time for your thread to exit at that point you can do your graceful things like freeing up resources and then exiting ok	thread	96
and when you want your threats to finish then you just change this to one and you in your other threads you occasionally poll meaning you occasionally check the value of this variable and if it's been changed to a true value then you know it's time for your thread to exit at that point you can do your graceful things like freeing up resources and then exiting ok	resources	335
this might be a global variable but you could also in more robust designs put it inside a struct and then passed out around as part of your information that you would pass to a thread that that is going so you could also have individual thread control as well	a struct	88
this might be a global variable but you could also in more robust designs put it inside a struct and then passed out around as part of your information that you would pass to a thread that that is going so you could also have individual thread control as well	a thread	175
this might be a global variable but you could also in more robust designs put it inside a struct and then passed out around as part of your information that you would pass to a thread that that is going so you could also have individual thread control as well	thread	177
ok so, right, the next thing is oh we talked about this yes we have differences between exit in p third exit ok so this stops the entire process and gives the processes at exit value pizza exit just stops this to one thread now is that thread happened to be the very last thread	thread	217
then the process will finish uh ok so that gives us a reason sometimes for calling p thread exit inside your main method is a way to be lazy let's let's go have a look at this so	thread	85
if i had a program that started many many threads are case so imagine	thread	42
started many many threads here i could write p thread join and wait for them all to finish i could put that inside a loop but an alternative is to say p thread exit are on the main thread right so now this return here will never happen	thread	18
will continue the process will continue until all of the other p three s have finished so that's going to lazy way of saying i just wanna start all these threads and i'm just done when the last one turns out the lights and shut the door ok so that's kind of a little trick that you'll see in kind of many smaller p thread programs right so of my next question to you is i've mentioned quite a few but can you think of four ways that a thread can be terminated right are you ready go	a thread	433
will continue the process will continue until all of the other p three s have finished so that's going to lazy way of saying i just wanna start all these threads and i'm just done when the last one turns out the lights and shut the door ok so that's kind of a little trick that you'll see in kind of many smaller p thread programs right so of my next question to you is i've mentioned quite a few but can you think of four ways that a thread can be terminated right are you ready go	thread	154
ok let's review this one what do you think the following code will print ok so	the following	43
ok let's review this one what do you think the following code will print ok so	code	57
how can we analyze this right so i've got a pizza it create an i'm storing somewhere the fed id 's and i'm going to say ok i want to thread that is going to start functioning and let's start function be and we're going to pass a void pointer the address of the string literals so the address of the capital a and address of the cadillacs to each one right so what will function be do function be then get this pointer and so we're giving it the address of xyz so when this runs and we're not quite sure when it will run it will print out xyz	string	261
how can we analyze this right so i've got a pizza it create an i'm storing somewhere the fed id 's and i'm going to say ok i want to thread that is going to start functioning and let's start function be and we're going to pass a void pointer the address of the string literals so the address of the capital a and address of the cadillacs to each one right so what will function be do function be then get this pointer and so we're giving it the address of xyz so when this runs and we're not quite sure when it will run it will print out xyz	thread	133
how can we analyze this right so i've got a pizza it create an i'm storing somewhere the fed id 's and i'm going to say ok i want to thread that is going to start functioning and let's start function be and we're going to pass a void pointer the address of the string literals so the address of the capital a and address of the cadillacs to each one right so what will function be do function be then get this pointer and so we're giving it the address of xyz so when this runs and we're not quite sure when it will run it will print out xyz	address	246
how can we analyze this right so i've got a pizza it create an i'm storing somewhere the fed id 's and i'm going to say ok i want to thread that is going to start functioning and let's start function be and we're going to pass a void pointer the address of the string literals so the address of the capital a and address of the cadillacs to each one right so what will function be do function be then get this pointer and so we're giving it the address of xyz so when this runs and we're not quite sure when it will run it will print out xyz	pointer	234
now what about function a so functionally when it runs let's see is given the address of abc ok but it doesn't do anything instead it just simply exits this thread and it returns an address so it takes the pointer that we gave it which was a pointer to the string in memory abc and a zero bite if it is	memory	267
now what about function a so functionally when it runs let's see is given the address of abc ok but it doesn't do anything instead it just simply exits this thread and it returns an address so it takes the pointer that we gave it which was a pointer to the string in memory abc and a zero bite if it is	string	257
now what about function a so functionally when it runs let's see is given the address of abc ok but it doesn't do anything instead it just simply exits this thread and it returns an address so it takes the pointer that we gave it which was a pointer to the string in memory abc and a zero bite if it is	thread	157
now what about function a so functionally when it runs let's see is given the address of abc ok but it doesn't do anything instead it just simply exits this thread and it returns an address so it takes the pointer that we gave it which was a pointer to the string in memory abc and a zero bite if it is	address	78
now what about function a so functionally when it runs let's see is given the address of abc ok but it doesn't do anything instead it just simply exits this thread and it returns an address so it takes the pointer that we gave it which was a pointer to the string in memory abc and a zero bite if it is	pointer	206
ok and we take that caster character add one in other words we just calculated a pointer that now points to the b ok an we return that so if and when these two threads run we know that the first first one returns a pointer to bc string and the second one prints are xyz right what is the rest of the code to write so equals p thread join on thread a and grab the result and so in stores that in there area code result ok so what what is going to be put inside this result so this line is going to wait is going to wait until it's able to join p thread so that means we wait until functionary has finished at which point we set this result variable to be a pointer and it's pointing to here we go do that be right there which we print out ok so this will print bc add a new line	code	300
ok and we take that caster character add one in other words we just calculated a pointer that now points to the b ok an we return that so if and when these two threads run we know that the first first one returns a pointer to bc string and the second one prints are xyz right what is the rest of the code to write so equals p thread join on thread a and grab the result and so in stores that in there area code result ok so what what is going to be put inside this result so this line is going to wait is going to wait until it's able to join p thread so that means we wait until functionary has finished at which point we set this result variable to be a pointer and it's pointing to here we go do that be right there which we print out ok so this will print bc add a new line	string	229
ok and we take that caster character add one in other words we just calculated a pointer that now points to the b ok an we return that so if and when these two threads run we know that the first first one returns a pointer to bc string and the second one prints are xyz right what is the rest of the code to write so equals p thread join on thread a and grab the result and so in stores that in there area code result ok so what what is going to be put inside this result so this line is going to wait is going to wait until it's able to join p thread so that means we wait until functionary has finished at which point we set this result variable to be a pointer and it's pointing to here we go do that be right there which we print out ok so this will print bc add a new line	thread	160
ok and we take that caster character add one in other words we just calculated a pointer that now points to the b ok an we return that so if and when these two threads run we know that the first first one returns a pointer to bc string and the second one prints are xyz right what is the rest of the code to write so equals p thread join on thread a and grab the result and so in stores that in there area code result ok so what what is going to be put inside this result so this line is going to wait is going to wait until it's able to join p thread so that means we wait until functionary has finished at which point we set this result variable to be a pointer and it's pointing to here we go do that be right there which we print out ok so this will print bc add a new line	pointer	81
ok right so now we hopefully you can conclude what this code is going to print right so if you said it's going to print bc or the new line then you'd be correct if you said it's going to print bc in a new line and xyz you'd be correct if you said is going to print xyz with a new line and bc you'd be correct yes so what code is actually indeterminate fethard create makes no promises about when these threads now going to stop maybe in a microsecond maybe in a millisecond time there's a very real chance that	code	56
ok right so now we hopefully you can conclude what this code is going to print right so if you said it's going to print bc or the new line then you'd be correct if you said it's going to print bc in a new line and xyz you'd be correct if you said is going to print xyz with a new line and bc you'd be correct yes so what code is actually indeterminate fethard create makes no promises about when these threads now going to stop maybe in a microsecond maybe in a millisecond time there's a very real chance that	thread	402
the first thread thread a could could start up exit and main thread could join on that we could print out an exit before thread b has a chance to start this would be particularly true on sale really busy system or a system that's only got one cpu core are poor threadbear it hasn't had a cpu scheduled yet and so our main thread is done before it he has a chance to start up ok right so all those those as possible if we modified our code so that we included p three exit on the main thread then you know that that means that because we are never returning from maine now our program is going to run until both those threads finish so now we expect both the bc to be printed and the xyz to be printed though we can't actually say definitively what order these two things can print we can make a guess as to which ones more likely but we haven't actually	code	434
the first thread thread a could could start up exit and main thread could join on that we could print out an exit before thread b has a chance to start this would be particularly true on sale really busy system or a system that's only got one cpu core are poor threadbear it hasn't had a cpu scheduled yet and so our main thread is done before it he has a chance to start up ok right so all those those as possible if we modified our code so that we included p three exit on the main thread then you know that that means that because we are never returning from maine now our program is going to run until both those threads finish so now we expect both the bc to be printed and the xyz to be printed though we can't actually say definitively what order these two things can print we can make a guess as to which ones more likely but we haven't actually	thread	10
the first thread thread a could could start up exit and main thread could join on that we could print out an exit before thread b has a chance to start this would be particularly true on sale really busy system or a system that's only got one cpu core are poor threadbear it hasn't had a cpu scheduled yet and so our main thread is done before it he has a chance to start up ok right so all those those as possible if we modified our code so that we included p three exit on the main thread then you know that that means that because we are never returning from maine now our program is going to run until both those threads finish so now we expect both the bc to be printed and the xyz to be printed though we can't actually say definitively what order these two things can print we can make a guess as to which ones more likely but we haven't actually	system	204
so fun stuff with threads fun stuff with thinking about interleaving and i hope you burn his mind as you write your own multithreaded programs	thread	18
use that file descriptor again to fill out this truck for me ok so these two do the same thing it's just a witcher matter of convenience as to whether you know the path or already have a file descriptor to an open file there's one other version is as well here which is going to leave a little bit but we're going to find that useful when we start talking about symbolic links so let's have a look at the kind of information that we can get back from stat ok right so the system gives us the following struct we can use and big important idea and we seen this multiple times is that ok we're going to give a pointer to struct so we're going to write things like ok here is a address of say some staff that some struct that we've got on our stack or somewhere else it's only going to fill out memory structure force if stat returns success so it's very important to be able to check that it returns ok so if it doesn't return ok ie zero then you can just assume that that memory structure was never touched in south the values inside that memory structure that is going to be arbitrary wait ok so let's see what we can find out about a file first of all great you can actually find the i node number and notice that all of these fields inside my struct start with the sd which is just short for stat ok we can find out some protection information about it so the	the following	488
use that file descriptor again to fill out this truck for me ok so these two do the same thing it's just a witcher matter of convenience as to whether you know the path or already have a file descriptor to an open file there's one other version is as well here which is going to leave a little bit but we're going to find that useful when we start talking about symbolic links so let's have a look at the kind of information that we can get back from stat ok right so the system gives us the following struct we can use and big important idea and we seen this multiple times is that ok we're going to give a pointer to struct so we're going to write things like ok here is a address of say some staff that some struct that we've got on our stack or somewhere else it's only going to fill out memory structure force if stat returns success so it's very important to be able to check that it returns ok so if it doesn't return ok ie zero then you can just assume that that memory structure was never touched in south the values inside that memory structure that is going to be arbitrary wait ok so let's see what we can find out about a file first of all great you can actually find the i node number and notice that all of these fields inside my struct start with the sd which is just short for stat ok we can find out some protection information about it so the	memory	792
use that file descriptor again to fill out this truck for me ok so these two do the same thing it's just a witcher matter of convenience as to whether you know the path or already have a file descriptor to an open file there's one other version is as well here which is going to leave a little bit but we're going to find that useful when we start talking about symbolic links so let's have a look at the kind of information that we can get back from stat ok right so the system gives us the following struct we can use and big important idea and we seen this multiple times is that ok we're going to give a pointer to struct so we're going to write things like ok here is a address of say some staff that some struct that we've got on our stack or somewhere else it's only going to fill out memory structure force if stat returns success so it's very important to be able to check that it returns ok so if it doesn't return ok ie zero then you can just assume that that memory structure was never touched in south the values inside that memory structure that is going to be arbitrary wait ok so let's see what we can find out about a file first of all great you can actually find the i node number and notice that all of these fields inside my struct start with the sd which is just short for stat ok we can find out some protection information about it so the	address	675
use that file descriptor again to fill out this truck for me ok so these two do the same thing it's just a witcher matter of convenience as to whether you know the path or already have a file descriptor to an open file there's one other version is as well here which is going to leave a little bit but we're going to find that useful when we start talking about symbolic links so let's have a look at the kind of information that we can get back from stat ok right so the system gives us the following struct we can use and big important idea and we seen this multiple times is that ok we're going to give a pointer to struct so we're going to write things like ok here is a address of say some staff that some struct that we've got on our stack or somewhere else it's only going to fill out memory structure force if stat returns success so it's very important to be able to check that it returns ok so if it doesn't return ok ie zero then you can just assume that that memory structure was never touched in south the values inside that memory structure that is going to be arbitrary wait ok so let's see what we can find out about a file first of all great you can actually find the i node number and notice that all of these fields inside my struct start with the sd which is just short for stat ok we can find out some protection information about it so the	system	472
use that file descriptor again to fill out this truck for me ok so these two do the same thing it's just a witcher matter of convenience as to whether you know the path or already have a file descriptor to an open file there's one other version is as well here which is going to leave a little bit but we're going to find that useful when we start talking about symbolic links so let's have a look at the kind of information that we can get back from stat ok right so the system gives us the following struct we can use and big important idea and we seen this multiple times is that ok we're going to give a pointer to struct so we're going to write things like ok here is a address of say some staff that some struct that we've got on our stack or somewhere else it's only going to fill out memory structure force if stat returns success so it's very important to be able to check that it returns ok so if it doesn't return ok ie zero then you can just assume that that memory structure was never touched in south the values inside that memory structure that is going to be arbitrary wait ok so let's see what we can find out about a file first of all great you can actually find the i node number and notice that all of these fields inside my struct start with the sd which is just short for stat ok we can find out some protection information about it so the	pointer	608
embedded inside all of these bits inside sd mode there's two useful pieces of information first of all you can find out information about read write and execute for the owner of the group and everybody else secondly you can use this to find out about whether it's a regular file whether it's a regular directory all whether it's something else like it's symbolic link or named pipe or some other bizzle object that we've got stored in a file system	system	442
directories where different names correspond to the same i knowed number in other words my actual file could appear in more than one place inside my directory structure which is pretty cool so once you get the idea that i node is the file then that opens up some pretty cool ideas ok then we've got things like ok the uid and gid so these are just number yes later and gentlemen you're you're just a number to the file system your user id the user is just a number so we don't actually store the username at all associated with a particular file so that tells us who owns it and the group of the owner as well	system	419
ok so up here to be the same we're going to look at the device id of a special file but don't worry about that instead this is how we can find out the true size of a file in bytes and rather than being just say an unsigned long or size today we want to be able to work with extremely large files so this special type here there's off underscored t is designed to be large enough that should be big enough for any files and we want to store inside this for today and in the future right so here is s t size so that's kind of useful but perhaps you actually care about how many how much space is currently being used on the disk so the disk itself i've talked about four kilobyte blocks but	block	678
ok so up here to be the same we're going to look at the device id of a special file but don't worry about that instead this is how we can find out the true size of a file in bytes and rather than being just say an unsigned long or size today we want to be able to work with extremely large files so this special type here there's off underscored t is designed to be large enough that should be big enough for any files and we want to store inside this for today and in the future right so here is s t size so that's kind of useful but perhaps you actually care about how many how much space is currently being used on the disk so the disk itself i've talked about four kilobyte blocks but	type	312
actually if we look back in time r block size on old systems was actually limited to just five hundred twelve twelve bytes so so if you want to know about the actual space used on their disk you can read this kind of blocksize here but realize that that if you	block	35
actually if we look back in time r block size on old systems was actually limited to just five hundred twelve twelve bytes so so if you want to know about the actual space used on their disk you can read this kind of blocksize here but realize that that if you	system	53
this other block size up here tells us today about the natural size of blocks for the particular file system so if i'm going to use my read and write calls i probably want to make sure that the number of bytes i'm requesting is some multiple of that or at least that site in order to make sure that i'm efficiently using my file system so that gives me hint about that natural size of read invites	block	11
this other block size up here tells us today about the natural size of blocks for the particular file system so if i'm going to use my read and write calls i probably want to make sure that the number of bytes i'm requesting is some multiple of that or at least that site in order to make sure that i'm efficiently using my file system so that gives me hint about that natural size of read invites	system	102
to this current file system right the last thing is hey we could find out some important some timing information so the c structure time t here is accurate to the lease gives a precision of one second the actual way that something might be stored on disk isn't necessarily that accurate or it might be more than more accurate than that for example some windows file systems are only accurate to within two seconds ok but	system	21
now let's see what we've got we've got when it was last accessed when it was last modified and to finally the time of the last status change ok what's the status change this is the time of when someone altered the i node ok so for example if you change the who owned a file then we would expect this status change to be modified so most of the time we want this modified time ok the middle one that is going to tell us when someone 's altered the bites of my actual file for example if you're writing uh make then we actually want to figure out when was the contents of the file my source code modified and it is that more recent or older than the executable that i'm trying to build so great let's actually do that in the next video let's actually kind of make a very simple kind of version of make that's going to use stat to figure out whether we should compile something or not	code	589
hi so our process has arguments that we can pass it on the command line and read those when we start with maine but actually we've got one other kind of cool little feature as well and these are environment variables we can read these inside our shell and also change them and similar we can do that inside our programs as well so what are these environment variables well you have a lot of them let's print some of them out so if i type e n v for example i can see all sorts of fun things i can see things like where my home directory is i can see things like my path i can see things like my current working directory i can see things like my display information i can see things where is my path let's do that so i can print out from bash ok let's do echo dollar path so if i start typing your command like vim or ls then i know that the shell is going to look inside all of these different directions to try to find a matching executable so	type	433
how about we actually want to get access these from rc code as well ok so to do that	code	55
so the way to think about environment variables is a very simple key value pairs and put a simple string dictionary and that gets passed into the process every time we start a new process	string	98
we might program can discover that it's running as a process with the username setters angrave but there's no secret been set yet and fortunately for fortunately for us put s doesn't crash if we passing a null string instead in this gcc implementation it prints out the friendly hey parentheses null so	a process	51
we might program can discover that it's running as a process with the username setters angrave but there's no secret been set yet and fortunately for fortunately for us put s doesn't crash if we passing a null string instead in this gcc implementation it prints out the friendly hey parentheses null so	string	210
i have the little dude line and then let's exit with a non zero code to mean failure	code	64
i guess i i've been pulling it off but now i think it's actually time to talk a little bit about these address structures which we've been happily throwing around and not really worrying too much about what they look like	address	103
because get address info filled them out for us	address	12
if i was actually manually setting up one of these structs myself so if i wasn't actually relying on get address info to do the work for me	address	105
ok n to network to host long as well so this is long which is thirty two bits back from the day when longs were thirty two bits and this is used to describe ip4 addresses as well so if you wanted a numeric version of an ip4 address and needed to convert it from the network implementation to a number which is understood on what machine you'll be using this as well	address	161
c code which is compatible and it doesn't matter whether your cpu uses a little endian format a big endian format	code	2
the kind of last thing here is that a notice that accept has a couple of arguments that i'm not using i can actually use accept to tell me a little bit more about who is connecting so with every tcp socket we not only have the destination address we also have the source address so we know where that socket where that client is coming from i know its ip address and so if i wish i can make use of that so for example i could check your ip address and if you're connecting from a certain machine i might give you a version of the website which is out of date or i might deliberately give you a website which has thousands of links so you can keep clicking for anywhere and so you're poor robot will never escape this recursive clicking hell, trying to troll my website and it will never find a way out ok	address	239
so i can do a lot with accept and i can i can perhaps if i find out your ip address i might try to connect back to you to see what kind of servers are running on your machine ok so the summary however is these are the big four calls that we need	address	76
to make a server they are right so we've got socket course we need to a socket then we need to bind it to a network card right after that we need to listen to basically open up shop to allow clients to connect and then finally we need to accept and we're going to put except inside a loop and accept is the only one of these calls which will block if there's no new clients to service with that i'm signing out and see you in a future video bye	block	342
i wanted to first of all create a a process where i've got a global variable little m here and we're going to initialize it by asking it to hold the memory address of this string literal in other words it's going to hold the address of where to find that that w there ok what do we do inside a little program here we have a little bit available could a we called fork and the return type of focus this process process id type	memory	149
i wanted to first of all create a a process where i've got a global variable little m here and we're going to initialize it by asking it to hold the memory address of this string literal in other words it's going to hold the address of where to find that that w there ok what do we do inside a little program here we have a little bit available could a we called fork and the return type of focus this process process id type	type	383
i wanted to first of all create a a process where i've got a global variable little m here and we're going to initialize it by asking it to hold the memory address of this string literal in other words it's going to hold the address of where to find that that w there ok what do we do inside a little program here we have a little bit available could a we called fork and the return type of focus this process process id type	a process	34
i wanted to first of all create a a process where i've got a global variable little m here and we're going to initialize it by asking it to hold the memory address of this string literal in other words it's going to hold the address of where to find that that w there ok what do we do inside a little program here we have a little bit available could a we called fork and the return type of focus this process process id type	string	172
i wanted to first of all create a a process where i've got a global variable little m here and we're going to initialize it by asking it to hold the memory address of this string literal in other words it's going to hold the address of where to find that that w there ok what do we do inside a little program here we have a little bit available could a we called fork and the return type of focus this process process id type	address	156
now so far i retired i did not tell you the completely doesn't work it is possible actually for fork to fail for example perhaps you've been careful an limited the total number of processes that system that your user in the system was allowed to run a caution you against creating that setting that to be a two smaller number because if you do that then by the time you've set the i've gotta login process that display process and pass all these other things there may not be enough process is left you to actually run any programs or so one hundred or two hundred is a reasonable number thirty or fifty may not be a reasonable number if you're running on a graphical system	system	195
ok so we call fork and now we're trying to wait a little bit more kind of robust code here because we actually checking for the error condition and if it fails do not pass go do not do not attempt to call fork again and instead immediately exit so for can be very dangerous if like agent smith in the matrix movies you allow every process to make more process is as fast as possible so be extremely careful that day that you start writing code we're fork is inside the loop and one day then that they will count when you create a shell where you are reading every line of input in order to run that as a process	the loop	465
ok so we call fork and now we're trying to wait a little bit more kind of robust code here because we actually checking for the error condition and if it fails do not pass go do not do not attempt to call fork again and instead immediately exit so for can be very dangerous if like agent smith in the matrix movies you allow every process to make more process is as fast as possible so be extremely careful that day that you start writing code we're fork is inside the loop and one day then that they will count when you create a shell where you are reading every line of input in order to run that as a process	a shell	528
ok so we call fork and now we're trying to wait a little bit more kind of robust code here because we actually checking for the error condition and if it fails do not pass go do not do not attempt to call fork again and instead immediately exit so for can be very dangerous if like agent smith in the matrix movies you allow every process to make more process is as fast as possible so be extremely careful that day that you start writing code we're fork is inside the loop and one day then that they will count when you create a shell where you are reading every line of input in order to run that as a process	code	81
ok so we call fork and now we're trying to wait a little bit more kind of robust code here because we actually checking for the error condition and if it fails do not pass go do not do not attempt to call fork again and instead immediately exit so for can be very dangerous if like agent smith in the matrix movies you allow every process to make more process is as fast as possible so be extremely careful that day that you start writing code we're fork is inside the loop and one day then that they will count when you create a shell where you are reading every line of input in order to run that as a process	a process	602
imagine now you have a split brain what we want to do is actually think about our code in two different scenarios that will have the scenario where we are the parents and the scenarios where we are the child and to make our life simple we can actually buy some if statements	code	82
this code here is actually being run inside the child crisis well return value from fork is what is o i can also find out who my parent is just by calling get p p i d so we've got all our condition for a child process and in child process i'm going to change its value of m to point to a different string hello and	code	5
this code here is actually being run inside the child crisis well return value from fork is what is o i can also find out who my parent is just by calling get p p i d so we've got all our condition for a child process and in child process i'm going to change its value of m to point to a different string hello and	string	298
right what happens next in the child process well all this other stuff going to else is irrelevant to that child process so what is the child process do next it prints out string put s remembers just print half with an additional new line as well so it's going to say ok child print out whatever you find with the m points to by kate providing you will remember that our value of m is completely different inside these two processes just like if we were to run a program multiple times different times of the day even though i can show you the same source code actually two different processes if you run it in the morning and in the afternoon so have that frame of mind when thinking about this kind of code	code	556
right what happens next in the child process well all this other stuff going to else is irrelevant to that child process so what is the child process do next it prints out string put s remembers just print half with an additional new line as well so it's going to say ok child print out whatever you find with the m points to by kate providing you will remember that our value of m is completely different inside these two processes just like if we were to run a program multiple times different times of the day even though i can show you the same source code actually two different processes if you run it in the morning and in the afternoon so have that frame of mind when thinking about this kind of code	string	172
actually write the code	code	19
that should work do you think let's see ok off we go let's run it again and this time we get a hundred and twenty nine but this happened to work work on this system but be careful because on some systems the eighth bit is used as a signing sign information so the values that you actually see maybe negative instead right so this kind of word of caution and let's just prove it truly is only kind of eight bits let's have a larger value here let's pick something which car be represented by eight bits let's go for say	system	158
right, ok. welcome to the next lecture i want us to think about how we might actually write the c library. ok so maybe you don't like the license of glibc maybe you want to write a library that is a lot smaller or simpler so how can we actually wrap the low level posix interface that the kernel gives us an actually implement the c-level objects like the file so let's i would go at this right now you know about fopen where i can pass in a filename k blah blah blah but there's also function called fdopen where i can just pass in an existing file descriptor so if we write f d open it would be pretty easy to then also implement f open which just calls open and then we can delegate the rest of the work to this ft open call right so here's what we need to do then we're going to be given a file descriptor and we want to create one of these file objects now normally these are opaque structures normally as programmers we don't need to peek inside to see how they're working but that's not true today because we are actually trying to write the c library so let's have a go at writing the kind of simplest version that we might want and that's what i've done up here ok so this is what i want to put inside my file struct i need to store several things first of all yeah i definitely need to know about the low level file descriptor that i'm going to need when actually call read and write secondly i want to have some kind of buffer and the purpose of my buffer is to actually reduce the number of times that i'm going to call read or write so if you give me some bytes to write out by default i'm not going to be the center i'm simply going to append them into some space into some memory and so that's the purposes of my buffer now i need to keep track of how large my buffer is so that's the purposes of of my capacity the size of my buffer and i need to keep keep track of how much i've used so far so that will be the size inside here and the last thing we can do today is to say what kind of buffering do we ask you want it might be that we want to use this forever stream in which case we want the option of saying we don't want any buffering at all so as soon as you give me some bytes i want to immediately call right or soon as you want to read i'm going to read exactly that number of bytes or maybe i want to use this to rap a terminal so i want to use line buffering so i'm going to flush my buffer every time you give me the new line or maybe i want the best performance possible and so i want the largest amount of buffering possible so this is full buffering and will only flush when the buffer is completely fallen other words we've reached the capacity ok so let's some sketch out some code then of how we can use this right then so you've given me a file descriptor the first time going to do then is just create enough space for this struct ok so you can see we're already using typedef so i don't need to keep on writing struct so instead i can say right the	memory	1688
right, ok. welcome to the next lecture i want us to think about how we might actually write the c library. ok so maybe you don't like the license of glibc maybe you want to write a library that is a lot smaller or simpler so how can we actually wrap the low level posix interface that the kernel gives us an actually implement the c-level objects like the file so let's i would go at this right now you know about fopen where i can pass in a filename k blah blah blah but there's also function called fdopen where i can just pass in an existing file descriptor so if we write f d open it would be pretty easy to then also implement f open which just calls open and then we can delegate the rest of the work to this ft open call right so here's what we need to do then we're going to be given a file descriptor and we want to create one of these file objects now normally these are opaque structures normally as programmers we don't need to peek inside to see how they're working but that's not true today because we are actually trying to write the c library so let's have a go at writing the kind of simplest version that we might want and that's what i've done up here ok so this is what i want to put inside my file struct i need to store several things first of all yeah i definitely need to know about the low level file descriptor that i'm going to need when actually call read and write secondly i want to have some kind of buffer and the purpose of my buffer is to actually reduce the number of times that i'm going to call read or write so if you give me some bytes to write out by default i'm not going to be the center i'm simply going to append them into some space into some memory and so that's the purposes of my buffer now i need to keep track of how large my buffer is so that's the purposes of of my capacity the size of my buffer and i need to keep keep track of how much i've used so far so that will be the size inside here and the last thing we can do today is to say what kind of buffering do we ask you want it might be that we want to use this forever stream in which case we want the option of saying we don't want any buffering at all so as soon as you give me some bytes i want to immediately call right or soon as you want to read i'm going to read exactly that number of bytes or maybe i want to use this to rap a terminal so i want to use line buffering so i'm going to flush my buffer every time you give me the new line or maybe i want the best performance possible and so i want the largest amount of buffering possible so this is full buffering and will only flush when the buffer is completely fallen other words we've reached the capacity ok so let's some sketch out some code then of how we can use this right then so you've given me a file descriptor the first time going to do then is just create enough space for this struct ok so you can see we're already using typedef so i don't need to keep on writing struct so instead i can say right the	a terminal	2342
right, ok. welcome to the next lecture i want us to think about how we might actually write the c library. ok so maybe you don't like the license of glibc maybe you want to write a library that is a lot smaller or simpler so how can we actually wrap the low level posix interface that the kernel gives us an actually implement the c-level objects like the file so let's i would go at this right now you know about fopen where i can pass in a filename k blah blah blah but there's also function called fdopen where i can just pass in an existing file descriptor so if we write f d open it would be pretty easy to then also implement f open which just calls open and then we can delegate the rest of the work to this ft open call right so here's what we need to do then we're going to be given a file descriptor and we want to create one of these file objects now normally these are opaque structures normally as programmers we don't need to peek inside to see how they're working but that's not true today because we are actually trying to write the c library so let's have a go at writing the kind of simplest version that we might want and that's what i've done up here ok so this is what i want to put inside my file struct i need to store several things first of all yeah i definitely need to know about the low level file descriptor that i'm going to need when actually call read and write secondly i want to have some kind of buffer and the purpose of my buffer is to actually reduce the number of times that i'm going to call read or write so if you give me some bytes to write out by default i'm not going to be the center i'm simply going to append them into some space into some memory and so that's the purposes of my buffer now i need to keep track of how large my buffer is so that's the purposes of of my capacity the size of my buffer and i need to keep keep track of how much i've used so far so that will be the size inside here and the last thing we can do today is to say what kind of buffering do we ask you want it might be that we want to use this forever stream in which case we want the option of saying we don't want any buffering at all so as soon as you give me some bytes i want to immediately call right or soon as you want to read i'm going to read exactly that number of bytes or maybe i want to use this to rap a terminal so i want to use line buffering so i'm going to flush my buffer every time you give me the new line or maybe i want the best performance possible and so i want the largest amount of buffering possible so this is full buffering and will only flush when the buffer is completely fallen other words we've reached the capacity ok so let's some sketch out some code then of how we can use this right then so you've given me a file descriptor the first time going to do then is just create enough space for this struct ok so you can see we're already using typedef so i don't need to keep on writing struct so instead i can say right the	type	2904
right, ok. welcome to the next lecture i want us to think about how we might actually write the c library. ok so maybe you don't like the license of glibc maybe you want to write a library that is a lot smaller or simpler so how can we actually wrap the low level posix interface that the kernel gives us an actually implement the c-level objects like the file so let's i would go at this right now you know about fopen where i can pass in a filename k blah blah blah but there's also function called fdopen where i can just pass in an existing file descriptor so if we write f d open it would be pretty easy to then also implement f open which just calls open and then we can delegate the rest of the work to this ft open call right so here's what we need to do then we're going to be given a file descriptor and we want to create one of these file objects now normally these are opaque structures normally as programmers we don't need to peek inside to see how they're working but that's not true today because we are actually trying to write the c library so let's have a go at writing the kind of simplest version that we might want and that's what i've done up here ok so this is what i want to put inside my file struct i need to store several things first of all yeah i definitely need to know about the low level file descriptor that i'm going to need when actually call read and write secondly i want to have some kind of buffer and the purpose of my buffer is to actually reduce the number of times that i'm going to call read or write so if you give me some bytes to write out by default i'm not going to be the center i'm simply going to append them into some space into some memory and so that's the purposes of my buffer now i need to keep track of how large my buffer is so that's the purposes of of my capacity the size of my buffer and i need to keep keep track of how much i've used so far so that will be the size inside here and the last thing we can do today is to say what kind of buffering do we ask you want it might be that we want to use this forever stream in which case we want the option of saying we don't want any buffering at all so as soon as you give me some bytes i want to immediately call right or soon as you want to read i'm going to read exactly that number of bytes or maybe i want to use this to rap a terminal so i want to use line buffering so i'm going to flush my buffer every time you give me the new line or maybe i want the best performance possible and so i want the largest amount of buffering possible so this is full buffering and will only flush when the buffer is completely fallen other words we've reached the capacity ok so let's some sketch out some code then of how we can use this right then so you've given me a file descriptor the first time going to do then is just create enough space for this struct ok so you can see we're already using typedef so i don't need to keep on writing struct so instead i can say right the	code	2709
the result will be equal to right let's get some memory here right malloc and then size of this struct ok so size of file not file pointer	memory	49
the result will be equal to right let's get some memory here right malloc and then size of this struct ok so size of file not file pointer	pointer	131
and then i can start to set things up in here so i can do things like ok right as the file descriptor could be equal to something was sending in the buffering we can set to some kind of default right maybe we want to try to test the current file descriptor and figure out if it's corresponds to a terminal or not but for today let's just make our implementation as simple as possible and for example let's does arbitrarily	a terminal	295
are we done no actually we need some more memory for the buffer as well so i will pick a capacity size how about four thousand and ninety six as a typical size of my buffer case so you could be four thousand ninety six an lastly let's set the the buffer itself so ok our buffer	memory	42
right will you can point to some more memory here we go right it's malloc and for brevity i'm just going to take four thousand and ninety six in here in practice i would refer to my buffering variable over there	memory	38
ok then i return all right so what do you think about that ok so we made a classic mistake here which is we didn't actually set everything up so yes we set the capacity yes we set the buffer but we did not actually specify size which is the number of bytes in my buffer that i'm currently using so maybe we'll be lucky maybe then we get from malloc will all be zero it out but that's not guaranteed and is unlikely if we're using malloc in a long running program where malloc might reuse some memory that had been used earlier so let's fix our program and actually make sure that we set this size equal to zero	memory	493
and inside our main method we're going to do we're going to create a whole load of pizza it's ok and make a note of their thread i ds pass in the firework function ok and then after we've done that we will set fireworks equal to one and then will call preconditions signals so we know that is going to wake up one thread	thread	122
now we want to wait for all threads to finish here so i could write a for loop to call p thread join on all of my thread i ds but i could also be lazy in to say ok pthread less exit the main thread	thread	28
so that we never returned from maine so i could call p thread exit here key	thread	55
right so great we've implemented that now actually let's have to think about how we can implement the firework right so what does r firework do k right well we acquire the mutex lock i might impede here just for for sure had so we've got we've got the mutex lock and all threads that run this code again to acquire the same lock	code	293
right so great we've implemented that now actually let's have to think about how we can implement the firework right so what does r firework do k right well we acquire the mutex lock i might impede here just for for sure had so we've got we've got the mutex lock and all threads that run this code again to acquire the same lock	thread	271
and then we say well while fireworks is zero corporate recognition weight in other words if my firework thread starts up here and it starts up early then we're just going to block it for but we're going to ask it to release the mutex lock and lock inside here so go back to the kind of first code remember we created all of the threads initially back when are fireworks variable with zero it's only after we've created all five	block	174
and then we say well while fireworks is zero corporate recognition weight in other words if my firework thread starts up here and it starts up early then we're just going to block it for but we're going to ask it to release the mutex lock and lock inside here so go back to the kind of first code remember we created all of the threads initially back when are fireworks variable with zero it's only after we've created all five	code	292
and then we say well while fireworks is zero corporate recognition weight in other words if my firework thread starts up here and it starts up early then we're just going to block it for but we're going to ask it to release the mutex lock and lock inside here so go back to the kind of first code remember we created all of the threads initially back when are fireworks variable with zero it's only after we've created all five	thread	104
ok so let's get down here ok right so what do we do after this point ok when we escape out of here where a scaping out of here because fireworks is no longer no longer zero and the very first thing we do is call p three condition broadcast in other words ring that fire bell wake everybody up in this might be sleeping inside this condition variable ok so now all five of my threads	thread	375
definitely working up ok so i implement increment the value of fireworks i print out oh and that value and then i decrement it ok so what's going to be the largest value this code will print one two three four five six what do you think so just as a reminder i've got five threads running this and the only way they can escape out of this code is after fireworks is no longer zero so what's the maximum possible value that we might see from this first to run this hundred or thousand to a million times what's the largest integer that would expect here ok so think about that pause this video and make your choice and then we'll see if you're correct ok so we think about this for five seconds and then we'll review the answers	code	175
definitely working up ok so i implement increment the value of fireworks i print out oh and that value and then i decrement it ok so what's going to be the largest value this code will print one two three four five six what do you think so just as a reminder i've got five threads running this and the only way they can escape out of this code is after fireworks is no longer zero so what's the maximum possible value that we might see from this first to run this hundred or thousand to a million times what's the largest integer that would expect here ok so think about that pause this video and make your choice and then we'll see if you're correct ok so we think about this for five seconds and then we'll review the answers	thread	273
ok wait times up so let's let's have a look at the key key detail here the key detail is a mutex lock our mutex lock allows us to reason strongly about the number of threads which are actually running in this code	code	209
ok wait times up so let's let's have a look at the key key detail here the key detail is a mutex lock our mutex lock allows us to reason strongly about the number of threads which are actually running in this code	a mutex	89
ok wait times up so let's let's have a look at the key key detail here the key detail is a mutex lock our mutex lock allows us to reason strongly about the number of threads which are actually running in this code	thread	166
because we've acquired mutex lock means that any other threads that want to run have to also require it so all of these lines of code can only be run by one thread at a time	code	129
because we've acquired mutex lock means that any other threads that want to run have to also require it so all of these lines of code can only be run by one thread at a time	thread	55
if the threads have gone to sleep inside p thread condition wait there only allowed to escape out of that after they reacquired the mutex log so that's the key idea that only one third of the time can be running this piece of code and it allows us to actually reason about this so we know that when we escape out of here the very first thread will see of fireworks value of one because we changed it upstairs in the main method so we implement so we increment it to two case of wig the first escapes out of here will	code	226
if the threads have gone to sleep inside p thread condition wait there only allowed to escape out of that after they reacquired the mutex log so that's the key idea that only one third of the time can be running this piece of code and it allows us to actually reason about this so we know that when we escape out of here the very first thread will see of fireworks value of one because we changed it upstairs in the main method so we implement so we increment it to two case of wig the first escapes out of here will	thread	7
will print out too and then we decrement it down to one again and then we unlock the mutex ok so the next step that comes out of here will only escape out of p three condition wait after we've unlock the mutex so it will also see a value of fireworks of one it also does a big forecast waking everybody up and most are too and so it will print out the value of two etc right and so on the next thread will come out check the condition for the while loop ok that is no longer true so it comes to an does the same thing increments it from one to two and then two to one and then unlocks the mutex which allows the next set to escape it checks the value and so on and so on so right so let's just kind of run this just to kind of prove it right so we have ok compiled it	thread	394
why is my machine slow ok there we go he got out all right and we see every firework every thread wanna see the value of two and we could do that through this strong reasoning thanks to the mutex log	thread	91
that these two lines of code here	code	24
between us deciding the value of fireworks is zero and then calling peter condition wait so if it happened right inside there if that just that moment in time then what's going to happen we've actually called preconditions signal but no thread was yet sleeping no thread was yet blocked inside condition wait ok so was to fix for that and the answer is to actually log on the same mutex here so if i call pete said mutex lock here	block	279
between us deciding the value of fireworks is zero and then calling peter condition wait so if it happened right inside there if that just that moment in time then what's going to happen we've actually called preconditions signal but no thread was yet sleeping no thread was yet blocked inside condition wait ok so was to fix for that and the answer is to actually log on the same mutex here so if i call pete said mutex lock here	thread	237
another thread is acquired mutex or after the all the threads have called pizza hut	thread	8
another thing this code is kind of highlights is that	code	19
that you can create threads but peter create doesn't wait for them to actually start so this this code is an attempt to say ok let's create all these threads and actually we're going to make our own barrier	code	98
that you can create threads but peter create doesn't wait for them to actually start so this this code is an attempt to say ok let's create all these threads and actually we're going to make our own barrier	thread	20
inside here so we won't let anybody go until we've actually created or five threads and also kind of starting up so but this line of actually changing the fireworks to one here could still actually technically occur before this five threads of actually started all we've just simply say is to say ok create them and at some point in the future please run alright so lots of interesting interleavings details there and as you can see this stuff is tricky	thread	76
hi right in this last video we've got a bit of a challenge here we go so i want to make use of the following function called get get message and this function first of all i'm going to change his name to be a bit more see like there we go get message and this function takes a pointer to a pointer and then we do some wonderful things with this pointer first of all let's go to my locker say hey malloc i need ten bites that will give me back the address of that ten contiguous bytes and we store that somewhere we store that inside magic except not available magic directly instead we follow magic wherever magic is pointing to that's the thing we're going to change	the following	95
hi right in this last video we've got a bit of a challenge here we go so i want to make use of the following function called get get message and this function first of all i'm going to change his name to be a bit more see like there we go get message and this function takes a pointer to a pointer and then we do some wonderful things with this pointer first of all let's go to my locker say hey malloc i need ten bites that will give me back the address of that ten contiguous bytes and we store that somewhere we store that inside magic except not available magic directly instead we follow magic wherever magic is pointing to that's the thing we're going to change	address	447
hi right in this last video we've got a bit of a challenge here we go so i want to make use of the following function called get get message and this function first of all i'm going to change his name to be a bit more see like there we go get message and this function takes a pointer to a pointer and then we do some wonderful things with this pointer first of all let's go to my locker say hey malloc i need ten bites that will give me back the address of that ten contiguous bytes and we store that somewhere we store that inside magic except not available magic directly instead we follow magic wherever magic is pointing to that's the thing we're going to change	pointer	277
that's where we're going to make our change so we know we just changed it we know that's actually going to be heap memory so into that heap memory we're going to ask a straight copy to copy the following following so in two three four five six seven do we have any characters that let's see one two three four five six seven eight nine ten oh we have a problem we actually going to copy eleven bytes because the zero bytes so if we wanted to make this code work with change this to eleven of course in real code we would actually not hard code this value of figure out how you could use size off in order to avoid this ok so how can we make our code down here actually put this out right so let me kind of show you something that's surprising that we have	the following	190
that's where we're going to make our change so we know we just changed it we know that's actually going to be heap memory so into that heap memory we're going to ask a straight copy to copy the following following so in two three four five six seven do we have any characters that let's see one two three four five six seven eight nine ten oh we have a problem we actually going to copy eleven bytes because the zero bytes so if we wanted to make this code work with change this to eleven of course in real code we would actually not hard code this value of figure out how you could use size off in order to avoid this ok so how can we make our code down here actually put this out right so let me kind of show you something that's surprising that we have	heap memory	110
that's where we're going to make our change so we know we just changed it we know that's actually going to be heap memory so into that heap memory we're going to ask a straight copy to copy the following following so in two three four five six seven do we have any characters that let's see one two three four five six seven eight nine ten oh we have a problem we actually going to copy eleven bytes because the zero bytes so if we wanted to make this code work with change this to eleven of course in real code we would actually not hard code this value of figure out how you could use size off in order to avoid this ok so how can we make our code down here actually put this out right so let me kind of show you something that's surprising that we have	memory	115
that's where we're going to make our change so we know we just changed it we know that's actually going to be heap memory so into that heap memory we're going to ask a straight copy to copy the following following so in two three four five six seven do we have any characters that let's see one two three four five six seven eight nine ten oh we have a problem we actually going to copy eleven bytes because the zero bytes so if we wanted to make this code work with change this to eleven of course in real code we would actually not hard code this value of figure out how you could use size off in order to avoid this ok so how can we make our code down here actually put this out right so let me kind of show you something that's surprising that we have	code	452
a little pointer here it is points too if you were to use it going to follow us address you would find a single character and i could initialize that to say nothing in other words right now it's pointing to nothing ok but what if i told you where that that pointer lived in memory we know it's going to be on the stack somewhere but suppose i actually found out is actual address by using the ampersand operator so if we knew that then why don't i give that	memory	274
a little pointer here it is points too if you were to use it going to follow us address you would find a single character and i could initialize that to say nothing in other words right now it's pointing to nothing ok but what if i told you where that that pointer lived in memory we know it's going to be on the stack somewhere but suppose i actually found out is actual address by using the ampersand operator so if we knew that then why don't i give that	address	80
a little pointer here it is points too if you were to use it going to follow us address you would find a single character and i could initialize that to say nothing in other words right now it's pointing to nothing ok but what if i told you where that that pointer lived in memory we know it's going to be on the stack somewhere but suppose i actually found out is actual address by using the ampersand operator so if we knew that then why don't i give that	pointer	9
address to	address	0
my little function get message ok so we can just say hey function here's the address of a variable that we'd like you to change and that's exactly what we're going to do so that when it returns my pointer variable is no longer looking at nothing it's now looking at some hit memory because this function changed it	memory	275
my little function get message ok so we can just say hey function here's the address of a variable that we'd like you to change and that's exactly what we're going to do so that when it returns my pointer variable is no longer looking at nothing it's now looking at some hit memory because this function changed it	address	77
my little function get message ok so we can just say hey function here's the address of a variable that we'd like you to change and that's exactly what we're going to do so that when it returns my pointer variable is no longer looking at nothing it's now looking at some hit memory because this function changed it	pointer	197
ok and approve it let's print it out right so i'm going to use put s today so i'm just say ok like here you go here's a pointer to character but don't treat it as a single character keep printing out those characters until you get to that zero what is put s this is actually equivalent to just print f to say ok printer print out the following string and a new line so it actually prints out a new line for us as well ok wait what are we missing we are missing some includes we need standard io for the printf we need something from alakan store copy how can we find that out use demand pages right so let me pull up a man pages right so tell me about ballack and you'll see that this inside standard lib so i need that ok and what about square copy again use the manpages right so man store copy and will see that's inside stringle h and if i have to scroll down i could find out more information about how they work king so copies from string the source to the destination ok right so let's put that in there and will have to get compiling this right so get out of that gcc reverse off and we're missing a semicolon so will fix that	the following	330
ok and approve it let's print it out right so i'm going to use put s today so i'm just say ok like here you go here's a pointer to character but don't treat it as a single character keep printing out those characters until you get to that zero what is put s this is actually equivalent to just print f to say ok printer print out the following string and a new line so it actually prints out a new line for us as well ok wait what are we missing we are missing some includes we need standard io for the printf we need something from alakan store copy how can we find that out use demand pages right so let me pull up a man pages right so tell me about ballack and you'll see that this inside standard lib so i need that ok and what about square copy again use the manpages right so man store copy and will see that's inside stringle h and if i have to scroll down i could find out more information about how they work king so copies from string the source to the destination ok right so let's put that in there and will have to get compiling this right so get out of that gcc reverse off and we're missing a semicolon so will fix that	printf	503
ok and approve it let's print it out right so i'm going to use put s today so i'm just say ok like here you go here's a pointer to character but don't treat it as a single character keep printing out those characters until you get to that zero what is put s this is actually equivalent to just print f to say ok printer print out the following string and a new line so it actually prints out a new line for us as well ok wait what are we missing we are missing some includes we need standard io for the printf we need something from alakan store copy how can we find that out use demand pages right so let me pull up a man pages right so tell me about ballack and you'll see that this inside standard lib so i need that ok and what about square copy again use the manpages right so man store copy and will see that's inside stringle h and if i have to scroll down i could find out more information about how they work king so copies from string the source to the destination ok right so let's put that in there and will have to get compiling this right so get out of that gcc reverse off and we're missing a semicolon so will fix that	string	344
ok and approve it let's print it out right so i'm going to use put s today so i'm just say ok like here you go here's a pointer to character but don't treat it as a single character keep printing out those characters until you get to that zero what is put s this is actually equivalent to just print f to say ok printer print out the following string and a new line so it actually prints out a new line for us as well ok wait what are we missing we are missing some includes we need standard io for the printf we need something from alakan store copy how can we find that out use demand pages right so let me pull up a man pages right so tell me about ballack and you'll see that this inside standard lib so i need that ok and what about square copy again use the manpages right so man store copy and will see that's inside stringle h and if i have to scroll down i could find out more information about how they work king so copies from string the source to the destination ok right so let's put that in there and will have to get compiling this right so get out of that gcc reverse off and we're missing a semicolon so will fix that	pointer	120
ok i gotta go right and if it's amazing see and that's it that's the end of this lecture i hope you had a lot of fun with this i encode you know to play and then we wind up that use the coursebook these lecture videos of kind of fun way to show you some hints and tips and tricks and opinionated stuff that i just like and i think it's cool and but also make sure that you get everything covered with the course book you will find that it will take time you'll find that you're running to road blocks that's ok	block	494
ok i gotta go right and if it's amazing see and that's it that's the end of this lecture i hope you had a lot of fun with this i encode you know to play and then we wind up that use the coursebook these lecture videos of kind of fun way to show you some hints and tips and tricks and opinionated stuff that i just like and i think it's cool and but also make sure that you get everything covered with the course book you will find that it will take time you'll find that you're running to road blocks that's ok	code	131
persevere and make sure that you use all the resources that are available to you everything from debuggers to thinking about careful design and modular design of your code to using google manpages really understand how things work alright so we've covered a lot of basic ground about talking about different kinds of memory and how we can access it and see and now it's your turn to run with homework zero and soon the first lab bye	memory	317
persevere and make sure that you use all the resources that are available to you everything from debuggers to thinking about careful design and modular design of your code to using google manpages really understand how things work alright so we've covered a lot of basic ground about talking about different kinds of memory and how we can access it and see and now it's your turn to run with homework zero and soon the first lab bye	code	167
persevere and make sure that you use all the resources that are available to you everything from debuggers to thinking about careful design and modular design of your code to using google manpages really understand how things work alright so we've covered a lot of basic ground about talking about different kinds of memory and how we can access it and see and now it's your turn to run with homework zero and soon the first lab bye	resources	45
ok right so you can see that all my little main program is going to do is actually call exact vp right so we're just going to say please sir start executing and if you give me some arguments then the first thing actual real parameter not program name but also the process name but actual argument you specify will be the name of the process and also will use this as well as any other remaining arguments as the arguments that process	parameter	224
ok so we immediately just going to delegate to this other program but before we do that we're going to set the process mask and this is fun because the process mask survives this disposition survives when we call exec so anything we set up now any drawbridge that we pull up will still be there when we exact to a new program right so let's set it up so we'll have a mask and the first thing we should do is the contents of this mask will be our but we haven't initialized it yet so we should call sig empty set to say right just initialize it to nothing ok so see empty set and here's the address of my mask ok now i want to start adding bits to my mask right so sigad set all my mask and the signal i care bell is cygnet	disposition	179
ok so we immediately just going to delegate to this other program but before we do that we're going to set the process mask and this is fun because the process mask survives this disposition survives when we call exec so anything we set up now any drawbridge that we pull up will still be there when we exact to a new program right so let's set it up so we'll have a mask and the first thing we should do is the contents of this mask will be our but we haven't initialized it yet so we should call sig empty set to say right just initialize it to nothing ok so see empty set and here's the address of my mask ok now i want to start adding bits to my mask right so sigad set all my mask and the signal i care bell is cygnet	address	590
ok and now we can change my my process is disposition the process mask so let's go what's the how here where we could call various things we could call the sig block that's going iterate through them we could call sig block and that would add it to the existing process mask we could unblock is not going to work for us but we could also call sigset mask today i'm going to use a cig block because	block	160
ok and now we can change my my process is disposition the process mask so let's go what's the how here where we could call various things we could call the sig block that's going iterate through them we could call sig block and that would add it to the existing process mask we could unblock is not going to work for us but we could also call sigset mask today i'm going to use a cig block because	disposition	42
sig block	block	4
alright so something about that let's let's give that give that ago right so will turn off find my code	code	99
so look at that i also chose to write sig_block as well	block	42
ok so here's the big idea to make tcp client i actually only need two calls i need a way to escape out of my c code and actually start talking to the network card and for that i need a socket. so this is the thing that is going to give me a file descriptor and we can pass some information into this is to say what kind of socket we want. do you want a tcp or udp kind of socket in other words do you want to stream based or packet based data ground based kind of socket here. so we'll talk about how to fill these pieces of information in in a moment but i want you to realize that the result of calling socket is just a file descriptor so this if you like is very similar to calling open or very similar to calling pipe. now i've actually got something that i can use	code	111
notice that in both these cases i'm careful to check the error values ok so this will be a non negative value if it is a valid file descriptor if it returns negative one then we know that my attempt to create a socket failed perhaps i don't have privileges perhaps i've created too many sockets. anyways so let's print out the string of error number and quit exit so network code has to check very carefully whether each system call worked but once you've got a socket now you can call connect so again let's check to see if this failed if it returned negative one let's find out our value of errno and print out a useful message and quit	code	375
notice that in both these cases i'm careful to check the error values ok so this will be a non negative value if it is a valid file descriptor if it returns negative one then we know that my attempt to create a socket failed perhaps i don't have privileges perhaps i've created too many sockets. anyways so let's print out the string of error number and quit exit so network code has to check very carefully whether each system call worked but once you've got a socket now you can call connect so again let's check to see if this failed if it returned negative one let's find out our value of errno and print out a useful message and quit	string	327
notice that in both these cases i'm careful to check the error values ok so this will be a non negative value if it is a valid file descriptor if it returns negative one then we know that my attempt to create a socket failed perhaps i don't have privileges perhaps i've created too many sockets. anyways so let's print out the string of error number and quit exit so network code has to check very carefully whether each system call worked but once you've got a socket now you can call connect so again let's check to see if this failed if it returned negative one let's find out our value of errno and print out a useful message and quit	system	421
and let's see what else oh yeah so i can block so if i call read and i haven't got any lights yet from the server then that read call is going to block forever until i do or an error occurs similarly my write call may block until it's able to send those bytes to a buffer	block	41
but we don't know we should also call close just like you have a file descriptor of the file, it's time to free up these resources ok so remember to close it as well	resources	121
right so with this in mind i think it's time to fill in some code here but there's one thing we haven't talked about up here so i said that our tcp server only needs actually two network calls which is true but in practice there's a third one that comes in very very useful and it's the following is this getaddressinfo this is a kind of swiss army knife of a call which can do all sorts of useful things for us and in particular is going to allow us to correctly set these kind of four parameters here for the socket and the network connection and also it allows us to not specify ip addresses directly instead we can "specify domain names like illinois dot edu and getaddressinfo can convert that into an ip for address and even potentially an ipv6 address as well so we don't need to memorize a whole load of ipv4 and ipv6 addresses instead we can use these fully qualified host names and getaddressinfo will convert those for us	the following	283
right so with this in mind i think it's time to fill in some code here but there's one thing we haven't talked about up here so i said that our tcp server only needs actually two network calls which is true but in practice there's a third one that comes in very very useful and it's the following is this getaddressinfo this is a kind of swiss army knife of a call which can do all sorts of useful things for us and in particular is going to allow us to correctly set these kind of four parameters here for the socket and the network connection and also it allows us to not specify ip addresses directly instead we can "specify domain names like illinois dot edu and getaddressinfo can convert that into an ip for address and even potentially an ipv6 address as well so we don't need to memorize a whole load of ipv4 and ipv6 addresses instead we can use these fully qualified host names and getaddressinfo will convert those for us	parameter	487
right so with this in mind i think it's time to fill in some code here but there's one thing we haven't talked about up here so i said that our tcp server only needs actually two network calls which is true but in practice there's a third one that comes in very very useful and it's the following is this getaddressinfo this is a kind of swiss army knife of a call which can do all sorts of useful things for us and in particular is going to allow us to correctly set these kind of four parameters here for the socket and the network connection and also it allows us to not specify ip addresses directly instead we can "specify domain names like illinois dot edu and getaddressinfo can convert that into an ip for address and even potentially an ipv6 address as well so we don't need to memorize a whole load of ipv4 and ipv6 addresses instead we can use these fully qualified host names and getaddressinfo will convert those for us	code	61
right so with this in mind i think it's time to fill in some code here but there's one thing we haven't talked about up here so i said that our tcp server only needs actually two network calls which is true but in practice there's a third one that comes in very very useful and it's the following is this getaddressinfo this is a kind of swiss army knife of a call which can do all sorts of useful things for us and in particular is going to allow us to correctly set these kind of four parameters here for the socket and the network connection and also it allows us to not specify ip addresses directly instead we can "specify domain names like illinois dot edu and getaddressinfo can convert that into an ip for address and even potentially an ipv6 address as well so we don't need to memorize a whole load of ipv4 and ipv6 addresses instead we can use these fully qualified host names and getaddressinfo will convert those for us	address	308
ok right and then what we do well if that's true first fixes let's stop less party on let's let's let's not actually waste anymore time going through the linked list so this code becomes a lot simpler we don't need to do any of these sophisticated checks anymore we're just going to say ok we found what we wanted right and in fact because we found it we can now stop iterating through the linked list so how do we do that we can either add an additional clause or while expression to say and chosen is null or we could just write break here to say ok stop going to the linked list	code	174
block code lessing block splitting keeping track of the starting at the end of your linked list etc then you want to make sure that your pointers are always valid and this is just yet another one to to get get correct so have a play with it but only after you've got some basic placement allocations working alright i will see you in the next video bye	block	0
block code lessing block splitting keeping track of the starting at the end of your linked list etc then you want to make sure that your pointers are always valid and this is just yet another one to to get get correct so have a play with it but only after you've got some basic placement allocations working alright i will see you in the next video bye	code	6
block code lessing block splitting keeping track of the starting at the end of your linked list etc then you want to make sure that your pointers are always valid and this is just yet another one to to get get correct so have a play with it but only after you've got some basic placement allocations working alright i will see you in the next video bye	pointer	137
hi welcome to lecture twenty four let's start with the code review case so we're going to do we're going to look at a fixed sized ring buffer and look at an implementation	code	55
and we know the following things about it so first of all it uses counting semaphores and the first one s one is going to be initialized to two fifty six so this is kind of counting the number of free space is	the following	12
or how much capacity is left s two is initialized to zero so that's counting the number of things we've actually got inside the buffer right now and then we've got lots of threads producing things and consuming things as well ok so here's some questions that we might want to ask in sort of code review first of all can we find a way that deadlock can occur in other words when could it actually get stuck and if so under what conditions could it be for example when it gets completely full or completely empty is underflow possible meaning that is it possible fordequeue to return something even though we don't actually have anything inside the buffer right now in other words it will just return some arbitrary value that happens to be stored inside the buffer	code	291
or how much capacity is left s two is initialized to zero so that's counting the number of things we've actually got inside the buffer right now and then we've got lots of threads producing things and consuming things as well ok so here's some questions that we might want to ask in sort of code review first of all can we find a way that deadlock can occur in other words when could it actually get stuck and if so under what conditions could it be for example when it gets completely full or completely empty is underflow possible meaning that is it possible fordequeue to return something even though we don't actually have anything inside the buffer right now in other words it will just return some arbitrary value that happens to be stored inside the buffer	thread	172
or overwritten some data that we actually do need like an earlier piece of the buffer ok so let's actually take a look at the code now and see what we can find right so the first thing i notice is that we're actually calling mutex lock really early on inside enqueue normally i'd only expect the lock and the unlock to be around the actual call of where we change the change the array here and the second thing i notice is ok good so our buffer size is two fifty six and in fact we're going to wrap around after we get to two hundred fifty five	code	126
so what we've got then is kind of long hold of the mutex lock inside my enqueue here so my concern is with this sem_wait what if i have a thread calling enqueue another those is produced an item wants to queue it up and we call sem_wait but i don't have any space left inside my data structure here in other words what if s one is zero we might have a problem here because now	a struct	282
so what we've got then is kind of long hold of the mutex lock inside my enqueue here so my concern is with this sem_wait what if i have a thread calling enqueue another those is produced an item wants to queue it up and we call sem_wait but i don't have any space left inside my data structure here in other words what if s one is zero we might have a problem here because now	a thread	136
so what we've got then is kind of long hold of the mutex lock inside my enqueue here so my concern is with this sem_wait what if i have a thread calling enqueue another those is produced an item wants to queue it up and we call sem_wait but i don't have any space left inside my data structure here in other words what if s one is zero we might have a problem here because now	thread	138
it's gone to sleep it's blocked inside the same wait call but it's still holding on to the mutex lock this is not a condition variable ok it's just a simple counting semaphore oh dear so can we have deadlock well let's "find out to what happens on the dequeue side so on the	block	24
if we also had onto the mutex lock earlier if our mutex lock had been one of the first things we've done then yes we would have encountered deadlock because the d q could not have continued it would have waited for that that mutex lock that would have never been never been released definition of deadlock waiting for an event that never happens so we didn't find deadlock just there there we came awfully close right what else can we find out about this code then ok so let's see the same post happens early ok that we're actually increasing increasing the count of the number of items in our buffer before we even changed the buffer values ok so we're basically going to add one discounted here so if somebody was waiting to extract value in other words if a thread had already called d cube but was waiting here because the count of s two was zero we're going to release them from that early oh yeah so this land sounds like a recipe for	code	455
if we also had onto the mutex lock earlier if our mutex lock had been one of the first things we've done then yes we would have encountered deadlock because the d q could not have continued it would have waited for that that mutex lock that would have never been never been released definition of deadlock waiting for an event that never happens so we didn't find deadlock just there there we came awfully close right what else can we find out about this code then ok so let's see the same post happens early ok that we're actually increasing increasing the count of the number of items in our buffer before we even changed the buffer values ok so we're basically going to add one discounted here so if somebody was waiting to extract value in other words if a thread had already called d cube but was waiting here because the count of s two was zero we're going to release them from that early oh yeah so this land sounds like a recipe for	a thread	759
if we also had onto the mutex lock earlier if our mutex lock had been one of the first things we've done then yes we would have encountered deadlock because the d q could not have continued it would have waited for that that mutex lock that would have never been never been released definition of deadlock waiting for an event that never happens so we didn't find deadlock just there there we came awfully close right what else can we find out about this code then ok so let's see the same post happens early ok that we're actually increasing increasing the count of the number of items in our buffer before we even changed the buffer values ok so we're basically going to add one discounted here so if somebody was waiting to extract value in other words if a thread had already called d cube but was waiting here because the count of s two was zero we're going to release them from that early oh yeah so this land sounds like a recipe for	thread	761
underflow that because we said we've incremented or pizza box by one even though we had actually put anything into the buffer yet right so is underflow possible will actually in this particular implementation no because my dequeue you cannot complete until the mutex lock is released because it is required before actually touching the buffer if this code tried to be a little bit more performance by giving the nq in the dequeue different mutex locks then we would have run into a problem because then we would have allowed a dq thread to try to read a value from the buffer before we've even put the value in right so better code of course would actually only increment the counting semaphore after we modified the buffer so so this line actually belongs down here so do this later ok and we can do it after we've released a mutex lock ok	code	351
underflow that because we said we've incremented or pizza box by one even though we had actually put anything into the buffer yet right so is underflow possible will actually in this particular implementation no because my dequeue you cannot complete until the mutex lock is released because it is required before actually touching the buffer if this code tried to be a little bit more performance by giving the nq in the dequeue different mutex locks then we would have run into a problem because then we would have allowed a dq thread to try to read a value from the buffer before we've even put the value in right so better code of course would actually only increment the counting semaphore after we modified the buffer so so this line actually belongs down here so do this later ok and we can do it after we've released a mutex lock ok	a mutex	825
underflow that because we said we've incremented or pizza box by one even though we had actually put anything into the buffer yet right so is underflow possible will actually in this particular implementation no because my dequeue you cannot complete until the mutex lock is released because it is required before actually touching the buffer if this code tried to be a little bit more performance by giving the nq in the dequeue different mutex locks then we would have run into a problem because then we would have allowed a dq thread to try to read a value from the buffer before we've even put the value in right so better code of course would actually only increment the counting semaphore after we modified the buffer so so this line actually belongs down here so do this later ok and we can do it after we've released a mutex lock ok	thread	530
then my same weight can can decrement that and my same post will cause increment what that so if at this very moment and q event happens then that can that can continue through an override the very value that i'd like to see we still need all that entries inside my buffer but now because i've posted on s one then if an nq thread appears then they can continue we haven't yet got the mutex lock so they get the mutex lock	thread	324
and then they call same way on s one but we've already incremented it's once they get to continue and then post on some post which will never block and now they overwrite their buffers so it's pretty big unhappy space here yes we've seen a problem here of overflow buffer overflow we overrode a value that we actually need we actually managed to put too much stuff into the buffer now the chances of that happening are pretty small is this very small number of microseconds between us calling sam post and then asking for the mutex lock but that is a non zero value also notice it's actually only really going to be a problem when my buffer is actually completely full so perhaps under light testing or if your website doesn't have many customers then you're not going to see this problem it's only when your buffer actually hit capacity do you have exposure to this problem ok so that's kind of fun stuff to think about reasoning about code like this is tricky my advice is to think about kind of the extreme conditions like underflow and the overflow and what happens if you have say two threads appearing at the same time and what would happen if just before you acquire the mutex lock another thread was able to acquire it instead	block	142
and then they call same way on s one but we've already incremented it's once they get to continue and then post on some post which will never block and now they overwrite their buffers so it's pretty big unhappy space here yes we've seen a problem here of overflow buffer overflow we overrode a value that we actually need we actually managed to put too much stuff into the buffer now the chances of that happening are pretty small is this very small number of microseconds between us calling sam post and then asking for the mutex lock but that is a non zero value also notice it's actually only really going to be a problem when my buffer is actually completely full so perhaps under light testing or if your website doesn't have many customers then you're not going to see this problem it's only when your buffer actually hit capacity do you have exposure to this problem ok so that's kind of fun stuff to think about reasoning about code like this is tricky my advice is to think about kind of the extreme conditions like underflow and the overflow and what happens if you have say two threads appearing at the same time and what would happen if just before you acquire the mutex lock another thread was able to acquire it instead	code	937
and then they call same way on s one but we've already incremented it's once they get to continue and then post on some post which will never block and now they overwrite their buffers so it's pretty big unhappy space here yes we've seen a problem here of overflow buffer overflow we overrode a value that we actually need we actually managed to put too much stuff into the buffer now the chances of that happening are pretty small is this very small number of microseconds between us calling sam post and then asking for the mutex lock but that is a non zero value also notice it's actually only really going to be a problem when my buffer is actually completely full so perhaps under light testing or if your website doesn't have many customers then you're not going to see this problem it's only when your buffer actually hit capacity do you have exposure to this problem ok so that's kind of fun stuff to think about reasoning about code like this is tricky my advice is to think about kind of the extreme conditions like underflow and the overflow and what happens if you have say two threads appearing at the same time and what would happen if just before you acquire the mutex lock another thread was able to acquire it instead	thread	1090
ipoh tracking that file descriptor anymore we might as well remove it from the active set of fire scripters so again here's another kind of example of saying ok if i know how to write this code i can say stop listening for event changes on this particular file descriptor where you don't need to listen so intently in order to make sure we get everything done	code	189
hi welcome to letter twenty four let's start with the code review case so we're going to do we're going to look at a fixed sized ring buffer and look at an implementation	code	54
and we know the following things about it so first of all it uses counting semaphores and the first one s one is going to be initialized to two fifty six so this is kind of counting the number of free space is	the following	12
or how much capacity is left s two is initialized to zero so that's counting the number of things we've actually got inside the buffer right now and then we've got lots of threads producing things and consuming things as well ok so here's some questions that we might want to ask in sort of code review first of all can we find a way that deadlock can occur in other words when good it actually get stuck and if so under what conditions could it be for example when it gets completely full or completely empty is underflow possible meaning that is it possible for d q to return something even though we don't actually have anything inside the buffer right now in other words it will just return some multivalue that happens to be stored inside the buffer	code	291
or how much capacity is left s two is initialized to zero so that's counting the number of things we've actually got inside the buffer right now and then we've got lots of threads producing things and consuming things as well ok so here's some questions that we might want to ask in sort of code review first of all can we find a way that deadlock can occur in other words when good it actually get stuck and if so under what conditions could it be for example when it gets completely full or completely empty is underflow possible meaning that is it possible for d q to return something even though we don't actually have anything inside the buffer right now in other words it will just return some multivalue that happens to be stored inside the buffer	thread	172
or overwritten some data that we actually do need like an earlier piece of the buffer ok so this actually take a look at the code now and see what we can find right so the first thing i notice is that we're actually calling mutex lock really early on inside nq normally i'd only expect the lock and unlock to be around the actual call of where we change the change the array here and the second thing i notice is ok good so our buffer size is two fifty six and in fact we're going to wrap around after we get to two hundred fifty five	code	125
so what we've got then is kind of long hold of the mutex lock inside my enqueue here so my concern is with this same wait what if i have a thread calling nq another those is produced an item wants to queue it up and we call some weight but i don't have any space left inside my data structure here in other words what if s one is zero we might have a problem here because now	a struct	281
so what we've got then is kind of long hold of the mutex lock inside my enqueue here so my concern is with this same wait what if i have a thread calling nq another those is produced an item wants to queue it up and we call some weight but i don't have any space left inside my data structure here in other words what if s one is zero we might have a problem here because now	a thread	137
so what we've got then is kind of long hold of the mutex lock inside my enqueue here so my concern is with this same wait what if i have a thread calling nq another those is produced an item wants to queue it up and we call some weight but i don't have any space left inside my data structure here in other words what if s one is zero we might have a problem here because now	thread	139
it's gone to sleep it's blocked inside the same weight call but it's still holding on to the mutex lock this is not a condition variable ok it's just a simple counting semaphore oh dear so can we have deadlock well let's find out to what happens on the d q side so on the dq side	block	24
if we also had onto the mutex lock earlier if our musics lock had been one of the first things we've done then yes we would have encountered deadlock because the d q could not have continued it would have waited for that that mutex lock that would have never been never been released definition of deadlock waiting for an event that never happens so we didn't find deadlock just there there we came awfully close right what else can we find out about this code then ok so let's see the same post happens early ok that we're actually increasing increasing the count of the number of items in our buffer before we even changed the buffer values ok so we're basically going to add one discounted here so if somebody was waiting to extract value in other words if a thread had already called d cube but was waiting here because the count of s two was zero we're going to release them from that early oh yeah so this land sounds like a recipe for	code	456
if we also had onto the mutex lock earlier if our musics lock had been one of the first things we've done then yes we would have encountered deadlock because the d q could not have continued it would have waited for that that mutex lock that would have never been never been released definition of deadlock waiting for an event that never happens so we didn't find deadlock just there there we came awfully close right what else can we find out about this code then ok so let's see the same post happens early ok that we're actually increasing increasing the count of the number of items in our buffer before we even changed the buffer values ok so we're basically going to add one discounted here so if somebody was waiting to extract value in other words if a thread had already called d cube but was waiting here because the count of s two was zero we're going to release them from that early oh yeah so this land sounds like a recipe for	a thread	760
if we also had onto the mutex lock earlier if our musics lock had been one of the first things we've done then yes we would have encountered deadlock because the d q could not have continued it would have waited for that that mutex lock that would have never been never been released definition of deadlock waiting for an event that never happens so we didn't find deadlock just there there we came awfully close right what else can we find out about this code then ok so let's see the same post happens early ok that we're actually increasing increasing the count of the number of items in our buffer before we even changed the buffer values ok so we're basically going to add one discounted here so if somebody was waiting to extract value in other words if a thread had already called d cube but was waiting here because the count of s two was zero we're going to release them from that early oh yeah so this land sounds like a recipe for	thread	762
underflow that because we said we've incremented or pizza box by one even though we had actually put anything into the buffer yet right so is underflow possible will actually in this particular implementation no because my dick you cannot complete until the mutex lock is released because it is required before actually touching the buffer if this code tried to be a little bit more performance by giving the nq in the dequeue different mutex locks then we would have run into a problem because then we would have allowed a dq thread to try to read a value from the buffer before we've even put the value in right so better code of course would actually only increment the counting semaphore after we modified the buffer so so this line actually belongs down here so do this later ok and we can do it after we've released a mutex lock ok	code	348
underflow that because we said we've incremented or pizza box by one even though we had actually put anything into the buffer yet right so is underflow possible will actually in this particular implementation no because my dick you cannot complete until the mutex lock is released because it is required before actually touching the buffer if this code tried to be a little bit more performance by giving the nq in the dequeue different mutex locks then we would have run into a problem because then we would have allowed a dq thread to try to read a value from the buffer before we've even put the value in right so better code of course would actually only increment the counting semaphore after we modified the buffer so so this line actually belongs down here so do this later ok and we can do it after we've released a mutex lock ok	a mutex	822
underflow that because we said we've incremented or pizza box by one even though we had actually put anything into the buffer yet right so is underflow possible will actually in this particular implementation no because my dick you cannot complete until the mutex lock is released because it is required before actually touching the buffer if this code tried to be a little bit more performance by giving the nq in the dequeue different mutex locks then we would have run into a problem because then we would have allowed a dq thread to try to read a value from the buffer before we've even put the value in right so better code of course would actually only increment the counting semaphore after we modified the buffer so so this line actually belongs down here so do this later ok and we can do it after we've released a mutex lock ok	thread	527
then my same weight can can decorate that and my same post will cause increment what that so if at this very moment and q event happens then that can that can continue through an override the very value that i'd like to see we still need all that entries inside my buffer but now because i've posted on s one then if an nq thread appears then they can continue we haven't yet got the mutex lock so they get the mutex lock	thread	323
and then they call same way on s one but we've already incremented it's once they get to continue and then post on some post which will never block and now they overwrite their buffers so it's pretty big unhappy space here yes we've seen a problem here of overflow buffer overflow we overrode a value that we actually need we actually managed to put too much stuff into the buffer now the chances of that happening are pretty small is this very small number of microseconds between us calling sam post and then asking for the mutex lock but that is a non zero value also notice it's actually only really going to be a problem when my buffer is actually completely full so perhaps under light testing or if your website doesn't have many customers then you're not going to see this problem it's only when your buffer actually hit capacity do you have exposure to this problem ok so that's kind of fun stuff to think about reasoning about code like this is tricky my advice is to think about kind of the extreme conditions like underflow and the overflow and what happens if you have say two threads appearing at the same time and what would happen if just before you acquire the mutex lock another thread was able to acquire it instead	block	142
and then they call same way on s one but we've already incremented it's once they get to continue and then post on some post which will never block and now they overwrite their buffers so it's pretty big unhappy space here yes we've seen a problem here of overflow buffer overflow we overrode a value that we actually need we actually managed to put too much stuff into the buffer now the chances of that happening are pretty small is this very small number of microseconds between us calling sam post and then asking for the mutex lock but that is a non zero value also notice it's actually only really going to be a problem when my buffer is actually completely full so perhaps under light testing or if your website doesn't have many customers then you're not going to see this problem it's only when your buffer actually hit capacity do you have exposure to this problem ok so that's kind of fun stuff to think about reasoning about code like this is tricky my advice is to think about kind of the extreme conditions like underflow and the overflow and what happens if you have say two threads appearing at the same time and what would happen if just before you acquire the mutex lock another thread was able to acquire it instead	code	937
and then they call same way on s one but we've already incremented it's once they get to continue and then post on some post which will never block and now they overwrite their buffers so it's pretty big unhappy space here yes we've seen a problem here of overflow buffer overflow we overrode a value that we actually need we actually managed to put too much stuff into the buffer now the chances of that happening are pretty small is this very small number of microseconds between us calling sam post and then asking for the mutex lock but that is a non zero value also notice it's actually only really going to be a problem when my buffer is actually completely full so perhaps under light testing or if your website doesn't have many customers then you're not going to see this problem it's only when your buffer actually hit capacity do you have exposure to this problem ok so that's kind of fun stuff to think about reasoning about code like this is tricky my advice is to think about kind of the extreme conditions like underflow and the overflow and what happens if you have say two threads appearing at the same time and what would happen if just before you acquire the mutex lock another thread was able to acquire it instead	thread	1090
good example here is perhaps our parent process was the shell we've logged in we ssh-ed in for example and we've type something to run and now we use fork to start a child process perhaps that child process for example is going to be running gcc but anyway for whatever reason it finishes and so now we want to make our original parent process wait for that how do we do that well we now make use of another call called wait or wait pid if i use weight pid i could actually specify a particular child process i'd like to wait for so for example let's wait for process number hundred and thirty two but we can do more than that we can say hey kernel please not only wait for this particular	type	113
process to finish but give me some hints tell me what happened to it i want to forensically find out why it why and how it exited so will pass in the address of an integer ok so here's the address of some little integer like s for status or something	address	150
right so i'm going to get back a limited number of bits of information and in fact this integer is packed full of good stuff it tells us the exit value that you may have defined in when exchange program by either calling exit or by returning from main or if your program crash for example it tried to read and write some invalid memory like memory location zero then it's going to segfault and we could discover that well or if your program was perfectly happily running along and somebody press control c and interrupted it then would crash your program then we can discover that too so all this information is encoded inside this little integer now i could tell you things like and on this particular system the exit value at least the eight bits the lowest 8 bits basically exact value are encoded somewhere somehow inside this integer perhaps in the lowest bits, perhaps in the highest bits,	memory	329
right so i'm going to get back a limited number of bits of information and in fact this integer is packed full of good stuff it tells us the exit value that you may have defined in when exchange program by either calling exit or by returning from main or if your program crash for example it tried to read and write some invalid memory like memory location zero then it's going to segfault and we could discover that well or if your program was perfectly happily running along and somebody press control c and interrupted it then would crash your program then we can discover that too so all this information is encoded inside this little integer now i could tell you things like and on this particular system the exit value at least the eight bits the lowest 8 bits basically exact value are encoded somewhere somehow inside this integer perhaps in the lowest bits, perhaps in the highest bits,	code	614
right so i'm going to get back a limited number of bits of information and in fact this integer is packed full of good stuff it tells us the exit value that you may have defined in when exchange program by either calling exit or by returning from main or if your program crash for example it tried to read and write some invalid memory like memory location zero then it's going to segfault and we could discover that well or if your program was perfectly happily running along and somebody press control c and interrupted it then would crash your program then we can discover that too so all this information is encoded inside this little integer now i could tell you things like and on this particular system the exit value at least the eight bits the lowest 8 bits basically exact value are encoded somewhere somehow inside this integer perhaps in the lowest bits, perhaps in the highest bits,	exchange	186
right so i'm going to get back a limited number of bits of information and in fact this integer is packed full of good stuff it tells us the exit value that you may have defined in when exchange program by either calling exit or by returning from main or if your program crash for example it tried to read and write some invalid memory like memory location zero then it's going to segfault and we could discover that well or if your program was perfectly happily running along and somebody press control c and interrupted it then would crash your program then we can discover that too so all this information is encoded inside this little integer now i could tell you things like and on this particular system the exit value at least the eight bits the lowest 8 bits basically exact value are encoded somewhere somehow inside this integer perhaps in the lowest bits, perhaps in the highest bits,	system	703
ok if that is true then we can pull out more information we can actually find out the exit status at least the lower state bits and that's the code actually that you will find as part of a particular android linux based system i pulled this from the as you can see android dot google source but in practice we would never actually productive write this expression we can just make use of the macro suppose you wanted to check to see whether your child process didn't exit normally but instead actually	code	143
ok if that is true then we can pull out more information we can actually find out the exit status at least the lower state bits and that's the code actually that you will find as part of a particular android linux based system i pulled this from the as you can see android dot google source but in practice we would never actually productive write this expression we can just make use of the macro suppose you wanted to check to see whether your child process didn't exit normally but instead actually	system	220
let's let's have a look at that in a little bit but for now i want you to appreciate that this basic mechanism of forking and then waiting is fundamental to all of the processes that you have running on your system in the beginning there's just one process process number one at some point when we bring up the system will be a second process it's listing on port twenty two for s for people to ssh into the way another process is running the local screen waiting for you to log in there and then when you log in through whatever mechanism you start up a terminal a bash command line interface	a terminal	553
let's let's have a look at that in a little bit but for now i want you to appreciate that this basic mechanism of forking and then waiting is fundamental to all of the processes that you have running on your system in the beginning there's just one process process number one at some point when we bring up the system will be a second process it's listing on port twenty two for s for people to ssh into the way another process is running the local screen waiting for you to log in there and then when you log in through whatever mechanism you start up a terminal a bash command line interface	system	208
ok sir yeah we talked about race conditions what i meant to say is let's talk about a critical section	section	95
so here's here's an important idea that there's possible code that is necessary that only one thread at a time should be executing because in that moment inside part of that code is where we are updating some resource for example updating some data structure or updating a file in a critical way and it's important that no are the process or thread updates at resource at the same time so it's critical that we prevent other threads or processes from also being inside a critical section at the same time so lots of kind of examples and in the real world where there's there's moments in time where we only want kind of one person to be working on something at a time or save as a database you might implement a database so it's critical that only one process updates particular row at a time ok so you can imagine that if we were doing code review you might say hold on a moment there i've got a race condition here between say my implement incrementing i and when we actually reading the value of i in our previous code when we were taking the value of this pointer	a struct	247
so here's here's an important idea that there's possible code that is necessary that only one thread at a time should be executing because in that moment inside part of that code is where we are updating some resource for example updating some data structure or updating a file in a critical way and it's important that no are the process or thread updates at resource at the same time so it's critical that we prevent other threads or processes from also being inside a critical section at the same time so lots of kind of examples and in the real world where there's there's moments in time where we only want kind of one person to be working on something at a time or save as a database you might implement a database so it's critical that only one process updates particular row at a time ok so you can imagine that if we were doing code review you might say hold on a moment there i've got a race condition here between say my implement incrementing i and when we actually reading the value of i in our previous code when we were taking the value of this pointer	code	57
so here's here's an important idea that there's possible code that is necessary that only one thread at a time should be executing because in that moment inside part of that code is where we are updating some resource for example updating some data structure or updating a file in a critical way and it's important that no are the process or thread updates at resource at the same time so it's critical that we prevent other threads or processes from also being inside a critical section at the same time so lots of kind of examples and in the real world where there's there's moments in time where we only want kind of one person to be working on something at a time or save as a database you might implement a database so it's critical that only one process updates particular row at a time ok so you can imagine that if we were doing code review you might say hold on a moment there i've got a race condition here between say my implement incrementing i and when we actually reading the value of i in our previous code when we were taking the value of this pointer	section	480
so here's here's an important idea that there's possible code that is necessary that only one thread at a time should be executing because in that moment inside part of that code is where we are updating some resource for example updating some data structure or updating a file in a critical way and it's important that no are the process or thread updates at resource at the same time so it's critical that we prevent other threads or processes from also being inside a critical section at the same time so lots of kind of examples and in the real world where there's there's moments in time where we only want kind of one person to be working on something at a time or save as a database you might implement a database so it's critical that only one process updates particular row at a time ok so you can imagine that if we were doing code review you might say hold on a moment there i've got a race condition here between say my implement incrementing i and when we actually reading the value of i in our previous code when we were taking the value of this pointer	thread	94
so here's here's an important idea that there's possible code that is necessary that only one thread at a time should be executing because in that moment inside part of that code is where we are updating some resource for example updating some data structure or updating a file in a critical way and it's important that no are the process or thread updates at resource at the same time so it's critical that we prevent other threads or processes from also being inside a critical section at the same time so lots of kind of examples and in the real world where there's there's moments in time where we only want kind of one person to be working on something at a time or save as a database you might implement a database so it's critical that only one process updates particular row at a time ok so you can imagine that if we were doing code review you might say hold on a moment there i've got a race condition here between say my implement incrementing i and when we actually reading the value of i in our previous code when we were taking the value of this pointer	pointer	1060
so we have synchronization bug and it would have been solved if we identified a critical section and said ok we need to divide a moment in time so that define a moment in time so that the value can be read independently of the update	section	89
ok so we'll talk more about critical sections in the future but like i said the big idea is that only one thread at a time should be inside a critical section if our program is to behave correctly	section	37
ok so we'll talk more about critical sections in the future but like i said the big idea is that only one thread at a time should be inside a critical section if our program is to behave correctly	thread	106
so how can we identify what can we do to ensure this and one way to do that is to put locks around our critical section code for example suppose you had some code from cs two twenty five that is going to say insert a link right on a data structure and this price is going to work in the linked list price is going to work on a vector and inside that code you realize that there's a moment in time where you're going to say of mess with the pointers or you're going to copy the entire data structure from us one sized piece of resource to say a doubling of the resources some other piece of memory over there ok so that's a critical section what we need to do then is to block any other threads that want to do a similar operation we want to somehow say right i want to give you exclusive access to this right now so the only you this comment thread is executing in this code gets too	memory	590
so how can we identify what can we do to ensure this and one way to do that is to put locks around our critical section code for example suppose you had some code from cs two twenty five that is going to say insert a link right on a data structure and this price is going to work in the linked list price is going to work on a vector and inside that code you realize that there's a moment in time where you're going to say of mess with the pointers or you're going to copy the entire data structure from us one sized piece of resource to say a doubling of the resources some other piece of memory over there ok so that's a critical section what we need to do then is to block any other threads that want to do a similar operation we want to somehow say right i want to give you exclusive access to this right now so the only you this comment thread is executing in this code gets too	block	670
so how can we identify what can we do to ensure this and one way to do that is to put locks around our critical section code for example suppose you had some code from cs two twenty five that is going to say insert a link right on a data structure and this price is going to work in the linked list price is going to work on a vector and inside that code you realize that there's a moment in time where you're going to say of mess with the pointers or you're going to copy the entire data structure from us one sized piece of resource to say a doubling of the resources some other piece of memory over there ok so that's a critical section what we need to do then is to block any other threads that want to do a similar operation we want to somehow say right i want to give you exclusive access to this right now so the only you this comment thread is executing in this code gets too	a struct	236
so how can we identify what can we do to ensure this and one way to do that is to put locks around our critical section code for example suppose you had some code from cs two twenty five that is going to say insert a link right on a data structure and this price is going to work in the linked list price is going to work on a vector and inside that code you realize that there's a moment in time where you're going to say of mess with the pointers or you're going to copy the entire data structure from us one sized piece of resource to say a doubling of the resources some other piece of memory over there ok so that's a critical section what we need to do then is to block any other threads that want to do a similar operation we want to somehow say right i want to give you exclusive access to this right now so the only you this comment thread is executing in this code gets too	code	120
so how can we identify what can we do to ensure this and one way to do that is to put locks around our critical section code for example suppose you had some code from cs two twenty five that is going to say insert a link right on a data structure and this price is going to work in the linked list price is going to work on a vector and inside that code you realize that there's a moment in time where you're going to say of mess with the pointers or you're going to copy the entire data structure from us one sized piece of resource to say a doubling of the resources some other piece of memory over there ok so that's a critical section what we need to do then is to block any other threads that want to do a similar operation we want to somehow say right i want to give you exclusive access to this right now so the only you this comment thread is executing in this code gets too	section	112
so how can we identify what can we do to ensure this and one way to do that is to put locks around our critical section code for example suppose you had some code from cs two twenty five that is going to say insert a link right on a data structure and this price is going to work in the linked list price is going to work on a vector and inside that code you realize that there's a moment in time where you're going to say of mess with the pointers or you're going to copy the entire data structure from us one sized piece of resource to say a doubling of the resources some other piece of memory over there ok so that's a critical section what we need to do then is to block any other threads that want to do a similar operation we want to somehow say right i want to give you exclusive access to this right now so the only you this comment thread is executing in this code gets too	thread	686
so how can we identify what can we do to ensure this and one way to do that is to put locks around our critical section code for example suppose you had some code from cs two twenty five that is going to say insert a link right on a data structure and this price is going to work in the linked list price is going to work on a vector and inside that code you realize that there's a moment in time where you're going to say of mess with the pointers or you're going to copy the entire data structure from us one sized piece of resource to say a doubling of the resources some other piece of memory over there ok so that's a critical section what we need to do then is to block any other threads that want to do a similar operation we want to somehow say right i want to give you exclusive access to this right now so the only you this comment thread is executing in this code gets too	resources	560
so how can we identify what can we do to ensure this and one way to do that is to put locks around our critical section code for example suppose you had some code from cs two twenty five that is going to say insert a link right on a data structure and this price is going to work in the linked list price is going to work on a vector and inside that code you realize that there's a moment in time where you're going to say of mess with the pointers or you're going to copy the entire data structure from us one sized piece of resource to say a doubling of the resources some other piece of memory over there ok so that's a critical section what we need to do then is to block any other threads that want to do a similar operation we want to somehow say right i want to give you exclusive access to this right now so the only you this comment thread is executing in this code gets too	pointer	440
gets to modify this data structure anybody else that wants to insert something into my data structure or iterate over the linked list or get a value that just going to have to wait until i finished operating on my data structure ok so only one surgeon at a time is the mantra here and how we're going to do that well i'm going to introduce you to our first synchronization primitive in a moment and that is going to be called a mutex alright so i'll see you in the next video when we start talking about new taxes in particular p three music clocks rp thread mutex	a struct	23
gets to modify this data structure anybody else that wants to insert something into my data structure or iterate over the linked list or get a value that just going to have to wait until i finished operating on my data structure ok so only one surgeon at a time is the mantra here and how we're going to do that well i'm going to introduce you to our first synchronization primitive in a moment and that is going to be called a mutex alright so i'll see you in the next video when we start talking about new taxes in particular p three music clocks rp thread mutex	a mutex	426
gets to modify this data structure anybody else that wants to insert something into my data structure or iterate over the linked list or get a value that just going to have to wait until i finished operating on my data structure ok so only one surgeon at a time is the mantra here and how we're going to do that well i'm going to introduce you to our first synchronization primitive in a moment and that is going to be called a mutex alright so i'll see you in the next video when we start talking about new taxes in particular p three music clocks rp thread mutex	thread	552
ok hi right so let's think about lock contention and also how this also relates to discovering race conditions ok so here's the scenario that we're going to think about that i've got a thread that most of the time is not inside the critical section and in fact if we sketch this out you'll see that initially i just got one single thread and only for a short period of time just one millisecond it's actually doing something inside a critical section that we haven't yet protected with any mutex locks but for the other nine hundred and ninety nine milliseconds	a thread	183
ok hi right so let's think about lock contention and also how this also relates to discovering race conditions ok so here's the scenario that we're going to think about that i've got a thread that most of the time is not inside the critical section and in fact if we sketch this out you'll see that initially i just got one single thread and only for a short period of time just one millisecond it's actually doing something inside a critical section that we haven't yet protected with any mutex locks but for the other nine hundred and ninety nine milliseconds	section	241
ok hi right so let's think about lock contention and also how this also relates to discovering race conditions ok so here's the scenario that we're going to think about that i've got a thread that most of the time is not inside the critical section and in fact if we sketch this out you'll see that initially i just got one single thread and only for a short period of time just one millisecond it's actually doing something inside a critical section that we haven't yet protected with any mutex locks but for the other nine hundred and ninety nine milliseconds	thread	185
is doing something else so this thing runs for one second and then it's some random type there's one second ok some random sign inside that just for one day second it goes and visits a critical section may be updates or reads a particular data structure ok so now that's fine but now we have two threads so here's another fit that also is going to run for the same second	type	84
is doing something else so this thing runs for one second and then it's some random type there's one second ok some random sign inside that just for one day second it goes and visits a critical section may be updates or reads a particular data structure ok so now that's fine but now we have two threads so here's another fit that also is going to run for the same second	a struct	242
is doing something else so this thing runs for one second and then it's some random type there's one second ok some random sign inside that just for one day second it goes and visits a critical section may be updates or reads a particular data structure ok so now that's fine but now we have two threads so here's another fit that also is going to run for the same second	section	194
is doing something else so this thing runs for one second and then it's some random type there's one second ok some random sign inside that just for one day second it goes and visits a critical section may be updates or reads a particular data structure ok so now that's fine but now we have two threads so here's another fit that also is going to run for the same second	thread	296
there we go and inside this it also might visit the critical section	section	61
ok of time where is ashley inside the the critical section so as we know everything will find our programs deterministic our program or function as expected provided these two don't meet another words providing they don't actually overlap right so could we estimate this will sure we could set up a full integral and think about how we think about these two random times as a whole bunch of times where they don't overlap and then there's times when they start overlap fully overlap and then only overlap a little bit again and then other times when we don't so we could set it up to set this up as a as a two dimensional integral but we just want to estimate this today so we're not going to worry about things like edge effects where where the very first thread goes into the critical section at the very end so it's not possible to overlap full or very visits critical section at the very end where it's not possible to overlap afterwards so let's not worry about that let's just concentrate on the idea that ninety nine point nine percent of the time my first date is not inside the critical section so we're going to look at the majority case an ignore the edge cases so right i thought and playing battleships with you now so i've thought of one moment in time where it is inside the critical section now you get to think of a number where you get to say ok right i'm going to choose my second thread to be inside this critical section what's the chances that we sunk the battleship what's the chances that they've overlapped	section	51
ok of time where is ashley inside the the critical section so as we know everything will find our programs deterministic our program or function as expected provided these two don't meet another words providing they don't actually overlap right so could we estimate this will sure we could set up a full integral and think about how we think about these two random times as a whole bunch of times where they don't overlap and then there's times when they start overlap fully overlap and then only overlap a little bit again and then other times when we don't so we could set it up to set this up as a as a two dimensional integral but we just want to estimate this today so we're not going to worry about things like edge effects where where the very first thread goes into the critical section at the very end so it's not possible to overlap full or very visits critical section at the very end where it's not possible to overlap afterwards so let's not worry about that let's just concentrate on the idea that ninety nine point nine percent of the time my first date is not inside the critical section so we're going to look at the majority case an ignore the edge cases so right i thought and playing battleships with you now so i've thought of one moment in time where it is inside the critical section now you get to think of a number where you get to say ok right i'm going to choose my second thread to be inside this critical section what's the chances that we sunk the battleship what's the chances that they've overlapped	thread	757
ok right so how can we analyze this i've got a one millisecond air slot here so there is actually a window of just two milliseconds where your choose a different color let's go for say loop again where your timing of your thread might overlap my critical window ok so we might be exactly the same or we might be just afterwards ok so there's just a two millisecond window here alright so how likely is it that you will actually achieve this well remember we said the timing is random so given that you're choosing these times all random you've got a two millisecond out of one out of one second window in other words are roughly about one hundred thousand dollar you want to be a little bit more accurate you might say roughly say one out of five hundred so so i could say	thread	222
right so that sounds actually pretty good or pretty bad depending on whether you truly want to try to discover this problem or you're hoping that your code works so even though we know we gotta race condition even though we know we didn't actually implement the locks we have a problem here which is this two percent chance that all code will fail	code	151
because two threads of enter the critical section at the same time right so if we test our code once twice three times ten times as are very strong chance that we won't notice this effect we've only going to see this one time out of five hundred approximately like i said we didn't do the exact integral but this means that actually make race conditions to occur can be quite hard now we went for figures that said	code	91
because two threads of enter the critical section at the same time right so if we test our code once twice three times ten times as are very strong chance that we won't notice this effect we've only going to see this one time out of five hundred approximately like i said we didn't do the exact integral but this means that actually make race conditions to occur can be quite hard now we went for figures that said	section	42
because two threads of enter the critical section at the same time right so if we test our code once twice three times ten times as are very strong chance that we won't notice this effect we've only going to see this one time out of five hundred approximately like i said we didn't do the exact integral but this means that actually make race conditions to occur can be quite hard now we went for figures that said	thread	12
the race the critical section took one millisecond dirt to run if you're critical section was much smaller than that for example in the code that we've just looked at with the push in the pop or adding another part that might only be orders of say ten microseconds so now the chances of of of threads being inside the critical section is actually slimmer so discovering problems just by testing is hard and that is why we do things like locate don't want it with two threads but when it with four threads now it's much more likely to occur or test it with a brute force loop trying to go into the critical section as often as possible and now you've increased the chances significantly this also applies to the idea of lock contention so lock contention is not a good thing it means that one thread is being forced to wait for another now we did this because we want programs to function correctly	code	136
the race the critical section took one millisecond dirt to run if you're critical section was much smaller than that for example in the code that we've just looked at with the push in the pop or adding another part that might only be orders of say ten microseconds so now the chances of of of threads being inside the critical section is actually slimmer so discovering problems just by testing is hard and that is why we do things like locate don't want it with two threads but when it with four threads now it's much more likely to occur or test it with a brute force loop trying to go into the critical section as often as possible and now you've increased the chances significantly this also applies to the idea of lock contention so lock contention is not a good thing it means that one thread is being forced to wait for another now we did this because we want programs to function correctly	section	22
the race the critical section took one millisecond dirt to run if you're critical section was much smaller than that for example in the code that we've just looked at with the push in the pop or adding another part that might only be orders of say ten microseconds so now the chances of of of threads being inside the critical section is actually slimmer so discovering problems just by testing is hard and that is why we do things like locate don't want it with two threads but when it with four threads now it's much more likely to occur or test it with a brute force loop trying to go into the critical section as often as possible and now you've increased the chances significantly this also applies to the idea of lock contention so lock contention is not a good thing it means that one thread is being forced to wait for another now we did this because we want programs to function correctly	thread	293
but if we held onto a lock for an unnecessarily extended amount of time now we're going to start to see an unwanted and unnecessary performance impact so right now we saw with a little rough back of the envelope calculation calculation there was only one point two percent chance of the two threads asking for the lock at the	thread	291
so one one of the thousand basically so we don't expect the css significant performance impact because of two threads updating this however if our code was different if we had threads which say wanted to update the data structure ten milliseconds out of one hundred milliseconds so now there's a one in ten chance that the lock that we asked for is is already in use	the data structure	211
so one one of the thousand basically so we don't expect the css significant performance impact because of two threads updating this however if our code was different if we had threads which say wanted to update the data structure ten milliseconds out of one hundred milliseconds so now there's a one in ten chance that the lock that we asked for is is already in use	a struct	218
so one one of the thousand basically so we don't expect the css significant performance impact because of two threads updating this however if our code was different if we had threads which say wanted to update the data structure ten milliseconds out of one hundred milliseconds so now there's a one in ten chance that the lock that we asked for is is already in use	code	147
so one one of the thousand basically so we don't expect the css significant performance impact because of two threads updating this however if our code was different if we had threads which say wanted to update the data structure ten milliseconds out of one hundred milliseconds so now there's a one in ten chance that the lock that we asked for is is already in use	thread	110
we don't want lock contention but on the other hand we want to be able to discover our race conditions as soon as possible in women during our testing before we put it into production before we start relying on this code to save lives or to move money or to give demos etc 's so race conditions are tricky is the big takeaway message and you could do back of the envelope calculation to see why it's difficult to detect these	code	216
ok right so with that in mind that means that our debugging skills understanding of how code can interleave	code	88
can is important are believed to actually reason about our code is just as important as being up to test	code	59
test it ok so here's here's the code we've got i'd like you to kind of look at this code and tell me what do you think it's going to do right so i've got i've got a couple of threads in a mutex as global variables up here ok	code	32
test it ok so here's here's the code we've got i'd like you to kind of look at this code and tell me what do you think it's going to do right so i've got i've got a couple of threads in a mutex as global variables up here ok	a mutex	186
test it ok so here's here's the code we've got i'd like you to kind of look at this code and tell me what do you think it's going to do right so i've got i've got a couple of threads in a mutex as global variables up here ok	thread	175
right and i've got a public counter global variable you can see i'm incrementing it inside this function and each thread that i'm going to create down here inside my main is going to run this code for a million times right so with that in mind what do you think it's going to do it i will tell you the answer that in the next lecture but why don't you pause this right now and make your prediction by	code	192
right and i've got a public counter global variable you can see i'm incrementing it inside this function and each thread that i'm going to create down here inside my main is going to run this code for a million times right so with that in mind what do you think it's going to do it i will tell you the answer that in the next lecture but why don't you pause this right now and make your prediction by	thread	114
but let's not go down there instead let's actually think about kind of one possibility ok so the story so far i've got myself and i knowed remember that i knows themselves or fixed size say one hundred and twenty eight bytes or so we don't have much space on them so definitely we want to store the meta information on it like say when this file was created or modified etc but then we actually want to say ok but if you hey there ;) can tell you where to load them so if my content serves cat dot jpeg is on disk block kind of three seven fifty nine etc i need to store these numbers somewhere ok so our first idea then is to say look for very small files why don't i actually store the actual disk block numbers so say three	block	514
ten direct this blocks ok so providing my file is not too big right so what does it mean to be too big right so how big is each disk block well is dis block remember we said it's going to be four kb ok so for files which	block	16
instead it passes the buck and says well if you actually want to read the fourth thousands the ninety seventh byte or higher i'm not going to tell you but i know someone who can why do you go to this particular dis block let's say on disk this happens to be a some arbitrary location like say this block number one hundred thirty seven go and read that and from that you can find out where the contents of the fourth albums and ninety seventh byte is so for these larger files the beginnings of the file you can still access immediately right you still know exactly where to go on the disk right we can get these straight away but as you progress into the file you're going to have to work a little bit harder so after forty kilobytes this is what you're going to have to do you read one extra disk block so you're going to go back to the disk and say hey i need four kb please and this will tell you where the next set of disk blocks are ok so they will be somewhat on the disk and where on disk will be stored inside this little table so let's talk about this little table	block	215
if my disk block numbers can be represented using four bytes	block	11
entries that i can store inside of this block so this diagram is very very incomplete there's actually many many many many more of these so there's a thousand and twenty four so called indirect blocks and they called indirect blocks because i had to load this in director table i had a performance hit whilst i	block	40
so now we can actually read the next quantity of one thousand and twenty four so wonderful great now i can start working with much larger files like i'm going to repeat myself again the first forty kilobytes of every file does matter is small or large we don't need to play this trick ok that we get this directly from the i node but for the forty first bite we can workout that i should go to the very first entry inside my indirect block table so i need to load this block and then follow the first entry and great i've now got myself another four kb	block	434
as i keep reading the file i'm going to workout which entries inside here i need to go to and each time will give you another diss block number to read from disk and i can keep reading the next four kb again for performance hopefully these are next door neighbors but they don't have to be they in fact it could be anywhere on the disk right so that's pretty good how big a file can we actually represent with this system so if my indirect table here is full	block	131
as i keep reading the file i'm going to workout which entries inside here i need to go to and each time will give you another diss block number to read from disk and i can keep reading the next four kb again for performance hopefully these are next door neighbors but they don't have to be they in fact it could be anywhere on the disk right so that's pretty good how big a file can we actually represent with this system so if my indirect table here is full	system	415
in other words my indirect blocks can hold four megabytes worth of information so this scheme will work providing i don't exceed four megabytes plus my direct blocks which i said there's ten of them so i've got forty kb ok that should be big enough for everybody can't imagine why anybody would want to store more information than that except when they do so what happens when we have files even larger than that well for these now huge files the initial part of the file again is stored as direct inside direct blocks the thinking being is quite often you would just want fast access to the beginning of the file after that will use this in director scheme but after that after we've exceeded this limit that we've just calculated we're going to play a new trick so now there's another entry inside the i node which says you know what i can't tell you where the next bite is going to be stored but i know someone that knows someone about where to go so great we read a disc lock off four kilobyte read here and again we have a little table thousand and twenty four entries inside it	block	27
but those entries themselves are not the answer i look this we're doing a second look up so we have to go back to our disk to read another little table and so this is a lot like kind of the page table tricks that we sought with virtual memory and finally this gives us the actual disk block that will actually hold the data so finally we can meet the next four kilobytes of data ok so how much can we store with this double indirection scheme here ok so	memory	236
but those entries themselves are not the answer i look this we're doing a second look up so we have to go back to our disk to read another little table and so this is a lot like kind of the page table tricks that we sought with virtual memory and finally this gives us the actual disk block that will actually hold the data so finally we can meet the next four kilobytes of data ok so how much can we store with this double indirection scheme here ok so	block	285
so for my double indirect blocks i've actually got	block	26
i need to be able to do math to say why is it less than four kilobytes in which case which one of these disk blocks is it direct blocks is it in the next range in which case which one of these are thousand and twenty four entries do i need to read ok and therefore where inside a particular this block do i need to read and watch the offset inside that particular block and finally if it's using this double indirect rick i need to read want table block and then a second one as well before i can finally find out where the actual data is stored ok are we done will actually it turns out there are triple indirect blocks as well but after that we stop so actually there's one more entry inside here there we go i'll just fight it now but the last entry here gives me a data block but sorry i block a table which doesn't give me the answer i had to use that to read one of one thousand and twenty four entries that doesn't give me the answer either and that itself gives me another block over thousand twenty four and that finally will actually lead me to the real data so one way we could have taken static picture here i want you to imagine how as you were making a larger larger file how this might actually fill up kind of initially we're just working on this very first this block as we make our file greater than four kb now we start writing bytes into this dis block as we keep going we need to find a new disk block which is available so we started writing bytes in there and so on and so on and so on and keep doing for the first forty kb and then what happens well now we need to find	block	109
a in director table so we find space on disk for that and then we start writing our data into the boat first indirect block here once that's filled up after four kb we need a second one of course will update our little table and we can keep playing this trick for thousand twenty four times and then we start making work as we kind of create these double indirect blocks and	block	118
you can see how there is some overhead here that have all of these blocks which don't actually hold any data over any cats or any other white actually useful content but the good thing about this scheme is that access to the beginning of the file is very very fast and i only pay for the overhead of all of these additional blocks for very large files so that's how i know addressing scheme i imagine that will have an assignment kind of based on this where you actually kind of can implement this scheme in order to read or write some exist some files onto an actual file system with us it i'll see in the next video bye	block	67
you can see how there is some overhead here that have all of these blocks which don't actually hold any data over any cats or any other white actually useful content but the good thing about this scheme is that access to the beginning of the file is very very fast and i only pay for the overhead of all of these additional blocks for very large files so that's how i know addressing scheme i imagine that will have an assignment kind of based on this where you actually kind of can implement this scheme in order to read or write some exist some files onto an actual file system with us it i'll see in the next video bye	address	373
you can see how there is some overhead here that have all of these blocks which don't actually hold any data over any cats or any other white actually useful content but the good thing about this scheme is that access to the beginning of the file is very very fast and i only pay for the overhead of all of these additional blocks for very large files so that's how i know addressing scheme i imagine that will have an assignment kind of based on this where you actually kind of can implement this scheme in order to read or write some exist some files onto an actual file system with us it i'll see in the next video bye	system	573
hi so let's start talking about deadlock ok so deadlock is the bane of multithreaded and programs which have synchronization so we've realized that it's important to make sometimes our threads and processes wait for events and for conditions to apply but then what happens if they end up waiting forever so when does this occur and how can we stop it alright so we're talking about deadlock first of all let's remind ourselves about a definition for deadlock do you remember it so we're using the following definition deadlock definitely deadlock for our definition for deadlock is we're going to wait in fact we're waiting	the following	493
hi so let's start talking about deadlock ok so deadlock is the bane of multithreaded and programs which have synchronization so we've realized that it's important to make sometimes our threads and processes wait for events and for conditions to apply but then what happens if they end up waiting forever so when does this occur and how can we stop it alright so we're talking about deadlock first of all let's remind ourselves about a definition for deadlock do you remember it so we're using the following definition deadlock definitely deadlock for our definition for deadlock is we're going to wait in fact we're waiting	thread	76
waiting for a counting semaphore to have for someone else to call send post may be waiting for a file to be nonempty but we're waiting for some kind of event that will never happen so we can reason about it we can show from an outsiders perspective that event will never happen but are poor piece of code are poor system is currently stuck waiting for that event that will never happen	code	300
waiting for a counting semaphore to have for someone else to call send post may be waiting for a file to be nonempty but we're waiting for some kind of event that will never happen so we can reason about it we can show from an outsiders perspective that event will never happen but are poor piece of code are poor system is currently stuck waiting for that event that will never happen	system	314
so it turns out that we can only actually get deadlock if the following four conditions apply and these are known as the coffman conditions and yes they are necessary and yes they are sufficient so an important idea is if you can break any one of them then you won't get deadlock ok that sounds easy right so let's think about what these are and how we might break them and unfortunately though it sounds easy to break because hey there's four of them in practice it's actually it's actually often hard to identify the best way to design our systems too sure we don't get deadlock so what are the common conditions so here they are first of all we need some kind of mutual execution mutual exclusion requirements so mutual or	the following	58
so it turns out that we can only actually get deadlock if the following four conditions apply and these are known as the coffman conditions and yes they are necessary and yes they are sufficient so an important idea is if you can break any one of them then you won't get deadlock ok that sounds easy right so let's think about what these are and how we might break them and unfortunately though it sounds easy to break because hey there's four of them in practice it's actually it's actually often hard to identify the best way to design our systems too sure we don't get deadlock so what are the common conditions so here they are first of all we need some kind of mutual execution mutual exclusion requirements so mutual or	system	542
so if we can just completely share resources then	resources	35
perfect for a soapbox drama because nothing is ever going to happen ok so we're going to see a more detailed example of these circular weights but you can see that what is necessary is that i've got different parts of my system waiting for other parts which are currently taken so if a was able to proceed without having to wait then we couldn't get deadlock so instead is this idea that we can identify a circular wait in the resources that are being held and needed by different threads and processes	thread	481
perfect for a soapbox drama because nothing is ever going to happen ok so we're going to see a more detailed example of these circular weights but you can see that what is necessary is that i've got different parts of my system waiting for other parts which are currently taken so if a was able to proceed without having to wait then we couldn't get deadlock so instead is this idea that we can identify a circular wait in the resources that are being held and needed by different threads and processes	resources	427
perfect for a soapbox drama because nothing is ever going to happen ok so we're going to see a more detailed example of these circular weights but you can see that what is necessary is that i've got different parts of my system waiting for other parts which are currently taken so if a was able to proceed without having to wait then we couldn't get deadlock so instead is this idea that we can identify a circular wait in the resources that are being held and needed by different threads and processes	system	221
so we'll come back to that one and the third one is the toddler conditions over the two year old so this idea of holding weight if process or thread only needed one resource then deadlock is impossible because once you get that resource you can you can continue and if you are not holding it then there's no possibility of anyone else waiting for you so we can't set up this circular wait so hold on wait is when you can imagine kind of day care through your kid or five year old kid is held onto the crayons were not anybody else have them and is now staring intently at another child that's got the colored paper and so i'm holding on to this and i'm waiting for the other resource meanwhile there other child	thread	142
that other thread has managed to get the colored paper and is now looking at me waiting for the queens and because we're holding onto our resources were not going to share them now we've got that look so the holden weight is the idea that you get exclusive access to the resource and daniel prepare to wait for other things you're not going to put it the app once you grabbed it you've got it ok so this is our threads and processes acting like toddlers or three year olds in a day care and the last one is the there is no daycare teacher in the room to actually	thread	11
that other thread has managed to get the colored paper and is now looking at me waiting for the queens and because we're holding onto our resources were not going to share them now we've got that look so the holden weight is the idea that you get exclusive access to the resource and daniel prepare to wait for other things you're not going to put it the app once you grabbed it you've got it ok so this is our threads and processes acting like toddlers or three year olds in a day care and the last one is the there is no daycare teacher in the room to actually	resources	138
the idea here is there is no preemption so if one of my processes or threads was a bully they could walk up to another child and say hey you give me the dependence give me the give me the clowns and force the other child to release their hold onto that that resource or perhaps if one of the threads was enlightened though i can see we've got a deadlock situation you know i will let go of my all the things i'm holding right now so that for the good of all of all of the other processes	thread	69
ok so we don't if we don't have that if there's no possibility preemption then then and all those other conditions occur then then we can have the possibility of deadlock ok so let's kind of try to differentiate between some of these because the press possibly last two sound kind of similar so holding weight is the idea that a process is holding onto one thing but so little or mount nested ok holding on to that but they want to have but there waiting for something else ok so	a process	327
something else ok no preemption is that they're not going to give up their resources that they're not going to agree to put down what they've got so we can't state are little thread hey you know that new text log that you locked yeah well we changed our mind about that would like you to reverse your code please please	code	301
something else ok no preemption is that they're not going to give up their resources that they're not going to agree to put down what they've got so we can't state are little thread hey you know that new text log that you locked yeah well we changed our mind about that would like you to reverse your code please please	thread	175
something else ok no preemption is that they're not going to give up their resources that they're not going to agree to put down what they've got so we can't state are little thread hey you know that new text log that you locked yeah well we changed our mind about that would like you to reverse your code please please	resources	75
go back five lines and let's just pretend that you never locked it and restart please r code can't do that we are unable to get a backtrack and go back to a time before we we locked it ok so we cannot force our threads to preemptively let go any resources ok and as you can see in my little example i'm setting up a circuit await i've now got my two little threads waiting for each other to continue but of course neither one is going to let go of their resources let me fill in his arm here the other ones going to let go and so both of them are unhappy both of them have reached a stalemate they've got deadlock and they want to share so they have exclusive access to these two resources resources so if they were prepared to share that wouldn't be a problem	code	88
go back five lines and let's just pretend that you never locked it and restart please r code can't do that we are unable to get a backtrack and go back to a time before we we locked it ok so we cannot force our threads to preemptively let go any resources ok and as you can see in my little example i'm setting up a circuit await i've now got my two little threads waiting for each other to continue but of course neither one is going to let go of their resources let me fill in his arm here the other ones going to let go and so both of them are unhappy both of them have reached a stalemate they've got deadlock and they want to share so they have exclusive access to these two resources resources so if they were prepared to share that wouldn't be a problem	thread	211
go back five lines and let's just pretend that you never locked it and restart please r code can't do that we are unable to get a backtrack and go back to a time before we we locked it ok so we cannot force our threads to preemptively let go any resources ok and as you can see in my little example i'm setting up a circuit await i've now got my two little threads waiting for each other to continue but of course neither one is going to let go of their resources let me fill in his arm here the other ones going to let go and so both of them are unhappy both of them have reached a stalemate they've got deadlock and they want to share so they have exclusive access to these two resources resources so if they were prepared to share that wouldn't be a problem	resources	246
weather we've actually got a circular wait inside of resource allocation graph and that's going to be the subject of our next next little video and ultimately i wanted to realize that even if you identify from the code that deadlock is possible it doesn't guarantee that deadlock will occur instead a certain interleavings a certain sequence of events needs to occur in order to ensure that deadlock is possible to say have code that appears to work ten thousand times but it's only when you put it into a rocket or an atm or your surgical robot or your scooter do you actually discover that deadlock canon can say one percent or point one or point zero one percent of the time right so in the next video and let's actually	code	214
i assert the following statement or sort following expression so it must be true so the c supports was called the assert macro remember those things the preprocessor macro now here's the kind of cool thing about asserts is that we can make them disappear	the following	9
so if you're writing code that you want to have the best performance then all those additional tests that you write inside the assert can disappear they'll never actually be seen by the compiler in other words our assert macro either will be compiled into a little if statement that may optionally stop the program with a useful error message or it will be compiled into nothing right so feel free to sprinkle lots of asserts around in your code and they will only affect the performance of your code when you compile it in debug mode right so let's sub just have a look at look at this	code	21
zero in other words those two strings are the same	string	30
ok right and then if we get this far we will say something like everything ok what is putus putus is equivalent to printf standouts printed for standard out then whatever you said followed by a newline so we expect that normally to be flushed out immediately when we sending stuff to the terminal ok so that's my silly little program let's return zero here to say we exited ok alright so first of all let's just try compiling this pcc assert demo and it's going to complain the fact that we haven't specified are types we have forgotten to	type	513
ok right and then if we get this far we will say something like everything ok what is putus putus is equivalent to printf standouts printed for standard out then whatever you said followed by a newline so we expect that normally to be flushed out immediately when we sending stuff to the terminal ok so that's my silly little program let's return zero here to say we exited ok alright so first of all let's just try compiling this pcc assert demo and it's going to complain the fact that we haven't specified are types we have forgotten to	printf	115
to include our includes here so hash include hey precompiler please get for main assert dot h and also i need to do stroke hump so that's going to be inside string college	string	157
a mistake on yes on my main here i didn't put the type here pointed reporter ok right right and last we need one more include which is the standard io for our puts call ok right so let's compile this gcc off we go and will run it ok and you'll see by default the assert	type	50
actually doesn't really cool it actually is generated c code that knows the filename assert demo and the line number line six that's really really cool how did they manage to do that well the trick by the way is that the	code	56
and what this does is that now inside your debugger you can find out a lot more about the current function that you're stepping through and the alternative to that is to say hey i want to now optimize my code perhaps some variables are only going to be mapped to registers on the cpu i'm not even going to find them inside memory and perhaps i want to turn off my assert code so for this i want to say hey compiler i want to define something predefined preprocessor constant here and in fact i'm going to say hey no debug information please no no debug	memory	323
and what this does is that now inside your debugger you can find out a lot more about the current function that you're stepping through and the alternative to that is to say hey i want to now optimize my code perhaps some variables are only going to be mapped to registers on the cpu i'm not even going to find them inside memory and perhaps i want to turn off my assert code so for this i want to say hey compiler i want to define something predefined preprocessor constant here and in fact i'm going to say hey no debug information please no no debug	code	204
and to check the preconditions of what you believe to be true so let's see that as an example here let's serve right let's put everything together we've learned inside this lecture to write a little program which is going to sum up the results of an array and we're going to convert the result into a text version of an ascii string of our sum so let's do that flight	string	326
add one to the pointer using packet of post increment here so is this correct we actually want to recommend a pointer and then take the value well this is dangerous code because we have to think carefully about whether we are incrementing before or after reading the value	code	165
add one to the pointer using packet of post increment here so is this correct we actually want to recommend a pointer and then take the value well this is dangerous code because we have to think carefully about whether we are incrementing before or after reading the value	pointer	15
thinking carefully let's let's put that aside to when we actually really need to think carefully and we're thinking about say memory allocation in the lifetime of objects so i would advise you don't try to be clever	memory	126
thinking carefully let's let's put that aside to when we actually really need to think carefully and we're thinking about say memory allocation in the lifetime of objects so i would advise you don't try to be clever	memory allocation	126
instead let's just write our code with the increment	code	29
and will let the optimal optimizations of the compiler run fit to figure out whether it can actually	optimizations	25
there we go optimize this code into something that runs faster so only be only be clever when you actually kind of need to be clever and only have to think carefully when you truly need to think carefully we've gotten enough problem still worry about ok so we're going to keep going through adding to us some the value that we're going to find at our pointer at the end of this great we've now got to some but we're not going to return this sum instead we want to put some have some memory which actually holds the ascii version of this	memory	483
there we go optimize this code into something that runs faster so only be only be clever when you actually kind of need to be clever and only have to think carefully when you truly need to think carefully we've gotten enough problem still worry about ok so we're going to keep going through adding to us some the value that we're going to find at our pointer at the end of this great we've now got to some but we're not going to return this sum instead we want to put some have some memory which actually holds the ascii version of this	code	26
there we go optimize this code into something that runs faster so only be only be clever when you actually kind of need to be clever and only have to think carefully when you truly need to think carefully we've gotten enough problem still worry about ok so we're going to keep going through adding to us some the value that we're going to find at our pointer at the end of this great we've now got to some but we're not going to return this sum instead we want to put some have some memory which actually holds the ascii version of this	pointer	351
change my variable for me please to point to some heat memory that i am going to need for the results so for example i want integer now and here's the integer value i need to convert into some text so almost done this this would now work but let's use our search to to test a few things	memory	55
into result result is just a pointer to an inch here take the value of some	pointer	29
ok so this would work but what would happen if someone passed in null as result pointer in other words it's not pointing at anything valid we would crash at line eleven so let's instead actually put our assumptions in here and we can say well you know what i expect that my	pointer	80
guess you could put logical billions and write that as a single line but my advice is don't because now if that assert fires if we stop a program without assert you'll immediately know whether it is line six or line seven that was the problem you can immediately debug from that and say oh i see that point it was not was not a valid pointer or result was not and therefore it would give me a look stronger debugging sequel to help me debug the calling code at this function alright that's there for these videos have a wonderful time good luck and don't forget to use the course book and don't forget to be playful and try this stuff that's it goodbye	code	453
guess you could put logical billions and write that as a single line but my advice is don't because now if that assert fires if we stop a program without assert you'll immediately know whether it is line six or line seven that was the problem you can immediately debug from that and say oh i see that point it was not was not a valid pointer or result was not and therefore it would give me a look stronger debugging sequel to help me debug the calling code at this function alright that's there for these videos have a wonderful time good luck and don't forget to use the course book and don't forget to be playful and try this stuff that's it goodbye	pointer	334
ok so we didn't need a definition for deadlock and this idea that our our threads are frozen up maybe one thread is waiting for a mutex lock that is never going to be unlocked maybe we're waiting for something from a data structure which is never going to be given to us so here's a general definition for dead log key	a struct	220
ok so we didn't need a definition for deadlock and this idea that our our threads are frozen up maybe one thread is waiting for a mutex lock that is never going to be unlocked maybe we're waiting for something from a data structure which is never going to be given to us so here's a general definition for dead log key	a mutex	128
ok so we didn't need a definition for deadlock and this idea that our our threads are frozen up maybe one thread is waiting for a mutex lock that is never going to be unlocked maybe we're waiting for something from a data structure which is never going to be given to us so here's a general definition for dead log key	thread	74
well ok can i type so i put in some in there ok	type	14
make this thread exit it's never going to happen ok so our poor poor little fair door process is waiting some for an event maybe we're going to signal that event using a variable or some other method and it's just never going to happen so it doesn't get to complete it doesn't get to kind of run its activity or run the code and of course debugging deadlock is tricky it's often there as pairs that i could a thread maybe it's stuck inside p threat condition wait and we don't know why why that event doesn't hasn't hasn't fired hasn't occured	code	320
make this thread exit it's never going to happen ok so our poor poor little fair door process is waiting some for an event maybe we're going to signal that event using a variable or some other method and it's just never going to happen so it doesn't get to complete it doesn't get to kind of run its activity or run the code and of course debugging deadlock is tricky it's often there as pairs that i could a thread maybe it's stuck inside p threat condition wait and we don't know why why that event doesn't hasn't hasn't fired hasn't occured	a thread	407
make this thread exit it's never going to happen ok so our poor poor little fair door process is waiting some for an event maybe we're going to signal that event using a variable or some other method and it's just never going to happen so it doesn't get to complete it doesn't get to kind of run its activity or run the code and of course debugging deadlock is tricky it's often there as pairs that i could a thread maybe it's stuck inside p threat condition wait and we don't know why why that event doesn't hasn't hasn't fired hasn't occured	thread	10
ok so we've got this general definition of deadlock now actually let's see if we can kind of construct some examples where we actually cause it so let's use team mutex locks and two threads to create an example of deadlock ok bye i'm going to actually do this in a text editor ok	thread	182
let's go right do i have so if i've got thread one imagine my thread first red make the coda bigger right has called	thread	40
p thread mutex lock k and we're going to say please lock on this first mutex and then after you've done that please lock on this other mutex right so it will do some work ok do something and then after that we want to at least ok so we will call p thread unlock on both of these mutex is ok	thread	2
so for example maybe we want to take some data out of out of data store one stick it into data structure to ok it doesn't matter particular which order that we released them in just for symmetry i'm going to do it this way but let's let's think about what happens if we lock these in a different sequence inside another thread so i'm going to have now another thread that does the same sequence of operations accept ha we have swapped these around the case so we swap these two lights ok so is this a problem	a struct	93
so for example maybe we want to take some data out of out of data store one stick it into data structure to ok it doesn't matter particular which order that we released them in just for symmetry i'm going to do it this way but let's let's think about what happens if we lock these in a different sequence inside another thread so i'm going to have now another thread that does the same sequence of operations accept ha we have swapped these around the case so we swap these two lights ok so is this a problem	thread	320
like most of the time no most of the time my threads are perfectly happy doing what they need to do until the following happens until one unfortunate day thread one has called preferred mutex lock on get this choose a new color	the following	106
like most of the time no most of the time my threads are perfectly happy doing what they need to do until the following happens until one unfortunate day thread one has called preferred mutex lock on get this choose a new color	thread	45
called prefix lock on the first one case is completed that at the same time my other thread which is curiously called thread one so let's fix that thread	thread	85
so now they were both able to do this but what happens next ok i think we should choose a new color for this let's go for yes it's kinda extreme pinky purple thing let's try that ok right so now what happens thread one says i'd like to lock this mutex but of course what	thread	208
does this do it blocks ok why because another thread has that new texts between you and me we know it's thread two meanwhile thread two tries to look	block	16
does this do it blocks ok why because another thread has that new texts between you and me we know it's thread two meanwhile thread two tries to look	thread	46
it takes one and that of course blocks	block	32
it's not yet available another thread is currently quite that musics lock ok so when will we escape out of this and the answer is never ok we can read the code and see that eventually we're going to release these locks but we're never going to get to that that piece of code that thread one is waiting for thread two and thread two is waiting for thread one so it's kind of stuck for stuck forever	code	155
it's not yet available another thread is currently quite that musics lock ok so when will we escape out of this and the answer is never ok we can read the code and see that eventually we're going to release these locks but we're never going to get to that that piece of code that thread one is waiting for thread two and thread two is waiting for thread one so it's kind of stuck for stuck forever	thread	31
ok i am not occured because we constructed this with the locks being acquired in a different order if they were in the same order it would have been fine let's just kind of quickly sketch that out to see that let's imagine that i had my first thread doing mutex worn and then mute x two and then mutex wanna mutex two down here for thread two then if they both try to acquire mutex in at the same time then we can imagine that thread one would acquire the mutex lock here which would mean thread two will be forced to block	block	518
ok i am not occured because we constructed this with the locks being acquired in a different order if they were in the same order it would have been fine let's just kind of quickly sketch that out to see that let's imagine that i had my first thread doing mutex worn and then mute x two and then mutex wanna mutex two down here for thread two then if they both try to acquire mutex in at the same time then we can imagine that thread one would acquire the mutex lock here which would mean thread two will be forced to block	a mutex	306
ok i am not occured because we constructed this with the locks being acquired in a different order if they were in the same order it would have been fine let's just kind of quickly sketch that out to see that let's imagine that i had my first thread doing mutex worn and then mute x two and then mutex wanna mutex two down here for thread two then if they both try to acquire mutex in at the same time then we can imagine that thread one would acquire the mutex lock here which would mean thread two will be forced to block	thread	243
so it doesn't get to go to step two which means thread one can continue and then when it's finished it will release those locks so now thread two can finish so	thread	48
if we'd actually written our code like this in the same order it would have been impossible to get deadlock	code	29
ok so that was with a mutex lock now that's actually think about could we do something similar with counting semaphores sure ok so let's do something similar with counting semaphores where thread one calls say sam weights on counting center four as well	a mutex	20
ok so that was with a mutex lock now that's actually think about could we do something similar with counting semaphores sure ok so let's do something similar with counting semaphores where thread one calls say sam weights on counting center four as well	thread	189
i'll have another thread that does something similar or key	thread	18
and another thread does something similar ok so do we see any problems right now nope we could imagine that these counting semaphore 's my kind except for has been initialized just account of one ok so same initiate here go let's have one pizza slice in there	thread	12
there's no possibility of deadlock right now that for every same weight called we call assam post ok right so what if we could have made it a little bit more complicated though and we said that same weight here is going to in order to continue i'm going to wait on this thread and then i'm going to post on some samples to an meanwhile thread two i'm going to wait on counting semaphore two and then i'm going to post on counting semaphore three ok and then some weight three i'm going to then post inseminate one ok if all my counties are forced to started off with a value of zero you can see that no one gets to play that all of my threads have got stuck that my first thread is blocked here waiting for the value for sale wanted change well someone will change down here but unfortunately thread three is blocked waiting for the count for sam three is waiting for pizza slice and were able to get that piece of sliced form it is waiting for sam post to be called by thread two but thread two is not going to give it that pizza slice until it gets a piece of slice out of counting semaphores s two and where will i get that only from thread one when thread one finally called stem post but that's not going to happen because thread what is still waiting for the pizza slice from thread three so now you see we've got this love triangle here between our three threads they'll never going to continue that always waiting for an event that's never going to happen so that's all example of deadlock we can construct lots of these varying bits of complexity usually we don't artificial construct them like this usually were scratching go ahead go why did my system come to a grinding halt and the other thing i want you to notice is that	block	682
there's no possibility of deadlock right now that for every same weight called we call assam post ok right so what if we could have made it a little bit more complicated though and we said that same weight here is going to in order to continue i'm going to wait on this thread and then i'm going to post on some samples to an meanwhile thread two i'm going to wait on counting semaphore two and then i'm going to post on counting semaphore three ok and then some weight three i'm going to then post inseminate one ok if all my counties are forced to started off with a value of zero you can see that no one gets to play that all of my threads have got stuck that my first thread is blocked here waiting for the value for sale wanted change well someone will change down here but unfortunately thread three is blocked waiting for the count for sam three is waiting for pizza slice and were able to get that piece of sliced form it is waiting for sam post to be called by thread two but thread two is not going to give it that pizza slice until it gets a piece of slice out of counting semaphores s two and where will i get that only from thread one when thread one finally called stem post but that's not going to happen because thread what is still waiting for the pizza slice from thread three so now you see we've got this love triangle here between our three threads they'll never going to continue that always waiting for an event that's never going to happen so that's all example of deadlock we can construct lots of these varying bits of complexity usually we don't artificial construct them like this usually were scratching go ahead go why did my system come to a grinding halt and the other thing i want you to notice is that	thread	270
there's no possibility of deadlock right now that for every same weight called we call assam post ok right so what if we could have made it a little bit more complicated though and we said that same weight here is going to in order to continue i'm going to wait on this thread and then i'm going to post on some samples to an meanwhile thread two i'm going to wait on counting semaphore two and then i'm going to post on counting semaphore three ok and then some weight three i'm going to then post inseminate one ok if all my counties are forced to started off with a value of zero you can see that no one gets to play that all of my threads have got stuck that my first thread is blocked here waiting for the value for sale wanted change well someone will change down here but unfortunately thread three is blocked waiting for the count for sam three is waiting for pizza slice and were able to get that piece of sliced form it is waiting for sam post to be called by thread two but thread two is not going to give it that pizza slice until it gets a piece of slice out of counting semaphores s two and where will i get that only from thread one when thread one finally called stem post but that's not going to happen because thread what is still waiting for the pizza slice from thread three so now you see we've got this love triangle here between our three threads they'll never going to continue that always waiting for an event that's never going to happen so that's all example of deadlock we can construct lots of these varying bits of complexity usually we don't artificial construct them like this usually were scratching go ahead go why did my system come to a grinding halt and the other thing i want you to notice is that	system	1656
i might have a thread that say forgets to call sam post or for some other forget or some bug causes some event not to occur and then you get all of this fall out where other threads and other processes are unable to continue because they are also waiting for that for that thread or the other process so you'll see this occasionally on your phone or on your laptop where one little issue say with their gui process or gui thread now starts to have cascading problems and your deadlock starts to affect other systems as well because everything else grinds to a halt and there's multiple dependencies between all of our threads and processes ok so that's deadlock what what we'd like to be able to do is ensure	a thread	13
i might have a thread that say forgets to call sam post or for some other forget or some bug causes some event not to occur and then you get all of this fall out where other threads and other processes are unable to continue because they are also waiting for that for that thread or the other process so you'll see this occasionally on your phone or on your laptop where one little issue say with their gui process or gui thread now starts to have cascading problems and your deadlock starts to affect other systems as well because everything else grinds to a halt and there's multiple dependencies between all of our threads and processes ok so that's deadlock what what we'd like to be able to do is ensure	thread	15
i might have a thread that say forgets to call sam post or for some other forget or some bug causes some event not to occur and then you get all of this fall out where other threads and other processes are unable to continue because they are also waiting for that for that thread or the other process so you'll see this occasionally on your phone or on your laptop where one little issue say with their gui process or gui thread now starts to have cascading problems and your deadlock starts to affect other systems as well because everything else grinds to a halt and there's multiple dependencies between all of our threads and processes ok so that's deadlock what what we'd like to be able to do is ensure	system	508
k which means hey now were available for connections and then finally we have accept and that's the one which is going to block until there's a new connection to be serviced in new client has actually finish connecting so that's the one that we put inside a loop	block	122
we'll assume that controlling the lunar base there were making a new tcp connection each time so our first problem is we want to save the astronaut having seconds elapsed between wanting to send a close air lock message and the server actually receiving their data ok so they asked about charges into the base an on earth side we run the following code right we make a socket we connect on that socket to the ip address of a lunar base and we write the following command and send thirteen bytes right so we could use our understanding the tcp protocol to it to work this out first packet at the moment we call connect that's going to take one point three seconds to cross	the following	334
we'll assume that controlling the lunar base there were making a new tcp connection each time so our first problem is we want to save the astronaut having seconds elapsed between wanting to send a close air lock message and the server actually receiving their data ok so they asked about charges into the base an on earth side we run the following code right we make a socket we connect on that socket to the ip address of a lunar base and we write the following command and send thirteen bytes right so we could use our understanding the tcp protocol to it to work this out first packet at the moment we call connect that's going to take one point three seconds to cross	code	348
we'll assume that controlling the lunar base there were making a new tcp connection each time so our first problem is we want to save the astronaut having seconds elapsed between wanting to send a close air lock message and the server actually receiving their data ok so they asked about charges into the base an on earth side we run the following code right we make a socket we connect on that socket to the ip address of a lunar base and we write the following command and send thirteen bytes right so we could use our understanding the tcp protocol to it to work this out first packet at the moment we call connect that's going to take one point three seconds to cross	address	412
right so that is a kind of bored idea of how tcp works notice that it just doing something simple we actually might come across this divide four times so this becomes important where we actually look at the most useful thing we do on the web today which is look at pictures of cats yes so let's start talking about not tcp but the implications of tcp on the hypertext protocol how we actually request web pages and other web based resources and will do that in the next video bye	resources	431
and inside our main method we're going to do we're going to create a whole load of pizza it's ok and make a note of their thread i ds pass in the firework function ok and then after we've done that we will set fireworks equal to one and then will call preconditions signals so we know that is going to wake up one thread	thread	122
now we want to wait for all threads to finish here so i could write a for loop to call p thread join on all of my thread i ds but i could also be lazy in to say ok pthread less exit the main thread	thread	28
so that we never returned from maine so i could call p thread exit here key	thread	55
right so great we've implemented that now actually let's have to think about how we can implement the firework right so what does r firework do k right well we acquire the mutex lock i might impede here just for for sure had so we've got we've got the mutex lock and all threads that run this code again to acquire the same lock	code	293
right so great we've implemented that now actually let's have to think about how we can implement the firework right so what does r firework do k right well we acquire the mutex lock i might impede here just for for sure had so we've got we've got the mutex lock and all threads that run this code again to acquire the same lock	thread	271
and then we say well while fireworks is zero corporate recognition weight in other words if my firework thread starts up here and it starts up early then we're just going to block it for but we're going to ask it to release the mutex lock and lock inside here so go back to the kind of first code remember we created all of the threads initially back when are fireworks variable with zero it's only after we've created all five	block	174
and then we say well while fireworks is zero corporate recognition weight in other words if my firework thread starts up here and it starts up early then we're just going to block it for but we're going to ask it to release the mutex lock and lock inside here so go back to the kind of first code remember we created all of the threads initially back when are fireworks variable with zero it's only after we've created all five	code	292
and then we say well while fireworks is zero corporate recognition weight in other words if my firework thread starts up here and it starts up early then we're just going to block it for but we're going to ask it to release the mutex lock and lock inside here so go back to the kind of first code remember we created all of the threads initially back when are fireworks variable with zero it's only after we've created all five	thread	104
ok so let's get down here ok right so what do we do after this point ok when we escape out of here where a scaping out of here because fireworks is no longer no longer zero and the very first thing we do is call p three condition broadcast in other words ring that fire bell wake everybody up in this might be sleeping inside this condition variable ok so now all five of my threads	thread	375
definitely working up ok so i implement increment the value of fireworks i print out oh and that value and then i decrement it ok so what's going to be the largest value this code will print one two three four five six what do you think so just as a reminder i've got five threads running this and the only way they can escape out of this code is after fireworks is no longer zero so what's the maximum possible value that we might see from this first to run this hundred or thousand to a million times what's the largest integer that would expect here ok so think about that pause this video and make your choice and then we'll see if you're correct ok so we think about this for five seconds and then we'll review the answers	code	175
definitely working up ok so i implement increment the value of fireworks i print out oh and that value and then i decrement it ok so what's going to be the largest value this code will print one two three four five six what do you think so just as a reminder i've got five threads running this and the only way they can escape out of this code is after fireworks is no longer zero so what's the maximum possible value that we might see from this first to run this hundred or thousand to a million times what's the largest integer that would expect here ok so think about that pause this video and make your choice and then we'll see if you're correct ok so we think about this for five seconds and then we'll review the answers	thread	273
ok wait times up so let's let's have a look at the key key detail here the key detail is a mutex lock our mutex lock allows us to reason strongly about the number of threads which are actually running in this code	code	209
ok wait times up so let's let's have a look at the key key detail here the key detail is a mutex lock our mutex lock allows us to reason strongly about the number of threads which are actually running in this code	a mutex	89
ok wait times up so let's let's have a look at the key key detail here the key detail is a mutex lock our mutex lock allows us to reason strongly about the number of threads which are actually running in this code	thread	166
because we've acquired mutex lock means that any other threads that want to run have to also require it so all of these lines of code can only be run by one thread at a time	code	129
because we've acquired mutex lock means that any other threads that want to run have to also require it so all of these lines of code can only be run by one thread at a time	thread	55
if the threads have gone to sleep inside p thread condition wait there only allowed to escape out of that after they reacquired the mutex log so that's the key idea that only one third of the time can be running this piece of code and it allows us to actually reason about this so we know that when we escape out of here the very first thread will see of fireworks value of one because we changed it upstairs in the main method so we implement so we increment it to two case of wig the first escapes out of here will	code	226
if the threads have gone to sleep inside p thread condition wait there only allowed to escape out of that after they reacquired the mutex log so that's the key idea that only one third of the time can be running this piece of code and it allows us to actually reason about this so we know that when we escape out of here the very first thread will see of fireworks value of one because we changed it upstairs in the main method so we implement so we increment it to two case of wig the first escapes out of here will	thread	7
will print out too and then we decrement it down to one again and then we unlock the mutex ok so the next step that comes out of here will only escape out of p three condition wait after we've unlock the mutex so it will also see a value of fireworks of one it also does a big forecast waking everybody up and most are too and so it will print out the value of two etc right and so on the next thread will come out check the condition for the while loop ok that is no longer true so it comes to an does the same thing increments it from one to two and then two to one and then unlocks the mutex which allows the next day to escape it checks the value and so on and so on so right so let's just kind of run this just to kind of prove it right so we have ok compiled it	thread	394
ok that's my machine slow ok there we go out alright and we see every firework every thread wanna see the value of two and we could do that through this strong reasoning thanks to the mutex log	thread	85
that these two lines of code here	code	24
between us deciding the value of fireworks is zero and then calling peter condition wait so if it happened right inside there if that just that moment in time then what's going to happen we've actually called preconditions signal but no thread was yet sleeping no thread was yet blocked inside condition wait ok so was to fix for that and the answer is to actually log on the same mutex here so if i call pete said mutex lock here	block	279
between us deciding the value of fireworks is zero and then calling peter condition wait so if it happened right inside there if that just that moment in time then what's going to happen we've actually called preconditions signal but no thread was yet sleeping no thread was yet blocked inside condition wait ok so was to fix for that and the answer is to actually log on the same mutex here so if i call pete said mutex lock here	thread	237
another thread is acquired mutex or after the all the threads have called pizza hut	thread	8
another thing this code is kind of highlights is that	code	19
that you can create threads but peter create doesn't wait for them to actually start so this this code is an attempt to say ok let's create all these threads and actually we're going to make our own barrier	code	98
that you can create threads but peter create doesn't wait for them to actually start so this this code is an attempt to say ok let's create all these threads and actually we're going to make our own barrier	thread	20
inside here so we won't let anybody go until we've actually created or five threads and also kind of starting up so but this line of actually changing the fireworks to one here could still actually technically occur before this five threads of actually started all we've just simply say is to say ok create them and at some point in the future please run alright so lots of interesting interleavings details there and as you can see this stuff is tricky	thread	76
ok right so remember signal blocking means that we've pulled up the drawbridge any zombies we have outside they they're not dead yet they held that there are there zombies but they haven't gone away so if there is a signal that's waiting to be delivered all we're doing is trying to delay the inevitable we're trying to stop that signal from being sent to us ok how do we do that we use sig prop mask and here's how it works it's a little bit like seek set in the sense that you can say exactly how you want to use it and so the first integer here is actually a choice of one of these three constants you can say i want to add to the existing mask so that's block here so any signals that i'm going to give you i want you to all them with existing mask or i want you to take the single set that i'm giving you here and use the bit set inside that signal set to unblock signals ok and then finally there's the i don't care about the existing mask i just want to replace the process mask with their one that i'm giving you ok so this how controls what the meaning is of the signal set here ok you also notice that actually we've got the three parameters here there's old here so if we wish we can ask cig pop mask details the old signal mask so that is sometimes useful because you might call mask twice you might initially calling to say hayes process here's my new signal mask and by the way i want to remember what the old process mask looks like and then later when i finish doing what i need to do i can take that whole process mask and say ok single prop mask now use that signal pattern that signal set as the new mask please thank you very much both these parameters if you wish can be null so if if you truly don't want to actually change the current signal mask put in all there if you truly don't care about the prior single mass before you changed it just put a note in the third parameter we keep so remember you this sick pop mask for single threaded programs and there's also a pthread version which behaves exactly the same way in same signature	block	28
ok right so remember signal blocking means that we've pulled up the drawbridge any zombies we have outside they they're not dead yet they held that there are there zombies but they haven't gone away so if there is a signal that's waiting to be delivered all we're doing is trying to delay the inevitable we're trying to stop that signal from being sent to us ok how do we do that we use sig prop mask and here's how it works it's a little bit like seek set in the sense that you can say exactly how you want to use it and so the first integer here is actually a choice of one of these three constants you can say i want to add to the existing mask so that's block here so any signals that i'm going to give you i want you to all them with existing mask or i want you to take the single set that i'm giving you here and use the bit set inside that signal set to unblock signals ok and then finally there's the i don't care about the existing mask i just want to replace the process mask with their one that i'm giving you ok so this how controls what the meaning is of the signal set here ok you also notice that actually we've got the three parameters here there's old here so if we wish we can ask cig pop mask details the old signal mask so that is sometimes useful because you might call mask twice you might initially calling to say hayes process here's my new signal mask and by the way i want to remember what the old process mask looks like and then later when i finish doing what i need to do i can take that whole process mask and say ok single prop mask now use that signal pattern that signal set as the new mask please thank you very much both these parameters if you wish can be null so if if you truly don't want to actually change the current signal mask put in all there if you truly don't care about the prior single mass before you changed it just put a note in the third parameter we keep so remember you this sick pop mask for single threaded programs and there's also a pthread version which behaves exactly the same way in same signature	parameter	1141
ok right so remember signal blocking means that we've pulled up the drawbridge any zombies we have outside they they're not dead yet they held that there are there zombies but they haven't gone away so if there is a signal that's waiting to be delivered all we're doing is trying to delay the inevitable we're trying to stop that signal from being sent to us ok how do we do that we use sig prop mask and here's how it works it's a little bit like seek set in the sense that you can say exactly how you want to use it and so the first integer here is actually a choice of one of these three constants you can say i want to add to the existing mask so that's block here so any signals that i'm going to give you i want you to all them with existing mask or i want you to take the single set that i'm giving you here and use the bit set inside that signal set to unblock signals ok and then finally there's the i don't care about the existing mask i just want to replace the process mask with their one that i'm giving you ok so this how controls what the meaning is of the signal set here ok you also notice that actually we've got the three parameters here there's old here so if we wish we can ask cig pop mask details the old signal mask so that is sometimes useful because you might call mask twice you might initially calling to say hayes process here's my new signal mask and by the way i want to remember what the old process mask looks like and then later when i finish doing what i need to do i can take that whole process mask and say ok single prop mask now use that signal pattern that signal set as the new mask please thank you very much both these parameters if you wish can be null so if if you truly don't want to actually change the current signal mask put in all there if you truly don't care about the prior single mass before you changed it just put a note in the third parameter we keep so remember you this sick pop mask for single threaded programs and there's also a pthread version which behaves exactly the same way in same signature	thread	1954
if you wanted to set it on a particular threat and as a reminder that if you want to stop those zombies from taking over your castle you better actually set that on all of your threads	thread	177
otherwise it will find away in it will find away to interrupt your your process it will find a way to deliver their signal right so let's actually have a look at some code that does this and for that we better understand how to manipulate these signal sets so you can think of a signal set	code	167
if you like as just really some kind of integer so maybe on particular system we could even typedef for example and say hey signal set is just equivalent to so i could say ok i'm going to write	type	92
if you like as just really some kind of integer so maybe on particular system we could even typedef for example and say hey signal set is just equivalent to so i could say ok i'm going to write	system	71
there we go and all that is actually is saying into along ok but i won't tell anybody that i've done that because i'm well terribly else to use my sig set type so for example i could pretend that my signals down or just some kind of integer with a whole lot of with enough bits that i can represent any possible signal on my system right but how do i then manipulate my signal set well i'm going to need some things to manipulate this number and for that	type	155
there we go and all that is actually is saying into along ok but i won't tell anybody that i've done that because i'm well terribly else to use my sig set type so for example i could pretend that my signals down or just some kind of integer with a whole lot of with enough bits that i can represent any possible signal on my system right but how do i then manipulate my signal set well i'm going to need some things to manipulate this number and for that	system	325
there's two useful things you can do you can say ok given some pointers and memory i want to initialize it to be zero to be the empty set of signals and the other thing i want to do is to be able to add a specific signal to this set so again i want to take a pointer to my mask and in this case i'm going to set single arm inside that single set so conceptually we can imagine that is just setting a single bit the one bit that happens to correspond to say sigler inside this integer value ok so once we've set this up we've we've initialized it and then added one alarm where using that to say ok sig block use this mask in other words if i wasn't protected against sell arms hooray i add now i've added it to their processes existing signal block i've also asked to find out what the original mask was so that presumably in a little bit i can reset the mask to what it was before i changed it ok so what should we write down here right so on my p thread call i want to say cig one my options for how i've got block unblock allset mask well it could be that the alarm signal was set before we even started so let's just rather than calling unblock let's call thread sig maggots with saying hey i'm going to give you	memory	76
there's two useful things you can do you can say ok given some pointers and memory i want to initialize it to be zero to be the empty set of signals and the other thing i want to do is to be able to add a specific signal to this set so again i want to take a pointer to my mask and in this case i'm going to set single arm inside that single set so conceptually we can imagine that is just setting a single bit the one bit that happens to correspond to say sigler inside this integer value ok so once we've set this up we've we've initialized it and then added one alarm where using that to say ok sig block use this mask in other words if i wasn't protected against sell arms hooray i add now i've added it to their processes existing signal block i've also asked to find out what the original mask was so that presumably in a little bit i can reset the mask to what it was before i changed it ok so what should we write down here right so on my p thread call i want to say cig one my options for how i've got block unblock allset mask well it could be that the alarm signal was set before we even started so let's just rather than calling unblock let's call thread sig maggots with saying hey i'm going to give you	block	602
there's two useful things you can do you can say ok given some pointers and memory i want to initialize it to be zero to be the empty set of signals and the other thing i want to do is to be able to add a specific signal to this set so again i want to take a pointer to my mask and in this case i'm going to set single arm inside that single set so conceptually we can imagine that is just setting a single bit the one bit that happens to correspond to say sigler inside this integer value ok so once we've set this up we've we've initialized it and then added one alarm where using that to say ok sig block use this mask in other words if i wasn't protected against sell arms hooray i add now i've added it to their processes existing signal block i've also asked to find out what the original mask was so that presumably in a little bit i can reset the mask to what it was before i changed it ok so what should we write down here right so on my p thread call i want to say cig one my options for how i've got block unblock allset mask well it could be that the alarm signal was set before we even started so let's just rather than calling unblock let's call thread sig maggots with saying hey i'm going to give you	the mask	851
there's two useful things you can do you can say ok given some pointers and memory i want to initialize it to be zero to be the empty set of signals and the other thing i want to do is to be able to add a specific signal to this set so again i want to take a pointer to my mask and in this case i'm going to set single arm inside that single set so conceptually we can imagine that is just setting a single bit the one bit that happens to correspond to say sigler inside this integer value ok so once we've set this up we've we've initialized it and then added one alarm where using that to say ok sig block use this mask in other words if i wasn't protected against sell arms hooray i add now i've added it to their processes existing signal block i've also asked to find out what the original mask was so that presumably in a little bit i can reset the mask to what it was before i changed it ok so what should we write down here right so on my p thread call i want to say cig one my options for how i've got block unblock allset mask well it could be that the alarm signal was set before we even started so let's just rather than calling unblock let's call thread sig maggots with saying hey i'm going to give you	thread	949
there's two useful things you can do you can say ok given some pointers and memory i want to initialize it to be zero to be the empty set of signals and the other thing i want to do is to be able to add a specific signal to this set so again i want to take a pointer to my mask and in this case i'm going to set single arm inside that single set so conceptually we can imagine that is just setting a single bit the one bit that happens to correspond to say sigler inside this integer value ok so once we've set this up we've we've initialized it and then added one alarm where using that to say ok sig block use this mask in other words if i wasn't protected against sell arms hooray i add now i've added it to their processes existing signal block i've also asked to find out what the original mask was so that presumably in a little bit i can reset the mask to what it was before i changed it ok so what should we write down here right so on my p thread call i want to say cig one my options for how i've got block unblock allset mask well it could be that the alarm signal was set before we even started so let's just rather than calling unblock let's call thread sig maggots with saying hey i'm going to give you	pointer	63
k and hear the mask i want to use is actually the result that was filled in by our previous call and we don't care about the old mask at this point the previous mask there we go right so call that and great now you've reset the signal mask to what it was before we started changing it	the mask	11
ok i want to mention just a curious little bit of linux here which is called the directory sticky bit so here's the problem we need to solve let's suppose we have a disk which is nice and large and i'm going to let everybody write into this disk because we need lots of space but people only need this big space for a temporary amount of time so we'll have a part of our file systems say called slash temp where both you and i and others can unpack things maybe compile things etc so this directory itself needs to be world writable so the permissions on this directory are going to be quite unusual because the directory on the temp directory will be seven seven seven meaning hey we can all read	system	376
ok so that's what the sticky bit prevents the sticky bit it's main purpose is to allow this world writable directory but things inside this world writable directory are restricted because only the owner can delete or rename the subdirectory how do i set the sticky bit you can use chmod where ideas plus t to set that particular item and guess what it's just another bit stored inside the mode flag and why do we need it in order to be able to share a temporary directory so let's go and have a quick look at that ok so we'll get out of here let's have a look on this linux system my current directory is slash temp there's lots of stuff inside here let me actually look at the permissions of the actual directory so rather than listing the directory i'm just going to say tell me about the current directory and you can see it's got this little sticky flag here and you'll see that yes it's the directory and look at all these permissions yes everybody has read write or execute so now if i list the long format all of the files inside here you'll see i've got many many kind of people on this but if i take a particular directory say for example here's one owned by a certain a different user even though it's executable i won't be able to rename this so let me take say w a three i'll take this one this xf-dll and let's see if we can move around so it will say ok move xf-dll xf-dll two and i'll see that's not allowed even though it's writable by the world so that's the sticky bit and it allows us to have a nice big slash temp directory which we can all share ok bye!	system	575
oh i forgot to say one little thing about erino down here which is when is it set ok so here's a big idea is that it set to zero when your first program first starts up its value is changed whenever there's an error with a system called and we read the man pages to learn more about that but it's never reset back to zero so if i had a whole lot of calls let's say that i try to read from warm particular file descriptor and then try to write those bites somewhere else to another file descriptor fd two over here if i then check if evan oh zero or not then i can't actually tell you whether where the error curd maybe it happened early on inside my read maybe it happened inside my right or maybe it happened even earlier so just think of is a global variable that if an error occurs we change it	a system call	221
oh i forgot to say one little thing about erino down here which is when is it set ok so here's a big idea is that it set to zero when your first program first starts up its value is changed whenever there's an error with a system called and we read the man pages to learn more about that but it's never reset back to zero so if i had a whole lot of calls let's say that i try to read from warm particular file descriptor and then try to write those bites somewhere else to another file descriptor fd two over here if i then check if evan oh zero or not then i can't actually tell you whether where the error curd maybe it happened early on inside my read maybe it happened inside my right or maybe it happened even earlier so just think of is a global variable that if an error occurs we change it	system	223
so now if you do that and you make some system tools	system	40
in practice of course bulletproof code robust production code would actually check the return values of all of your system calls and that is kind of really good system programming practice to kind of detect when errors go wrong and actually becomes critical when you start writing network code c in the next video bye	code	34
in practice of course bulletproof code robust production code would actually check the return values of all of your system calls and that is kind of really good system programming practice to kind of detect when errors go wrong and actually becomes critical when you start writing network code c in the next video bye	system	116
another thread or call that unlocked for different thread note you must do it from the thread that cord lock so they're perfect for the beginning and end of critical section but but that's all they can do and sometimes we want more flexibility and for that hard counting summerfields semaphores to their rescue so how does accounting before work accounting semaphore behaves a lot more like a pizza box so let me get a pizza box here right here is and inside this fantastic pizza right	section	166
another thread or call that unlocked for different thread note you must do it from the thread that cord lock so they're perfect for the beginning and end of critical section but but that's all they can do and sometimes we want more flexibility and for that hard counting summerfields semaphores to their rescue so how does accounting before work accounting semaphore behaves a lot more like a pizza box so let me get a pizza box here right here is and inside this fantastic pizza right	thread	8
going to reduce the pizza count by one and there's nothing there then your thread will block it wait standing by the pizza box	block	87
going to reduce the pizza count by one and there's nothing there then your thread will block it wait standing by the pizza box	thread	75
until there is a piece of sleights of a slice of pizza available so here we go looking kind of sad there's no pizza so our thread falls asleep at that moment waiting till the day that a slice of pizza comes so here we have a user that's going to reduce the count by one so if there were three slices in here ok there will be two and immediately carry on but if the zero there, our poor little thread here has to wait	thread	123
ok the good news is that anybody any other thread can always walk up to a pizza box and put a new slice back in there so we can maybe do a little wedge here	thread	43
throwing a slice into the box we doesn't never block you can throw as many in there as you wish taking a slice and taking the countdown by one will block if the count is currently at zero so if the count is at zero right now	block	47
poor little thread that is stuck waiting and then you walk up used to our slice of pizza in there but the other thread images are i'm going to take that thank you that's mine and so the count would be brief you might imagine go up to one but then actually gets back handed down to zero again ok so that's essential idea i can have	thread	12
multiple threads or calling down on my box here ok	thread	9
if you decide to throw in a new slice ok so now we've now got one slice in there there we go we've got up to one then one of these people is happy so let's go they able to take the slice and leave and continue on with the next line of code so that's the theory we will actually see the code that does this in the future lecture but the only operations that will need for counting semaphore is to go down by one or up by one and then when we create it we get to say how many slices of pizza we'd like to put inside the box when we first get the box and we first create it that's it ok alright bye for now	code	235
our hints i'm sending it to zero i want to do everything where i just done by by paper and maybe i want to connect locally or maybe i want to connect to illinois ok so first of all let's try let's try it and see what it says if we do this ok so pick an address right so how about cs ok	address	253
right. remember that the port number must be in double quotes we're passing a string ok and we're taking the address of my hints struct and the address of the pointer	string	78
right. remember that the port number must be in double quotes we're passing a string ok and we're taking the address of my hints struct and the address of the pointer	address	109
right. remember that the port number must be in double quotes we're passing a string ok and we're taking the address of my hints struct and the address of the pointer	pointer	159
so if it fails let's just exit after printing out the error ok and here's where we're just going to only look at the very first entry so i make a socket with the right family and the right socket type and	type	196
then i'm going to connect and connect all that needs is the socket file descriptor key and the address and the length of of that struct ok so let's compile this then we talk about the remainder of the code okay alright so	code	201
then i'm going to connect and connect all that needs is the socket file descriptor key and the address and the length of of that struct ok so let's compile this then we talk about the remainder of the code okay alright so	address	95
wait woohoo it connected a k and what it gave us it told us to go to a different page ok so please refresh this and go to this other web page fine so i'd write a web server web client now which actually kind of understands this text and follows that link right but we'll see that fundamentally our request was ok and it gave us back 163 bytes of actual content and the content it gave us was a web page ok that's the mme type text slash html so let's have a brief look at the remainder of the code to see how it works	type	421
wait woohoo it connected a k and what it gave us it told us to go to a different page ok so please refresh this and go to this other web page fine so i'd write a web server web client now which actually kind of understands this text and follows that link right but we'll see that fundamentally our request was ok and it gave us back 163 bytes of actual content and the content it gave us was a web page ok that's the mme type text slash html so let's have a brief look at the remainder of the code to see how it works	code	493
first of all i'm defining my request here just using a macro so this time rather than just requesting a resource i'm also telling the server that i want it to behave as if i connect as if it was this other address this other host name, illinois.edu. here's why today we can have multiple hostnames which resolve to the same ip address and so our web server doesn't know which actual host that you would like it to pretend to be unless you tell it so perhaps if i told it that we wanted "to connect to behave as ""www.cs.illinois.edu""" it might give us a different response hey let's just try that for a moment ok so we'll compile it ok and will run the client again	address	206
ok ok nope that's still telling us to go to a different web page ok but you might notice something surprising here which is that i'm using this call i haven't talked about it before called dprintf ok so dprint f is this very strange call is not truly part of the posix standard but it makes our life a lot easier what it does is it	printf	190
and start passing in additional parameters ok so if you've got strings and integer numbers that you want to send to your socket remember dprintf can be a useful tool here rather than using write directly and then i'm going to start reading back what the server says so i need a little buffer and i've got my little read loop in here and every time i get some bytes back i'm going to write them out to standard out i'm going to finish if it	parameter	32
and start passing in additional parameters ok so if you've got strings and integer numbers that you want to send to your socket remember dprintf can be a useful tool here rather than using write directly and then i'm going to start reading back what the server says so i need a little buffer and i've got my little read loop in here and every time i get some bytes back i'm going to write them out to standard out i'm going to finish if it	printf	138
and start passing in additional parameters ok so if you've got strings and integer numbers that you want to send to your socket remember dprintf can be a useful tool here rather than using write directly and then i'm going to start reading back what the server says so i need a little buffer and i've got my little read loop in here and every time i get some bytes back i'm going to write them out to standard out i'm going to finish if it	string	63
ever fails so if either i read back zero meaning ok there's no more bytes for us then i want to stop also if read returns -1, then we're not going to read anymore so this is the simplest kind of code i write but it's not complete i'm not yet handling the case that we got we got interrupted i'm also not handling	code	195
ok the last thing that we're not doing in his code is gracefully shutting down tcp connection so really we should be using shutdown	code	46
and also we should polite code should also call close on the file descriptor so we should also call socket close on the file descriptor socket	code	26
to say hey let's free up this socket but as this is very simple and short demo code that's going to happen automatically when the process shuts down ok so that's the beginnings of our tcp client let's see in the next video let's talk about how to make a tcp server are you ready let's go	code	79
and i'll have a child process work with each each client well that was scale up to a certain point because at some point my all these processes might be very heavy handed way of servicing thousands of clients processes relatively expensive to create and maybe i could do a better job so maybe a better job is to use threads ok so great let's make a new thread for every client that connects every time except returns let me kick off a new thread just to handle that request and some web servers do that so for example there's python web servers do that ok so this scales fairly well but of course if we attempted to have say a thousand active threads all trying to run at the same time then my performance will start to suffer perhaps there is a better way of doing this and so yes ladies and gentlemen welcome to the game i've tried to figure out how to write really top and high performance servers servers that actually squeeze the most possible bandwidth out of our limit cpu limited memory limited network connections etc and we want to be able to handle not just say ten friends or hundred people that connect to our machine but possibly thousands or even greater connections	memory	988
and i'll have a child process work with each each client well that was scale up to a certain point because at some point my all these processes might be very heavy handed way of servicing thousands of clients processes relatively expensive to create and maybe i could do a better job so maybe a better job is to use threads ok so great let's make a new thread for every client that connects every time except returns let me kick off a new thread just to handle that request and some web servers do that so for example there's python web servers do that ok so this scales fairly well but of course if we attempted to have say a thousand active threads all trying to run at the same time then my performance will start to suffer perhaps there is a better way of doing this and so yes ladies and gentlemen welcome to the game i've tried to figure out how to write really top and high performance servers servers that actually squeeze the most possible bandwidth out of our limit cpu limited memory limited network connections etc and we want to be able to handle not just say ten friends or hundred people that connect to our machine but possibly thousands or even greater connections	thread	316
and we need therefore away to be able to handle thousands or ten thousands possibly even millions of connections so how can we do that and this is where posix comes to the rescue and we're going to quickly kind of go through a little bit about kind of three options that you have today so here's a game plan for forget for a moment we've got threads and processes let's just think about how even just one process with one thread	thread	342
could actually service many clients so this is a bit like a problem of having a single waiter in your restaurant and how can that way to serve many tables at the same time what we need is a way for the waiter to only pay attention to the tables which actually ready to talk to the waiter maybe they're ready to eat maybe they are ready to clear the table and return the country order right but for many other tables there's nothing to do right now they don't need the attention of the waiter so this the ideology works in terms of our far descriptors that if i've got a set of file descriptors right now so let's see accept 's return to many time and many times and i've actually got say here we go far descriptors four five six and seven correspond to four different connections right now i could have a single thread i think process somehow trying to talk to all of these clients at the same time ok now but it turns out of course that right now for we don't need to do anything with the waiting for them to say something to us five death sending are some data and but they don't have any data for us right at this instant we're still waiting for more to arrive six we're currently sending result and we're halfway through sending that file but they're not ready to receive any more data yet and seven well we just haven't heard of in awhile perhaps at some point we're going to give up on seven and terminate that connection right so one single waiter could do all of this so our plan is to somehow say hey thread i want you to block until some some activity is required on our open connections say on this set of connections and this is what does select does so with select you can say here's a range of far descriptors say four to seven and i want you to block forever until something is happened ok actually select allows you just put a time out so you could say block until something is happened or say one millisecond or second has passed right so when he returns are you can actually interrogate to see what's happened to each of your tables and decide what you're waiting wants to do the problem with select is this checking this polling of all of the file descriptors is an order n operation so	block	1531
could actually service many clients so this is a bit like a problem of having a single waiter in your restaurant and how can that way to serve many tables at the same time what we need is a way for the waiter to only pay attention to the tables which actually ready to talk to the waiter maybe they're ready to eat maybe they are ready to clear the table and return the country order right but for many other tables there's nothing to do right now they don't need the attention of the waiter so this the ideology works in terms of our far descriptors that if i've got a set of file descriptors right now so let's see accept 's return to many time and many times and i've actually got say here we go far descriptors four five six and seven correspond to four different connections right now i could have a single thread i think process somehow trying to talk to all of these clients at the same time ok now but it turns out of course that right now for we don't need to do anything with the waiting for them to say something to us five death sending are some data and but they don't have any data for us right at this instant we're still waiting for more to arrive six we're currently sending result and we're halfway through sending that file but they're not ready to receive any more data yet and seven well we just haven't heard of in awhile perhaps at some point we're going to give up on seven and terminate that connection right so one single waiter could do all of this so our plan is to somehow say hey thread i want you to block until some some activity is required on our open connections say on this set of connections and this is what does select does so with select you can say here's a range of far descriptors say four to seven and i want you to block forever until something is happened ok actually select allows you just put a time out so you could say block until something is happened or say one millisecond or second has passed right so when he returns are you can actually interrogate to see what's happened to each of your tables and decide what you're waiting wants to do the problem with select is this checking this polling of all of the file descriptors is an order n operation so	thread	812
it's not order n squared is not n log n so it's only order n but if we're talking about say wanting to have thousands connections or truly truly having the most performance possible then we were little upset about this is that hey we don't like it when our system calls actually slow us down perhaps as a better design	system	257
and so this is where poll comes in paul was really designed system interface to say maybe we need instead away to say look i'm going to tell the system about a set of file descriptors i care about and come back to me when something is happened but don't make me keep asking each table whether it's ready instead tell me which specific tables need more food so poll was a new way to kind of interrogate the system to see which file descriptors were ready to either receive or send more data	each table	274
and so this is where poll comes in paul was really designed system interface to say maybe we need instead away to say look i'm going to tell the system about a set of file descriptors i care about and come back to me when something is happened but don't make me keep asking each table whether it's ready instead tell me which specific tables need more food so poll was a new way to kind of interrogate the system to see which file descriptors were ready to either receive or send more data	system	60
the poll was developed on there going to bsd system so not linux but the another free operating system which is also aims to be posix compliant but today you won't find poll on your linux machine but you will find it on your macintosh laptop on os x because os x is based on bsd ok so which brings us finally to epoll so whilst poll was an improvement over select and satisfied a few corner cases like being able to easily discover when file descriptors had closed eapol tried to kind of fix all the corner cases of poll ok so today if your challenge is to write the world 's fastest web server linux then you need to pull out epoll out of your back pocket so equal solves the order n problem epoll allows us to in order one time find out which file descriptors are ready to receive or send information	system	45
oh i forgot to say one little thing about erino down here which is when is it set ok so here's a big idea is that it set to zero when your first program first starts up its value is changed whenever there's an error with a system called and we read the man pages to learn more about that but it's never reset back to zero so if i had a whole lot of calls let's say that i try to read from warm particular file descriptor and then try to write those bites somewhere else to another file descriptor fd two over here if i then check if evan oh zero or not then i can't actually tell you whether where the error curd maybe it happened early on inside my read maybe it happened inside my right or maybe it happened even earlier so just think of is a global variable that if an error occurs we change it	a system call	221
oh i forgot to say one little thing about erino down here which is when is it set ok so here's a big idea is that it set to zero when your first program first starts up its value is changed whenever there's an error with a system called and we read the man pages to learn more about that but it's never reset back to zero so if i had a whole lot of calls let's say that i try to read from warm particular file descriptor and then try to write those bites somewhere else to another file descriptor fd two over here if i then check if evan oh zero or not then i can't actually tell you whether where the error curd maybe it happened early on inside my read maybe it happened inside my right or maybe it happened even earlier so just think of is a global variable that if an error occurs we change it	system	223
so now if you do that and you make some system tools	system	40
in practice of course bulletproof code robust production code would actually check the return values of all of your system calls and that is kind of really good system programming practice to kind of detect when errors go wrong and actually becomes critical when you start writing network code c in the next video bye	code	34
in practice of course bulletproof code robust production code would actually check the return values of all of your system calls and that is kind of really good system programming practice to kind of detect when errors go wrong and actually becomes critical when you start writing network code c in the next video bye	system	116
alright so let's talk about rate right so the big idea is we want to make our file systems resilient gay right sir	system	83
the cost of per gate is is going down and the size of the features are going down and so great we have lots and lots of cpu power if your cpu is not fast enough just wait a year plus our memory was going faster but actual persistent storage disks they weren't doing so well that the seek time the time required to move	memory	187
the biggest disadvantage of this system is that we've just doubled the cost now they cost	system	33
per megabyte is double what it needed to be for just buying a single disk so however it's simple it's easy to understand and today you can still buy raid one disc siper i personally have one as a backup system which presents itself as a single usb disk but internally is actually formatted an configured as a raid one drive so if one of those disks dies i can still hopefully recover their backup	system	203
ok right so that's very well let's have a look at a slightly better system where we can use paraty codes so if you give me a set of n bits let's say four therm or eight of them then i can always generate another bit called the parody bit to ensure that the total number of ones	code	99
ok right so that's very well let's have a look at a slightly better system where we can use paraty codes so if you give me a set of n bits let's say four therm or eight of them then i can always generate another bit called the parody bit to ensure that the total number of ones	system	68
is is even ok so if i just simply x all all the bits you give me i can then use that as my paraty code so this is useful because now we can always recover any one of these last bits so if if my disk i've lost bit two out of this set then i could just use the parrot ebit along with all of the other remaining bits to infer what is missing	code	98
so the cost of my system put for each megabyte is not that much worse than just buying individual disks	system	18
right one disadvantage is that that every time we want to write down a block of data we must write to disparity disk so come back right so there is a potential go back there we go get my pen working right so we've always gotta be updating this disparity block which means we'll always writing to the parity disk and so in practice with raid three this becomes the usual becomes the major performance bottleneck here which is that i'm i'm stressing out my poor parity disk all the time as i every time i do a right so	block	71
ok so then a small nuclear explosion happens on one of my discs right but you say hurrah i can actually recover my data so we can just going to do this by reading the data back from all the other disks and we can re calculate the last data using the parity code and then of course we can rebuild the data so i can buy purchasing your disk and carry on as before so whilst it's doing this while she's rebuilding the raid the raid the raid array we can continue to use these disk drives my enterprise service my website whatever it is can continue to function however of course the amount of disk io that i can use is now reduced because these discs are very busy pulling out all of the old data in order to recalculate the parrot information in order to recalculate the lost data also notice that its scheme is only going to work providing we we lose at most one disc	code	257
ok so can we do better than made three yeah let's talk about kind of raid five raid five and raid six or kind of some of those standard raids that we use today i'm not going to go into full detail of grateful life i'll just mention some highlights first of all we no longer strike just using single bytes and look into bits we actually now have much larger check blocks which reduces the can increase of performance because potentially we can just store one part of our data on a single disk for example but we still have the idea of storing a paraty information it's just rather than pudding that party information inside a single special specialized disk we can now distribute it across our away so these check blocks these are parrot information here for different different data blocks will be stored on different disks	block	363
and then i will build up a raise of those of those disks as if my mirrors themselves are single disks other people go the other way or who made zero plus one but it is quite common instant tries to say look if i'm going to mirror mirror some bites across two discs then i might put them in separate enclosures so that if there's water damage if the roof fails if the pipes leak or electrical takes out just one of my disk enclosures at least as a good chance that all of my data is still available inside my other enclosure another final comment on raid is that it's not a backup solution as you can see is the purpose of raid is to be able to cope with disk failures and still have storage mechanism which will remain online there's always an opportunity for my entire disk array to fail like i said for example there's lightning or water damage just takes out all of your disks in one go at which point you better have a larger backup system in place ready to recover all of your data	system	937
and google so this is the kind of quote from one of people working at google say hey you know you have a large storage system when you get paged at one o'clock in the morning to say you only have a few petabytes of storage left not a problem that i've ever have had to worry about early having a petabyte of data left bit petabytes of storage left so these are the kind	system	119
to start a little startup which is going to grow to the size of google how would you design a file system	system	99
to service all of googles app stand out all of these applications everything from gmail to docs to its website etc to its web serving we need a file system to represent all this how do we make it resilient ok so any other sides of google then failure is not an option it's the common case so disks fail all the time and physical disks fail are typically between one and ten percent so it's a full more than the full time job just simply replacing all those disks which are failing and in a single data warehouse you might have say sixty thousand one hundred thousand physical disks so	system	149
replacing those is a full time job but we want our file system to be up it would be embarrassing to say excuse me moment google has to be down for a day or two we need an extremely reliable file system without that file system you cannot do anything else so we need to realize of failure modes go beyond just reduce go beyond just losing one or two discs inside a single rate so for example we need to design a system	system	56
they can survive not just a fairly of a single disk but the failure of a whole rack of servers or even a whole light of a whole data center perhaps two the two fiber lines that are running out on either side of the building both simultaneously get attacked by say earthquake or mechanical digging device there are lots of reasons why suddenly your data center may not be available to the rest of the world maybe the entire power goes out in your backup generators fail maybe there's lightning maybe there's war etc etc so how can we build a distributed storage mechanism that services the whole world ok so here's how google approached it back in two thousand and one they used simple redundancy so around the world had kind of two or three copies of each file today the file system is similar to kind of raid design except that we use	system	776
there we go reed solomon codes so reed solomon codes they crop up actually in different interesting places inside computer sites one of their most first uses mass market uses was actually with compact discs with cds here's a wonderful thing about reed solomon	code	25
codes that you can their mathematical codes and you can choose them in terms of their redundancy of information that you're prepared to accept so you can choose your risk and the expense ratio that you'd like to use for different codes and reed solomoncodes work very well when there's a missing block of data so their idea was not just to say oh i have some parity information but that i can be extended periods of data missing so for example in this case i've just kind of taking out the middle part of this block i still can recover the original bits that this block of data represented so this is great for cds because i actually might have a physical error on part of the disk surface which prevents me from reading a small contiguous set of bits here and yet i'm able to recover the whole set of bits from my original data simple idea with space communication if i want to talk to a probe on the moon or further then electromagnetic noise and other	block	296
codes that you can their mathematical codes and you can choose them in terms of their redundancy of information that you're prepared to accept so you can choose your risk and the expense ratio that you'd like to use for different codes and reed solomoncodes work very well when there's a missing block of data so their idea was not just to say oh i have some parity information but that i can be extended periods of data missing so for example in this case i've just kind of taking out the middle part of this block i still can recover the original bits that this block of data represented so this is great for cds because i actually might have a physical error on part of the disk surface which prevents me from reading a small contiguous set of bits here and yet i'm able to recover the whole set of bits from my original data simple idea with space communication if i want to talk to a probe on the moon or further then electromagnetic noise and other	code	0
noise elements can take out blocks moments of data and so with reed solomon codes i can ensure that there's a strong likelihood i've i can still recover parts of the data all right so that's all i want to say about reedsolomoncodes just hey put that in your back pocket maybe one day you'll be working on an application that can benefit from them and last thing is hey notice that the google decided to go with an overhead of about one point five redundancies so so for every megabyte that you want to store it actually uses one point five megabytes on the disk	block	28
noise elements can take out blocks moments of data and so with reed solomon codes i can ensure that there's a strong likelihood i've i can still recover parts of the data all right so that's all i want to say about reedsolomoncodes just hey put that in your back pocket maybe one day you'll be working on an application that can benefit from them and last thing is hey notice that the google decided to go with an overhead of about one point five redundancies so so for every megabyte that you want to store it actually uses one point five megabytes on the disk	code	76
ok right so let's talk about what what is a mutex mutex is the key thing that we need in order to implement critical sections if you think about our code from moment where our critics sections are basically	code	149
ok right so let's talk about what what is a mutex mutex is the key thing that we need in order to implement critical sections if you think about our code from moment where our critics sections are basically	a mutex	42
ok right so let's talk about what what is a mutex mutex is the key thing that we need in order to implement critical sections if you think about our code from moment where our critics sections are basically	section	117
where we want to do surgery on a data structure that moment we only want one surgeon in the room most of the time my thread can be busy say working on the sound another one could be working on the ui another one	a struct	36
where we want to do surgery on a data structure that moment we only want one surgeon in the room most of the time my thread can be busy say working on the sound another one could be working on the ui another one	thread	117
but at some point they need to come together and say send messages over data bus or some other kind of event structure so when they manipulate that structure only one of them should be changing at a time ok so that we've identified a critical section and now we need to make sure that if one thread is currently doing that then other threads get temporarily blocked put on pause if you like whilst we are in that critical piece of code and the key to doing that then is this	block	358
but at some point they need to come together and say send messages over data bus or some other kind of event structure so when they manipulate that structure only one of them should be changing at a time ok so that we've identified a critical section and now we need to make sure that if one thread is currently doing that then other threads get temporarily blocked put on pause if you like whilst we are in that critical piece of code and the key to doing that then is this	code	431
but at some point they need to come together and say send messages over data bus or some other kind of event structure so when they manipulate that structure only one of them should be changing at a time ok so that we've identified a critical section and now we need to make sure that if one thread is currently doing that then other threads get temporarily blocked put on pause if you like whilst we are in that critical piece of code and the key to doing that then is this	section	243
but at some point they need to come together and say send messages over data bus or some other kind of event structure so when they manipulate that structure only one of them should be changing at a time ok so that we've identified a critical section and now we need to make sure that if one thread is currently doing that then other threads get temporarily blocked put on pause if you like whilst we are in that critical piece of code and the key to doing that then is this	thread	292
add a mutex is actually go back there right actually a shortening of do i have i want to be able to type we try some letters here ok there we go right ashley short for	type	100
add a mutex is actually go back there right actually a shortening of do i have i want to be able to type we try some letters here ok there we go right ashley short for	a mutex	4
so the pieces sort of peaceful so we've got we've seen p thread so far now that if you look at what posix gives us for mutexes ok i'll see you in the next video	thread	57
and if it doesn't have enough entropy available then it blocks until there is some entropy available so you'll see that with our four hundred and seven bits that is what about fifty bites or about kind of a hundred or so hexadecimal digits which is of order or what we've just printed out just here so we've exhausted the entropy	block	56
stream of random numbers but realize that it's a very limited stream you can't just keep asking for megabytes of data from that so use it wisely user just a small amount of it otherwise you'll be blocked waiting for more interpreted to appear	block	196
if you're random needs less less strict perhaps you don't need to kind of be generating secrets for encryption keys for example then you can use slash dev slash view random and urandom does not block so will keep generating for us to a whole lot of random numbers still based on some of the secure entropy of the system however	block	194
if you're random needs less less strict perhaps you don't need to kind of be generating secrets for encryption keys for example then you can use slash dev slash view random and urandom does not block so will keep generating for us to a whole lot of random numbers still based on some of the secure entropy of the system however	system	313
there's no requirement for it to be cryptographically secure gay so in principle these numbers are guessable by an adversary for example suppose you were writing making a system on some devices which booted up like a small router or something and there's very little entropy in the system so you decided to use urandom well that means now that an adversary might under some circumstances if they really understand your system and which version of the kernel you using etc etc etc might stand a chance of being able to workout what your	system	171
guess as to what inputs you had your cryptographic system and therefore might be able to breakdown your encryption system so urandom is great for when you just need numbers but you're not worried about kind of robust random under which you can put into an encryption system ok so let's go back to our	system	51
there we go right to random and say why you were to give any more data so we need to increase the amount of entropy in my system i could do that by generating say network packets by by sending some io so let's send some network packets ok so here's me on another terminal i'm going to send a whole load of network packets by just kind of randomly typing for a little while so this should be increasing the entropy of my system but would have put up with arbiter right we could do ls we could say to a cd we can causing hopefully some more network packets i could say find and take all the output and put it into case so i want to take all the output and put it into slash dev stack so it will stop that and yes that was enough to generate some more entropy so that we could actually get some more random numbers out of this thing so that's fun remember then you've got two sources of random information and one of them slash random dev slash random is great when you want to cryptographically secure stuff but may block if there's not enough entropy in the system by	block	1014
there we go right to random and say why you were to give any more data so we need to increase the amount of entropy in my system i could do that by generating say network packets by by sending some io so let's send some network packets ok so here's me on another terminal i'm going to send a whole load of network packets by just kind of randomly typing for a little while so this should be increasing the entropy of my system but would have put up with arbiter right we could do ls we could say to a cd we can causing hopefully some more network packets i could say find and take all the output and put it into case so i want to take all the output and put it into slash dev stack so it will stop that and yes that was enough to generate some more entropy so that we could actually get some more random numbers out of this thing so that's fun remember then you've got two sources of random information and one of them slash random dev slash random is great when you want to cryptographically secure stuff but may block if there's not enough entropy in the system by	system	122
and inside our main method we're going to do we're going to create a whole load of pizza it's ok and make a note of their thread i ds pass in the firework function ok and then after we've done that we will set fireworks equal to one and then will call preconditions signals so we know that is going to wake up one thread	thread	122
now we want to wait for all threads to finish here so i could write a for loop to call p thread join on all of my thread i ds but i could also be lazy in to say ok pthread less exit the main thread	thread	28
so that we never returned from maine so i could call p thread exit here key	thread	55
right so great we've implemented that now actually let's have to think about how we can implement the firework right so what does r firework do k right well we acquire the mutex lock i might impede here just for for sure had so we've got we've got the mutex lock and all threads that run this code again to acquire the same lock	code	293
right so great we've implemented that now actually let's have to think about how we can implement the firework right so what does r firework do k right well we acquire the mutex lock i might impede here just for for sure had so we've got we've got the mutex lock and all threads that run this code again to acquire the same lock	thread	271
and then we say well while fireworks is zero corporate recognition weight in other words if my firework thread starts up here and it starts up early then we're just going to block it for but we're going to ask it to release the mutex lock and lock inside here so go back to the kind of first code remember we created all of the threads initially back when are fireworks variable with zero it's only after we've created all five	block	174
and then we say well while fireworks is zero corporate recognition weight in other words if my firework thread starts up here and it starts up early then we're just going to block it for but we're going to ask it to release the mutex lock and lock inside here so go back to the kind of first code remember we created all of the threads initially back when are fireworks variable with zero it's only after we've created all five	code	292
and then we say well while fireworks is zero corporate recognition weight in other words if my firework thread starts up here and it starts up early then we're just going to block it for but we're going to ask it to release the mutex lock and lock inside here so go back to the kind of first code remember we created all of the threads initially back when are fireworks variable with zero it's only after we've created all five	thread	104
ok so let's get down here ok right so what do we do after this point ok when we escape out of here where a scaping out of here because fireworks is no longer no longer zero and the very first thing we do is call p three condition broadcast in other words ring that fire bell wake everybody up in this might be sleeping inside this condition variable ok so now all five of my threads	thread	375
definitely working up ok so i implement increment the value of fireworks i print out oh and that value and then i decrement it ok so what's going to be the largest value this code will print one two three four five six what do you think so just as a reminder i've got five threads running this and the only way they can escape out of this code is after fireworks is no longer zero so what's the maximum possible value that we might see from this first to run this hundred or thousand to a million times what's the largest integer that would expect here ok so think about that pause this video and make your choice and then we'll see if you're correct ok so we think about this for five seconds and then we'll review the answers	code	175
definitely working up ok so i implement increment the value of fireworks i print out oh and that value and then i decrement it ok so what's going to be the largest value this code will print one two three four five six what do you think so just as a reminder i've got five threads running this and the only way they can escape out of this code is after fireworks is no longer zero so what's the maximum possible value that we might see from this first to run this hundred or thousand to a million times what's the largest integer that would expect here ok so think about that pause this video and make your choice and then we'll see if you're correct ok so we think about this for five seconds and then we'll review the answers	thread	273
ok wait times up so let's let's have a look at the key key detail here the key detail is a mutex lock our mutex lock allows us to reason strongly about the number of threads which are actually running in this code	code	209
ok wait times up so let's let's have a look at the key key detail here the key detail is a mutex lock our mutex lock allows us to reason strongly about the number of threads which are actually running in this code	a mutex	89
ok wait times up so let's let's have a look at the key key detail here the key detail is a mutex lock our mutex lock allows us to reason strongly about the number of threads which are actually running in this code	thread	166
because we've acquired mutex lock means that any other threads that want to run have to also require it so all of these lines of code can only be run by one thread at a time	code	129
because we've acquired mutex lock means that any other threads that want to run have to also require it so all of these lines of code can only be run by one thread at a time	thread	55
if the threads have gone to sleep inside p thread condition wait there only allowed to escape out of that after they reacquired the mutex log so that's the key idea that only one third of the time can be running this piece of code and it allows us to actually reason about this so we know that when we escape out of here the very first thread will see of fireworks value of one because we changed it upstairs in the main method so we implement so we increment it to two case of wig the first escapes out of here will	code	226
if the threads have gone to sleep inside p thread condition wait there only allowed to escape out of that after they reacquired the mutex log so that's the key idea that only one third of the time can be running this piece of code and it allows us to actually reason about this so we know that when we escape out of here the very first thread will see of fireworks value of one because we changed it upstairs in the main method so we implement so we increment it to two case of wig the first escapes out of here will	thread	7
will print out too and then we decrement it down to one again and then we unlock the mutex ok so the next step that comes out of here will only escape out of p three condition wait after we've unlock the mutex so it will also see a value of fireworks of one it also does a big forecast waking everybody up and most are too and so it will print out the value of two etc right and so on the next thread will come out check the condition for the while loop ok that is no longer true so it comes to an does the same thing increments it from one to two and then two to one and then unlocks the mutex which allows the next set to escape it checks the value and so on and so on so right so let's just kind of run this just to kind of prove it right so we have ok compiled it	thread	394
why is my machine slow ok there we go he got out all right and we see every firework every thread wanna see the value of two and we could do that through this strong reasoning thanks to the mutex log	thread	91
that these two lines of code here	code	24
between us deciding the value of fireworks is zero and then calling peter condition wait so if it happened right inside there if that just that moment in time then what's going to happen we've actually called preconditions signal but no thread was yet sleeping no thread was yet blocked inside condition wait ok so was to fix for that and the answer is to actually log on the same mutex here so if i call pete said mutex lock here	block	279
between us deciding the value of fireworks is zero and then calling peter condition wait so if it happened right inside there if that just that moment in time then what's going to happen we've actually called preconditions signal but no thread was yet sleeping no thread was yet blocked inside condition wait ok so was to fix for that and the answer is to actually log on the same mutex here so if i call pete said mutex lock here	thread	237
another thread is acquired mutex or after the all the threads have called pizza hut	thread	8
another thing this code is kind of highlights is that	code	19
that you can create threads but peter create doesn't wait for them to actually start so this this code is an attempt to say ok let's create all these threads and actually we're going to make our own barrier	code	98
that you can create threads but peter create doesn't wait for them to actually start so this this code is an attempt to say ok let's create all these threads and actually we're going to make our own barrier	thread	20
inside here so we won't let anybody go until we've actually created or five threads and also kind of starting up so but this line of actually changing the fireworks to one here could still actually technically occur before this five threads of actually started all we've just simply say is to say ok create them and at some point in the future please run alright so lots of interesting interleavings details there and as you can see this stuff is tricky	thread	76
ok so our game is to determine is that deadlock here right so let's sketch this out i'll start with some black just to put down my process is so i've got process one process to process three and this time a process four was well ok right process one gets a then be right	a process	205
k and you will be requesting being in the future but you haven't quite got there yet ok so what do we got right so is there deadlock well process one can continue as we mentioned that before so at some point in the future process one can release those resources ok so what happens next so now process two we set our locks were going to be so the access to this was going to be fair and so	resources	252
hi ok so let's talk about critical sections of functions which are not necessarily thread safe in terms of their implementation so here's a little example based on some real code where we want to be able to internally log errors so we don't want to display them to the console now we actually want to store them on some file so let's have a quick look to see how it works so when you call my log error function it takes an error number some integer and an optional message which eventually we're going to save to a file so you'll see down here we call f printf we're going to store it in this file handle when we've just got a string of the message and some error string as well and then finally let's flush that as well so it is actually definitely written out of the file ok now let's look at some of the other details first of all notice that	code	174
hi ok so let's talk about critical sections of functions which are not necessarily thread safe in terms of their implementation so here's a little example based on some real code where we want to be able to internally log errors so we don't want to display them to the console now we actually want to store them on some file so let's have a quick look to see how it works so when you call my log error function it takes an error number some integer and an optional message which eventually we're going to save to a file so you'll see down here we call f printf we're going to store it in this file handle when we've just got a string of the message and some error string as well and then finally let's flush that as well so it is actually definitely written out of the file ok now let's look at some of the other details first of all notice that	printf	554
hi ok so let's talk about critical sections of functions which are not necessarily thread safe in terms of their implementation so here's a little example based on some real code where we want to be able to internally log errors so we don't want to display them to the console now we actually want to store them on some file so let's have a quick look to see how it works so when you call my log error function it takes an error number some integer and an optional message which eventually we're going to save to a file so you'll see down here we call f printf we're going to store it in this file handle when we've just got a string of the message and some error string as well and then finally let's flush that as well so it is actually definitely written out of the file ok now let's look at some of the other details first of all notice that	string	627
hi ok so let's talk about critical sections of functions which are not necessarily thread safe in terms of their implementation so here's a little example based on some real code where we want to be able to internally log errors so we don't want to display them to the console now we actually want to store them on some file so let's have a quick look to see how it works so when you call my log error function it takes an error number some integer and an optional message which eventually we're going to save to a file so you'll see down here we call f printf we're going to store it in this file handle when we've just got a string of the message and some error string as well and then finally let's flush that as well so it is actually definitely written out of the file ok now let's look at some of the other details first of all notice that	section	35
hi ok so let's talk about critical sections of functions which are not necessarily thread safe in terms of their implementation so here's a little example based on some real code where we want to be able to internally log errors so we don't want to display them to the console now we actually want to store them on some file so let's have a quick look to see how it works so when you call my log error function it takes an error number some integer and an optional message which eventually we're going to save to a file so you'll see down here we call f printf we're going to store it in this file handle when we've just got a string of the message and some error string as well and then finally let's flush that as well so it is actually definitely written out of the file ok now let's look at some of the other details first of all notice that	thread	83
my file up here is null so if not file then that's when i'm going to choose to f open it and i'm going to call it a file called error log dot text and i want to append so if there's any other content down there let's zip to the end of the file first ok so if two threads were calling this at the same time	thread	263
you could imagine where an interleaving of instructions where both threads see value of null because we haven't opened the file yet so both threads decide to call f open and then write that result into the single file handle the global variable there so that wouldn't be great we only want one thread to ever call ever open so that is certainly a critical section	section	356
you could imagine where an interleaving of instructions where both threads see value of null because we haven't opened the file yet so both threads decide to call f open and then write that result into the single file handle the global variable there so that wouldn't be great we only want one thread to ever call ever open so that is certainly a critical section	thread	67
the time between actually testing whether it is null and changing it we don't we don't want to be interrupted during those times there's a second question in here as well however which is how do we generate a character based error message here string called terror former number we're using something called store error i wonder if this is safe to call for multiple threads at the same time and of course one of the reasons that we kind of suspicious about this	string	244
the time between actually testing whether it is null and changing it we don't we don't want to be interrupted during those times there's a second question in here as well however which is how do we generate a character based error message here string called terror former number we're using something called store error i wonder if this is safe to call for multiple threads at the same time and of course one of the reasons that we kind of suspicious about this	thread	366
is because it takes an inch returns a character pointer	pointer	48
and it doesn't look like we need to free that character pointers so i wonder if it's going to internally using some static memory or something so warm way to find that out on a lennox machine is to go and check the thread safety of the functions that you actually using so i want to mac right now so i pulled up the lyrics version of stuart error and will see a couple surprising things first of all there's a whole lot of additional versions with under school are underneath	memory	123
and it doesn't look like we need to free that character pointers so i wonder if it's going to internally using some static memory or something so warm way to find that out on a lennox machine is to go and check the thread safety of the functions that you actually using so i want to mac right now so i pulled up the lyrics version of stuart error and will see a couple surprising things first of all there's a whole lot of additional versions with under school are underneath	thread	215
and it doesn't look like we need to free that character pointers so i wonder if it's going to internally using some static memory or something so warm way to find that out on a lennox machine is to go and check the thread safety of the functions that you actually using so i want to mac right now so i pulled up the lyrics version of stuart error and will see a couple surprising things first of all there's a whole lot of additional versions with under school are underneath	pointer	56
right so how do we fix this well one option of course is to use these other versions to underscore art another is to use locking so for example we could use our mutex locks to lock a mutex at the beginning and unlock it at the end so if we wanted to make sure that i know of	a mutex	181
thread could also effort therefore flush at the same time to my file then i would unlock afterwards so that would be one way	thread	0
about the performance hit now on my application because now every time i'm looking something i've every time i log in some things only one time can do that and only one thread at a time can write to the message and flush the files so with all these flashes going on as well it might actually slow down my application so how can i fix that or maybe i need to develop a better logging mechanism say	thread	169
ok great i welcome to like twenty eight so let's get started we're going to look a little bit more at our file system representation and then dive into stats and how we're going to have hard links and symbolic	system	111
to our files so just as a kind of quick warmup remember we're playing with the model of the e x two two file system	system	109
and my i node is the file i can't create a file in this i've actually gotten i knowed entry and i'm going to have will say ten entries inside my i know directly to the first ten disk blocks used by my file so in otherwise i could hold forty kb there and then i also have inside the i node that this block which holds a table with a thousand twenty four entries and then another entry side the i node for my double interact an another entry for the really large files which is actually going to be a triple indirect in those for the triple indirect i need to follow the money three times i have to load three blocks before actually can find out where the data is stored but even for very large files the beginning of the file is always stored in these direct blocks so that we have nice fast access to those	block	183
ok right so let's kind of run through this remember that my disk is when i format it i've formatted it into a super block and i may have copies of that to the rest of the rest of the disk for backup purposes have a space set aside for i nodes and the rest of the space is going to be used for the actual files and any indirect blocks that we need to store okie sue this will look at our quick first question for x two with four kilobyte blocks at thirty two bit addressing watson maximum size are disk that we can support well the idea for this question is not about the indirect and double in triple indirect it's more the fact that if i want to say to the disk hey disc actually would load a particular disk block please then i can pass in a number which is bounded by thirty two bit addressing scheme so i've got two to thirty two possible dis blocks i could request and each one is four kb so if we do the math here and i think i did it in a previous lecture here that's remember the two to the thirty two how can i think about that well two to the ten is anybody knows is about a thousand thousand and twenty four ok so two of the thirty two is actually two to the ten times two to the ten times two to ten times ten times two to the two ok so now we can see that i'm going to change my units from kilobytes to megabytes to gigabytes to terabytes queso terabytes and then i've just got this two of the two times the original four so in other words i can support up to sixteen terabyte disks alright i hope that quick back of the envelope calculation makes sense	block	116
ok right so let's kind of run through this remember that my disk is when i format it i've formatted it into a super block and i may have copies of that to the rest of the rest of the disk for backup purposes have a space set aside for i nodes and the rest of the space is going to be used for the actual files and any indirect blocks that we need to store okie sue this will look at our quick first question for x two with four kilobyte blocks at thirty two bit addressing watson maximum size are disk that we can support well the idea for this question is not about the indirect and double in triple indirect it's more the fact that if i want to say to the disk hey disc actually would load a particular disk block please then i can pass in a number which is bounded by thirty two bit addressing scheme so i've got two to thirty two possible dis blocks i could request and each one is four kb so if we do the math here and i think i did it in a previous lecture here that's remember the two to the thirty two how can i think about that well two to the ten is anybody knows is about a thousand thousand and twenty four ok so two of the thirty two is actually two to the ten times two to the ten times two to ten times ten times two to the two ok so now we can see that i'm going to change my units from kilobytes to megabytes to gigabytes to terabytes queso terabytes and then i've just got this two of the two times the original four so in other words i can support up to sixteen terabyte disks alright i hope that quick back of the envelope calculation makes sense	address	462
ok so let's have a look at the following question then so if each i'd entries are fixed size always a hundred and twenty eight bytes and i've when i formatted my disk i said please put a size sixty four kb for the i node away in the words the space up here there we go	the following	27
how large can of rb before triple indirect blocks are required ok so to answer this one it means we're going to use the ten direct blocks so that's going to be forty kilobytes then we have the indirect block so my indirect block itself is four kb but we're using thirty two bit addressing so that means each one of those entries here is going to be a number which takes four bytes for my thirty two bits ok so for my four kb block here that means i can have	block	43
how large can of rb before triple indirect blocks are required ok so to answer this one it means we're going to use the ten direct blocks so that's going to be forty kilobytes then we have the indirect block so my indirect block itself is four kb but we're using thirty two bit addressing so that means each one of those entries here is going to be a number which takes four bytes for my thirty two bits ok so for my four kb block here that means i can have	address	278
a thousand and twenty four numbers in other words i can reference a thousand and twenty fourth data blocks which means that i've got four kilobytes which means for each block which means i've got four megabytes of data here for my direct for my first indirect and then for double indirect each one of those thousand twenty four entries they themselves can actually	block	100
the largest file i can store before i need to start using triple indirect addressing is going to be forty kb plus four megabytes	address	74
plus four gigabytes an i could turn that into a an actual number of bytes if i really wanted to ok so a quick comment is so far i've been using lg k here for kilobytes meaning that my units are are based on two to the ten another thousand twenty four this manufacturers however tend to would like to maximize the apparent number of bytes that they're selling you so they use a different numbering system	system	397
they prefer to think about units in a decimal system in other words in multiples of a thousand so you the correct way to write this today is to put a little small i after this for example like a kilobyte would mean one thousand bytes or a megabyte so that would be a million bytes as in one zero zero zero zero zero zero bytes however you don't be surprised if i'm the marketing materials the disk manufacturers conveniently forget to write the small i hear also if you're buying a modem we want to talk about bits then if i'm talking about say megabits per second the small b is used to represent bits not bytes so just watch out for those kind of little gotchas there and don't be surprised in the marketing materials if they really if we get to be accurate	a megabyte	237
they prefer to think about units in a decimal system in other words in multiples of a thousand so you the correct way to write this today is to put a little small i after this for example like a kilobyte would mean one thousand bytes or a megabyte so that would be a million bytes as in one zero zero zero zero zero zero bytes however you don't be surprised if i'm the marketing materials the disk manufacturers conveniently forget to write the small i hear also if you're buying a modem we want to talk about bits then if i'm talking about say megabits per second the small b is used to represent bits not bytes so just watch out for those kind of little gotchas there and don't be surprised in the marketing materials if they really if we get to be accurate	system	46
right so let's kind of go back onto our file systems	system	45
now here's a useful little command get cwd noticed that's right it tells us the process is current working directory which is going to be useful if we want to work with relative directories and in fact paths in your system of defined to have a maximum length so you can be confident that the string that you can request can never be larger than this constant here path max and we add one just to ensure that there's enough space for the c string zero bite at the end ok so if you want to know how where you currently on file system here is one way to do it right	string	292
now here's a useful little command get cwd noticed that's right it tells us the process is current working directory which is going to be useful if we want to work with relative directories and in fact paths in your system of defined to have a maximum length so you can be confident that the string that you can request can never be larger than this constant here path max and we add one just to ensure that there's enough space for the c string zero bite at the end ok so if you want to know how where you currently on file system here is one way to do it right	system	216
so that is a limitation of function here so in fact if i type c w p w for present working directory that internally is using this gets cwd command so there it is actually part of the standard library and we can either pass in some space or we can pass in null and it will allocate it on on the heap	the heap	290
so that is a limitation of function here so in fact if i type c w p w for present working directory that internally is using this gets cwd command so there it is actually part of the standard library and we can either pass in some space or we can pass in null and it will allocate it on on the heap	type	57
in general then if you want to work with kind of paths then you can use this constant which is actually part of the kernel but provided by the c library to assure that your c strings are always of sufficient size	string	175
ok so when we do that we get a pointer back to this little directory entry structure and it's a very simple structure in fact it only has two entries it has name and the i node number so if you wanted to print out the i node number you can say ok dp tell me the i node numbers just i know so that's all it can do and you just put it in a loop and you can iterate through the directory	pointer	31
so here's a little bit of code then that actually looks at the current directory to see if a certain file exists will looking	code	26
my right so just the pen it's working good right so we are just looking to see if a particular file name exists inside the current directory and what we turned what otherwise let's return zero so what do you think about this code can you spot any mistakes in it	code	225
ok so hopefully your system programming a alarm bells go off because the problem with this code is that there's a path of execution where we forget to close the current directory so if we do find the name that we're looking for we returned one we never actually execute this closed so that's a problem	code	91
ok so hopefully your system programming a alarm bells go off because the problem with this code is that there's a path of execution where we forget to close the current directory so if we do find the name that we're looking for we returned one we never actually execute this closed so that's a problem	system	21
that we haven't closed resources so this actually security problem that it might work once or twice or ten times but we're leaving a file descriptor open and eventually will run out of spare far descriptors for process and then opening files or calling opened are won't work in the future we don't have any spare file descriptors left ok the other thing that we might comment on if we were doing a code review instead opened a could fail so if this returns null for example there is no current directory 's kind of a little bit bizarre but we could imagine that happens for example someone 's deleted the current direct current directory then this open durcal would return null so we're not actually checking for that ok and by the way in case you didn't notice look we're doing this trick to hear to say ok i know that i've finished reading the current directory when this is called to read returns null that's when i know where there's no more entries left to fight but the biggest idea here is that we didn't clean up ourselves we didn't always release resources so always check your code your system programming code to make sure that in all code paths particularly error code paths you've released resources as soon as you finished using them ok and this will correspond to file descriptors to memory to any other resources to tcp sockets etc etc etc right ok so	memory	1299
that we haven't closed resources so this actually security problem that it might work once or twice or ten times but we're leaving a file descriptor open and eventually will run out of spare far descriptors for process and then opening files or calling opened are won't work in the future we don't have any spare file descriptors left ok the other thing that we might comment on if we were doing a code review instead opened a could fail so if this returns null for example there is no current directory 's kind of a little bit bizarre but we could imagine that happens for example someone 's deleted the current direct current directory then this open durcal would return null so we're not actually checking for that ok and by the way in case you didn't notice look we're doing this trick to hear to say ok i know that i've finished reading the current directory when this is called to read returns null that's when i know where there's no more entries left to fight but the biggest idea here is that we didn't clean up ourselves we didn't always release resources so always check your code your system programming code to make sure that in all code paths particularly error code paths you've released resources as soon as you finished using them ok and this will correspond to file descriptors to memory to any other resources to tcp sockets etc etc etc right ok so	code	398
that we haven't closed resources so this actually security problem that it might work once or twice or ten times but we're leaving a file descriptor open and eventually will run out of spare far descriptors for process and then opening files or calling opened are won't work in the future we don't have any spare file descriptors left ok the other thing that we might comment on if we were doing a code review instead opened a could fail so if this returns null for example there is no current directory 's kind of a little bit bizarre but we could imagine that happens for example someone 's deleted the current direct current directory then this open durcal would return null so we're not actually checking for that ok and by the way in case you didn't notice look we're doing this trick to hear to say ok i know that i've finished reading the current directory when this is called to read returns null that's when i know where there's no more entries left to fight but the biggest idea here is that we didn't clean up ourselves we didn't always release resources so always check your code your system programming code to make sure that in all code paths particularly error code paths you've released resources as soon as you finished using them ok and this will correspond to file descriptors to memory to any other resources to tcp sockets etc etc etc right ok so	resources	23
that we haven't closed resources so this actually security problem that it might work once or twice or ten times but we're leaving a file descriptor open and eventually will run out of spare far descriptors for process and then opening files or calling opened are won't work in the future we don't have any spare file descriptors left ok the other thing that we might comment on if we were doing a code review instead opened a could fail so if this returns null for example there is no current directory 's kind of a little bit bizarre but we could imagine that happens for example someone 's deleted the current direct current directory then this open durcal would return null so we're not actually checking for that ok and by the way in case you didn't notice look we're doing this trick to hear to say ok i know that i've finished reading the current directory when this is called to read returns null that's when i know where there's no more entries left to fight but the biggest idea here is that we didn't clean up ourselves we didn't always release resources so always check your code your system programming code to make sure that in all code paths particularly error code paths you've released resources as soon as you finished using them ok and this will correspond to file descriptors to memory to any other resources to tcp sockets etc etc etc right ok so	system	1097
here it is right and in this demo we're going to implement a version of ls that is going to read a directory and also not only print out the name but print out the i node number as well so i want to make my code be somewhat cross platform as i'm just bring it out i'm going to assume that this i know number is at least unsigned is no	code	207
ok if it's larger than unsigned long i don't care because i'm just printing out the number anyway so let me just cast it i wouldn't claim that this is kind of completely portable were bused bulletproof code because maybe on some systems and i know it might be a have a larger representation further than a simple long ok right so let me compile this directory list	code	202
ok if it's larger than unsigned long i don't care because i'm just printing out the number anyway so let me just cast it i wouldn't claim that this is kind of completely portable were bused bulletproof code because maybe on some systems and i know it might be a have a larger representation further than a simple long ok right so let me compile this directory list	system	229
ok so let me say alright i'd like to list a kind directory and where hey off it goes right so you can see it's happily printing out directory names and i know numbers and on a mac don't be surprised to see very large i knowed numbers ok so we've got now a program that is behaving a little bit like ls when i type eles it prints out the names in fact i can say hey this please tell me the unknown numbers i think it's minus i and there we go we can see now the i node numbers associated with each file hopefully this is going to be the same as yet eight three four twenty for my actual program here and if i wish i could say to ls ok please actually do it in a format where it's one per per per line the other thing you might notice however is that in my program it printed out two extra yeah so actually it turns out that for	type	309
hi so let's have a look at some race conditions and we will check to see if we can actually make these race conditions occur and then maybe we can figure out how to use our mutex locks to fix them right so here's a story so far i've got my little main method doesn't do much it creates irwan thread here for under one and another thread for two ok then we run for five seconds then we set a global flag code please stop ok and then inside my main method i just wait for both to finish before returning so that is my main method nothing to it there's going to have a look at these two little runner threads here ok so here we go first of all let's look at run a one doesn't do much it's got its own little account while this variable please stop is still zero it cause a helpful function here called two text message looks like we're going to spam angry with a lot of messages so here we go right so we've got going to pass in anger even illinois number one for some reason right and then we'll do something with the result so what do we do with the result we get back character and we just printed out so we're going to print out a number that's just our counter	code	403
hi so let's have a look at some race conditions and we will check to see if we can actually make these race conditions occur and then maybe we can figure out how to use our mutex locks to fix them right so here's a story so far i've got my little main method doesn't do much it creates irwan thread here for under one and another thread for two ok then we run for five seconds then we set a global flag code please stop ok and then inside my main method i just wait for both to finish before returning so that is my main method nothing to it there's going to have a look at these two little runner threads here ok so here we go first of all let's look at run a one doesn't do much it's got its own little account while this variable please stop is still zero it cause a helpful function here called two text message looks like we're going to spam angry with a lot of messages so here we go right so we've got going to pass in anger even illinois number one for some reason right and then we'll do something with the result so what do we do with the result we get back character and we just printed out so we're going to print out a number that's just our counter	thread	292
and then will print out that message alright so we expect to see some message involving an grove and illinois meanwhile i have another thread that doesn't print anything all it does it just calls two text message at the same time so let's see if we run into any problems here because it looks like this is a completely useless thread right it doesn't actually do anything with the result it just keeps on calling text message so my question to this is problem are we going to run into any kind of critical sections here can we find any race conditions to answer that we actually need to understand more about two text message now i'm already a little concerned about it because it clearly returns a pointer here which we never free so i that is appointed to some global memory or like a static variable or this is generating	memory	770
and then will print out that message alright so we expect to see some message involving an grove and illinois meanwhile i have another thread that doesn't print anything all it does it just calls two text message at the same time so let's see if we run into any problems here because it looks like this is a completely useless thread right it doesn't actually do anything with the result it just keeps on calling text message so my question to this is problem are we going to run into any kind of critical sections here can we find any race conditions to answer that we actually need to understand more about two text message now i'm already a little concerned about it because it clearly returns a pointer here which we never free so i that is appointed to some global memory or like a static variable or this is generating	section	506
and then will print out that message alright so we expect to see some message involving an grove and illinois meanwhile i have another thread that doesn't print anything all it does it just calls two text message at the same time so let's see if we run into any problems here because it looks like this is a completely useless thread right it doesn't actually do anything with the result it just keeps on calling text message so my question to this is problem are we going to run into any kind of critical sections here can we find any race conditions to answer that we actually need to understand more about two text message now i'm already a little concerned about it because it clearly returns a pointer here which we never free so i that is appointed to some global memory or like a static variable or this is generating	thread	135
and then will print out that message alright so we expect to see some message involving an grove and illinois meanwhile i have another thread that doesn't print anything all it does it just calls two text message at the same time so let's see if we run into any problems here because it looks like this is a completely useless thread right it doesn't actually do anything with the result it just keeps on calling text message so my question to this is problem are we going to run into any kind of critical sections here can we find any race conditions to answer that we actually need to understand more about two text message now i'm already a little concerned about it because it clearly returns a pointer here which we never free so i that is appointed to some global memory or like a static variable or this is generating	pointer	699
billions of millions of bits of heap memory that we never free so let's go see look at it implementation ok so we go right so here is our implementation of two text message and you'll notice that up above this we've got a couple of global variables here i've got one called message that takes up to two hundred characters and there's my kind of please stop as well right so let's have lots of all it does ok takes a two	heap memory	32
billions of millions of bits of heap memory that we never free so let's go see look at it implementation ok so we go right so here is our implementation of two text message and you'll notice that up above this we've got a couple of global variables here i've got one called message that takes up to two hundred characters and there's my kind of please stop as well right so let's have lots of all it does ok takes a two	memory	37
and a form and some value ok right so it calls s printf so s printf is like printf but what it does is it pushes the result into some memory so here is where we're going to push it we're going to push it into that global memory so remember that global memory is only one of it exists for the entire time with my process	memory	134
and a form and some value ok right so it calls s printf so s printf is like printf but what it does is it pushes the result into some memory so here is where we're going to push it we're going to push it into that global memory so remember that global memory is only one of it exists for the entire time with my process	printf	49
and so we're going to write the following into that memory ok and it looks like we're going to tell angry that he's won a million dollars woo	the following	28
and so we're going to write the following into that memory ok and it looks like we're going to tell angry that he's won a million dollars woo	memory	52
so that means we have two threads calling this at the same time so let's first of all see what happens when we do that ok and remember that our main program caused run a one after two seconds we start runner two so off we go right so let's run this i've compiled it with piv it support and so it starts spamming angrave with	thread	26
a million dollars and oh hold on a moment what's this dinosaur business that should never appear remember my second my other thread didn't actually do anything with the result instead this dinosaur is claiming that it's so jurassic park have one close to a billion dollars right so we can see that these two threads are are interacting in a way that we don't want to happen right the string that we're using down here have been corrupted by the other thread now hopefully this is probably obvious as to why this is happening that the two calls to text message from other one another two both end up writing into the same piece of memory so let's just talk about how we might try to fix it so one possibility is you might say well what if i made this static ok that's not going to help all you've done is change the visibility of this variable is still only going to be one of it is just that now only the code inside this dot c file this compilation unit will actually be able to refer to this particular variable	memory	630
a million dollars and oh hold on a moment what's this dinosaur business that should never appear remember my second my other thread didn't actually do anything with the result instead this dinosaur is claiming that it's so jurassic park have one close to a billion dollars right so we can see that these two threads are are interacting in a way that we don't want to happen right the string that we're using down here have been corrupted by the other thread now hopefully this is probably obvious as to why this is happening that the two calls to text message from other one another two both end up writing into the same piece of memory so let's just talk about how we might try to fix it so one possibility is you might say well what if i made this static ok that's not going to help all you've done is change the visibility of this variable is still only going to be one of it is just that now only the code inside this dot c file this compilation unit will actually be able to refer to this particular variable	code	905
a million dollars and oh hold on a moment what's this dinosaur business that should never appear remember my second my other thread didn't actually do anything with the result instead this dinosaur is claiming that it's so jurassic park have one close to a billion dollars right so we can see that these two threads are are interacting in a way that we don't want to happen right the string that we're using down here have been corrupted by the other thread now hopefully this is probably obvious as to why this is happening that the two calls to text message from other one another two both end up writing into the same piece of memory so let's just talk about how we might try to fix it so one possibility is you might say well what if i made this static ok that's not going to help all you've done is change the visibility of this variable is still only going to be one of it is just that now only the code inside this dot c file this compilation unit will actually be able to refer to this particular variable	string	384
a million dollars and oh hold on a moment what's this dinosaur business that should never appear remember my second my other thread didn't actually do anything with the result instead this dinosaur is claiming that it's so jurassic park have one close to a billion dollars right so we can see that these two threads are are interacting in a way that we don't want to happen right the string that we're using down here have been corrupted by the other thread now hopefully this is probably obvious as to why this is happening that the two calls to text message from other one another two both end up writing into the same piece of memory so let's just talk about how we might try to fix it so one possibility is you might say well what if i made this static ok that's not going to help all you've done is change the visibility of this variable is still only going to be one of it is just that now only the code inside this dot c file this compilation unit will actually be able to refer to this particular variable	thread	125
like that is no longer a legal program because now we're returning a pointer to some array that's on the stack and that is not valid memory to use after we return so it might appear to work but there's no guarantee that that memory is going to remain good after we returned from two text motor two text message so next time i try to say ok let's try static here well ok so now what you've done you've just made a global variable again but this time it's yes it exists for the lifetime of the process but now the scope of it the ability to refer to this particular variable is now just limited to any code that you write inside this particular function right sort of static is said ok this is not going to live on the stack so if we do that it's still going to break we're still going to see dinosaurs winning money so i'll just prove that so after two seconds oh we see that we are corrupting our message so yes both threads now using the same piece of memory ok so none of those work	memory	133
like that is no longer a legal program because now we're returning a pointer to some array that's on the stack and that is not valid memory to use after we return so it might appear to work but there's no guarantee that that memory is going to remain good after we returned from two text motor two text message so next time i try to say ok let's try static here well ok so now what you've done you've just made a global variable again but this time it's yes it exists for the lifetime of the process but now the scope of it the ability to refer to this particular variable is now just limited to any code that you write inside this particular function right sort of static is said ok this is not going to live on the stack so if we do that it's still going to break we're still going to see dinosaurs winning money so i'll just prove that so after two seconds oh we see that we are corrupting our message so yes both threads now using the same piece of memory ok so none of those work	code	600
like that is no longer a legal program because now we're returning a pointer to some array that's on the stack and that is not valid memory to use after we return so it might appear to work but there's no guarantee that that memory is going to remain good after we returned from two text motor two text message so next time i try to say ok let's try static here well ok so now what you've done you've just made a global variable again but this time it's yes it exists for the lifetime of the process but now the scope of it the ability to refer to this particular variable is now just limited to any code that you write inside this particular function right sort of static is said ok this is not going to live on the stack so if we do that it's still going to break we're still going to see dinosaurs winning money so i'll just prove that so after two seconds oh we see that we are corrupting our message so yes both threads now using the same piece of memory ok so none of those work	thread	917
like that is no longer a legal program because now we're returning a pointer to some array that's on the stack and that is not valid memory to use after we return so it might appear to work but there's no guarantee that that memory is going to remain good after we returned from two text motor two text message so next time i try to say ok let's try static here well ok so now what you've done you've just made a global variable again but this time it's yes it exists for the lifetime of the process but now the scope of it the ability to refer to this particular variable is now just limited to any code that you write inside this particular function right sort of static is said ok this is not going to live on the stack so if we do that it's still going to break we're still going to see dinosaurs winning money so i'll just prove that so after two seconds oh we see that we are corrupting our message so yes both threads now using the same piece of memory ok so none of those work	pointer	69
what else could we try well we could change your text message to actually return some memory so i could say get me some some heap memory so i could say ok my love me some memory here that would work we now have to update the rest of our program to make sure we free that memory the downside however is performance that if i i really care about this being as fast as possible always allocating more memory for a result might be fired in your c plus plus programs but if we truly care about best performance calling malloc every time we want to do this is going to be slow right so	heap memory	125
what else could we try well we could change your text message to actually return some memory so i could say get me some some heap memory so i could say ok my love me some memory here that would work we now have to update the rest of our program to make sure we free that memory the downside however is performance that if i i really care about this being as fast as possible always allocating more memory for a result might be fired in your c plus plus programs but if we truly care about best performance calling malloc every time we want to do this is going to be slow right so	memory	86
what can we do well one option is to declare that this use of this message is part of a critical section and so let's have a think about where the critical section is it's not just it's not just in here where we right into the memory and return it it's all the time between when we write into the memory and then we actually use the contents so if we were to look at our program	memory	227
what can we do well one option is to declare that this use of this message is part of a critical section and so let's have a think about where the critical section is it's not just it's not just in here where we right into the memory and return it it's all the time between when we write into the memory and then we actually use the contents so if we were to look at our program	section	97
right here where we get the result from to text message and then we actually use it so we actually when print f runs and takes the sequence of bytes at memory location	memory	152
right so that's the first part of our critical section the other is when we also want to overwrite it so that will be inside here we do not want these two pieces of code running at the same time ok so how can we do that and so a mutabal the music 's let's get our mutex to rescue this code all right and make sure that only angrave wins a million dollars and jurassic park never sees its money ok so here we go right so i need to make myself a mutex case so i can do that i can do that in my main here right so i'll say pthread mutex	code	165
right so that's the first part of our critical section the other is when we also want to overwrite it so that will be inside here we do not want these two pieces of code running at the same time ok so how can we do that and so a mutabal the music 's let's get our mutex to rescue this code all right and make sure that only angrave wins a million dollars and jurassic park never sees its money ok so here we go right so i need to make myself a mutex case so i can do that i can do that in my main here right so i'll say pthread mutex	a mutex	442
right so that's the first part of our critical section the other is when we also want to overwrite it so that will be inside here we do not want these two pieces of code running at the same time ok so how can we do that and so a mutabal the music 's let's get our mutex to rescue this code all right and make sure that only angrave wins a million dollars and jurassic park never sees its money ok so here we go right so i need to make myself a mutex case so i can do that i can do that in my main here right so i'll say pthread mutex	section	47
right so that's the first part of our critical section the other is when we also want to overwrite it so that will be inside here we do not want these two pieces of code running at the same time ok so how can we do that and so a mutabal the music 's let's get our mutex to rescue this code all right and make sure that only angrave wins a million dollars and jurassic park never sees its money ok so here we go right so i need to make myself a mutex case so i can do that i can do that in my main here right so i'll say pthread mutex	thread	521
now other way is if you're my remember is to say wait let me have the type up here ok here's my deck and	type	70
case point it and i can say pthread mutex initializer so that does the same thing initializer ok so if i do that then i get can actually skip there	thread	29
ok i need it ok let's just delete it right ok so i've got myself a duck now i can use my dark like a bodyguard to say ok you can't come in right now and where should i put that well we identified the critical section so the starting an entity point of those points are going to be where we want to lock the dark and unlock the duck literally like a gatekeeper so we want to say peered mutex lock here's my duck ok and	section	209
ok so and then after that unlock it wait and similarly with the other thread runner we want to lock it and then only allow other threads to modify that memory after we finished using it so after printf has returned ok so let's give that a whirl if we gotta type sweat	memory	152
ok so and then after that unlock it wait and similarly with the other thread runner we want to lock it and then only allow other threads to modify that memory after we finished using it so after printf has returned ok so let's give that a whirl if we gotta type sweat	type	257
ok so and then after that unlock it wait and similarly with the other thread runner we want to lock it and then only allow other threads to modify that memory after we finished using it so after printf has returned ok so let's give that a whirl if we gotta type sweat	printf	195
ok so and then after that unlock it wait and similarly with the other thread runner we want to lock it and then only allow other threads to modify that memory after we finished using it so after printf has returned ok so let's give that a whirl if we gotta type sweat	thread	70
ok we need we not included p thread yet yes we have k what about done incompatible into pointer conversion now that's because i should have an actual type here ok so let's give that a whirl anne now will see that we've gotta change my types too	type	150
ok we need we not included p thread yet yes we have k what about done incompatible into pointer conversion now that's because i should have an actual type here ok so let's give that a whirl anne now will see that we've gotta change my types too	thread	29
ok we need we not included p thread yet yes we have k what about done incompatible into pointer conversion now that's because i should have an actual type here ok so let's give that a whirl anne now will see that we've gotta change my types too	pointer	88
the address of a duck	address	4
ok right so now we wanted after two seconds we start creating dinosaur messages but you can see they no longer impacts our text messages so great we've written our first program using a mutex lock we use them after we identify the critical sections and when we implemented it correctly we can ensure that there's no more race conditions in our code alright one last question for you what do you think would happen if i said you know i little concerned now about the performance of my code now i've got my two runners switch have to potentially wait for each others as a contention for this lock	code	344
ok right so now we wanted after two seconds we start creating dinosaur messages but you can see they no longer impacts our text messages so great we've written our first program using a mutex lock we use them after we identify the critical sections and when we implemented it correctly we can ensure that there's no more race conditions in our code alright one last question for you what do you think would happen if i said you know i little concerned now about the performance of my code now i've got my two runners switch have to potentially wait for each others as a contention for this lock	a mutex	184
ok right so now we wanted after two seconds we start creating dinosaur messages but you can see they no longer impacts our text messages so great we've written our first program using a mutex lock we use them after we identify the critical sections and when we implemented it correctly we can ensure that there's no more race conditions in our code alright one last question for you what do you think would happen if i said you know i little concerned now about the performance of my code now i've got my two runners switch have to potentially wait for each others as a contention for this lock	section	240
that if i want to call two text message over here and two text message over there then one of them will have to wait until the dot gets unlocked again so i'm going to speed up my code by	code	179
t mutex locks but when no longer preventing two threads from going into the two text message at the same time	thread	48
so it's a bit like you've got a club now bounces letting people in from two different doors we didn't want that we we just need one mutex lock in this case in order to ensure that we've implemented r r code inside the critical section correctly ok so let's go remove the banana and go back to the dark right now we have working code again alright thanks a lot i'll see you in the next letter that's it goodbye	code	202
so it's a bit like you've got a club now bounces letting people in from two different doors we didn't want that we we just need one mutex lock in this case in order to ensure that we've implemented r r code inside the critical section correctly ok so let's go remove the banana and go back to the dark right now we have working code again alright thanks a lot i'll see you in the next letter that's it goodbye	section	227
and as you know they are necessary and sufficient we need all fall to be true and exactly or for them to be true and then we know that we've met the conditions for deadlock so what are they let's actually look at some definitions here so here's the first wanna process is currently holding at least one resource and requesting additional resources which are being held by other processes ok so it is holding and waiting so that's a hold and wait condition	a process	259
and as you know they are necessary and sufficient we need all fall to be true and exactly or for them to be true and then we know that we've met the conditions for deadlock so what are they let's actually look at some definitions here so here's the first wanna process is currently holding at least one resource and requesting additional resources which are being held by other processes ok so it is holding and waiting so that's a hold and wait condition	resources	338
my process is all threads only needed to actually hold on to say just one mutex lock at a time that deadlock would be impossible	thread	18
and the process or thread wait for graph	thread	19
no pre emption right that we cannot force a task or thread to put down a lot or something that is acquired exclusively ok no pre are going to say pre emptive but let's change that to know preemption	thread	52
use that file descriptor again to fill out this truck for me ok so these two do the same thing it's just a witcher matter of convenience as to whether you know the path or already have a file descriptor to an open file there's one other version is as well here which is going to leave a little bit but we're going to find that useful when we start talking about symbolic links so let's have a look at the kind of information that we can get back from stat ok right so the system gives us the following struct we can use and big important idea and we seen this multiple times is that ok we're going to give a pointer to struct so we're going to write things like ok here is a address of say some staff that some struct that we've got on our stack or somewhere else it's only going to fill out memory structure force if stat returns success so it's very important to be able to check that it returns ok so if it doesn't return ok ie zero then you can just assume that that memory structure was never touched in south the values inside that memory structure that is going to be arbitrary wait ok so let's see what we can find out about a file first of all great you can actually find the i node number and notice that all of these fields inside my struct start with the sd which is just short for stat ok we can find out some protection information about it so the	the following	488
use that file descriptor again to fill out this truck for me ok so these two do the same thing it's just a witcher matter of convenience as to whether you know the path or already have a file descriptor to an open file there's one other version is as well here which is going to leave a little bit but we're going to find that useful when we start talking about symbolic links so let's have a look at the kind of information that we can get back from stat ok right so the system gives us the following struct we can use and big important idea and we seen this multiple times is that ok we're going to give a pointer to struct so we're going to write things like ok here is a address of say some staff that some struct that we've got on our stack or somewhere else it's only going to fill out memory structure force if stat returns success so it's very important to be able to check that it returns ok so if it doesn't return ok ie zero then you can just assume that that memory structure was never touched in south the values inside that memory structure that is going to be arbitrary wait ok so let's see what we can find out about a file first of all great you can actually find the i node number and notice that all of these fields inside my struct start with the sd which is just short for stat ok we can find out some protection information about it so the	memory	792
use that file descriptor again to fill out this truck for me ok so these two do the same thing it's just a witcher matter of convenience as to whether you know the path or already have a file descriptor to an open file there's one other version is as well here which is going to leave a little bit but we're going to find that useful when we start talking about symbolic links so let's have a look at the kind of information that we can get back from stat ok right so the system gives us the following struct we can use and big important idea and we seen this multiple times is that ok we're going to give a pointer to struct so we're going to write things like ok here is a address of say some staff that some struct that we've got on our stack or somewhere else it's only going to fill out memory structure force if stat returns success so it's very important to be able to check that it returns ok so if it doesn't return ok ie zero then you can just assume that that memory structure was never touched in south the values inside that memory structure that is going to be arbitrary wait ok so let's see what we can find out about a file first of all great you can actually find the i node number and notice that all of these fields inside my struct start with the sd which is just short for stat ok we can find out some protection information about it so the	address	675
use that file descriptor again to fill out this truck for me ok so these two do the same thing it's just a witcher matter of convenience as to whether you know the path or already have a file descriptor to an open file there's one other version is as well here which is going to leave a little bit but we're going to find that useful when we start talking about symbolic links so let's have a look at the kind of information that we can get back from stat ok right so the system gives us the following struct we can use and big important idea and we seen this multiple times is that ok we're going to give a pointer to struct so we're going to write things like ok here is a address of say some staff that some struct that we've got on our stack or somewhere else it's only going to fill out memory structure force if stat returns success so it's very important to be able to check that it returns ok so if it doesn't return ok ie zero then you can just assume that that memory structure was never touched in south the values inside that memory structure that is going to be arbitrary wait ok so let's see what we can find out about a file first of all great you can actually find the i node number and notice that all of these fields inside my struct start with the sd which is just short for stat ok we can find out some protection information about it so the	system	472
use that file descriptor again to fill out this truck for me ok so these two do the same thing it's just a witcher matter of convenience as to whether you know the path or already have a file descriptor to an open file there's one other version is as well here which is going to leave a little bit but we're going to find that useful when we start talking about symbolic links so let's have a look at the kind of information that we can get back from stat ok right so the system gives us the following struct we can use and big important idea and we seen this multiple times is that ok we're going to give a pointer to struct so we're going to write things like ok here is a address of say some staff that some struct that we've got on our stack or somewhere else it's only going to fill out memory structure force if stat returns success so it's very important to be able to check that it returns ok so if it doesn't return ok ie zero then you can just assume that that memory structure was never touched in south the values inside that memory structure that is going to be arbitrary wait ok so let's see what we can find out about a file first of all great you can actually find the i node number and notice that all of these fields inside my struct start with the sd which is just short for stat ok we can find out some protection information about it so the	pointer	608
embedded inside all of these bits inside sd mode there's two useful pieces of information first of all you can find out information about read write and execute for the owner of the group and everybody else secondly you can use this to find out about whether it's a regular file whether it's a regular directory all whether it's something else like it's symbolic link or named pipe or some other bizzle object that we've got stored in a file system	system	442
directories where different names correspond to the same i knowed number in other words my actual file could appear in more than one place inside my directory structure which is pretty cool so once you get the idea that i node is the file then that opens up some pretty cool ideas ok then we've got things like ok the uid and gid so these are just number yes later and gentlemen you're you're just a number to the file system your user id the user is just a number so we don't actually store the username at all associated with a particular file so that tells us who owns it and the group of the owner as well	system	419
ok so up here to be the same we're going to look at the device id of a special file but don't worry about that instead this is how we can find out the true size of a file in bytes and rather than being just say an unsigned long or size today we want to be able to work with extremely large files so this special type here there's off underscored t is designed to be large enough that should be big enough for any files and we want to store inside this for today and in the future right so here is s t size so that's kind of useful but perhaps you actually care about how many how much space is currently being used on the disk so the disk itself i've talked about four kilobyte blocks but	block	678
ok so up here to be the same we're going to look at the device id of a special file but don't worry about that instead this is how we can find out the true size of a file in bytes and rather than being just say an unsigned long or size today we want to be able to work with extremely large files so this special type here there's off underscored t is designed to be large enough that should be big enough for any files and we want to store inside this for today and in the future right so here is s t size so that's kind of useful but perhaps you actually care about how many how much space is currently being used on the disk so the disk itself i've talked about four kilobyte blocks but	type	312
actually if we look back in time r block size on old systems was actually limited to just five hundred twelve twelve bytes so so if you want to know about the actual space used on their disk you can read this kind of blocksize here but realize that that if you	block	35
actually if we look back in time r block size on old systems was actually limited to just five hundred twelve twelve bytes so so if you want to know about the actual space used on their disk you can read this kind of blocksize here but realize that that if you	system	53
this other block size up here tells us today about the natural size of blocks for the particular file system so if i'm going to use my read and write calls i probably want to make sure that the number of bytes i'm requesting is some multiple of that or at least that site in order to make sure that i'm efficiently using my file system so that gives me hint about that natural size of read invites	block	11
this other block size up here tells us today about the natural size of blocks for the particular file system so if i'm going to use my read and write calls i probably want to make sure that the number of bytes i'm requesting is some multiple of that or at least that site in order to make sure that i'm efficiently using my file system so that gives me hint about that natural size of read invites	system	102
to this current file system right the last thing is hey we could find out some important some timing information so the c structure time t here is accurate to the lease gives a precision of one second the actual way that something might be stored on disk isn't necessarily that accurate or it might be more than more accurate than that for example some windows file systems are only accurate to within two seconds ok but	system	21
now let's see what we've got we've got when it was last accessed when it was last modified and to finally the time of the last status change ok what's the status change this is the time of when someone altered the i node ok so for example if you change the who owned a file then we would expect this status change to be modified so most of the time we want this modified time ok the middle one that is going to tell us when someone 's altered the bites of my actual file for example if you're writing uh make then we actually want to figure out when was the contents of the file my source code modified and it is that more recent or older than the executable that i'm trying to build so great let's actually do that in the next video let's actually kind of make a very simple kind of version of make that's going to use stat to figure out whether we should compile something or not	code	589
ok so that's my little pointer thing ok right so we've done all three allocations according to the scheduler buff cape and some free space at the end right what happens next next we free up pb right so he was pb and we are now going to mark this space as available so that was easy will just to update that particular entry inside the linked list to say this is no longer some allocated space but it's actually available	pointer	23
there we get the beginning this is not available so the story so far is that i've got this space being used for pd i then i've got a space and then i've got some more memory being used for pc and then i've got another space and some more bytes available ok so the last allocation we're going to do is is malik for one kilobyte right so if we were doing better at this point the answer would be obvious we've got the perfect apartment for you right there	memory	167
but instead worst fits is going to look for the maximal space to take this one kilobyte form ok and in fact we've got a tiebreaker here we could take it from the very beginning or from the very yet and i've also tiebreaker is if there's a type break use the one which is lowest in memory has the lowest memory address so we will actually assign	memory	281
but instead worst fits is going to look for the maximal space to take this one kilobyte form ok and in fact we've got a tiebreaker here we could take it from the very beginning or from the very yet and i've also tiebreaker is if there's a type break use the one which is lowest in memory has the lowest memory address so we will actually assign	type	239
but instead worst fits is going to look for the maximal space to take this one kilobyte form ok and in fact we've got a tiebreaker here we could take it from the very beginning or from the very yet and i've also tiebreaker is if there's a type break use the one which is lowest in memory has the lowest memory address so we will actually assign	address	310
ok and the up here is a two to kill about whole there's two kilobytes spaces right so what are we conclude well we can write down the actual memory replacement that memory placements of these different allocations and i wanted to know sis that they are different ok so how things get laid out in memory depends not only	memory	141
hi, so if you want to allocate some heap memory, how can we do it in c? hopefully you already know the answer to this one. if i want a certain number of bytes, i'm going to call malloc. and yes, we might hard code a value in here, but other times, we might actually evaluate something. so for example, strlen of my	heap memory	36
hi, so if you want to allocate some heap memory, how can we do it in c? hopefully you already know the answer to this one. if i want a certain number of bytes, i'm going to call malloc. and yes, we might hard code a value in here, but other times, we might actually evaluate something. so for example, strlen of my	memory	41
hi, so if you want to allocate some heap memory, how can we do it in c? hopefully you already know the answer to this one. if i want a certain number of bytes, i'm going to call malloc. and yes, we might hard code a value in here, but other times, we might actually evaluate something. so for example, strlen of my	code	209
character pointer and then plus one because, of course, i need at least one extra byte to hold the zero byte. ok that gives me back a pointer, what can i do with that pointer? answer almost anything i want, providing i promise but of course i only use the number of buttons that i requested. i don't want to accidentally start writing memory locations before that pointer or memory locations after the end of it. i'm going to corrupt the process memory. so if i've got a pointer that malloc has given me,	memory	335
character pointer and then plus one because, of course, i need at least one extra byte to hold the zero byte. ok that gives me back a pointer, what can i do with that pointer? answer almost anything i want, providing i promise but of course i only use the number of buttons that i requested. i don't want to accidentally start writing memory locations before that pointer or memory locations after the end of it. i'm going to corrupt the process memory. so if i've got a pointer that malloc has given me,	pointer	10
"there we go. ""so hey malloc, please give me some memory.""" then later, when i finished using that memory,	memory	51
"by saying, ""hey memory allocator, i'm now done with this" piece of memory, so perhaps would be useful for some other malloc request in the future. the trick of course is that we don't want to accidentally use that memory	memory	18
once i've called free. so in c, we have to think carefully about when we allocate memory and when we free memory. this is of course challenging, but hey, challenges are good for you. plus if you actually do this carefully, you can make your programs run quite quickly if you are aware of when memory allocation occurs. memory is a very precious resource on systems, and also allocating memory is a slow slow process. so this is one reason why many interpreted languages are quite slow, simply because of the number of allocations and deallocations that we're doing on the heap all the time.	memory	82
once i've called free. so in c, we have to think carefully about when we allocate memory and when we free memory. this is of course challenging, but hey, challenges are good for you. plus if you actually do this carefully, you can make your programs run quite quickly if you are aware of when memory allocation occurs. memory is a very precious resource on systems, and also allocating memory is a slow slow process. so this is one reason why many interpreted languages are quite slow, simply because of the number of allocations and deallocations that we're doing on the heap all the time.	memory allocation	293
once i've called free. so in c, we have to think carefully about when we allocate memory and when we free memory. this is of course challenging, but hey, challenges are good for you. plus if you actually do this carefully, you can make your programs run quite quickly if you are aware of when memory allocation occurs. memory is a very precious resource on systems, and also allocating memory is a slow slow process. so this is one reason why many interpreted languages are quite slow, simply because of the number of allocations and deallocations that we're doing on the heap all the time.	the heap	568
once i've called free. so in c, we have to think carefully about when we allocate memory and when we free memory. this is of course challenging, but hey, challenges are good for you. plus if you actually do this carefully, you can make your programs run quite quickly if you are aware of when memory allocation occurs. memory is a very precious resource on systems, and also allocating memory is a slow slow process. so this is one reason why many interpreted languages are quite slow, simply because of the number of allocations and deallocations that we're doing on the heap all the time.	system	357
perhaps, if you're writing a game, maybe it would be better to preallocate a lot of memory for the current scene and then only free it after the current scene has finished.	memory	84
so let's go back to our program then, where we are actually kind of thinking about doing things manually, where we are actually allocating [indistinct word]. so what do you think about this? if i free up some memory and then, for some deliberate or accidental reason, i	memory	209
alright, is it really a good idea? no, of course not! it's going to crash. why? because when we implement free as you will in the future portion of this course, the thing that we have to do in free, is to change our linked list structure. the heap allocator is going to keep a record of all the available pieces of memory that is currently being used and all available pieces of memory that is currently could be used in the future.	memory	315
alright, is it really a good idea? no, of course not! it's going to crash. why? because when we implement free as you will in the future portion of this course, the thing that we have to do in free, is to change our linked list structure. the heap allocator is going to keep a record of all the available pieces of memory that is currently being used and all available pieces of memory that is currently could be used in the future.	the heap	239
so by calling free twice, our memory allocator is just going to happily update those lists. wait a moment, why doesn't free actually detect this? so the short answer is performance. as i've already mentioned, allocating and deallocating memory can be a very common occurrence. so, we want our memory allocator calls to be as fast as possible and it's up to you, the programmer, to make sure that you use it correctly. so how can we detect problems with using the heap. one picture of white i had for you is, after freeing, it's a good convention to then take your pointer that pointed that memory and change it so that we explicitly change it to an invalid location. why do we do this? well, the idea is that if, then, later on in the program, someone accidentally uses this pointer, then it's going to cause the program to crash quickly. i'd much rather see a program stop and fail than it accidentally corrupting the data that we have now outside that piece of memory or crashing at a much later point. it would be much harder to debug and discover this error.	memory	30
so by calling free twice, our memory allocator is just going to happily update those lists. wait a moment, why doesn't free actually detect this? so the short answer is performance. as i've already mentioned, allocating and deallocating memory can be a very common occurrence. so, we want our memory allocator calls to be as fast as possible and it's up to you, the programmer, to make sure that you use it correctly. so how can we detect problems with using the heap. one picture of white i had for you is, after freeing, it's a good convention to then take your pointer that pointed that memory and change it so that we explicitly change it to an invalid location. why do we do this? well, the idea is that if, then, later on in the program, someone accidentally uses this pointer, then it's going to cause the program to crash quickly. i'd much rather see a program stop and fail than it accidentally corrupting the data that we have now outside that piece of memory or crashing at a much later point. it would be much harder to debug and discover this error.	the heap	459
so by calling free twice, our memory allocator is just going to happily update those lists. wait a moment, why doesn't free actually detect this? so the short answer is performance. as i've already mentioned, allocating and deallocating memory can be a very common occurrence. so, we want our memory allocator calls to be as fast as possible and it's up to you, the programmer, to make sure that you use it correctly. so how can we detect problems with using the heap. one picture of white i had for you is, after freeing, it's a good convention to then take your pointer that pointed that memory and change it so that we explicitly change it to an invalid location. why do we do this? well, the idea is that if, then, later on in the program, someone accidentally uses this pointer, then it's going to cause the program to crash quickly. i'd much rather see a program stop and fail than it accidentally corrupting the data that we have now outside that piece of memory or crashing at a much later point. it would be much harder to debug and discover this error.	pointer	564
so, by the way, this kind of bug where we've freed something twice is called a double free error, and yes, the example i gave below is obvious because we've written it twice, but sometimes it can occur by accident, where the free is part of an indirect operation but buried inside some other code.	code	292
one good news about setting something to, setting a pointer to null here is that	pointer	52
let's see. we talk about the following little problem. we are going to walk through the following code where we attempt to write our own version of strcat. so, take a look at this code and figure out what is missing and what we should do to it to make it work. we want to be able to copy from source	the following	25
let's see. we talk about the following little problem. we are going to walk through the following code where we attempt to write our own version of strcat. so, take a look at this code and figure out what is missing and what we should do to it to make it work. we want to be able to copy from source	code	98
hi i wanted to talk about environment variables which we've seen before so hopefully you can remember what these do if you and your c program you say tell me about the environment variable called home you get their users home directory this can be useful for kids perhaps you want to say store some default parameter settings or default settings for next time you run your program you know about path now so now you can find out exactly where the system will look for executables we can find out the current user that is running	parameter	307
hi i wanted to talk about environment variables which we've seen before so hopefully you can remember what these do if you and your c program you say tell me about the environment variable called home you get their users home directory this can be useful for kids perhaps you want to say store some default parameter settings or default settings for next time you run your program you know about path now so now you can find out exactly where the system will look for executables we can find out the current user that is running	system	447
process what about people do you think get em of awesome will return well you might say is defined to always return cs two forty one but actually on most systems today there is no awesome environment variable so this expression would return null until the day you decide to set such an awesome environment variable	system	154
in addition to asking about the particular values or particular variables you can actually iterate through order them and here's how to do that yes ladies and gentlemen it's another table of character pointers so ok so the environment variable in violent is a pointer	pointer	201
so immediately after a little pointer and what's it pointing to ok it's pointing to a character pointer so this is going to point to a string so somewhere inside	string	135
so immediately after a little pointer and what's it pointing to ok it's pointing to a character pointer so this is going to point to a string so somewhere inside	pointer	30
memory there's a string that says a equals b so key value pair and we could pass that and if we wanted to implement getenv except of course there's more than one environment variable there's another one so just like argv argc there's a whole load of them and the last point are here is null so that's the way to find out all the variables now big important point here is that if you declare this environment variable it's important to tell the compiler the following is important to the environment the compiler that this environment environment variable is extern is it meanings external to the currency program that you're writing if you don't do this the compiler will say oh look at your list compiled you're declaring your own global variable i'll set aside a bit of space inside your process memory low down for your nice little variable that's not what we want we actually want to say or compiler i promise you that when you link on my program together when you pull in the selye be when you put in the other libraries when you pull in the code that i write in this c file and that other compilation unit is other c file then eventually when you put all that together there already is variable call&nbsp; environ so that's what extend us you're declaring this external to the compilation unit external to the current program	the following	453
memory there's a string that says a equals b so key value pair and we could pass that and if we wanted to implement getenv except of course there's more than one environment variable there's another one so just like argv argc there's a whole load of them and the last point are here is null so that's the way to find out all the variables now big important point here is that if you declare this environment variable it's important to tell the compiler the following is important to the environment the compiler that this environment environment variable is extern is it meanings external to the currency program that you're writing if you don't do this the compiler will say oh look at your list compiled you're declaring your own global variable i'll set aside a bit of space inside your process memory low down for your nice little variable that's not what we want we actually want to say or compiler i promise you that when you link on my program together when you pull in the selye be when you put in the other libraries when you pull in the code that i write in this c file and that other compilation unit is other c file then eventually when you put all that together there already is variable call&nbsp; environ so that's what extend us you're declaring this external to the compilation unit external to the current program	memory	0
memory there's a string that says a equals b so key value pair and we could pass that and if we wanted to implement getenv except of course there's more than one environment variable there's another one so just like argv argc there's a whole load of them and the last point are here is null so that's the way to find out all the variables now big important point here is that if you declare this environment variable it's important to tell the compiler the following is important to the environment the compiler that this environment environment variable is extern is it meanings external to the currency program that you're writing if you don't do this the compiler will say oh look at your list compiled you're declaring your own global variable i'll set aside a bit of space inside your process memory low down for your nice little variable that's not what we want we actually want to say or compiler i promise you that when you link on my program together when you pull in the selye be when you put in the other libraries when you pull in the code that i write in this c file and that other compilation unit is other c file then eventually when you put all that together there already is variable call&nbsp; environ so that's what extend us you're declaring this external to the compilation unit external to the current program	code	1047
memory there's a string that says a equals b so key value pair and we could pass that and if we wanted to implement getenv except of course there's more than one environment variable there's another one so just like argv argc there's a whole load of them and the last point are here is null so that's the way to find out all the variables now big important point here is that if you declare this environment variable it's important to tell the compiler the following is important to the environment the compiler that this environment environment variable is extern is it meanings external to the currency program that you're writing if you don't do this the compiler will say oh look at your list compiled you're declaring your own global variable i'll set aside a bit of space inside your process memory low down for your nice little variable that's not what we want we actually want to say or compiler i promise you that when you link on my program together when you pull in the selye be when you put in the other libraries when you pull in the code that i write in this c file and that other compilation unit is other c file then eventually when you put all that together there already is variable call&nbsp; environ so that's what extend us you're declaring this external to the compilation unit external to the current program	string	17
ok but the next video we're going to look at the following little puzzle an workout what does it print and why are you ready go	the following	45
hi ok so quick question for you my pee thread programmed calls pthread_create twice so how many stacks does my process have	thread	39
if you guessed two guess again yes the correct answer is three why because when my program started i get one thread for free the main thread and the main thread has its own stack so in my little program here i expect to actually have three threads i could approve this	thread	109
by at least i could have shown this by for example showing the address of the variable here so for example i could have said p thread so print f the address of td one is right and then print it out so let me take the address of my variable here ok	thread	127
by at least i could have shown this by for example showing the address of the variable here so for example i could have said p thread so print f the address of td one is right and then print it out so let me take the address of my variable here ok	address	63
k so it's a little strange to think about that i can have my process memory	memory	69
and i've got multiple cpus using the code that i have written in here so down below here we've got all of our instructions for the functions that we've written	code	37
and they can be executing a different points because they've got different pc registers and each one knows its thread of execution because it's got a stack so let's have a stack here for the first thread stack down here for the second thread stuck down here for the third thread if you get the idea	thread	111
when a thread finishes then this memory is not needed anymore in practice we might use it again when a another thread is created	memory	33
when a thread finishes then this memory is not needed anymore in practice we might use it again when a another thread is created	a thread	5
when a thread finishes then this memory is not needed anymore in practice we might use it again when a another thread is created	thread	7
right so anything else you want to say about this yeah and realize that look i can have some heat memory in here i could call malloc from one thread i could have some global variables just beneath that and all of my threads can refer to these things that just memory addresses it's up to you how you store these memory addresses where you use them so all of my threads could see my constants like hello tomato so let me put tomorrow in here somewhere down here but near the code if i'd made some malloc memory i could have passed that address to my threads all they need adjust addresses and they could happily use them so one thread can even see the stack memory of another thread there that isn't always a safe thing to do and i'll let you work out why so	memory	98
right so anything else you want to say about this yeah and realize that look i can have some heat memory in here i could call malloc from one thread i could have some global variables just beneath that and all of my threads can refer to these things that just memory addresses it's up to you how you store these memory addresses where you use them so all of my threads could see my constants like hello tomato so let me put tomorrow in here somewhere down here but near the code if i'd made some malloc memory i could have passed that address to my threads all they need adjust addresses and they could happily use them so one thread can even see the stack memory of another thread there that isn't always a safe thing to do and i'll let you work out why so	code	474
right so anything else you want to say about this yeah and realize that look i can have some heat memory in here i could call malloc from one thread i could have some global variables just beneath that and all of my threads can refer to these things that just memory addresses it's up to you how you store these memory addresses where you use them so all of my threads could see my constants like hello tomato so let me put tomorrow in here somewhere down here but near the code if i'd made some malloc memory i could have passed that address to my threads all they need adjust addresses and they could happily use them so one thread can even see the stack memory of another thread there that isn't always a safe thing to do and i'll let you work out why so	thread	142
right so anything else you want to say about this yeah and realize that look i can have some heat memory in here i could call malloc from one thread i could have some global variables just beneath that and all of my threads can refer to these things that just memory addresses it's up to you how you store these memory addresses where you use them so all of my threads could see my constants like hello tomato so let me put tomorrow in here somewhere down here but near the code if i'd made some malloc memory i could have passed that address to my threads all they need adjust addresses and they could happily use them so one thread can even see the stack memory of another thread there that isn't always a safe thing to do and i'll let you work out why so	address	267
quite the next video let's talk about the different system between a process and a thread	a thread	81
quite the next video let's talk about the different system between a process and a thread	a process	67
quite the next video let's talk about the different system between a process and a thread	thread	83
quite the next video let's talk about the different system between a process and a thread	system	52
hi welcome to like twenty four we're going to start with a quick code review let's see look at this attempted waiting a fixed sized ring buffer and we'll see if we can figure out how it might go wrong ok so some of the things that we want to ask are is deadlock possible in other words could get stuck so that's never able to continue is underflow possible in other words could it be that we attempt to write so attempt to read some data that's not actually inside the ring buffer so will just be reading back some garbage information or perhaps overflow as possible which means that we're able to put more data into my buffer then it can actually hold so presumably we were going to corrupt something possibly value that we have not yet written out so what do we got here we have	code	65
two counting semaphores and will see the s one is initialized to two hundred and fifty six so this smells to me like some kind of capacity counting thing which is going to go down as we started add things and as two is initialized to zero so s two sounds to me like it's going to be counting the number of items in ok let's touch you have a look at the code then for my enqueue and dequeue or nq and deck so i see i'm going to move text lock ok so that's good so that only one thread at the time can be actually inside this code and in fact for this particular implementation is chosen to use the same mutex lock for both the nq in the dequeue ok but i do notice inside this implementation is that normally what do we do normally send post so the same way it happens first and we normally only have the mutex lock that wraps the buffer call as well so yeah	code	353
two counting semaphores and will see the s one is initialized to two hundred and fifty six so this smells to me like some kind of capacity counting thing which is going to go down as we started add things and as two is initialized to zero so s two sounds to me like it's going to be counting the number of items in ok let's touch you have a look at the code then for my enqueue and dequeue or nq and deck so i see i'm going to move text lock ok so that's good so that only one thread at the time can be actually inside this code and in fact for this particular implementation is chosen to use the same mutex lock for both the nq in the dequeue ok but i do notice inside this implementation is that normally what do we do normally send post so the same way it happens first and we normally only have the mutex lock that wraps the buffer call as well so yeah	thread	477
ok let's do a code review on some attempt to write a	code	14
temp to write a ring buffer and let's see what we can see about this ok well it's so we've got our buffer of sixteen slots looks like sixty void pointers so we can use it for any kind of pointer we're going to keep track of an in and out a number of items and we're using condition variables so my first concern here is these things every initialized	a ring buffer	14
temp to write a ring buffer and let's see what we can see about this ok well it's so we've got our buffer of sixteen slots looks like sixty void pointers so we can use it for any kind of pointer we're going to keep track of an in and out a number of items and we're using condition variables so my first concern here is these things every initialized	pointer	145
ok let's choose a darkish red ok so i better check that these things are initialized if they don't call patriot mutex initiate the very least we need to use the magic constant p thread mutex initializer ok so let's check that ok what else can we see in our little code review ok so we are using	code	264
ok let's choose a darkish red ok so i better check that these things are initialized if they don't call patriot mutex initiate the very least we need to use the magic constant p thread mutex initializer ok so let's check that ok what else can we see in our little code review ok so we are using	thread	178
we've got an infinite loop here so this is going to lead to deadlock because one thread is going to hold onto that new tax law can never release it oh dear right	thread	81
what about these variables i care global variables so there should be initialized to zero but what's the purpose here so i think we better kind of rethink about this code and what it's trying to do ok here's another problem i see however is that this code uses modular arithmetic so that's going to be great for about the first two billion items so in light testing in simple demos it's going to be great but if we are actually using this code for a long period of time eventually my little variable called in here is going to exceed what i can represent using using it so once it gets above in max what happens when you add one well technically the c standard says its undefined behavior ok so at this point it could get up and change your grandmother 's facebook page but maybe perhaps more likely is on most systems that rather than changing your grandmother 's page it this is simply going to look around to a bit pattern that represents the most negative integer and unfortunately for code if you take a negative integer and put it into the modulo operator you get back a negative number so this whole expression will be a negative number at some point somewhere between minus fifteen negative one oh dear right so now we've done buffer underflow were actually	code	166
what about these variables i care global variables so there should be initialized to zero but what's the purpose here so i think we better kind of rethink about this code and what it's trying to do ok here's another problem i see however is that this code uses modular arithmetic so that's going to be great for about the first two billion items so in light testing in simple demos it's going to be great but if we are actually using this code for a long period of time eventually my little variable called in here is going to exceed what i can represent using using it so once it gets above in max what happens when you add one well technically the c standard says its undefined behavior ok so at this point it could get up and change your grandmother 's facebook page but maybe perhaps more likely is on most systems that rather than changing your grandmother 's page it this is simply going to look around to a bit pattern that represents the most negative integer and unfortunately for code if you take a negative integer and put it into the modulo operator you get back a negative number so this whole expression will be a negative number at some point somewhere between minus fifteen negative one oh dear right so now we've done buffer underflow were actually	system	811
writing into memory that is no longer part of our buffer we writing into whatever variable happens to be stored before my buffer oh dear whoopsie daisy so that's not good and we're not going to even see this bug until we've incremented in by two billion times so we better fix this so i would not use if i if you force me to use modular i would also have an if condition to reset it back to zero	memory	13
ok so this code is trying to use condition variables to implement an q but it right now it's not even thread safe we could have multiple threads calling nq and both of them could see the same value of in so this code right here of where we're changing the buffer that's the part that actually needs to be have a lock plus if we're going to change variables like count again the plus plus it's not thread safe so again that needs to be protected by a lock ok so let's move this peter mutex lock down ok will do that they're very end	code	11
ok so this code is trying to use condition variables to implement an q but it right now it's not even thread safe we could have multiple threads calling nq and both of them could see the same value of in so this code right here of where we're changing the buffer that's the part that actually needs to be have a lock plus if we're going to change variables like count again the plus plus it's not thread safe so again that needs to be protected by a lock ok so let's move this peter mutex lock down ok will do that they're very end	thread	102
also we actually need to block we actually need to pause if my buffer is completely full so that seems to be the purpose of discount plus plus so their logic here is not correct i want to go to sleep i want to wait if my counters got is become equal to sixteen so let's fix this look if i've got sixteen items inside my queue right now then let me send this thread to sleep through our call my p thread condition there we go caper condition wait	block	25
also we actually need to block we actually need to pause if my buffer is completely full so that seems to be the purpose of discount plus plus so their logic here is not correct i want to go to sleep i want to wait if my counters got is become equal to sixteen so let's fix this look if i've got sixteen items inside my queue right now then let me send this thread to sleep through our call my p thread condition there we go caper condition wait	thread	358
all right so we're only using one condition variable if i was to make this code more performance i would consider using two one for the end q threads and one for the d q threats but anyway so will sleep in there	code	75
all right so we're only using one condition variable if i was to make this code more performance i would consider using two one for the end q threads and one for the d q threats but anyway so will sleep in there	thread	142
see if we know that there might be a thread sleeping inside this condition variable but we'll leave that for now because we've still got work to do on the d q as well so let's get that sorted so what do we got so far right so looking back over nq yeah it's good that we use a p thread mutex lock we like that so that only one thread at a time can be working in this code but we actually want to stop when we discovered that the queue is fault when my buffer already has sixteen items at which point we call p three condition wait	code	366
see if we know that there might be a thread sleeping inside this condition variable but we'll leave that for now because we've still got work to do on the d q as well so let's get that sorted so what do we got so far right so looking back over nq yeah it's good that we use a p thread mutex lock we like that so that only one thread at a time can be working in this code but we actually want to stop when we discovered that the queue is fault when my buffer already has sixteen items at which point we call p three condition wait	a thread	35
see if we know that there might be a thread sleeping inside this condition variable but we'll leave that for now because we've still got work to do on the d q as well so let's get that sorted so what do we got so far right so looking back over nq yeah it's good that we use a p thread mutex lock we like that so that only one thread at a time can be working in this code but we actually want to stop when we discovered that the queue is fault when my buffer already has sixteen items at which point we call p three condition wait	thread	37
but we don't just go to sleep on the condition variable remember we've also got a pass in their mutex lock as well so that will become unlocked while we sleep in there when we return from peace recondition weight will have to re lock that new talks then recalling pizza kitchen broadcaster we've woken up some threads we're incrementing the count by one and we put the data in and only at the very end we release the mutex lock after we finish modifying all about data so great	thread	310
good we want our d q to lock a mutex the same utexas before because we're going to be sharing this count variable so yes in this case we do want to wait while count is equal to zero but let's not busy wait instead we want to block on cider condition variable so there's rp three condition wait ok so thread please go to sleep inside this condition variable and please let go of the mutex whilst you are blocked ok ok otherwise if we continued we know that the count is non zero so we can at least get something out so great let's pull something out of our buffer again i'm going to modify this to be bit masking ok i just care about the lowest four bits there we go	block	225
good we want our d q to lock a mutex the same utexas before because we're going to be sharing this count variable so yes in this case we do want to wait while count is equal to zero but let's not busy wait instead we want to block on cider condition variable so there's rp three condition wait ok so thread please go to sleep inside this condition variable and please let go of the mutex whilst you are blocked ok ok otherwise if we continued we know that the count is non zero so we can at least get something out so great let's pull something out of our buffer again i'm going to modify this to be bit masking ok i just care about the lowest four bits there we go	a mutex	29
good we want our d q to lock a mutex the same utexas before because we're going to be sharing this count variable so yes in this case we do want to wait while count is equal to zero but let's not busy wait instead we want to block on cider condition variable so there's rp three condition wait ok so thread please go to sleep inside this condition variable and please let go of the mutex whilst you are blocked ok ok otherwise if we continued we know that the count is non zero so we can at least get something out so great let's pull something out of our buffer again i'm going to modify this to be bit masking ok i just care about the lowest four bits there we go	thread	300
and we'll call preset conditions broadcast on the off chance as any threads which are sleeping will call oh wait a moment we don't want to hit any race conditions around this count this better happen as part of our critical section so before we unlock the mutex let's make sure we decorated count so if we do that make all these changes congratulations we've now got a working fix sized ring buffer using condition variables	section	224
and we'll call preset conditions broadcast on the off chance as any threads which are sleeping will call oh wait a moment we don't want to hit any race conditions around this count this better happen as part of our critical section so before we unlock the mutex let's make sure we decorated count so if we do that make all these changes congratulations we've now got a working fix sized ring buffer using condition variables	thread	68
and we could do a bit better performance if we limited the pizza addition broadcaster only calling this if we if there might be a thread either dq thread or an nq thread that is sleeping but let's so we could put some ifs inside here and also we could invent two condition variables but i'm not going to worry about this condition those performance improvements right now instead i want to finish this lecture with a look at how to build a real autograder so we're going to look at some real code from cs 241 and i'll see at the last video of this lecture bye	code	492
and we could do a bit better performance if we limited the pizza addition broadcaster only calling this if we if there might be a thread either dq thread or an nq thread that is sleeping but let's so we could put some ifs inside here and also we could invent two condition variables but i'm not going to worry about this condition those performance improvements right now instead i want to finish this lecture with a look at how to build a real autograder so we're going to look at some real code from cs 241 and i'll see at the last video of this lecture bye	a thread	128
and we could do a bit better performance if we limited the pizza addition broadcaster only calling this if we if there might be a thread either dq thread or an nq thread that is sleeping but let's so we could put some ifs inside here and also we could invent two condition variables but i'm not going to worry about this condition those performance improvements right now instead i want to finish this lecture with a look at how to build a real autograder so we're going to look at some real code from cs 241 and i'll see at the last video of this lecture bye	thread	130
we're going to now have an entry for the space that we've we're going to return and so this is now allocated right and eventually we will return a pointer to the beginning of its soapie will be looking at this and our second entry will be his all of our free space ironic unallocated space ok right there next malloc courses i need four kb please right so let's go through our link list looking for an entry that is sufficiently large and available ok so not the first one of course but the second one is great let's take that so again will split this will mark the beginning of it as taken ok that is no longer available and of course we're going to turn a pointer to the beginning of this so this eventually was where pb is going to be a side and what about the remaining space well we've got a third link list entry now for all of the remaining free bites in our heap then is called again with the three kilobyte to request case so again we walked through our linked list structure and	pointer	147
we can ignore the ones which correspond to allocate it entries but here's one which is a non allocated an sufficiently large so let's take that and split it again two or three kilobytes are going to be here for a pc we're going to be returning a pointer to pc will point to hear ok and finally we have the	pointer	246
an entry for the remaining space ok right the next thing happens is the memory at pb is no longer required so free is going to be called on that point are right so it's time to update our	memory	72
linked list case now is just wipe that away right this now this entry now actually correspond to some memory that we can reuse in the future ok and then next we have another malloc call saying hey i need three kilobytes	memory	102
of course is malloc call could actually be a kellogg call but for the problem of just choosing where to put this memory it doesn't matter so we've got a three kilobyte request ok where should we put it now remember we are doing	memory	113
so in fact we could write this in here that pd was going to be equal to ten kb ok right and then after that we free pa ok so we can update our link this structure to now say this memory is free but remember there's something else we should do is that right now are linked list structure doesn't realize that these two pieces of memory that are next door to each other actually could be coalesced into one so let's do that let's update all linked list structure so that rather than having two separate items	memory	179
it's cut out these pieces there we go ok we just have one giant entry for all of this between zero and the six end of the six kb here right here we go i got six seven kilobytes of available memory now if we didn't do that then if we request say came in for seven kb we could actually assign that but according to our linked list we don't have enough space so it's important to do block coalesce sing	memory	190
it's cut out these pieces there we go ok we just have one giant entry for all of this between zero and the six end of the six kb here right here we go i got six seven kilobytes of available memory now if we didn't do that then if we request say came in for seven kb we could actually assign that but according to our linked list we don't have enough space so it's important to do block coalesce sing	block	380
we've only got kind of one area available so that's easy so now we're going to split this into two we'll have the area that is going to be assigned for pe answer p is going to be back in fact in the same piece of memory that was originally used for pa and now we've got all of our remaining space in one nice big free chunk which is great so in this case we didn't suffer from significant fragmentation at least not four	memory	213
this particular simulation this particular sequence of malloc and free calls and more robust simulation would actually measure the performance of memory allocator under real conditions so for example we could actually instrument python or java or c plus plus program to see how efficient we could use the heat memory ok so that's it for best fit we can make a note of where p is well so	memory	146
ok so but the same process can do both so how can we actually send a udp packet well first of all we actually need to make a socket that the right type	type	147
and the right protocol and how can we get the parameters correct first a socket answer hey get address info to our friend is our friend again	parameter	46
and the right protocol and how can we get the parameters correct first a socket answer hey get address info to our friend is our friend again	address	95
ok so we've made our socket and if we just want to send something somewhere just simply call send too and that moment you say here's my fire descriptor here's the memory address that i want to start sending bytes from then on the number of bytes and here's the address off your go seal it with a kiss and off off both at packet right and hope it hopefully it virus what about the receiver	memory	163
ok so we've made our socket and if we just want to send something somewhere just simply call send too and that moment you say here's my fire descriptor here's the memory address that i want to start sending bytes from then on the number of bytes and here's the address off your go seal it with a kiss and off off both at packet right and hope it hopefully it virus what about the receiver	address	170
and we call bind how do we get what we need for bind again we can just get address info and then how do we actually wait for something to arrive and the answer to that is you can use receive from there we go and when received from returns then great a packet has arrived datagram has arrived and as part of that information not only do you get the data you actually get the source ip and the source port from which that packet claim form	address	75
on is just the bikes have been set inside the header there's no way for the internet to actually confirm whether that information is true or false if you want to be certain that that information you're getting by udp is kind of form a bona fide sender	the header	42
and it's going to stop and listen for connections on that socket so i can now call received from there and this is the moment where it blocks but how do i find out who sent me that the data well for that i'm going to pass in one of these socket address structures and in fact i'm going to use the largest possible version of the kind that can represent ip for ip six or any other possible socket addresses and so i give the address of my source here it is casted to the base type and also i need to say how many bytes it is as well so i end up giving that information as well so we see from there will block until finally one day my buffer is filled up because a packet has arrived ok so what are we going to do at this point well my little program is going to print it out just for debugging purposes and then do a tiny bit of computation in fact all it's going to do is flip the lowest bit of all of the bytes of the message for any bites that look like they are greater than ascii value of sixty four greater than equal to sixty four and then finally let's send it back to whoever sent it to us which hey guess what we can now use that source information as the target address so we will send it back to whoever claimed to ascendas the information in the first place and let's say here's the buffer and here's the number of bytes that we originally received let's use that as our sending information so that's our i guess you could call it our server in the sense that it's waiting for information at the beginning what about our client our client looks similar to to our	block	135
and it's going to stop and listen for connections on that socket so i can now call received from there and this is the moment where it blocks but how do i find out who sent me that the data well for that i'm going to pass in one of these socket address structures and in fact i'm going to use the largest possible version of the kind that can represent ip for ip six or any other possible socket addresses and so i give the address of my source here it is casted to the base type and also i need to say how many bytes it is as well so i end up giving that information as well so we see from there will block until finally one day my buffer is filled up because a packet has arrived ok so what are we going to do at this point well my little program is going to print it out just for debugging purposes and then do a tiny bit of computation in fact all it's going to do is flip the lowest bit of all of the bytes of the message for any bites that look like they are greater than ascii value of sixty four greater than equal to sixty four and then finally let's send it back to whoever sent it to us which hey guess what we can now use that source information as the target address so we will send it back to whoever claimed to ascendas the information in the first place and let's say here's the buffer and here's the number of bytes that we originally received let's use that as our sending information so that's our i guess you could call it our server in the sense that it's waiting for information at the beginning what about our client our client looks similar to to our	type	475
and it's going to stop and listen for connections on that socket so i can now call received from there and this is the moment where it blocks but how do i find out who sent me that the data well for that i'm going to pass in one of these socket address structures and in fact i'm going to use the largest possible version of the kind that can represent ip for ip six or any other possible socket addresses and so i give the address of my source here it is casted to the base type and also i need to say how many bytes it is as well so i end up giving that information as well so we see from there will block until finally one day my buffer is filled up because a packet has arrived ok so what are we going to do at this point well my little program is going to print it out just for debugging purposes and then do a tiny bit of computation in fact all it's going to do is flip the lowest bit of all of the bytes of the message for any bites that look like they are greater than ascii value of sixty four greater than equal to sixty four and then finally let's send it back to whoever sent it to us which hey guess what we can now use that source information as the target address so we will send it back to whoever claimed to ascendas the information in the first place and let's say here's the buffer and here's the number of bytes that we originally received let's use that as our sending information so that's our i guess you could call it our server in the sense that it's waiting for information at the beginning what about our client our client looks similar to to our	address	245
tcp client except that yeah we're going to change the kind of socket we want we want to suck it d gram and then rather than calling connect we just immediately going to call send to and say ok here's my message i want to send here is the ip address that i want to send	address	241
our client however can also wait for packets to arrive so we could wait for the result before printing something out ok right that's enough talking let's actually see this little demo so on my local machine here i can call this little send two thing and i'm going to send a message to a remote lennox machine ok so so what is my ip address over here right well i better run it first of all ok so let's let's run	address	332
i received from ok and when we need a ton used port address let's go for seven six five four ok great it's listening on that so now i need to connect to it ok so will try	address	52
ok and great we send a little datagram with six bytes the actual datagram that gets sent of course is a little larger because we've got the overhead of the ip address in the front of it and then we wait for a response and here it is now you and i know that all my little server group the other end is just flipping the lowest bit ok and you can see that it's been processing it here so if we actually send the same message	address	159
back ok this time great because we flip the bits on the letters we can see that we've also managed to flip it back to absorb it back into the original message called hello so you can see great encrypt it twice if you want to make it doubly secure and that's a joke by the way so that is kind of a quick quick play with udp and you can see it's a very simple protocol and that's the basis of kind of dns system today	system	403
so quick comment stands that yeah i've got all these different types of socket addresses i've got basic type if you can think of that is like the base class if you like but then i've got versions to work with ip four ip six or if you just want to say i'm going to have a storage mechanism which is big enough for or possible socket address then there's this type dissipate type here	type	63
so quick comment stands that yeah i've got all these different types of socket addresses i've got basic type if you can think of that is like the base class if you like but then i've got versions to work with ip four ip six or if you just want to say i'm going to have a storage mechanism which is big enough for or possible socket address then there's this type dissipate type here	address	79
right now it is possible to if you truly only want to send data to one to one ip address and one port so called end point then it is possible to use connect with datagram	address	81
ok this is important that there is there is no handshake there's no part of the protocol that says i'm going to first sense in packets backwards enforce it truly is connectionless you want to send a message you send just another packet so when you call connect you're not really connecting to the other side you're simply actually just giving a hint to your machine that future calls to using send will always use the same host and port number as as the destination so it just makes the future part of your code just a little bit cleaner because now you just need to file descriptor and the buffer that you want to use to send those bites so that's big important idea that compared to tcp which is connection based udp is and always will be a connectionless protocol ok so that's the udp if you haven't had a quick play with it have start start with the code i've put in to get his part of the lecture and the last thing i'm going to leave you with this lecture is i've got a little piece of code here which is based on the so-called underhanded c challenge and	code	507
ok this is important that there is there is no handshake there's no part of the protocol that says i'm going to first sense in packets backwards enforce it truly is connectionless you want to send a message you send just another packet so when you call connect you're not really connecting to the other side you're simply actually just giving a hint to your machine that future calls to using send will always use the same host and port number as as the destination so it just makes the future part of your code just a little bit cleaner because now you just need to file descriptor and the buffer that you want to use to send those bites so that's big important idea that compared to tcp which is connection based udp is and always will be a connectionless protocol ok so that's the udp if you haven't had a quick play with it have start start with the code i've put in to get his part of the lecture and the last thing i'm going to leave you with this lecture is i've got a little piece of code here which is based on the so-called underhanded c challenge and	the protocol	76
here's my challenge to you can see the code is actually quite short and what i'd like you to be able to do is figure out how can you give this code some arguments such that it actually ends up printing the following admin slash debug in other words do not allowed to kind of change the code is written that would be too easy no here is the code and there is something we can due to this code such that when you run it it ends up printing out this following following and your notice step there is no way to actually change these variables and that they are global variables so they should be zero right and yet for some reason there it is possible to give this program some data an argument such that they become non zero my question to you is can you actually make that happen so that's kind of a little bit of a challenge see if you can figure out how with that that's the end of this lecture by	the following	202
here's my challenge to you can see the code is actually quite short and what i'd like you to be able to do is figure out how can you give this code some arguments such that it actually ends up printing the following admin slash debug in other words do not allowed to kind of change the code is written that would be too easy no here is the code and there is something we can due to this code such that when you run it it ends up printing out this following following and your notice step there is no way to actually change these variables and that they are global variables so they should be zero right and yet for some reason there it is possible to give this program some data an argument such that they become non zero my question to you is can you actually make that happen so that's kind of a little bit of a challenge see if you can figure out how with that that's the end of this lecture by	code	39
hi welcome to lecture thirty two so let's talk about scheduling and schedule algorithms as a warm up let's think about why processes might be placed on the ready queue ok so the story so far is we never have enough cpu 's and we can imagine times when a process would like to run for example a thread is ready to go but we don't have a cpu available so let's talk about some enumerate some possible reasons why that might occur	a thread	292
hi welcome to lecture thirty two so let's talk about scheduling and schedule algorithms as a warm up let's think about why processes might be placed on the ready queue ok so the story so far is we never have enough cpu 's and we can imagine times when a process would like to run for example a thread is ready to go but we don't have a cpu available so let's talk about some enumerate some possible reasons why that might occur	a process	252
hi welcome to lecture thirty two so let's talk about scheduling and schedule algorithms as a warm up let's think about why processes might be placed on the ready queue ok so the story so far is we never have enough cpu 's and we can imagine times when a process would like to run for example a thread is ready to go but we don't have a cpu available so let's talk about some enumerate some possible reasons why that might occur	thread	294
but we'll ignore that kind of little computation complication for now right so why might a process be placed on ready queue well it could simply be that it's a new process and there are no cpu cores available right now they're all busy working on other things so we're just waiting to get it started	a process	89
is first some io event to complete right so some input output for example perhaps you've called open perhaps you've called read perhaps you've called write and we need to talk to an external device for in order to get the data or put the data sometimes these these calls can complete to immediately if we already have the data inside ram but at other times we have to wait for the data to physically arrive ok so once that data is ready there in that system call can return an example of this might be you have written a ui program complete with windows and menu drop downs and all that good stuff processing those window events is just another piece of kind of io now we're waiting for events to occur from user input and so fundamentally there is some kind of read call going on to find out what the user wants us to do and most of the time it cost the user isn't giving his events but occasionally the user going to type a key press the screen that kind of thing and then our culture we can return it and our code can continue ok what else might we finish waiting for think about something that we've seen and you used inside this course well ok how about our synchronization primitives so some synchronization event has happened that we allows us to continue so what do we got we've got things like mutex locks you are able to acquire the lock we've got counting semaphores somebody's returned that piece of pizza into the counting semaphore so now we get to pull it out and continue and of course we've seen condition variables so now say broadcasters occured and now my thread is made continue we've also got other things like barriers so for example finally all the feds have turned up so now i'm going to wait this thread and let it continue	type	919
is first some io event to complete right so some input output for example perhaps you've called open perhaps you've called read perhaps you've called write and we need to talk to an external device for in order to get the data or put the data sometimes these these calls can complete to immediately if we already have the data inside ram but at other times we have to wait for the data to physically arrive ok so once that data is ready there in that system call can return an example of this might be you have written a ui program complete with windows and menu drop downs and all that good stuff processing those window events is just another piece of kind of io now we're waiting for events to occur from user input and so fundamentally there is some kind of read call going on to find out what the user wants us to do and most of the time it cost the user isn't giving his events but occasionally the user going to type a key press the screen that kind of thing and then our culture we can return it and our code can continue ok what else might we finish waiting for think about something that we've seen and you used inside this course well ok how about our synchronization primitives so some synchronization event has happened that we allows us to continue so what do we got we've got things like mutex locks you are able to acquire the lock we've got counting semaphores somebody's returned that piece of pizza into the counting semaphore so now we get to pull it out and continue and of course we've seen condition variables so now say broadcasters occured and now my thread is made continue we've also got other things like barriers so for example finally all the feds have turned up so now i'm going to wait this thread and let it continue	code	1012
is first some io event to complete right so some input output for example perhaps you've called open perhaps you've called read perhaps you've called write and we need to talk to an external device for in order to get the data or put the data sometimes these these calls can complete to immediately if we already have the data inside ram but at other times we have to wait for the data to physically arrive ok so once that data is ready there in that system call can return an example of this might be you have written a ui program complete with windows and menu drop downs and all that good stuff processing those window events is just another piece of kind of io now we're waiting for events to occur from user input and so fundamentally there is some kind of read call going on to find out what the user wants us to do and most of the time it cost the user isn't giving his events but occasionally the user going to type a key press the screen that kind of thing and then our culture we can return it and our code can continue ok what else might we finish waiting for think about something that we've seen and you used inside this course well ok how about our synchronization primitives so some synchronization event has happened that we allows us to continue so what do we got we've got things like mutex locks you are able to acquire the lock we've got counting semaphores somebody's returned that piece of pizza into the counting semaphore so now we get to pull it out and continue and of course we've seen condition variables so now say broadcasters occured and now my thread is made continue we've also got other things like barriers so for example finally all the feds have turned up so now i'm going to wait this thread and let it continue	thread	1576
is first some io event to complete right so some input output for example perhaps you've called open perhaps you've called read perhaps you've called write and we need to talk to an external device for in order to get the data or put the data sometimes these these calls can complete to immediately if we already have the data inside ram but at other times we have to wait for the data to physically arrive ok so once that data is ready there in that system call can return an example of this might be you have written a ui program complete with windows and menu drop downs and all that good stuff processing those window events is just another piece of kind of io now we're waiting for events to occur from user input and so fundamentally there is some kind of read call going on to find out what the user wants us to do and most of the time it cost the user isn't giving his events but occasionally the user going to type a key press the screen that kind of thing and then our culture we can return it and our code can continue ok what else might we finish waiting for think about something that we've seen and you used inside this course well ok how about our synchronization primitives so some synchronization event has happened that we allows us to continue so what do we got we've got things like mutex locks you are able to acquire the lock we've got counting semaphores somebody's returned that piece of pizza into the counting semaphore so now we get to pull it out and continue and of course we've seen condition variables so now say broadcasters occured and now my thread is made continue we've also got other things like barriers so for example finally all the feds have turned up so now i'm going to wait this thread and let it continue	system	451
excuse me so there's lots of reasons why a process or thread might be ready to continue needs and is ready for a cpu there's another one as well which is that occasionally we'll take a process and take it away from the cpu so on a standard scheduling system you only get the cpu for a limited amount of time and typically it's a one millisecond or ten milliseconds without their time why because the cpu is in high demand and if we	a process	41
excuse me so there's lots of reasons why a process or thread might be ready to continue needs and is ready for a cpu there's another one as well which is that occasionally we'll take a process and take it away from the cpu so on a standard scheduling system you only get the cpu for a limited amount of time and typically it's a one millisecond or ten milliseconds without their time why because the cpu is in high demand and if we	thread	54
excuse me so there's lots of reasons why a process or thread might be ready to continue needs and is ready for a cpu there's another one as well which is that occasionally we'll take a process and take it away from the cpu so on a standard scheduling system you only get the cpu for a limited amount of time and typically it's a one millisecond or ten milliseconds without their time why because the cpu is in high demand and if we	system	251
if we allowed you to use the cpu for as much time as you wanted then our interactive systems wouldn't they wouldn't be interactive with press a key and nothing would happen because right now the cpu is being used by someone else so in practice we have these little time quanta so at some point we will take the cpu away from you but at some point again in the future will put the process back onto so we'll put it back onto the ready queue and at some point it will be the process is turned to run again right so	system	85
you could actually imagine that we could draw a little state diagram for each thread or if it was a single threaded process each process you can imagine that we've got different states we've got things like it's knew it's ready it's running	thread	78
and it's finished it's done and that overtime my little thread can transfers and simply across but is more likely to be transitioning backwards and forwards so here's our first example where he goes running back to ready but we could also have a block state as well so that if my thread or process is waiting for some io to complete then it's cannot make use the cpu and only some point in the future when that event is satisfied can we go back into the ready state in order to start running again	block	246
and it's finished it's done and that overtime my little thread can transfers and simply across but is more likely to be transitioning backwards and forwards so here's our first example where he goes running back to ready but we could also have a block state as well so that if my thread or process is waiting for some io to complete then it's cannot make use the cpu and only some point in the future when that event is satisfied can we go back into the ready state in order to start running again	thread	56
ok right so that's kind of quick idea that our process is stop and start they get scheduled they put get put onto a cpu they get taken away from a cpu and even if we're just waiting in the innermost for loop we may not be actually truly truly running that code a hundred percent at the type sometimes a cpu is given to another process instead	type	286
ok right so that's kind of quick idea that our process is stop and start they get scheduled they put get put onto a cpu they get taken away from a cpu and even if we're just waiting in the innermost for loop we may not be actually truly truly running that code a hundred percent at the type sometimes a cpu is given to another process instead	code	256
ok right so let's talk about some scheduling terms the first one is the wait time if someone talk about the wait time what do you think we mean do you think we're talking about the total wait time or does the first waiting time before it is between when it is first scheduled and when it actually runs ok make your guest now and the correct answer is it's the total wait time so this is all the time that we wish the operator would actually using the cpu but was unable to because it was in the ready queue but it was unable to actually use the cpu core cpu is you being used by different process ok so ideally at the wait time of our system would be zero for all of our processes maybe that could occur if i had more cpus than	system	635
then i could imagine that there is some time when nothing happens it's just waiting to start then we might have all of the execution time all in one block but it doesn't need to be and then it completes so that's kind of one picture of what might happen so this is the kind of completion time	block	149
ok so that gives us a total time that our process worse was actually on the scene as part of our system but for some of that time it was actually executing so let's remove the execution time	system	97
ok so now we can actually calculate the wait time and like i said ideally we were scheduled things and we have enough resources that that could be zero	resources	118
ok right now it's time to start talking about some deep miller leave its of system programming and in particular what happens when system calls get interrupted ok so many system calls a very fast for example if you want to find your pid that will return immediately but some things might be slow for example if you call right and it's to something which might block like a network socket or a pipe then it is possible that this write called might be interrupted before it completes so posix has the idea of fast and slow devices local disk is considered fast but for slow devices possible than not little bites maybe actually be written so it's important that we find out what actually happened ok so it's important that we actually get store the result of write call and then check to see what happens ok so let's just see what are man pages at least on my mac says about to the write call here it is and you'll see that k we've got our standard right we've got p right we talked about a little bit which allows us to include an offset there's even another version which allows us to assemble right using different bits of memories so rather than requiring all of your data to be in one contiguous area you can use this more complicated version to say ok take these bits over there and those bits over there	block	360
ok right now it's time to start talking about some deep miller leave its of system programming and in particular what happens when system calls get interrupted ok so many system calls a very fast for example if you want to find your pid that will return immediately but some things might be slow for example if you call right and it's to something which might block like a network socket or a pipe then it is possible that this write called might be interrupted before it completes so posix has the idea of fast and slow devices local disk is considered fast but for slow devices possible than not little bites maybe actually be written so it's important that we find out what actually happened ok so it's important that we actually get store the result of write call and then check to see what happens ok so let's just see what are man pages at least on my mac says about to the write call here it is and you'll see that k we've got our standard right we've got p right we talked about a little bit which allows us to include an offset there's even another version which allows us to assemble right using different bits of memories so rather than requiring all of your data to be in one contiguous area you can use this more complicated version to say ok take these bits over there and those bits over there	system	76
then it will just return doesn't actually do any writing force ok what a lazy kernel that is so ok will keep scrolling down and you can see here there's more and more stuff there's other ones as well for when we start talking about asynchronous rights so you probably heard of node node js which is kind of taking the server world by storm but we can make javascript on the server that uses asynchronous io and so it uses epoll to figure out which file descriptors ready and it uses things like these e again and he would block to figure out which file descriptors ready for more bytes so as you can see there's plenty and plenty of errors that we might want to deal with at some point or gate right but we are just going to think about this what this idea about oh i was interrupted key so if we don't handle this then	block	522
exciting things might happen so perhaps you've written code that uses same weight right so same way is supposed to actually wait until there was a piece of pizza available in the pizza box for as to eat but it just got interrupted and just returned as it off so i can be bothered to wait anymore right and so then we let our code continue	code	55
oh idea so we've been oversimplifying things at this point we haven't been writing high quality code instead what we need to do is we need to check the return value of some weight and read and write and even sleep if we actually want to write production worthy code because some weight might be say oh i failed and it might fail simply because it got into up to do to a signal so we can check this and then we can just re run it again so typically you'll see the following kind of code that	the following	459
oh idea so we've been oversimplifying things at this point we haven't been writing high quality code instead what we need to do is we need to check the return value of some weight and read and write and even sleep if we actually want to write production worthy code because some weight might be say oh i failed and it might fail simply because it got into up to do to a signal so we can check this and then we can just re run it again so typically you'll see the following kind of code that	code	96
and we're going to call sem_wait on a particular counting semaphore ok like ok here's a pointer to my structure there but it could be that that returns a negative one meaning it failed ok so we could store that inside a little variable here it is	pointer	88
k is equal to ok you just interrupted then go round the loop again so here's our trick that's all big expression for awhile and notice it as a side effect of evaluating this while we actually call sam wait ok so put all that inside there and dropped a t t inside and for the actual body of the while loop don't do anything	the loop	52
ok right so that would be more production quality code we might as well log any other errors as well so that if we get out of this loop and we see that we didn't get zero value here then maybe we actually want to	code	50
for example that would that would help us catch if the county center was not properly initialized ok so this is a lot of annoying code to write each time and actually makes it harder for us to generally read our code so also people tend to kind of put this code inside a little function calls so you might want something called say same way reentrant or my same weight which kind of does this error checking as well and does this	code	130
oh i must have right to thirty seven bytes but that's not enough so let's keep account of the true number of bytes that we've actually sent so far and then go round the loop to try to send the remainder obviously we don't start from the beginning we want to start from whatever offset that we've counted up so far or maybe we've now got to the point where total bytes sent is everything which case we can finish and return say yeah we sent all the bytes ok we're done we're done with this return so we've actually got to write code that copes correctly with all four of these situations	the loop	165
oh i must have right to thirty seven bytes but that's not enough so let's keep account of the true number of bytes that we've actually sent so far and then go round the loop to try to send the remainder obviously we don't start from the beginning we want to start from whatever offset that we've counted up so far or maybe we've now got to the point where total bytes sent is everything which case we can finish and return say yeah we sent all the bytes ok we're done we're done with this return so we've actually got to write code that copes correctly with all four of these situations	code	527
for read we also have the possibility that it would return zero which means ok that's it you've read anything and there's no more bites coming through this pipe is now closed for business i can tell you no one is going to read anymore or this stream safer the terminal is not getting any more bites or this file you've reached the end of it ok so again we have to write sophisticated code to think about these possible different states	code	384
right i finally was sleep so we sleep we say please sleep for so many seconds but it is possible to be interrupted so let's have a quick look at sleep this one is going to be a little bit easier so we see we probably want section two let's try that section three ten	section	222
k so will put that in there and will know that sleep return zero if the if it's actually manage to sleep number of seconds otherwise for sleep it will never return negative one so we don't have to worry about that for sleep so life is a bit simpler for sleep we just need to keep a running tally the total number of seconds slept so far so ok done plus equals are so that's a lot simpler in the right code again after right but gives you the same idea that we keep keep track of how much progress we've made towards completing our goal so if we now put this	code	401
into the earlier code where we played with process is you'd now notice that sleep now would works a lot better even when i have child processes that existing and causing c chart events which interrupt our sleep	code	17
ok so time stop talking about how we can mount and unmount an entire file system so the reason it's called mounting and unmounting is for harks back to a time when file systems were big and heavy they might be contained on their very large drum there might be a large piece of magnetic tape that we actually had to put onto a machine so it required some physical effort to mount the file system so that you could read or write to it so today of course are full systems can be very light very tiny physically but we still use these words to talk about when we have a file system that we can now access and when we want to no longer access it we can unmount it ok right so in the beginning when your machine starts up it's actually gonna look for filesystems does described in this side is special file etc/fstab so that can describe a whole load of additional file systems like there might be a file system just for the users there might be a remote file system that is mounted on a network drive somewhere we can describe all of these inside this little text file and it just stands for file system table s tab and that can include additional options like whether we want to load the file system that's just read only or what to do if an error occurs so	system	74
let's let's start kind of play with especially today we're going to mount a file system that i downloaded from the internet it's a complete working version of linux and will just explore will just to see what's inside it right one thing we're going to see is the idea of a loop back file system so the items i've downloaded from the internet of course is just a regular file and a regular file is not what we need for a file system	system	81
regular file has bytes we can navigate to it we can seek backwards and forwards etc that's not quite what we need for a file system i want to be able to read and write blocks so i need to	block	168
regular file has bytes we can navigate to it we can seek backwards and forwards etc that's not quite what we need for a file system i want to be able to read and write blocks so i need to	system	125
now need to provide an interface where i can read or write random blocks or possibly blocks in a contiguous order so there's a virtual device that the kernel supports a lot of physical device no but they pretend device there's actually inside the kernel called a loop back file system which	block	66
now need to provide an interface where i can read or write random blocks or possibly blocks in a contiguous order so there's a virtual device that the kernel supports a lot of physical device no but they pretend device there's actually inside the kernel called a loop back file system which	system	278
we presented a regular file and it presents to the kernel then this ability to read or write blocks in order for us to then actually mount a file system and explore inside it ok so we're going to use that today	block	93
we presented a regular file and it presents to the kernel then this ability to read or write blocks in order for us to then actually mount a file system and explore inside it ok so we're going to use that today	system	146
as part of looking at this file system we're going to use a command called mount now i need to be root for this so you could do is say on your own virtual machines on your laptop and mount take some options so for example we might say you know i care about it being read only or in our case actually i need	system	32
you give me an intermediate loop back device as well and then we need to give two things first of all where can we actually find the file system so in our case we're going to do today is we're going to look at the file that i downloaded from the internet called is a dot iso file	system	138
so there will be some file somewhere and second we need to say where will it appear inside our main file system so for example we might want to say you know what i want it to appear inside a anytime i look inside a directory called slash home or in our case we're going to make a special directory called say something like explore and then when we look inside this directory	system	105
rather than just looking at our regular file system we will go and look inside this file so the idea then is that your file system then becomes a large hierarchy of other file systems ok so the root of it all we've got a single slash and then on lenox we've got things like e t c home user been var all of these places they themselves could be different file systems or you could choose subdirectory within that so for example you might have home	system	45
extras like that could be his own file system or you might have say slash mount and your usb device so inside that you could have a file system so the point is that we choose a path where we want to load where we want to mount the file system so enough talking let's go and see some action let's go see this right so i was getting kind of annoyed with this long prompt so i changed it i said say ps one equals something so we can for example say	system	39
ok what if we want right so some silly kind of prompt like that ok and now let's see where we are ok so i'll make a directory called say explore iso right and of course there's nothing inside explore iso right now ok so that is where we'd like to mount our file system	system	262
so hey find start recursively searching from the current directory and i care about all files which end with which match the following patterns so that end with i so so there it is we found this ok that's what we're going to use so now i can say right hello melt if i just say mount without any options it let's me all of the current file systems which have been mounted	the following	121
so hey find start recursively searching from the current directory and i care about all files which end with which match the following patterns so that end with i so so there it is we found this ok that's what we're going to use so now i can say right hello melt if i just say mount without any options it let's me all of the current file systems which have been mounted	system	339
but let's not worry about that right now let's instead say right i want to use the folder option i need to loop back device here's the iso file that we downloaded and let's mount that say explore ice oh ok now it gives me a hint that the file system we're using is read only and in fact we expect that with iso files because the iso format or more precisely the iso nine six six echo format worth designed for cd roms which is a read only	system	243
medium ok so this fast system type is great if you don't intend to change anything right so rights are not supported inside this file system so anyway let's go and have a look inside explore iso ansi what we found ok holder stuff actually not that much stuff so let's do find this and just to see how many files and you see it's not that many files at all however we see some things which do indeed look like the startup things that	type	30
medium ok so this fast system type is great if you don't intend to change anything right so rights are not supported inside this file system so anyway let's go and have a look inside explore iso ansi what we found ok holder stuff actually not that much stuff so let's do find this and just to see how many files and you see it's not that many files at all however we see some things which do indeed look like the startup things that	system	23
but lennox might need so this to me looks a lot like complete bootable linux system and we will see in a future lecture how we can actually run this inside an emulator so i've got a complete operating system now is not a very big one so if i say say disk usage	system	77
see a summary you see it's about fifty thousand fifty thousand megabytes let's check yeah fifty fifty megabytes so the whole thing is a tiny operating system just fifty meg	system	151
it's over it we can't see it right explore iso now immediately is is the mounted file system so any files we have inside that from my old file system now invisible to us we cannot see them anymore right so time to unmount it	system	86
so it does give the mountpoints there we go and now it's back so now we can see our little hello again ok so that's that's kind of quick introduction to mounting and unmounting filesystems like i said you need to be root for this	system	181
and lastly let's have a look at the s staff so far system table here it is you can see for this machine there's not much stuff we've got the uid of a disk it would like to mount as our root file system here and we're giving a hint that on this we expect to find an e x t four file system but should any errors occur while were mounting it then we want to remount it just using read only we also have a swap device but we're not going to talk about that today but will revisit that in the future	system	51
okay right so in the next video let's just review what a process contains i'll see you then	a process	55
ok so let's have a look at some json and google protocol buffers an xml right so hey let's do this in reverse order so here's google 's protocol buffers now one advantage of using google protocol buffers is that they allow you to write code in multiple languages	code	236
ok so let's have a look at some json and google protocol buffers an xml right so hey let's do this in reverse order so here's google 's protocol buffers now one advantage of using google protocol buffers is that they allow you to write code in multiple languages	protocol buffers	48
so rpc obviously jenn only works really fucking a c and c plus plus projects versus google protocol buffers or implementations of this of course all major languages today some of them are third party but still this means that i can write a client in a different language from the server for	protocol buffers	91
example my server might be written in python ok so let's see how they work so here is the idea is that r i d l type files now look like messages and in fact the basic idea is that their message is the equivalent of the object that we want to kind of use for	type	111
an email as well we can also describe phone numbers inside this as well we can have enumerated types and	type	95
is that it gives me lots and lots of code boilerplate code for me automatically it will generate the code to marshall my objects and send them in a binary efficient binary format	code	37
now one of the great things about google protocol buffers is that they support versioning so if you are for example that the size of google you don't actually get to update all of your servers and all of your clients all at the same time as just not practical so we need to be able to weigh to support the idea that i'm going to have to be able to send information between clients and servers that are running slightly different versions of my my software and tomorrow i might decide that a person has to have a say a new field so perhaps you know whether they like cheesecake or not for example	protocol buffers	41
so how can i do this i can't update all of our clients and all my service and take everything offline google is currently down for maintenance that we don't want to see that so google protocol buffers allows you to specify a default value for fields which are missing in future versions so i can have a client for example of that is not quite the same version that number as my server and google protocols does something reasonable	protocol buffers	184
so that is kind of rather than just crashing and burning and saying hey my binary formats are different instead we can define default behaviors for fields which only have been created in more recent versions of your adl of your person object ok so that's kind of one big advantage the second like i said is that it's supported by many many different different programming languages right so that's kind of the most complicated way of doing things this is actually going to look at some other ways to transfer structured information over the network today the first one i want to talk about is jason objects case so jason actually looks a lot like javascript objects so a javascript object you can think of is kind of key value pairs so cave just writing a simple brace gives me a javascript object so for example i could say on my javascript object here's a key as a string here and i'll give it a value so for example i might have a key of say abc	string	867
ok and i can separate more key value pairs with a comma now unfortunately for that adjacent implementations do not allow you to have just a trailing comma at the end ok so that is not good jason syntax so which is annoying because it's a common error when you're constructing json objects by by hand so let's have a look at this example json as you can see it's got nested things that's because for a value inside this particular jason object i've got another jason object here it is right other things are just simple strings on this side so one of the nice things about json is extremely readable and if i give you a blob of json there were online tools to kind of nicely formatted nicely indented so json is of very loose format and is used today primarily for	string	519
sending back information requests from a server and then we'll have some client side code to render this into some html for example so we see a lot of json information being sent today back to back to back to web pages where they then iterate over this in order to turn it into something displayable for on the page ok so the downside of json is that there's no formal specification about which fields will be there which are required and then you know kind of formatting information so you can think it was going to very kind of loose format	code	85
ok so what happens if you mouse over that event or my body here wall no node one is a key i can say bg color and i can set the background color of my web page today more than html has attributes to do with style sheets so i can say hey use the following particular kind of style for say this h h one tag but let's actually have a look at some more xml with regards to actual kind of data that we might want to set so in fact down here i've got the very same it is kind of very same piece of xml data as before so same data as before but this time instead of json i've expected expressed it as xml and i want you to notice that is very very wordy it's much longer take small bites to send an xml messaged and json so one reason is because for every opening tag we're gonna have to find a closing tag as well so xml actually takes more compute power to pause and more network bandwidth to send compared to json so why would anybody use xml today given these deficiencies well one great thing about xml is that you can define	the following	240
ok so what happens if you mouse over that event or my body here wall no node one is a key i can say bg color and i can set the background color of my web page today more than html has attributes to do with style sheets so i can say hey use the following particular kind of style for say this h h one tag but let's actually have a look at some more xml with regards to actual kind of data that we might want to set so in fact down here i've got the very same it is kind of very same piece of xml data as before so same data as before but this time instead of json i've expected expressed it as xml and i want you to notice that is very very wordy it's much longer take small bites to send an xml messaged and json so one reason is because for every opening tag we're gonna have to find a closing tag as well so xml actually takes more compute power to pause and more network bandwidth to send compared to json so why would anybody use xml today given these deficiencies well one great thing about xml is that you can define	background	127
other servers my server might send an xml message in order to confirm that booking or in order to find out if an airplane has some some seats between two destinations that are at a certain price point for example ok so xml is very kind of popular as interchange format for kind of finance and booking applications now quick comment is that you don't need to write your own json parser your xml pauses today of course there's plenty of library code out there that will do this for you some of them will give you events based on each time they see a new tag others will read the whole thing into memory and creates what's called a dom document object model module which is great for a kind of small message is not so great if your dom is huge and then you can iterate through that by asking a dom to say find a particular child of a certain type one last thing is you'll notice that each element we have here we can actually have water cord attributes case so we've talked about elements which are the items we actually find insight memory each element may have kind of attributes the difference between an element and a tag is the tag is the actual piece of string that we've written here the actor going to bite sequence that we needed to actually describe the elements ok so the tag is the actual thing with the open and close	memory	594
other servers my server might send an xml message in order to confirm that booking or in order to find out if an airplane has some some seats between two destinations that are at a certain price point for example ok so xml is very kind of popular as interchange format for kind of finance and booking applications now quick comment is that you don't need to write your own json parser your xml pauses today of course there's plenty of library code out there that will do this for you some of them will give you events based on each time they see a new tag others will read the whole thing into memory and creates what's called a dom document object model module which is great for a kind of small message is not so great if your dom is huge and then you can iterate through that by asking a dom to say find a particular child of a certain type one last thing is you'll notice that each element we have here we can actually have water cord attributes case so we've talked about elements which are the items we actually find insight memory each element may have kind of attributes the difference between an element and a tag is the tag is the actual piece of string that we've written here the actor going to bite sequence that we needed to actually describe the elements ok so the tag is the actual thing with the open and close	type	839
other servers my server might send an xml message in order to confirm that booking or in order to find out if an airplane has some some seats between two destinations that are at a certain price point for example ok so xml is very kind of popular as interchange format for kind of finance and booking applications now quick comment is that you don't need to write your own json parser your xml pauses today of course there's plenty of library code out there that will do this for you some of them will give you events based on each time they see a new tag others will read the whole thing into memory and creates what's called a dom document object model module which is great for a kind of small message is not so great if your dom is huge and then you can iterate through that by asking a dom to say find a particular child of a certain type one last thing is you'll notice that each element we have here we can actually have water cord attributes case so we've talked about elements which are the items we actually find insight memory each element may have kind of attributes the difference between an element and a tag is the tag is the actual piece of string that we've written here the actor going to bite sequence that we needed to actually describe the elements ok so the tag is the actual thing with the open and close	code	443
other servers my server might send an xml message in order to confirm that booking or in order to find out if an airplane has some some seats between two destinations that are at a certain price point for example ok so xml is very kind of popular as interchange format for kind of finance and booking applications now quick comment is that you don't need to write your own json parser your xml pauses today of course there's plenty of library code out there that will do this for you some of them will give you events based on each time they see a new tag others will read the whole thing into memory and creates what's called a dom document object model module which is great for a kind of small message is not so great if your dom is huge and then you can iterate through that by asking a dom to say find a particular child of a certain type one last thing is you'll notice that each element we have here we can actually have water cord attributes case so we've talked about elements which are the items we actually find insight memory each element may have kind of attributes the difference between an element and a tag is the tag is the actual piece of string that we've written here the actor going to bite sequence that we needed to actually describe the elements ok so the tag is the actual thing with the open and close	string	1157
characters to greater than and less than characters to actually describe the element type that we're going to have so that's it for kind of xml json and protocol buffers there is no never of course one right answer	type	85
characters to greater than and less than characters to actually describe the element type that we're going to have so that's it for kind of xml json and protocol buffers there is no never of course one right answer	protocol buffers	153
hi so it's quite common to put aside a little bit of heat memory in order to define exactly what we want our thread to do so i want to give you an example of that and then talk about how would set it up right so here's the idea suppose i had an away and i want to be able to kind of process all the elements in my way and fortunately my task is embarrassingly parallel some part of it is meaning that i can easily just spit up my data and say ok thread you do this half and another thread ok you do that half so right now what if i got so i've got method then that i want or function that i want to speed up i want to make multithreaded here it is is my little calc method here and it's given a pointer to an integer ie the very first element of my array and the number of items we'd like to process ok so if we're going to speed things up let's just split this down the middle it doesn't make sense for one thread to say work on all the even indexed items and another thread to work in the audience next items that wouldn't be very great for cash there is a much better to split it down the middle ok so will calculate the half of it and then game plan then is to create a thread or two to do this so for example we might do the following	the following	1226
hi so it's quite common to put aside a little bit of heat memory in order to define exactly what we want our thread to do so i want to give you an example of that and then talk about how would set it up right so here's the idea suppose i had an away and i want to be able to kind of process all the elements in my way and fortunately my task is embarrassingly parallel some part of it is meaning that i can easily just spit up my data and say ok thread you do this half and another thread ok you do that half so right now what if i got so i've got method then that i want or function that i want to speed up i want to make multithreaded here it is is my little calc method here and it's given a pointer to an integer ie the very first element of my array and the number of items we'd like to process ok so if we're going to speed things up let's just split this down the middle it doesn't make sense for one thread to say work on all the even indexed items and another thread to work in the audience next items that wouldn't be very great for cash there is a much better to split it down the middle ok so will calculate the half of it and then game plan then is to create a thread or two to do this so for example we might do the following	memory	58
hi so it's quite common to put aside a little bit of heat memory in order to define exactly what we want our thread to do so i want to give you an example of that and then talk about how would set it up right so here's the idea suppose i had an away and i want to be able to kind of process all the elements in my way and fortunately my task is embarrassingly parallel some part of it is meaning that i can easily just spit up my data and say ok thread you do this half and another thread ok you do that half so right now what if i got so i've got method then that i want or function that i want to speed up i want to make multithreaded here it is is my little calc method here and it's given a pointer to an integer ie the very first element of my array and the number of items we'd like to process ok so if we're going to speed things up let's just split this down the middle it doesn't make sense for one thread to say work on all the even indexed items and another thread to work in the audience next items that wouldn't be very great for cash there is a much better to split it down the middle ok so will calculate the half of it and then game plan then is to create a thread or two to do this so for example we might do the following	a thread	1172
hi so it's quite common to put aside a little bit of heat memory in order to define exactly what we want our thread to do so i want to give you an example of that and then talk about how would set it up right so here's the idea suppose i had an away and i want to be able to kind of process all the elements in my way and fortunately my task is embarrassingly parallel some part of it is meaning that i can easily just spit up my data and say ok thread you do this half and another thread ok you do that half so right now what if i got so i've got method then that i want or function that i want to speed up i want to make multithreaded here it is is my little calc method here and it's given a pointer to an integer ie the very first element of my array and the number of items we'd like to process ok so if we're going to speed things up let's just split this down the middle it doesn't make sense for one thread to say work on all the even indexed items and another thread to work in the audience next items that wouldn't be very great for cash there is a much better to split it down the middle ok so will calculate the half of it and then game plan then is to create a thread or two to do this so for example we might do the following	thread	109
hi so it's quite common to put aside a little bit of heat memory in order to define exactly what we want our thread to do so i want to give you an example of that and then talk about how would set it up right so here's the idea suppose i had an away and i want to be able to kind of process all the elements in my way and fortunately my task is embarrassingly parallel some part of it is meaning that i can easily just spit up my data and say ok thread you do this half and another thread ok you do that half so right now what if i got so i've got method then that i want or function that i want to speed up i want to make multithreaded here it is is my little calc method here and it's given a pointer to an integer ie the very first element of my array and the number of items we'd like to process ok so if we're going to speed things up let's just split this down the middle it doesn't make sense for one thread to say work on all the even indexed items and another thread to work in the audience next items that wouldn't be very great for cash there is a much better to split it down the middle ok so will calculate the half of it and then game plan then is to create a thread or two to do this so for example we might do the following	pointer	695
escorpi thread create we're going to make a note of the thread id we don't pass we don't need pass any attributes today and then here's the actual image calculation method that we're going to use here we go there going to actually do the calculation i just need to when i call that actually kind of passing some hints about what it should be doing so let's make a little task and put that on the heap so we'll have a little pointer here called say task one k which will represent what we'd like that thread to do ok so let's set this up right so what kind of information do i want to send to my image calculation well i probably would want to send the actual data so in this case this is just a pointer to the data so that can be data and then i need to decide or define how i want to specify the range that i wanted to work in there so i for example	the heap	392
escorpi thread create we're going to make a note of the thread id we don't pass we don't need pass any attributes today and then here's the actual image calculation method that we're going to use here we go there going to actually do the calculation i just need to when i call that actually kind of passing some hints about what it should be doing so let's make a little task and put that on the heap so we'll have a little pointer here called say task one k which will represent what we'd like that thread to do ok so let's set this up right so what kind of information do i want to send to my image calculation well i probably would want to send the actual data so in this case this is just a pointer to the data so that can be data and then i need to decide or define how i want to specify the range that i wanted to work in there so i for example	thread	8
escorpi thread create we're going to make a note of the thread id we don't pass we don't need pass any attributes today and then here's the actual image calculation method that we're going to use here we go there going to actually do the calculation i just need to when i call that actually kind of passing some hints about what it should be doing so let's make a little task and put that on the heap so we'll have a little pointer here called say task one k which will represent what we'd like that thread to do ok so let's set this up right so what kind of information do i want to send to my image calculation well i probably would want to send the actual data so in this case this is just a pointer to the data so that can be data and then i need to decide or define how i want to specify the range that i wanted to work in there so i for example	pointer	424
is always the beginning of where i want my calculations to start i just need to say the number of items so let me put another squeeze in here another item in here so i've got the number of items that i actually wanted to work on that case so this would be a size t and again i'll be numb items right so very similar to the actual calling instructions we had four original kind of calculation here right so let's create a couple of examples of this so now when i create a task i going to create that today on the heap so let's do that i can say right i'll have a task pointer ok	the heap	508
is always the beginning of where i want my calculations to start i just need to say the number of items so let me put another squeeze in here another item in here so i've got the number of items that i actually wanted to work on that case so this would be a size t and again i'll be numb items right so very similar to the actual calling instructions we had four original kind of calculation here right so let's create a couple of examples of this so now when i create a task i going to create that today on the heap so let's do that i can say right i'll have a task pointer ok	pointer	567
and all this make my wanna little bit nicer though t one equals now i need to get some memory sir let me call malloc an as usual let's make sure when you slow down and check the number of bytes that we actually want so today want not there we go so its size of i don't want ask pointer that would only give me eight bytes or four bytes i actually want enough bytes to hold this little struct so there we go task underscore t right so now i've got that back good error checking would check to make sure that that is non null	memory	87
and all this make my wanna little bit nicer though t one equals now i need to get some memory sir let me call malloc an as usual let's make sure when you slow down and check the number of bytes that we actually want so today want not there we go so its size of i don't want ask pointer that would only give me eight bytes or four bytes i actually want enough bytes to hold this little struct so there we go task underscore t right so now i've got that back good error checking would check to make sure that that is non null	pointer	278
ok cool that as our argument here ok now how this memory be freed in fact we can delegate that to our image calculation so once that actually has completed it can call free on this argument so it's perfectly fine to create memory inside one thread will create heat memory inside one thread and release it inside another just be careful that when you free it you're completely sure that no thread is going to be accessing that data in the future	memory	50
ok cool that as our argument here ok now how this memory be freed in fact we can delegate that to our image calculation so once that actually has completed it can call free on this argument so it's perfectly fine to create memory inside one thread will create heat memory inside one thread and release it inside another just be careful that when you free it you're completely sure that no thread is going to be accessing that data in the future	thread	241
we would end up writing something like this we would say right number of items that we actually want should be our parameter an items minus the half that the lower half that the first thread is going to do for us ok so that's taken care of a potential off by one hour and in this case we are going to pass in the data ok now we can use pointer arithmetic let's make sure that we're pointing to the right kind of thing we just want to offset by half so you could imagine writing this in a loop as well	parameter	115
we would end up writing something like this we would say right number of items that we actually want should be our parameter an items minus the half that the lower half that the first thread is going to do for us ok so that's taken care of a potential off by one hour and in this case we are going to pass in the data ok now we can use pointer arithmetic let's make sure that we're pointing to the right kind of thing we just want to offset by half so you could imagine writing this in a loop as well	thread	184
we would end up writing something like this we would say right number of items that we actually want should be our parameter an items minus the half that the lower half that the first thread is going to do for us ok so that's taken care of a potential off by one hour and in this case we are going to pass in the data ok now we can use pointer arithmetic let's make sure that we're pointing to the right kind of thing we just want to offset by half so you could imagine writing this in a loop as well	pointer	336
you could actually potentially say alright if i'm running on a machine with eight spare cpu cause i could create threats alright so what do i need to finish well obviously i need to put another p thread creating here and then a whole order pizza joins to make sure that we don't continue until all of all of those threads have finished otherwise the caller will assume that the data has been properly and manipulated and the output is ready ok so don't forget to do the joins down here and in a sense what we've created is a barrier that we've started all these threads were going to let them earn independently but then this thread doesn't continue until we're certain that all those are the pets are finished ok one last comment here is that we could actually implement this just using one additional thread we could do half the work on the actual calling thread	thread	196
and so that would reduce the overhead of creating a second thread in this example does that save you alot little tiny bit but creating threads is pretty cheap and they were trying to create tens of thousands of them so the much cheaper than creating a process	a process	250
and so that would reduce the overhead of creating a second thread in this example does that save you alot little tiny bit but creating threads is pretty cheap and they were trying to create tens of thousands of them so the much cheaper than creating a process	thread	59
so great now you can actually walk into an internship and say right assume your code i will speed it up i will make it run twice as fast	code	80
except as mckenna discover you never get quite as much at speed up as we claim so you can use marketing speaking ceo will be up to twice as fast because we're pretty confident that there's going to be some additional overhead and other reasons why the actual final code won't run twice as fast and we'll talk about that again in the future right i'll see in the next video bye	code	265
oh i got a challenge for you let's go back and write flush for the case that we actually implementing the c library oh how can we do this well this moment it's time for us to actually say to the system ok here's some bites so we would want to say ok hey write and inside my file i know the file descriptor so let's grab that	system	195
right now if i wanted to possibly make this have a little bit better performance i might check that size truly is positive value before attempting to call right but i'm not sure that would give me much of a performance improvement we only would only be skipping the call to write in the times where nothing has actually been been been written ok but hopefully you can see that there's not necessarily kind of any magic inside the c library ultimately what it's doing is doing the very stuff that we study inside cs two forty one ok it's wrapping these low level system calls so that we can do more inside the process space and we can reduce the amount of kind of io that we're asking for so that we are only writing things out when we actually have either exhausted buffer or when the user has decided that they don't want to cache anything and we really do want to send things out to the output ok alright	system	562
hi welcome to lecture twenty four let's start with the code review ok so we're going to do we're going to look at a fixed sized ring buffer and look at an implementation	code	55
and we know the following things about it so first of all it uses counting semaphores and the first one s one is going to be initialized to two fifty six so this is kind of counting the number of free space is	the following	12
or how much capacity is left s two is initialized to zero so that's counting the number of things we've actually got inside the buffer right now and then we've got lots of threads producing things and consuming things as well ok so here's some questions that we might want to ask in sort of code review first of all can we find a way that deadlock can occur in other words when good it actually get stuck and if so under what conditions could it be for example when it gets completely full or completely empty is underflow possible meaning that is it possible for d q to return something even though we don't actually have anything inside the buffer right now in other words it will just return some multivalue that happens to be stored inside the buffer	code	291
or how much capacity is left s two is initialized to zero so that's counting the number of things we've actually got inside the buffer right now and then we've got lots of threads producing things and consuming things as well ok so here's some questions that we might want to ask in sort of code review first of all can we find a way that deadlock can occur in other words when good it actually get stuck and if so under what conditions could it be for example when it gets completely full or completely empty is underflow possible meaning that is it possible for d q to return something even though we don't actually have anything inside the buffer right now in other words it will just return some multivalue that happens to be stored inside the buffer	thread	172
or overwritten some data that we actually do need like an earlier piece of the buffer ok so let's actually take a look at the code now and see what we can find right so the first thing i notice is that we're actually calling mutex lock really early on inside nq normally i'd only expect the lock and unlock to be around the actual call of where we change the change the array here and the second thing i notice is ok good so our buffer size is two fifty six and in fact we're going to wrap around after we get to two hundred fifty five	code	126
so what we've got then is kind of long hold of the mutex lock inside my enqueue here so my concern is with this sem_wait what if i have a thread calling nq another those is produced an item wants to queue it up and we call sem_wait but i don't have any space left inside my data structure here in other words what if s one is zero we might have a problem here because now	a struct	277
so what we've got then is kind of long hold of the mutex lock inside my enqueue here so my concern is with this sem_wait what if i have a thread calling nq another those is produced an item wants to queue it up and we call sem_wait but i don't have any space left inside my data structure here in other words what if s one is zero we might have a problem here because now	a thread	136
so what we've got then is kind of long hold of the mutex lock inside my enqueue here so my concern is with this sem_wait what if i have a thread calling nq another those is produced an item wants to queue it up and we call sem_wait but i don't have any space left inside my data structure here in other words what if s one is zero we might have a problem here because now	thread	138
it's gone to sleep it's blocked inside the sem_wait call but it's still holding on to the mutex lock this is not a condition variable ok it's just a simple counting semaphore oh dear so can we have deadlock well let's find out to what happens on the d q side so on the dq side	block	24
if we also held onto the mutex lock earlier if our musics lock had been one of the first things we've done then yes we would have encountered deadlock because the d q could not have continued it would have waited for that that mutex lock that would have never been never been released definition of deadlock waiting for an event that never happens so we didn't find deadlock just there there we came awfully close right what else can we find out about this code then ok so let's see the same post happens early ok that we're actually increasing increasing the count of the number of items in our buffer before we even changed the buffer values ok so we're basically going to add one discounted here so if somebody was waiting to extract value in other words if a thread had already called d cube but was waiting here because the count of s two was zero we're going to release them from that early oh yeah so this line sounds like a recipe for	code	457
if we also held onto the mutex lock earlier if our musics lock had been one of the first things we've done then yes we would have encountered deadlock because the d q could not have continued it would have waited for that that mutex lock that would have never been never been released definition of deadlock waiting for an event that never happens so we didn't find deadlock just there there we came awfully close right what else can we find out about this code then ok so let's see the same post happens early ok that we're actually increasing increasing the count of the number of items in our buffer before we even changed the buffer values ok so we're basically going to add one discounted here so if somebody was waiting to extract value in other words if a thread had already called d cube but was waiting here because the count of s two was zero we're going to release them from that early oh yeah so this line sounds like a recipe for	a thread	761
if we also held onto the mutex lock earlier if our musics lock had been one of the first things we've done then yes we would have encountered deadlock because the d q could not have continued it would have waited for that that mutex lock that would have never been never been released definition of deadlock waiting for an event that never happens so we didn't find deadlock just there there we came awfully close right what else can we find out about this code then ok so let's see the same post happens early ok that we're actually increasing increasing the count of the number of items in our buffer before we even changed the buffer values ok so we're basically going to add one discounted here so if somebody was waiting to extract value in other words if a thread had already called d cube but was waiting here because the count of s two was zero we're going to release them from that early oh yeah so this line sounds like a recipe for	thread	763
underflow that because we said we've incremented our pizza box by one even though we had actually put anything into the buffer yet right so is underflow possible well actually in this particular implementation no because my dequeue cannot complete until the mutex lock is released because it is required before actually touching the buffer if this code tried to be a little bit more performance by giving the nq in the dequeue different mutex locks then we would have run into a problem because then we would have allowed a dq thread to try to read a value from the buffer before we've even put the value in right so better code of course would actually only increment the counting semaphore after we modified the buffer so so this line actually belongs down here so do this later ok and we can do it after we've released a mutex lock ok	code	348
underflow that because we said we've incremented our pizza box by one even though we had actually put anything into the buffer yet right so is underflow possible well actually in this particular implementation no because my dequeue cannot complete until the mutex lock is released because it is required before actually touching the buffer if this code tried to be a little bit more performance by giving the nq in the dequeue different mutex locks then we would have run into a problem because then we would have allowed a dq thread to try to read a value from the buffer before we've even put the value in right so better code of course would actually only increment the counting semaphore after we modified the buffer so so this line actually belongs down here so do this later ok and we can do it after we've released a mutex lock ok	a mutex	822
underflow that because we said we've incremented our pizza box by one even though we had actually put anything into the buffer yet right so is underflow possible well actually in this particular implementation no because my dequeue cannot complete until the mutex lock is released because it is required before actually touching the buffer if this code tried to be a little bit more performance by giving the nq in the dequeue different mutex locks then we would have run into a problem because then we would have allowed a dq thread to try to read a value from the buffer before we've even put the value in right so better code of course would actually only increment the counting semaphore after we modified the buffer so so this line actually belongs down here so do this later ok and we can do it after we've released a mutex lock ok	thread	527
because any threads that called dequeue will call sem_wait first we can never allow any more threads through this which are greater than the total number of items which are currently in the buffer so it's not possible to	thread	12
then my sem_wait can can decorate that and my sem post will cause increment what that so if at this very moment an enqueue event happens then that can that can continue through and overwrite the very value that i'd like to see we still need all that entries inside my buffer but now because i've posted on s one then if an nq thread appears then they can continue we haven't yet got the mutex lock so they get the mutex lock	thread	326
and then they call sem_wait on s one but we've already incremented s one so they get to continue and then post on sem_post which will never block and now they overwrite their buffers so it's pretty big unhappy space here yes we've seen a problem here of overflow buffer overflow we overrode a value that we actually need we actually managed to put too much stuff into the buffer now the chances of that happening are pretty small is this very small number of microseconds between us calling sem_post and then asking for the mutex lock but that is a non zero value also notice it's actually only really going to be a problem when my buffer is actually completely full so perhaps under light testing or if your website doesn't have many customers then you're not going to see this problem it's only when your buffer actually hit capacity do you have exposure to this problem ok so that's kind of fun stuff to think about reasoning about code like this is tricky my advice is to think about kind of the extreme conditions like underflow and the overflow and what happens if you have say two threads appearing at the same time and what would happen if just before you acquire the mutex lock another thread was able to acquire it instead	block	140
and then they call sem_wait on s one but we've already incremented s one so they get to continue and then post on sem_post which will never block and now they overwrite their buffers so it's pretty big unhappy space here yes we've seen a problem here of overflow buffer overflow we overrode a value that we actually need we actually managed to put too much stuff into the buffer now the chances of that happening are pretty small is this very small number of microseconds between us calling sem_post and then asking for the mutex lock but that is a non zero value also notice it's actually only really going to be a problem when my buffer is actually completely full so perhaps under light testing or if your website doesn't have many customers then you're not going to see this problem it's only when your buffer actually hit capacity do you have exposure to this problem ok so that's kind of fun stuff to think about reasoning about code like this is tricky my advice is to think about kind of the extreme conditions like underflow and the overflow and what happens if you have say two threads appearing at the same time and what would happen if just before you acquire the mutex lock another thread was able to acquire it instead	code	935
and then they call sem_wait on s one but we've already incremented s one so they get to continue and then post on sem_post which will never block and now they overwrite their buffers so it's pretty big unhappy space here yes we've seen a problem here of overflow buffer overflow we overrode a value that we actually need we actually managed to put too much stuff into the buffer now the chances of that happening are pretty small is this very small number of microseconds between us calling sem_post and then asking for the mutex lock but that is a non zero value also notice it's actually only really going to be a problem when my buffer is actually completely full so perhaps under light testing or if your website doesn't have many customers then you're not going to see this problem it's only when your buffer actually hit capacity do you have exposure to this problem ok so that's kind of fun stuff to think about reasoning about code like this is tricky my advice is to think about kind of the extreme conditions like underflow and the overflow and what happens if you have say two threads appearing at the same time and what would happen if just before you acquire the mutex lock another thread was able to acquire it instead	thread	1088
hi ok so we're going to look at a couple of fun animations in a little bit we're going to look at how to build a mandelbrot picture but first do you member seeing the matrix movie where neo was trapped inside a virtual world ok so let's think about how we can produce this kind of effect and of course we're going to use this to think about threads what will have is different threads are being responsible for different parts of this rain so each kind of raindrop will have a state and will update those independently	thread	341
we're using threads so that's kind of our game plan that i think about how we can do this cave so i'm going to spec out a simple program we've got to have ten threads and here's my global variables so all of these can be accessed from each each thread as agree one copy of these variables we've got all of our threads which is going to be the runners which actually do the display	thread	12
and now i want to represent that so with my ascii graphics i'm going to have a character i wanted to display in each one of those positions of my little terminal window so i've got height times width and i just want to initially to set all of those two a dot k so rather than might be in for loop let's use their more performant memset i want every bite to be this doc character so whatever ascii value that happens to be happens to be thirty three but no one needs to know that and will do that for the say half million characters or however many there are in my display probably eighty times twenty four for example right so time to get started right so here's here's the plan then right i need the thread runner that's going to sign my thread that's going to run the display and that's going to run the function called display and as an argument will pass that heap memory and then i've got all of my runners which actually cause the rain on my display so they're going to run a little function called run and again i pass a pointer to my heat then we so you might be concerned that my variable here image is actually a stack variable will remember we're not actually going to that particular variable we actually passing its value what is this value is a pointer is looking at the heap memory that we we allocated here ok so yes we are using a heap stack variable here but that's fine because actually what gets passed is the address of of heap memory of the mileage memory ok so anyway back to this we're going to create all of those threads we remember the thread i ds then we're going to call p fed exit on our main thread in other words we will never get to this line here so	heap memory	864
and now i want to represent that so with my ascii graphics i'm going to have a character i wanted to display in each one of those positions of my little terminal window so i've got height times width and i just want to initially to set all of those two a dot k so rather than might be in for loop let's use their more performant memset i want every bite to be this doc character so whatever ascii value that happens to be happens to be thirty three but no one needs to know that and will do that for the say half million characters or however many there are in my display probably eighty times twenty four for example right so time to get started right so here's here's the plan then right i need the thread runner that's going to sign my thread that's going to run the display and that's going to run the function called display and as an argument will pass that heap memory and then i've got all of my runners which actually cause the rain on my display so they're going to run a little function called run and again i pass a pointer to my heat then we so you might be concerned that my variable here image is actually a stack variable will remember we're not actually going to that particular variable we actually passing its value what is this value is a pointer is looking at the heap memory that we we allocated here ok so yes we are using a heap stack variable here but that's fine because actually what gets passed is the address of of heap memory of the mileage memory ok so anyway back to this we're going to create all of those threads we remember the thread i ds then we're going to call p fed exit on our main thread in other words we will never get to this line here so	memory	869
and now i want to represent that so with my ascii graphics i'm going to have a character i wanted to display in each one of those positions of my little terminal window so i've got height times width and i just want to initially to set all of those two a dot k so rather than might be in for loop let's use their more performant memset i want every bite to be this doc character so whatever ascii value that happens to be happens to be thirty three but no one needs to know that and will do that for the say half million characters or however many there are in my display probably eighty times twenty four for example right so time to get started right so here's here's the plan then right i need the thread runner that's going to sign my thread that's going to run the display and that's going to run the function called display and as an argument will pass that heap memory and then i've got all of my runners which actually cause the rain on my display so they're going to run a little function called run and again i pass a pointer to my heat then we so you might be concerned that my variable here image is actually a stack variable will remember we're not actually going to that particular variable we actually passing its value what is this value is a pointer is looking at the heap memory that we we allocated here ok so yes we are using a heap stack variable here but that's fine because actually what gets passed is the address of of heap memory of the mileage memory ok so anyway back to this we're going to create all of those threads we remember the thread i ds then we're going to call p fed exit on our main thread in other words we will never get to this line here so	the heap	1281
and now i want to represent that so with my ascii graphics i'm going to have a character i wanted to display in each one of those positions of my little terminal window so i've got height times width and i just want to initially to set all of those two a dot k so rather than might be in for loop let's use their more performant memset i want every bite to be this doc character so whatever ascii value that happens to be happens to be thirty three but no one needs to know that and will do that for the say half million characters or however many there are in my display probably eighty times twenty four for example right so time to get started right so here's here's the plan then right i need the thread runner that's going to sign my thread that's going to run the display and that's going to run the function called display and as an argument will pass that heap memory and then i've got all of my runners which actually cause the rain on my display so they're going to run a little function called run and again i pass a pointer to my heat then we so you might be concerned that my variable here image is actually a stack variable will remember we're not actually going to that particular variable we actually passing its value what is this value is a pointer is looking at the heap memory that we we allocated here ok so yes we are using a heap stack variable here but that's fine because actually what gets passed is the address of of heap memory of the mileage memory ok so anyway back to this we're going to create all of those threads we remember the thread i ds then we're going to call p fed exit on our main thread in other words we will never get to this line here so	thread	701
and now i want to represent that so with my ascii graphics i'm going to have a character i wanted to display in each one of those positions of my little terminal window so i've got height times width and i just want to initially to set all of those two a dot k so rather than might be in for loop let's use their more performant memset i want every bite to be this doc character so whatever ascii value that happens to be happens to be thirty three but no one needs to know that and will do that for the say half million characters or however many there are in my display probably eighty times twenty four for example right so time to get started right so here's here's the plan then right i need the thread runner that's going to sign my thread that's going to run the display and that's going to run the function called display and as an argument will pass that heap memory and then i've got all of my runners which actually cause the rain on my display so they're going to run a little function called run and again i pass a pointer to my heat then we so you might be concerned that my variable here image is actually a stack variable will remember we're not actually going to that particular variable we actually passing its value what is this value is a pointer is looking at the heap memory that we we allocated here ok so yes we are using a heap stack variable here but that's fine because actually what gets passed is the address of of heap memory of the mileage memory ok so anyway back to this we're going to create all of those threads we remember the thread i ds then we're going to call p fed exit on our main thread in other words we will never get to this line here so	address	1430
and now i want to represent that so with my ascii graphics i'm going to have a character i wanted to display in each one of those positions of my little terminal window so i've got height times width and i just want to initially to set all of those two a dot k so rather than might be in for loop let's use their more performant memset i want every bite to be this doc character so whatever ascii value that happens to be happens to be thirty three but no one needs to know that and will do that for the say half million characters or however many there are in my display probably eighty times twenty four for example right so time to get started right so here's here's the plan then right i need the thread runner that's going to sign my thread that's going to run the display and that's going to run the function called display and as an argument will pass that heap memory and then i've got all of my runners which actually cause the rain on my display so they're going to run a little function called run and again i pass a pointer to my heat then we so you might be concerned that my variable here image is actually a stack variable will remember we're not actually going to that particular variable we actually passing its value what is this value is a pointer is looking at the heap memory that we we allocated here ok so yes we are using a heap stack variable here but that's fine because actually what gets passed is the address of of heap memory of the mileage memory ok so anyway back to this we're going to create all of those threads we remember the thread i ds then we're going to call p fed exit on our main thread in other words we will never get to this line here so	pointer	1028
will never be returning forty two at this point ok so that's all our main thread what about other threads is going to look at that ok with that instead i want to scroll over him	thread	74
i just want to print print out everything and for that i'm going to use right today remember how it works is you simply say here's a memory address start sending the following bytes and as we're sending this to a terminal we're going to see that as ascii values so i've just got a very simple a piece of code here that goes through this prints out a width number of bytes and a little bit of calculation here to workout where in that heap i should start from at the end of that do a new lines have gone to the next one and then i need some control characters so this oh thirty three is actually the value twenty seven	the following	162
i just want to print print out everything and for that i'm going to use right today remember how it works is you simply say here's a memory address start sending the following bytes and as we're sending this to a terminal we're going to see that as ascii values so i've just got a very simple a piece of code here that goes through this prints out a width number of bytes and a little bit of calculation here to workout where in that heap i should start from at the end of that do a new lines have gone to the next one and then i need some control characters so this oh thirty three is actually the value twenty seven	memory	133
i just want to print print out everything and for that i'm going to use right today remember how it works is you simply say here's a memory address start sending the following bytes and as we're sending this to a terminal we're going to see that as ascii values so i've just got a very simple a piece of code here that goes through this prints out a width number of bytes and a little bit of calculation here to workout where in that heap i should start from at the end of that do a new lines have gone to the next one and then i need some control characters so this oh thirty three is actually the value twenty seven	a terminal	211
i just want to print print out everything and for that i'm going to use right today remember how it works is you simply say here's a memory address start sending the following bytes and as we're sending this to a terminal we're going to see that as ascii values so i've just got a very simple a piece of code here that goes through this prints out a width number of bytes and a little bit of calculation here to workout where in that heap i should start from at the end of that do a new lines have gone to the next one and then i need some control characters so this oh thirty three is actually the value twenty seven	code	304
i just want to print print out everything and for that i'm going to use right today remember how it works is you simply say here's a memory address start sending the following bytes and as we're sending this to a terminal we're going to see that as ascii values so i've just got a very simple a piece of code here that goes through this prints out a width number of bytes and a little bit of calculation here to workout where in that heap i should start from at the end of that do a new lines have gone to the next one and then i need some control characters so this oh thirty three is actually the value twenty seven	address	140
to go back back up so that in a certain amount of time will go round this loop again and we want to rewrite the whole display starting from the top so i'm asking for ten millisecond delay and then around we go again so that's my display loop as you can see it doesn't actually do any calculation it simply takes what's in my heap memory and displays it and send it out to spell it out his stand up my file descriptor one	heap memory	325
to go back back up so that in a certain amount of time will go round this loop again and we want to rewrite the whole display starting from the top so i'm asking for ten millisecond delay and then around we go again so that's my display loop as you can see it doesn't actually do any calculation it simply takes what's in my heap memory and displays it and send it out to spell it out his stand up my file descriptor one	memory	330
ok right and then what about my my rain effect while here's here's my loop i'm going to run remember this little piece of code ten times ten different cpus or at least a cpu pretending to be ten cpus will run this independently each one gets its own stack so each one has image pointer each one gets its own	code	122
ok right and then what about my my rain effect while here's here's my loop i'm going to run remember this little piece of code ten times ten different cpus or at least a cpu pretending to be ten cpus will run this independently each one gets its own stack so each one has image pointer each one gets its own	pointer	278
memory to hold its own value of x which is going to be just some random number so we're basically choosing a random column and then we change change a particular particular spot so in this version of the code i'm going to flip some bits so this is x or and i'm flipping some bits here	memory	0
memory to hold its own value of x which is going to be just some random number so we're basically choosing a random column and then we change change a particular particular spot so in this version of the code i'm going to flip some bits so this is x or and i'm flipping some bits here	code	204
running in parallel ok so that's the code let's actually have it running it so i think i've called it matrix	code	37
will just check that the azure code that i'm going to run looks similar to that yeah i'm flipping some bits	code	31
and we'll try different version of that in a moment ok and here is my magic code to get the width and the height you see i'm taking pointers to it to integers	code	76
and we'll try different version of that in a moment ok and here is my magic code to get the width and the height you see i'm taking pointers to it to integers	pointer	132
and then i update i right into those locations ok so back in my main method where are we we can say get terminal width and will pass in the address of two integers the last thing to do is change the colour so there are control codes we consent to change the background color in the foreground color in the terminal ok so great let's run this right	code	227
and then i update i right into those locations ok so back in my main method where are we we can say get terminal width and will pass in the address of two integers the last thing to do is change the colour so there are control codes we consent to change the background color in the foreground color in the terminal ok so great let's run this right	background	258
and then i update i right into those locations ok so back in my main method where are we we can say get terminal width and will pass in the address of two integers the last thing to do is change the colour so there are control codes we consent to change the background color in the foreground color in the terminal ok so great let's run this right	address	140
and you see ok we've got our initial version of the matrix it doesn't look quite as cool we've got a few ways to go before we can win oscar yet but hey it's a start so let's let's improve this and when i hit control c i'm still in green by hit clear i'm still in green but if you type reset that sends a whole order control	type	280
control codes so my terminal is back to black and white so let's just improve this a little bit i don't want just flipping bits like this let me choose a character as well so i could say choose choose to set set it equal to some character which is randomly chosen form from this set of sequence here cs two forty one box so i'm choosing a random number modulo the length of the message using that to pull out one character and then i'm going right into my image i could also make those letters going appear to drum tumbled down bye bye clearing out the last one so i could do something like this like y minus one equals nothing say the dot again alright what do you think about that ok so once care report here is what would happen if y was actually	code	8
a zero oh now we've calculated negative address so we're going to write into some arbitrary piece into the heap maybe not such a good idea let's instead	the heap	103
a zero oh now we've calculated negative address so we're going to write into some arbitrary piece into the heap maybe not such a good idea let's instead	address	40
in c code and that is now a very common source of noise for graphical effects so you look it up perlin noise or like i said it's the only a piece of code and it's in c to win an oscar alright so there we go that's our first piece of graphical code using a whole bunch of threads to run and feel free to play with this and turn it into something that looks more like a matrix like the matrix movie i hear that the original coding of the matrix effect actually was based on characters scanned out of a chinese cookbook but that's why don't you kind of invent your own character set and see how far you can make it really an interesting result ok and with that i will see you in the next set up by	code	5
in c code and that is now a very common source of noise for graphical effects so you look it up perlin noise or like i said it's the only a piece of code and it's in c to win an oscar alright so there we go that's our first piece of graphical code using a whole bunch of threads to run and feel free to play with this and turn it into something that looks more like a matrix like the matrix movie i hear that the original coding of the matrix effect actually was based on characters scanned out of a chinese cookbook but that's why don't you kind of invent your own character set and see how far you can make it really an interesting result ok and with that i will see you in the next set up by	thread	271
there we go right so we use four quotes do you know that it creates a second process it clones the existing one so other variable shared and no that though we use the parent as our template we now have two independent processes my pointer variables they address locations they only make sense inside a particular process i just want to imagine for a moment that say you're running gcc i'm running gcc	address	254
there we go right so we use four quotes do you know that it creates a second process it clones the existing one so other variable shared and no that though we use the parent as our template we now have two independent processes my pointer variables they address locations they only make sense inside a particular process i just want to imagine for a moment that say you're running gcc i'm running gcc	pointer	231
inside those processes there was lots of pointers going on going about whether it's c code or c plus plus code those menu locations are actually scoped by virtual memory by that particular process so your	memory	163
inside those processes there was lots of pointers going on going about whether it's c code or c plus plus code those menu locations are actually scoped by virtual memory by that particular process so your	code	86
inside those processes there was lots of pointers going on going about whether it's c code or c plus plus code those menu locations are actually scoped by virtual memory by that particular process so your	pointer	41
idea of what's the address ten thousand is completely different and independent of what i think is address ten thousand so there's a very kind of important idea right so	address	19
we usually exact does not return usually with exact we provide a program on disk to load and that's the moment we give our poor little process ahead temp head transplant we've completely thrown away all of the heap memory order the stack no need to do free or all that memory has disappeared to be replaced by a brand new program it's the same process and will have the same process id and the same number of open files but now it's running a completely different program that is going to start from maine so hopefully you can now see that a very very common pattern is to call fork and then inside the child process we want to do something else we don't keep executing the same code so the child process will call exec meanwhile the parent process wants to wait for the child to finish	heap memory	210
we usually exact does not return usually with exact we provide a program on disk to load and that's the moment we give our poor little process ahead temp head transplant we've completely thrown away all of the heap memory order the stack no need to do free or all that memory has disappeared to be replaced by a brand new program it's the same process and will have the same process id and the same number of open files but now it's running a completely different program that is going to start from maine so hopefully you can now see that a very very common pattern is to call fork and then inside the child process we want to do something else we don't keep executing the same code so the child process will call exec meanwhile the parent process wants to wait for the child to finish	memory	215
we usually exact does not return usually with exact we provide a program on disk to load and that's the moment we give our poor little process ahead temp head transplant we've completely thrown away all of the heap memory order the stack no need to do free or all that memory has disappeared to be replaced by a brand new program it's the same process and will have the same process id and the same number of open files but now it's running a completely different program that is going to start from maine so hopefully you can now see that a very very common pattern is to call fork and then inside the child process we want to do something else we don't keep executing the same code so the child process will call exec meanwhile the parent process wants to wait for the child to finish	the heap	206
we usually exact does not return usually with exact we provide a program on disk to load and that's the moment we give our poor little process ahead temp head transplant we've completely thrown away all of the heap memory order the stack no need to do free or all that memory has disappeared to be replaced by a brand new program it's the same process and will have the same process id and the same number of open files but now it's running a completely different program that is going to start from maine so hopefully you can now see that a very very common pattern is to call fork and then inside the child process we want to do something else we don't keep executing the same code so the child process will call exec meanwhile the parent process wants to wait for the child to finish	code	679
right so let's just review again in now code as to how we would use are going to wait pid so if we go to the manual you'll look at these definitions again and i'm going to call wait pid and pass in the address of my little integer here and for options i don't need any options today there are options which you might find useful in the future for example wnohang to say hey wait pid if my	code	40
right so let's just review again in now code as to how we would use are going to wait pid so if we go to the manual you'll look at these definitions again and i'm going to call wait pid and pass in the address of my little integer here and for options i don't need any options today there are options which you might find useful in the future for example wnohang to say hey wait pid if my	address	202
child hasn't actually finished don't just block instead immediately return and i can detect whether weight pid successfully waited for childhood finished or there was no child get finished by checking the return value of wait pid and here those macros that we saw last time we explored and we actually saw their implementation now let's think about the more abstractly to say that these macros just extract bit based information out of our integer but there's there was rules that we need to be aware of first of all we can only actually check the exit stat status those eight bits of the exit status provided we first check this other macro provided the first thing that w if exited is non zero and similar we can only actually of pull out which signal terminated our process if we first check if signaled is true and in practice only one of these could be true it doesn't make sense to say my program exited normally and it signaled as well there are a couple of other reasons why wait pid might return for example you can actually pause an ongoing process or restart it and wait pid will tell us about those events as well so these aren't	block	42
hi so you've probably seen things like printf where the first	printf	39
the first thing we passed the printf is a format string and so we can do things like percent s or percent d to talk about hey the parameter is going to give you next are going to be a string so here's a pointer and that pointer that i give you i want you to start reading those out as a sequence of bytes or here's a value i want to treat that value and put it out as an integer so forty two for example right and those will appear on the shell or to standard out there other versions of printf which maybe will be useful to you i'll just mention them we're going to do it today but there's asprintf and sprintf which allow you to print the result into memory somewhere and then there's fprintf which allows you to send the result out to a file or some kind of file so it could actually be standard out so if tomorrow i said hey no more fprint for anybody you could immediately turn around and use fprintf instead	memory	653
the first thing we passed the printf is a format string and so we can do things like percent s or percent d to talk about hey the parameter is going to give you next are going to be a string so here's a pointer and that pointer that i give you i want you to start reading those out as a sequence of bytes or here's a value i want to treat that value and put it out as an integer so forty two for example right and those will appear on the shell or to standard out there other versions of printf which maybe will be useful to you i'll just mention them we're going to do it today but there's asprintf and sprintf which allow you to print the result into memory somewhere and then there's fprintf which allows you to send the result out to a file or some kind of file so it could actually be standard out so if tomorrow i said hey no more fprint for anybody you could immediately turn around and use fprintf instead	parameter	130
the first thing we passed the printf is a format string and so we can do things like percent s or percent d to talk about hey the parameter is going to give you next are going to be a string so here's a pointer and that pointer that i give you i want you to start reading those out as a sequence of bytes or here's a value i want to treat that value and put it out as an integer so forty two for example right and those will appear on the shell or to standard out there other versions of printf which maybe will be useful to you i'll just mention them we're going to do it today but there's asprintf and sprintf which allow you to print the result into memory somewhere and then there's fprintf which allows you to send the result out to a file or some kind of file so it could actually be standard out so if tomorrow i said hey no more fprint for anybody you could immediately turn around and use fprintf instead	printf	30
the first thing we passed the printf is a format string and so we can do things like percent s or percent d to talk about hey the parameter is going to give you next are going to be a string so here's a pointer and that pointer that i give you i want you to start reading those out as a sequence of bytes or here's a value i want to treat that value and put it out as an integer so forty two for example right and those will appear on the shell or to standard out there other versions of printf which maybe will be useful to you i'll just mention them we're going to do it today but there's asprintf and sprintf which allow you to print the result into memory somewhere and then there's fprintf which allows you to send the result out to a file or some kind of file so it could actually be standard out so if tomorrow i said hey no more fprint for anybody you could immediately turn around and use fprintf instead	string	49
the first thing we passed the printf is a format string and so we can do things like percent s or percent d to talk about hey the parameter is going to give you next are going to be a string so here's a pointer and that pointer that i give you i want you to start reading those out as a sequence of bytes or here's a value i want to treat that value and put it out as an integer so forty two for example right and those will appear on the shell or to standard out there other versions of printf which maybe will be useful to you i'll just mention them we're going to do it today but there's asprintf and sprintf which allow you to print the result into memory somewhere and then there's fprintf which allows you to send the result out to a file or some kind of file so it could actually be standard out so if tomorrow i said hey no more fprint for anybody you could immediately turn around and use fprintf instead	pointer	203
ok so some standard scheduling algorithms so here's the plan is that i could imagine a little kind of fairground ride here so here's my kind of little fairground ride maybe it's a rollercoaster maybe it's a big wheel ok but that's where our threads and processes are happiest when actually on the cpu using the cpu but leading up to it i've got a ready queue ok so here's the kind of long the long line of processes or threads that would actually like to use this i'm going to start this reducing it to talking about processes but i'm sure you can see how we can generalize this to threads for multithreaded programs as well ok so for my cpu right now i've got to say process five has arrived is ready to run and we've given at the cpu or any other processes which want to use this cpu are in this long	thread	241
this long queue here ok so our first idea about scheduling is how about a first come first serve queso p five arrive first and then i've also got processed six process seven process eight etc right so i've got a whole line here right is that fair well like i've been trying to say before is that there is no simple definition of fairness it depends upon your objectives and whether it's a batch interactive or real time system so what do we think about this kind of first come first serve idea ok so it is fair in the sense that the earliest jobs will get access to the cpu and then once process five becomes blocked or finished then we can everybody can move forward so yes eventually all processes will get to play on our fairground route better get to be on the cpu who right so another name for first come first served	block	609
this long queue here ok so our first idea about scheduling is how about a first come first serve queso p five arrive first and then i've also got processed six process seven process eight etc right so i've got a whole line here right is that fair well like i've been trying to say before is that there is no simple definition of fairness it depends upon your objectives and whether it's a batch interactive or real time system so what do we think about this kind of first come first serve idea ok so it is fair in the sense that the earliest jobs will get access to the cpu and then once process five becomes blocked or finished then we can everybody can move forward so yes eventually all processes will get to play on our fairground route better get to be on the cpu who right so another name for first come first served	system	420
ok right so that's our first simple idea very very easy to implement you just need to write a simple queue data structure and will just pop the next process off here and run that next on the cpu	a struct	110
meaning that we could actually going to analyze and workout ourselves exactly how long it takes a job to run or we perhaps would run the same jobs yesterday so we actually have an empirical result based on how long we expect these jobs to run but we could actually kind of prioritize our jobs based on how much cpu time they need and this by the way is the total cpu time they need and in fact on a real system we talk about the idea of the burst time so let me go back to my very first discussion about hey on real process is they may not actually need one hundred seconds of cpu time in total because after one second of cpu time they're ready to do some	system	404
a real sjf system	system	11
they they have a smaller burst time and process five will go back into our q presumably process five still has the shortest burst time of all the other remaining process is so it will be next ok so that's preemption where you can walk up to a table and say get out of that chair i'm sitting there you can be rude with presumption you can stop a process while sits in on the cpu so that's the big idea preemption that we can stop a process that's currently assigned to cpu because we've decided to cpu is going to date someone else and sorry that process does not have a choice about it ok so preemption is rude and it's it's a bit of a bully if you like but the idea is that we always want to give priority to the to the in this case the job which has the shortest best time right so here's another one which is kind of very famous horror i rewrite this dance for round robin	a process	343
this is not about singing a hundred versus of a country and western song because it's more fun than singing just fifty round robin is the idea that we want to give the cpu to a process just for a limited amount of time	a process	175
so this is great for interactive systems so what will do here is on our	system	33
my little hardware clock makes a little electrical signal to the cpu and we run a tiny piece of code inside the kernel which is part of the scheduler to say hey times up for your current process right so pre five i know you wanted more time but i'm going to interrupt you i know you're deep inside that for loop right now	code	96
so the amount of time that we allow a process to have	a process	36
here it is and you could think about the extremes here suppose we said that our clock is going to go off every ten nanoseconds right what do you think about that ok so the problem about doing it was such a short period is that of cpus today do have order one instruction per nanosecond so our poor little cpus are poor little process is barely get anything done and in fact now the overhead of switching out from one process to another makes our system very sluggish our performance has dropped a significant amount now the we barely have enough time to switch out one process and put a new process in the percentage of time that we're spending inside the kernel scheduler code is now a lot more than say just a percent or two so we've paid for this two daily so let's go to the other extreme let's imagine that we said well i see what will swap out process after ten minutes	code	673
here it is and you could think about the extremes here suppose we said that our clock is going to go off every ten nanoseconds right what do you think about that ok so the problem about doing it was such a short period is that of cpus today do have order one instruction per nanosecond so our poor little cpus are poor little process is barely get anything done and in fact now the overhead of switching out from one process to another makes our system very sluggish our performance has dropped a significant amount now the we barely have enough time to switch out one process and put a new process in the percentage of time that we're spending inside the kernel scheduler code is now a lot more than say just a percent or two so we've paid for this two daily so let's go to the other extreme let's imagine that we said well i see what will swap out process after ten minutes	system	446
ok so now we very rarely swap out process is so the overhead of running the kernel scheduler code is minimal but this is not so hot for interactive systems now the time is going to take before process ten gets any cpu time might be upwards of an hour more that's a long time to wait for a key pressed on in fact with such a long time say ten minutes most processes won't even use up that full ten minutes maybe they'll get stuck in an io events or they'll	code	93
ok so now we very rarely swap out process is so the overhead of running the kernel scheduler code is minimal but this is not so hot for interactive systems now the time is going to take before process ten gets any cpu time might be upwards of an hour more that's a long time to wait for a key pressed on in fact with such a long time say ten minutes most processes won't even use up that full ten minutes maybe they'll get stuck in an io events or they'll	system	148
older systems had ten milliseconds today however most linux systems use a shorter time quantum of about a millisecond because there may be multiple active jobs inside here and	system	6
and so if we have a short quanta then then if we're swapping out multiple processes in here then hopefully we'll get each process will get a cpu time within the reaction time of what humans need to feel like system is interactive	system	208
another quick comment on this is that if you're working with audio then one millisecond ten milliseconds may not be enough you can actually easily detect for example the difference in timing between an audio signal arriving in one here and another so you may not be satisfied with a round robin approach if you have near real time needs of processing audio so with audio you would actually might consider kind of other higher priority system scheduling is dead right so there's kind of the basic theory and operating system courses can develop formulas and talk about these kind of example models in detail in today's real lennox world we don't actually use any of these simple models instead the lennox uses something called the cfs there completely fair scheduler ok why because it's completely fair ok so will just mention this briefly	system	435
to some process is so for example let's say that you resize the window that might take up a lot of cpu time in order to do all of their kind of layout and updating the data structures etc but we'd like that to be as interactive as possible so will give you an extra piece of cpu time if you haven't been monopolizing the cpu in the recent past so let's keep track of whether you used up the full time quanta in yoga last time you used a cpu and if you didn't then we are going to generously give you a portion of that this time around ok so on average you will get just a regular time content let's say your average one millisecond but you get a kind of a bursty access to that if you didn't need much in the past on the other hand if you were just continually using the cpu or that i'm right up to your quanta of one millisecond that i'm only going to allow you to have one milisecond again in the future so that's kind of completely fair schedule you can read a bit more about it on the course book but we try to make systems behave better for interactive users	the data structure	164
to some process is so for example let's say that you resize the window that might take up a lot of cpu time in order to do all of their kind of layout and updating the data structures etc but we'd like that to be as interactive as possible so will give you an extra piece of cpu time if you haven't been monopolizing the cpu in the recent past so let's keep track of whether you used up the full time quanta in yoga last time you used a cpu and if you didn't then we are going to generously give you a portion of that this time around ok so on average you will get just a regular time content let's say your average one millisecond but you get a kind of a bursty access to that if you didn't need much in the past on the other hand if you were just continually using the cpu or that i'm right up to your quanta of one millisecond that i'm only going to allow you to have one milisecond again in the future so that's kind of completely fair schedule you can read a bit more about it on the course book but we try to make systems behave better for interactive users	a struct	171
to some process is so for example let's say that you resize the window that might take up a lot of cpu time in order to do all of their kind of layout and updating the data structures etc but we'd like that to be as interactive as possible so will give you an extra piece of cpu time if you haven't been monopolizing the cpu in the recent past so let's keep track of whether you used up the full time quanta in yoga last time you used a cpu and if you didn't then we are going to generously give you a portion of that this time around ok so on average you will get just a regular time content let's say your average one millisecond but you get a kind of a bursty access to that if you didn't need much in the past on the other hand if you were just continually using the cpu or that i'm right up to your quanta of one millisecond that i'm only going to allow you to have one milisecond again in the future so that's kind of completely fair schedule you can read a bit more about it on the course book but we try to make systems behave better for interactive users	system	1020
ok so we've kind of talked a little bit about this idea before so it could i implement p thread mutex lock just by disabling interrupts on on the cpu so the idea here is that if my code is running on the cpu if i disable interrupts then i cannot be stopped become agent smith out of the matrix that now i own the cpu so no one else can can take it for me so one of the limitations of this first of all that yes we can ensure that we're the only ones going into the critical section if one there is only one cpu	code	181
ok so we've kind of talked a little bit about this idea before so it could i implement p thread mutex lock just by disabling interrupts on on the cpu so the idea here is that if my code is running on the cpu if i disable interrupts then i cannot be stopped become agent smith out of the matrix that now i own the cpu so no one else can can take it for me so one of the limitations of this first of all that yes we can ensure that we're the only ones going into the critical section if one there is only one cpu	section	474
ok so we've kind of talked a little bit about this idea before so it could i implement p thread mutex lock just by disabling interrupts on on the cpu so the idea here is that if my code is running on the cpu if i disable interrupts then i cannot be stopped become agent smith out of the matrix that now i own the cpu so no one else can can take it for me so one of the limitations of this first of all that yes we can ensure that we're the only ones going into the critical section if one there is only one cpu	thread	89
ok so if i control the one and only cpu and i cannot be interrupted then i get to do everything inside the critical section until i give up the cpu ok so providing i don't make any system calls providing i'm just updating my data structure no one can stop me because i disabled into apps	a struct	228
ok so if i control the one and only cpu and i cannot be interrupted then i get to do everything inside the critical section until i give up the cpu ok so providing i don't make any system calls providing i'm just updating my data structure no one can stop me because i disabled into apps	section	116
ok so if i control the one and only cpu and i cannot be interrupted then i get to do everything inside the critical section until i give up the cpu ok so providing i don't make any system calls providing i'm just updating my data structure no one can stop me because i disabled into apps	system	181
ok the second is that i require an here's a big problem here is that actually require sufficient privileges to disable the interrupts and because this is such a powerful operation by default that is disabled for normal user programs we need interrupts in order to make a cpu stop running one thread and start running another in order to handle hardware interrupt you too do to devices iot devices being ready to either take data from the system or give data from the system for example the network card might report that her new packages arrived and here's some data or a disk or solid state disk might report hey i've now finally got the data you can now read this into memory or gpu might ask for more memory more data so there's lots	memory	671
ok the second is that i require an here's a big problem here is that actually require sufficient privileges to disable the interrupts and because this is such a powerful operation by default that is disabled for normal user programs we need interrupts in order to make a cpu stop running one thread and start running another in order to handle hardware interrupt you too do to devices iot devices being ready to either take data from the system or give data from the system for example the network card might report that her new packages arrived and here's some data or a disk or solid state disk might report hey i've now finally got the data you can now read this into memory or gpu might ask for more memory more data so there's lots	thread	292
ok the second is that i require an here's a big problem here is that actually require sufficient privileges to disable the interrupts and because this is such a powerful operation by default that is disabled for normal user programs we need interrupts in order to make a cpu stop running one thread and start running another in order to handle hardware interrupt you too do to devices iot devices being ready to either take data from the system or give data from the system for example the network card might report that her new packages arrived and here's some data or a disk or solid state disk might report hey i've now finally got the data you can now read this into memory or gpu might ask for more memory more data so there's lots	system	438
of reasons why we in over a normal complex system we cannot just disable disable interrupts ok so this	system	43
is one solution to the critical section but like i said it's not a generally useful solution to the critical section we need to find a way to be able to kind of implement these correctly and will talk about some algorithmic concerns about that in the future instead now is what i've got a real challenge for you which is i want to implement a barrier in fact i'm going to give you all the code that you need here it is i just want to implement a barrier that will wait until five threads call this method called this function and i've got to keep track of how many there we go and all i'm going to give you is the following code which uses a counting semaphore so you get to choose how what you would like to implement what you'd like to to initialize is counting semaphore with and all you have to do is rearrange these lines enter the correct order so that's my challenge to you pause this video and see if you can work it out i'll give you the solution next video but before you do that make some brain new brain cell connections and actually think about how you're going to rearrange this code to the actually works by	the following	610
is one solution to the critical section but like i said it's not a generally useful solution to the critical section we need to find a way to be able to kind of implement these correctly and will talk about some algorithmic concerns about that in the future instead now is what i've got a real challenge for you which is i want to implement a barrier in fact i'm going to give you all the code that you need here it is i just want to implement a barrier that will wait until five threads call this method called this function and i've got to keep track of how many there we go and all i'm going to give you is the following code which uses a counting semaphore so you get to choose how what you would like to implement what you'd like to to initialize is counting semaphore with and all you have to do is rearrange these lines enter the correct order so that's my challenge to you pause this video and see if you can work it out i'll give you the solution next video but before you do that make some brain new brain cell connections and actually think about how you're going to rearrange this code to the actually works by	code	389
is one solution to the critical section but like i said it's not a generally useful solution to the critical section we need to find a way to be able to kind of implement these correctly and will talk about some algorithmic concerns about that in the future instead now is what i've got a real challenge for you which is i want to implement a barrier in fact i'm going to give you all the code that you need here it is i just want to implement a barrier that will wait until five threads call this method called this function and i've got to keep track of how many there we go and all i'm going to give you is the following code which uses a counting semaphore so you get to choose how what you would like to implement what you'd like to to initialize is counting semaphore with and all you have to do is rearrange these lines enter the correct order so that's my challenge to you pause this video and see if you can work it out i'll give you the solution next video but before you do that make some brain new brain cell connections and actually think about how you're going to rearrange this code to the actually works by	section	32
is one solution to the critical section but like i said it's not a generally useful solution to the critical section we need to find a way to be able to kind of implement these correctly and will talk about some algorithmic concerns about that in the future instead now is what i've got a real challenge for you which is i want to implement a barrier in fact i'm going to give you all the code that you need here it is i just want to implement a barrier that will wait until five threads call this method called this function and i've got to keep track of how many there we go and all i'm going to give you is the following code which uses a counting semaphore so you get to choose how what you would like to implement what you'd like to to initialize is counting semaphore with and all you have to do is rearrange these lines enter the correct order so that's my challenge to you pause this video and see if you can work it out i'll give you the solution next video but before you do that make some brain new brain cell connections and actually think about how you're going to rearrange this code to the actually works by	thread	480
hi so let's workout how we can use real path to actually test something about our directory structure and for example whether file is truly inside the directory that we care about alright so first of all let's have a quick play with it directly so here is real path and will see that we're going to pass in the following relative directory so that's relative to the current path of my program the current path associated with this process and we are not going to give it any memory to write the result into so real path internally is actually going to call malloc is going to get some heat memory for the result which is why at the very end we are going to free it so you'll notice i put a little bit of logic in here to see whether it	the following	307
hi so let's workout how we can use real path to actually test something about our directory structure and for example whether file is truly inside the directory that we care about alright so first of all let's have a quick play with it directly so here is real path and will see that we're going to pass in the following relative directory so that's relative to the current path of my program the current path associated with this process and we are not going to give it any memory to write the result into so real path internally is actually going to call malloc is going to get some heat memory for the result which is why at the very end we are going to free it so you'll notice i put a little bit of logic in here to see whether it	memory	475
i want to compile this ok so we had real path demo give it a second so we've gone missing skin we go all night to fix that ok right so what is it down it's given me a path which is the absolute path but as you can see it's dropped two directory as we've dropped slash code slash like twenty seven at the top which makes probably says because we went to the parent directory twice so what about this suppose we went into some subdirectory	code	268
ok run it again and this time it is no such path so real path is doing more than just simple string manipulation is actually testing to see whether each part that path element exists or not so in order for it to actually find that directory we actually have to go and make those places we have to make someone sub too so let's do that we can say make this one and then make do a sub one sub too if i wanted to do that in one go i could have actually said minus p and that would have made all	string	93
so now those exist so now when we run it it gives us a non null path it went into someone when it is up two and then i said ok now i need to find a parent now you find that so great is given me canonical paths let's start talking about how we can use this for something like a file server so which is part of a web server how can i make sure that i only serve content from my web directory i don't want to start this happily sending the contents of arbitrary files ok so for this i'm going to make use of two other things i'm going to use ass printf and also straw compare but not destroy compare but stewart end compare so we'll see how these are useful so remember that if you call sprint app and nothing is going to appear instead you give it some memory you say ok here's some memory on the heap that i've already met locked and please write the string into their so for example if i wanted to construct path like i might say ok look at percent air some centers and this might be say the the root of where i'm storing all my files and the request from the user of to what particular resource they want that's great but i better make sure that this string that construct is no bigger than the heap memory that i required perhaps i just want to be lazy and say hey predict can't you	heap memory	1196
so now those exist so now when we run it it gives us a non null path it went into someone when it is up two and then i said ok now i need to find a parent now you find that so great is given me canonical paths let's start talking about how we can use this for something like a file server so which is part of a web server how can i make sure that i only serve content from my web directory i don't want to start this happily sending the contents of arbitrary files ok so for this i'm going to make use of two other things i'm going to use ass printf and also straw compare but not destroy compare but stewart end compare so we'll see how these are useful so remember that if you call sprint app and nothing is going to appear instead you give it some memory you say ok here's some memory on the heap that i've already met locked and please write the string into their so for example if i wanted to construct path like i might say ok look at percent air some centers and this might be say the the root of where i'm storing all my files and the request from the user of to what particular resource they want that's great but i better make sure that this string that construct is no bigger than the heap memory that i required perhaps i just want to be lazy and say hey predict can't you	memory	751
so now those exist so now when we run it it gives us a non null path it went into someone when it is up two and then i said ok now i need to find a parent now you find that so great is given me canonical paths let's start talking about how we can use this for something like a file server so which is part of a web server how can i make sure that i only serve content from my web directory i don't want to start this happily sending the contents of arbitrary files ok so for this i'm going to make use of two other things i'm going to use ass printf and also straw compare but not destroy compare but stewart end compare so we'll see how these are useful so remember that if you call sprint app and nothing is going to appear instead you give it some memory you say ok here's some memory on the heap that i've already met locked and please write the string into their so for example if i wanted to construct path like i might say ok look at percent air some centers and this might be say the the root of where i'm storing all my files and the request from the user of to what particular resource they want that's great but i better make sure that this string that construct is no bigger than the heap memory that i required perhaps i just want to be lazy and say hey predict can't you	the heap	791
so now those exist so now when we run it it gives us a non null path it went into someone when it is up two and then i said ok now i need to find a parent now you find that so great is given me canonical paths let's start talking about how we can use this for something like a file server so which is part of a web server how can i make sure that i only serve content from my web directory i don't want to start this happily sending the contents of arbitrary files ok so for this i'm going to make use of two other things i'm going to use ass printf and also straw compare but not destroy compare but stewart end compare so we'll see how these are useful so remember that if you call sprint app and nothing is going to appear instead you give it some memory you say ok here's some memory on the heap that i've already met locked and please write the string into their so for example if i wanted to construct path like i might say ok look at percent air some centers and this might be say the the root of where i'm storing all my files and the request from the user of to what particular resource they want that's great but i better make sure that this string that construct is no bigger than the heap memory that i required perhaps i just want to be lazy and say hey predict can't you	printf	543
so now those exist so now when we run it it gives us a non null path it went into someone when it is up two and then i said ok now i need to find a parent now you find that so great is given me canonical paths let's start talking about how we can use this for something like a file server so which is part of a web server how can i make sure that i only serve content from my web directory i don't want to start this happily sending the contents of arbitrary files ok so for this i'm going to make use of two other things i'm going to use ass printf and also straw compare but not destroy compare but stewart end compare so we'll see how these are useful so remember that if you call sprint app and nothing is going to appear instead you give it some memory you say ok here's some memory on the heap that i've already met locked and please write the string into their so for example if i wanted to construct path like i might say ok look at percent air some centers and this might be say the the root of where i'm storing all my files and the request from the user of to what particular resource they want that's great but i better make sure that this string that construct is no bigger than the heap memory that i required perhaps i just want to be lazy and say hey predict can't you	string	850
just get some heap memory automatically for me and that is the purpose of a s printf which will automatically	heap memory	14
just get some heap memory automatically for me and that is the purpose of a s printf which will automatically	memory	19
just get some heap memory automatically for me and that is the purpose of a s printf which will automatically	printf	78
reserve some memory on the heap and return a pointer that ok so we just have to put in a sprint f keep going down here here it is you'll see that it takes up pointed with pointer so now with aspirin def we actually say ok here's the result my result variable and	memory	13
reserve some memory on the heap and return a pointer that ok so we just have to put in a sprint f keep going down here here it is you'll see that it takes up pointed with pointer so now with aspirin def we actually say ok here's the result my result variable and	the heap	23
reserve some memory on the heap and return a pointer that ok so we just have to put in a sprint f keep going down here here it is you'll see that it takes up pointed with pointer so now with aspirin def we actually say ok here's the result my result variable and	pointer	45
i want it once address because i'm going to change it so so i actually have a little built for example that and that's going to be changed and then later don't forget to free it as well so let's be good zero	address	15
so we could check to see if it really worked if we wanted to write really robust code ok so let's say where am i going to store my files let's say that all the files i want to serve our inside	code	81
and you notice that we've got two strings now on the heap ok so let's just make that cat right so i can touch files sub one sub to cat dot jpeg and touch does two things it creates a file if it doesn't exist obviously with zero bytes and also we've just going to change the modification time to just now so touch even if the file exists is modifying the metro information about when the i was last changed when it was last modified ok os let's give this a shot let's actually try this and see whether we get a valid path so let's clear this	the heap	49
and you notice that we've got two strings now on the heap ok so let's just make that cat right so i can touch files sub one sub to cat dot jpeg and touch does two things it creates a file if it doesn't exist obviously with zero bytes and also we've just going to change the modification time to just now so touch even if the file exists is modifying the metro information about when the i was last changed when it was last modified ok os let's give this a shot let's actually try this and see whether we get a valid path so let's clear this	string	34
everything that we are sending is a subdirectory of the following in other words the canonical path should always start with the following characters that i've highlighted if there was a malicious user requesting resources for example they might request dot dot slash dot dot slash dot dot slash dot dot slash	the following	52
everything that we are sending is a subdirectory of the following in other words the canonical path should always start with the following characters that i've highlighted if there was a malicious user requesting resources for example they might request dot dot slash dot dot slash dot dot slash dot dot slash	resources	213
two paths and now i just want to see if they are valid so for this i want to say ok let's compare the first end characters so let's have a look at the path of what you'd like versus the base path and we'll see if they start the same so those are the two strings i want to compare but i do want to compare all of the letters and you want to compare up to the length of the base path ok so if they're the same then great i now know that i'm looking inside that subdirectory	string	254
ok oh wait i need to include storing compare so i haven't included string late yet ok fine let's get stringed each	string	67
ok so let's talk start talking about how we can store items on a disk and in particular how we might actually represent the data what features we might want in our file system so we're going to start by just a bit of a brainstorming exercise by saying if money was no object if i can get you the best software engineers	system	169
what features would you like to add to your file system so let's not try to be too constrained by the limitations of the file system on your laptop or what you've seen in a linux virtual machine so far let's actually think about what we need ok so this is kind of real let's start with the white board and will start to write down some features ok so what would make a great file system right so let's come up with a few ideas and then all kind of see how well we did and compare it to some other kind of brainstorm exercises i've done in the past right so what would you like first well maybe you want some access control right so we want the idea that look many people are going to be using this file system and perhaps i want to make sure that some people can't read all of my files or perhaps i want to make sure that some files are only read only or perhaps i want to make sure that only a limited set of files should be executed so if you give me a a file i can't just easily turn that turn around and say ok bash run this or ok cpu load this as a program	system	49
so i want to define some sort of security about our my files maybe we want to write a file system create a file system that even tracks who is accessing the	system	91
files so maybe the sort of auditing and logging auditing and logging perhaps if i'm going to get my file system to the nsa i want to know which analysts have opened which files so perhaps i've got some kind of logging i want to keep track of the number of files have been created each week probably want to keep track of the latest files so there's some meta information that we want as well so we've got things like when was the last file access when was the file opened and who by how large is a file in terms of bytes or other information	system	105
it recorded so we might want to have more than just lump sum bytes if we care about multiple versions perhaps our system should innately support that so for example if you overwrite a file	system	114
perhaps your system's been compromised and it's trying to lock up all of your files in order for you to pay some bitcoin to get them unlocked it would be nice if my file system rather than just delete the old version actually kept a prior versions around so i could go back in time and pull out the previous version all version before that so maybe we want some versioning as well ok	system	13
now on a typical file system it's not unusual for the same piece of data to be found in multiple places there's certainly going to be true of course with versioning but you and i might have a same copy of a text file same copy of a c file so if i shared some music with you for example or video file and we're storing it on the same disk it seems a bit of a waste of space to actually store those bytes multiple times on the disk surface so perhaps we want our file system to support deduplication	system	22
ok so we like our file systems to be nice and fast	system	23
and of course we want to do this we use in the minimum over cpu time because i want to use my cpu for other things so what else might we need here right k so if i'm storing say text information that text could easily be compressed so maybe my file system should support compression as well so for some files for example suppose i'm storing all of the linux kernel	system	248
that's just a lot of c code and i could store that in a very much smaller space on my disk and if i can decompress it quickly i might even be able to load these files in and use on the fly decompression and actually get better performance from my file system so we want compression potential potentially for performance if i can decompose quickly but also of course i want to maximize the amount of things i can store on my file system	code	23
that's just a lot of c code and i could store that in a very much smaller space on my disk and if i can decompress it quickly i might even be able to load these files in and use on the fly decompression and actually get better performance from my file system so we want compression potential potentially for performance if i can decompose quickly but also of course i want to maximize the amount of things i can store on my file system	system	252
right what else ok so we could go through and keep talking about kind of more features like this but i want to remind you that so far we've been thinking very much like software engineers we've forgotten that real filesystems live on real devices and so	system	218
a big thing that we've missed out here i have not thought about is that we want our file system to be robust so perhaps there's going to be an error on the disk surface because the bit was never written correctly perhaps	system	89
stray cosmic rays modified one bit inside my ssd it would be unfortunate if my file system suddenly made all of my files unreadable just because one bit was flipped similarly if i dropped my hard disk my physical spinning hard disk i'd like to think there's a fair chance that haven't suddenly lost all of my files so there's robustness in terms of what damage and how likely is it that i'm unable to recover anything there's also	system	84
inefficient and quite timely it takes a long period of time if i want to scan through all of my files to see which ones have changed which ones have been created it would be great if my file system could actually tell me which files have been created or modified since the last backup so we need some features to support that how are we going to do that right i kind of want to mention that one fun thing about all these features is that they are not required of course with all applications but they also are difficult to implement together for example compression may or may not hurt performance deduplication requires ability to scan files and may take additional cpu time additional memory and so may actually actually affect negatively the performance of your whole system	memory	687
inefficient and quite timely it takes a long period of time if i want to scan through all of my files to see which ones have changed which ones have been created it would be great if my file system could actually tell me which files have been created or modified since the last backup so we need some features to support that how are we going to do that right i kind of want to mention that one fun thing about all these features is that they are not required of course with all applications but they also are difficult to implement together for example compression may or may not hurt performance deduplication requires ability to scan files and may take additional cpu time additional memory and so may actually actually affect negatively the performance of your whole system	system	191
ok it's it's writing it's kind of sympathetic with the kind of hardware constraints and features so for example if i'm waiting on a spinning disc there's actual physical constraints about how quickly that can spin how often a particular sector is actually readable if i'm writing to an ssd then portions of that electrical system can only be written a number of times before it starts to become likely that i won't be able to correctly read that bit again in the future so i wanted to make sure that how i represent my files on my disk and how i implement these features and how i talk to the hardware respects the kind of natural physical constraints and features of the hardware that is used underneath ok so we came up with a kind of a good list not bad for a quick brainstorming session let's have another look at another list i made see how close we got so what did we what did we miss so here's his another kind of incomplete	system	323
kind of dust on his disc surface but things like what happens if a prior write to my disk didn't complete maybe because there was a power losd how likely is it that i'm able to detect that or recover from that in some way or have i just lost the entire disk have i just lost all of my files or in the future what i read back a file and not even realize it's incorrect here's some other features we didn't think about is accounting and quota ideas so do i want to allow anyone user just completely fill up the storage system or do i want to be able to limit the number of files on the amount of disk space that they're writing to	system	517
we didn't talk about indexing and searching so if tomorrow i want to find all files by a particular artist or if i want to be able to kind of find the moment in a video file that the word camel was spoken then perhaps my file system should support that in interesting ways	system	226
ok right so that was a pretty good listen i hope you get to see why actually implementing a file system is hard and many file systems today are surprisingly old it's actually some of the oldest code you'll find inside the kernel why because writing code without bugs to satisfy all of these kind of design ideas and design goals is really really really hard and this is one area of the system where we do not want bugs we do not want our file system to suddenly start misbehaving when their disk becomes full for example we want all file system to work with all sorts of edge cases for example when a particular sector on a disk goes bad or if we want to start shuffling information around in our disk for better performance in the future these little use cases are all tricky and take a long time to kind of get right both in terms of correctness and performance are our expectations of this part of the of this part of the kernel working robustly again and again and again even if we're writing large numbers of bytes at ten to twelve or greater number of bytes is very very high so we tend to find that this code is extremely old and mature and extremely well tested	code	194
ok right so that was a pretty good listen i hope you get to see why actually implementing a file system is hard and many file systems today are surprisingly old it's actually some of the oldest code you'll find inside the kernel why because writing code without bugs to satisfy all of these kind of design ideas and design goals is really really really hard and this is one area of the system where we do not want bugs we do not want our file system to suddenly start misbehaving when their disk becomes full for example we want all file system to work with all sorts of edge cases for example when a particular sector on a disk goes bad or if we want to start shuffling information around in our disk for better performance in the future these little use cases are all tricky and take a long time to kind of get right both in terms of correctness and performance are our expectations of this part of the of this part of the kernel working robustly again and again and again even if we're writing large numbers of bytes at ten to twelve or greater number of bytes is very very high so we tend to find that this code is extremely old and mature and extremely well tested	system	97
ok so that's kind of a fun little game perhaps you'd like to think about your own features if tomorrow you decided to have a new startup to make a new file system we'll return to this little game in the future when we look at some newer file systems like zfs and also btrfs and what else we got ok so another nonlinux systems you'll find xfs as well where where these newer filesystems actually	system	156
support whole load of features of much more than a much more complex than our model file system that we're going to study inside this course	system	89
'cause we are going to turn our attention to model of ext2 which is sufficient for us to think about how we can represent different sized files on a file system and what constraints and limitations and performance impacts our choices have that's it for this video i'll see you in the next bye	system	154
ok so we didn't need a definition for deadlock and this idea that our our threads are frozen up maybe one thread is waiting for a mutex lock that is never going to be unlocked maybe we're waiting for something from a data structure which is never going to be given to us so here's a general definition for dead log key	a struct	220
ok so we didn't need a definition for deadlock and this idea that our our threads are frozen up maybe one thread is waiting for a mutex lock that is never going to be unlocked maybe we're waiting for something from a data structure which is never going to be given to us so here's a general definition for dead log key	a mutex	128
ok so we didn't need a definition for deadlock and this idea that our our threads are frozen up maybe one thread is waiting for a mutex lock that is never going to be unlocked maybe we're waiting for something from a data structure which is never going to be given to us so here's a general definition for dead log key	thread	74
well ok can i type so i put in some in there ok	type	14
make this thread exit it's never going to happen ok so our poor poor little fair door process is waiting some for an event maybe we're going to signal that event using a variable or some other method and it's just never going to happen so it doesn't get to complete it doesn't get to kind of run its activity or run the code and of course debugging deadlock is tricky it's often there as pairs that i could a thread maybe it's stuck inside p threat condition wait and we don't know why why that event doesn't hasn't hasn't fired hasn't occured	code	320
make this thread exit it's never going to happen ok so our poor poor little fair door process is waiting some for an event maybe we're going to signal that event using a variable or some other method and it's just never going to happen so it doesn't get to complete it doesn't get to kind of run its activity or run the code and of course debugging deadlock is tricky it's often there as pairs that i could a thread maybe it's stuck inside p threat condition wait and we don't know why why that event doesn't hasn't hasn't fired hasn't occured	a thread	407
make this thread exit it's never going to happen ok so our poor poor little fair door process is waiting some for an event maybe we're going to signal that event using a variable or some other method and it's just never going to happen so it doesn't get to complete it doesn't get to kind of run its activity or run the code and of course debugging deadlock is tricky it's often there as pairs that i could a thread maybe it's stuck inside p threat condition wait and we don't know why why that event doesn't hasn't hasn't fired hasn't occured	thread	10
ok so we've got this general definition of deadlock now actually let's see if we can kind of construct some examples where we actually cause it so let's use team mutex locks and two threads to create an example of deadlock ok bye i'm going to actually do this in a text editor ok	thread	182
let's go right do i have so if i've got thread one imagine my thread first red make the coda bigger right has called	thread	40
p thread mutex lock k and we're going to say please lock on this first mutex and then after you've done that please lock on this other mutex right so it will do some work ok do something and then after that we want to at least ok so we will call p thread unlock on both of these mutex is ok	thread	2
so for example maybe we want to take some data out of out of data store one stick it into data structure to ok it doesn't matter particular which order that we released them in just for symmetry i'm going to do it this way but let's let's think about what happens if we lock these in a different sequence inside another thread so i'm going to have now another thread that does the same sequence of operations accept ha we have swapped these around the case so we swap these two lights ok so is this a problem	a struct	93
so for example maybe we want to take some data out of out of data store one stick it into data structure to ok it doesn't matter particular which order that we released them in just for symmetry i'm going to do it this way but let's let's think about what happens if we lock these in a different sequence inside another thread so i'm going to have now another thread that does the same sequence of operations accept ha we have swapped these around the case so we swap these two lights ok so is this a problem	thread	320
like most of the time no most of the time my threads are perfectly happy doing what they need to do until the following happens until one unfortunate day thread one has called preferred mutex lock on get this choose a new color	the following	106
like most of the time no most of the time my threads are perfectly happy doing what they need to do until the following happens until one unfortunate day thread one has called preferred mutex lock on get this choose a new color	thread	45
called prefix lock on the first one case is completed that at the same time my other thread which is curiously called thread one so let's fix that thread	thread	85
so now they were both able to do this but what happens next ok i think we should choose a new color for this let's go for yes it's kinda extreme pinky purple thing let's try that ok right so now what happens thread one says i'd like to lock this mutex but of course what	thread	208
does this do it blocks ok why because another thread has that new texts between you and me we know it's thread two meanwhile thread two tries to look	block	16
does this do it blocks ok why because another thread has that new texts between you and me we know it's thread two meanwhile thread two tries to look	thread	46
it takes one and that of course blocks	block	32
it's not yet available another thread is currently quite that musics lock ok so when will we escape out of this and the answer is never ok we can read the code and see that eventually we're going to release these locks but we're never going to get to that that piece of code that thread one is waiting for thread two and thread two is waiting for thread one so it's kind of stuck for stuck forever	code	155
it's not yet available another thread is currently quite that musics lock ok so when will we escape out of this and the answer is never ok we can read the code and see that eventually we're going to release these locks but we're never going to get to that that piece of code that thread one is waiting for thread two and thread two is waiting for thread one so it's kind of stuck for stuck forever	thread	31
ok i am not occured because we constructed this with the locks being acquired in a different order if they were in the same order it would have been fine let's just kind of quickly sketch that out to see that let's imagine that i had my first thread doing mutex worn and then mute x two and then mutex wanna mutex two down here for thread two then if they both try to acquire mutex in at the same time then we can imagine that thread one would acquire the mutex lock here which would mean thread two will be forced to block	block	518
ok i am not occured because we constructed this with the locks being acquired in a different order if they were in the same order it would have been fine let's just kind of quickly sketch that out to see that let's imagine that i had my first thread doing mutex worn and then mute x two and then mutex wanna mutex two down here for thread two then if they both try to acquire mutex in at the same time then we can imagine that thread one would acquire the mutex lock here which would mean thread two will be forced to block	a mutex	306
ok i am not occured because we constructed this with the locks being acquired in a different order if they were in the same order it would have been fine let's just kind of quickly sketch that out to see that let's imagine that i had my first thread doing mutex worn and then mute x two and then mutex wanna mutex two down here for thread two then if they both try to acquire mutex in at the same time then we can imagine that thread one would acquire the mutex lock here which would mean thread two will be forced to block	thread	243
so it doesn't get to go to step two which means thread one can continue and then when it's finished it will release those locks so now thread two can finish so	thread	48
if we'd actually written our code like this in the same order it would have been impossible to get deadlock	code	29
ok so that was with a mutex lock now that's actually think about could we do something similar with counting semaphores sure ok so let's do something similar with counting semaphores where thread one calls say sam weights on counting center four as well	a mutex	20
ok so that was with a mutex lock now that's actually think about could we do something similar with counting semaphores sure ok so let's do something similar with counting semaphores where thread one calls say sam weights on counting center four as well	thread	189
i'll have another thread that does something similar or key	thread	18
and another thread does something similar ok so do we see any problems right now nope we could imagine that these counting semaphore 's my kind except for has been initialized just account of one ok so same initiate here go let's have one pizza slice in there	thread	12
there's no possibility of deadlock right now that for every same weight called we call assam post ok right so what if we could have made it a little bit more complicated though and we said that same weight here is going to in order to continue i'm going to wait on this thread and then i'm going to post on some samples to an meanwhile thread two i'm going to wait on counting semaphore two and then i'm going to post on counting semaphore three ok and then some weight three i'm going to then post inseminate one ok if all my counties are forced to started off with a value of zero you can see that no one gets to play that all of my threads have got stuck that my first thread is blocked here waiting for the value for sale wanted change well someone will change down here but unfortunately thread three is blocked waiting for the count for sam three is waiting for pizza slice and were able to get that piece of sliced form it is waiting for sam post to be called by thread two but thread two is not going to give it that pizza slice until it gets a piece of slice out of counting semaphores s two and where will i get that only from thread one when thread one finally called stem post but that's not going to happen because thread what is still waiting for the pizza slice from thread three so now you see we've got this love triangle here between our three threads they'll never going to continue that always waiting for an event that's never going to happen so that's all example of deadlock we can construct lots of these varying bits of complexity usually we don't artificial construct them like this usually were scratching go ahead go why did my system come to a grinding halt and the other thing i want you to notice is that	block	682
there's no possibility of deadlock right now that for every same weight called we call assam post ok right so what if we could have made it a little bit more complicated though and we said that same weight here is going to in order to continue i'm going to wait on this thread and then i'm going to post on some samples to an meanwhile thread two i'm going to wait on counting semaphore two and then i'm going to post on counting semaphore three ok and then some weight three i'm going to then post inseminate one ok if all my counties are forced to started off with a value of zero you can see that no one gets to play that all of my threads have got stuck that my first thread is blocked here waiting for the value for sale wanted change well someone will change down here but unfortunately thread three is blocked waiting for the count for sam three is waiting for pizza slice and were able to get that piece of sliced form it is waiting for sam post to be called by thread two but thread two is not going to give it that pizza slice until it gets a piece of slice out of counting semaphores s two and where will i get that only from thread one when thread one finally called stem post but that's not going to happen because thread what is still waiting for the pizza slice from thread three so now you see we've got this love triangle here between our three threads they'll never going to continue that always waiting for an event that's never going to happen so that's all example of deadlock we can construct lots of these varying bits of complexity usually we don't artificial construct them like this usually were scratching go ahead go why did my system come to a grinding halt and the other thing i want you to notice is that	thread	270
there's no possibility of deadlock right now that for every same weight called we call assam post ok right so what if we could have made it a little bit more complicated though and we said that same weight here is going to in order to continue i'm going to wait on this thread and then i'm going to post on some samples to an meanwhile thread two i'm going to wait on counting semaphore two and then i'm going to post on counting semaphore three ok and then some weight three i'm going to then post inseminate one ok if all my counties are forced to started off with a value of zero you can see that no one gets to play that all of my threads have got stuck that my first thread is blocked here waiting for the value for sale wanted change well someone will change down here but unfortunately thread three is blocked waiting for the count for sam three is waiting for pizza slice and were able to get that piece of sliced form it is waiting for sam post to be called by thread two but thread two is not going to give it that pizza slice until it gets a piece of slice out of counting semaphores s two and where will i get that only from thread one when thread one finally called stem post but that's not going to happen because thread what is still waiting for the pizza slice from thread three so now you see we've got this love triangle here between our three threads they'll never going to continue that always waiting for an event that's never going to happen so that's all example of deadlock we can construct lots of these varying bits of complexity usually we don't artificial construct them like this usually were scratching go ahead go why did my system come to a grinding halt and the other thing i want you to notice is that	system	1656
i might have a thread that say forgets to call sam post or for some other forget or some bug causes some event not to occur and then you get all of this fall out where other threads and other processes are unable to continue because they are also waiting for that for that thread or the other process so you'll see this occasionally on your phone or on your laptop where one little issue say with their gui process or gui thread now starts to have cascading problems and your deadlock starts to affect other systems as well because everything else grinds to a halt and there's multiple dependencies between all of our threads and processes ok so that's deadlock what what we'd like to be able to do is ensure	a thread	13
i might have a thread that say forgets to call sam post or for some other forget or some bug causes some event not to occur and then you get all of this fall out where other threads and other processes are unable to continue because they are also waiting for that for that thread or the other process so you'll see this occasionally on your phone or on your laptop where one little issue say with their gui process or gui thread now starts to have cascading problems and your deadlock starts to affect other systems as well because everything else grinds to a halt and there's multiple dependencies between all of our threads and processes ok so that's deadlock what what we'd like to be able to do is ensure	thread	15
i might have a thread that say forgets to call sam post or for some other forget or some bug causes some event not to occur and then you get all of this fall out where other threads and other processes are unable to continue because they are also waiting for that for that thread or the other process so you'll see this occasionally on your phone or on your laptop where one little issue say with their gui process or gui thread now starts to have cascading problems and your deadlock starts to affect other systems as well because everything else grinds to a halt and there's multiple dependencies between all of our threads and processes ok so that's deadlock what what we'd like to be able to do is ensure	system	508
close or far descriptions or we close all those places as well but the same is true for open file open files as well ok so when you call say f open underneath you know that actually is going to call open to give us a little file descriptor and that far to script is shared if we call fork so let's just draw a little model here that if i've got my parent process just here with file descriptor here it is safe i'll skip to number three that is actually of course referring to an actual object inside the kernel that we indirectly talk to the biotic either calling read or write seek right so if i then call fork to make a child process then the same number child process over here the same integer number here we go right refers to the same kernel objects so here's the wonderful colonel up here with its view on the world its view of all the peripherals view on what it needs to send out of the network code to the disk etc etc so i've got my idea of a file over here the kernel itself has buffers and also it will have a file position as well so for random access files	code	904
ok nothing happened but now we have a little file called data dot csv and there it is ok so we've got our god data being saved inside there right so now let's start to play with fc can all that good stuff so we've talked a little bit about ftl let's play without first so let's look at the position in the file currently ok so please turn my position of this current file let's print it out so print f right my position is ok right and we can we need a long so will will guess what that might be let's let's deliberately get it wrong see if their warnings will tell us right so here's my type k and will deliberately try to compile that	type	588
right so please put out the following long variable	the following	24
go flush ok then will close it now this last flush i just did i could type there we go is technically unnecessary because in closing the file handle we will flush anyway	type	70
"is a hint to the c library to say, ""hey, we know you like" to buffer everything. we know that you don't want to make system calls unnecessarily. but, no really, now it's time to actually tell the kernel that we want to change the position. so we change conceptually the position of where future read and writes will occur here, but by default the c library will kind of cache that internally	system	119
you will come across something called peter cancel great you say fantastic away from me to gracefully shut down my threads well yes and no my advice is don't use it unless you really understand what is doing there is often better ways to do it so p said cancel looks like it's going to say excuse me thread i want you to stop and yes that is true but there's no guarantee on how fast and when that's going to happen so you might have a p thread that you've assigned to do along calculation and even if you call peter cancel on that then the thread might continue to run deep inside some deeply nested for loops was do you say invert a massive matrix or mine your next bitcoin or something like that so there are better ways to do this and one common way to do this is to create a global variable for example	thread	115
and when you want your threats to finish then you just change this to one and you in your other threads you occasionally pull meaning you occasionally check the value of this variable and if it's been changed to a true value then you know it's time for your thread to exit at that point you can do your graceful things like freeing up resources and then exiting ok	thread	96
and when you want your threats to finish then you just change this to one and you in your other threads you occasionally pull meaning you occasionally check the value of this variable and if it's been changed to a true value then you know it's time for your thread to exit at that point you can do your graceful things like freeing up resources and then exiting ok	resources	335
this might be a global variable but you could also in more robust designs put it inside a struct and then passed out around as part of your information that you would pass to a thread that that is going so you could also have individual thread control as well	a struct	88
this might be a global variable but you could also in more robust designs put it inside a struct and then passed out around as part of your information that you would pass to a thread that that is going so you could also have individual thread control as well	a thread	175
this might be a global variable but you could also in more robust designs put it inside a struct and then passed out around as part of your information that you would pass to a thread that that is going so you could also have individual thread control as well	thread	177
ok sir wait the next thing is oh we talked about this yes we have differences between exit in p third exit ok so this stops the entire process and gives the processes at exit value pizza exit just stops this to one thread now is that thread happened to be the very last thread	thread	215
then the process will finish uh ok so that gives us a reason sometimes for calling p thread exit inside your main method is a way to be lazy let's let's go have a look at this so	thread	85
if i had a program that started many many threads are case so imagine	thread	42
started many many threads here i could write p thread join and wait for them all to finish i could put that inside a loop but an alternative is to say p thread exit are on the main thread right so now this return here will never happen	thread	18
will continue the process will continue until all of the other p three s have finished so that's going to lazy way of saying i just wanna start all these threads and i'm just done when the last one turns out the lights and shut the door ok so that's kind of a little trick that you'll see in kind of many smaller p thread programs right so of my next question to you is i've mentioned quite a few but can you think of four ways that a thread can be terminated right are you ready go	a thread	433
will continue the process will continue until all of the other p three s have finished so that's going to lazy way of saying i just wanna start all these threads and i'm just done when the last one turns out the lights and shut the door ok so that's kind of a little trick that you'll see in kind of many smaller p thread programs right so of my next question to you is i've mentioned quite a few but can you think of four ways that a thread can be terminated right are you ready go	thread	154
i've got my little mining idea here and eventually only threads of course to parallelize my my my coin searching here and maybe later i will take the same idea and run it on your gpu and maybe later after that i'll design some hardware that does the same operations so let's talk a little bit very quickly about kind of bit coins and related currencies so the idea is that we need a way to make it hard for people to find a coin of some kind and so for that will use a cryptographic hash and the last thing about cryptographic hashes is that you can start off with a message generate a hash for that	thread	56
take some kind of string here it is and i can pass into this nice lock function called shorter fifty six and say here's the number of bytes of my message and that's going to give me back a pointer to some memory	memory	205
take some kind of string here it is and i can pass into this nice lock function called shorter fifty six and say here's the number of bytes of my message and that's going to give me back a pointer to some memory	string	18
take some kind of string here it is and i can pass into this nice lock function called shorter fifty six and say here's the number of bytes of my message and that's going to give me back a pointer to some memory	pointer	189
and that memory represents the hash so all i'm going to do to declare whether it's one of my anger of coins	memory	9
so for this you can see that i got a big loop going to go from some start to ending value in my loop here it is or print that out as well using long 's and then so for each value of i i construct just a simple c string here it is i'm going to construct it not not by printing it out but i've got some memory here my little message so let me use aspirin f which is going to write the result into message and my message is going to be angry with coin and some long value printed out as a hexadecimal value	memory	301
so for this you can see that i got a big loop going to go from some start to ending value in my loop here it is or print that out as well using long 's and then so for each value of i i construct just a simple c string here it is i'm going to construct it not not by printing it out but i've got some memory here my little message so let me use aspirin f which is going to write the result into message and my message is going to be angry with coin and some long value printed out as a hexadecimal value	string	212
single threaded	thread	7
ok and if it goes so i called that search function where the start and end here and it's busy thinking about it ok it looks like it's going to take me along time to make any money from my coins in fact it even find any in that first rate there's my first coin alright so i can tell the world look this particular set of ascii characters if you put that into the shorter fifty six is a valid coin and look we can prove it look at this we're minting money now right oh wow ok so we have a bit coin right but it's not faster with this mining rate i think it's time that we brought some threads to the rescue so let's have a think about how we can make our program go a little bit faster alright so what do we got you'll notice that i was different search ranges here	thread	583
and so i could take these three lines and run them just with different different threads and pass in the start and end points as part of some information and i'm going to send to my p thread so let's have a look at that alright so here it is	thread	81
i i get to start now three threads are call my pizza at exit and it is ok and i'm going to pass in a void pointer to my array of starting and ending positions here so now when i call runner	thread	27
i i get to start now three threads are call my pizza at exit and it is ok and i'm going to pass in a void pointer to my array of starting and ending positions here so now when i call runner	pointer	106
on pc it create that's given by people there ok what is runner oh it's just a simple little wrapper around the original search function that we saw and we can pull out the pointer in the next one so the first thread will take these first two values the second thread will take the next two	thread	209
on pc it create that's given by people there ok what is runner oh it's just a simple little wrapper around the original search function that we saw and we can pull out the pointer in the next one so the first thread will take these first two values the second thread will take the next two	pointer	172
there we go the next thread will choose a different color there we go will take next to values	thread	21
off it goes you can see i got three threads now learning in parallel and it should find all those same coins	thread	36
is my code correct	code	6
so if we were reviewing this code we might have been	code	29
notice that the value here that we get back from sha two fifty six well where did that memory come from	memory	87
is it shared between potentially different threads of off this call because if it is then the hash value that i later check this point might have been generated by a call to shar two fifty six from a different threat so there is a very small but non zero window of opportunity between ours calculating the message and then later using that memory down here so there's a small chance today another thread in that time might change the contents of that hash let's see if we were lucky or unlucky ok so in this case today i didn't generate any bad coins and i befitting the reason for that is because my machine is actually really busy right now so if i do top order by cpu will see that actually i've got plenty of cp being used to actually record this lecture so compared to when i run this without recording it as less for chance of two cpus actually running 'cause another cpu is busy capturing the screen so unfortunately this demo didn't actually work we didn't see any bad coins let's just see if we can	memory	340
is it shared between potentially different threads of off this call because if it is then the hash value that i later check this point might have been generated by a call to shar two fifty six from a different threat so there is a very small but non zero window of opportunity between ours calculating the message and then later using that memory down here so there's a small chance today another thread in that time might change the contents of that hash let's see if we were lucky or unlucky ok so in this case today i didn't generate any bad coins and i befitting the reason for that is because my machine is actually really busy right now so if i do top order by cpu will see that actually i've got plenty of cp being used to actually record this lecture so compared to when i run this without recording it as less for chance of two cpus actually running 'cause another cpu is busy capturing the screen so unfortunately this demo didn't actually work we didn't see any bad coins let's just see if we can	thread	43
ok so what's the fix and why did this occur what the answer that we actually have to understand how shar two fifty six works and in fact if we would read the man pages we would discover that we could have passed in a point to some memory and if we made that memory unique to each thread then we would have had threadsafe code so let's look at quick look at the solution here so the solution is to get some space on the stack and remember each thread is going to have its own stack and passed a pointer to that for short two fifty six core and if we do that now we have thread safe code so i guess also takeaway message here is you have to fully understand the syst[em] calls that you're using if you want to write threadsafe code and then that's it that's the other elected by	memory	231
ok so what's the fix and why did this occur what the answer that we actually have to understand how shar two fifty six works and in fact if we would read the man pages we would discover that we could have passed in a point to some memory and if we made that memory unique to each thread then we would have had threadsafe code so let's look at quick look at the solution here so the solution is to get some space on the stack and remember each thread is going to have its own stack and passed a pointer to that for short two fifty six core and if we do that now we have thread safe code so i guess also takeaway message here is you have to fully understand the syst[em] calls that you're using if you want to write threadsafe code and then that's it that's the other elected by	code	321
ok so what's the fix and why did this occur what the answer that we actually have to understand how shar two fifty six works and in fact if we would read the man pages we would discover that we could have passed in a point to some memory and if we made that memory unique to each thread then we would have had threadsafe code so let's look at quick look at the solution here so the solution is to get some space on the stack and remember each thread is going to have its own stack and passed a pointer to that for short two fifty six core and if we do that now we have thread safe code so i guess also takeaway message here is you have to fully understand the syst[em] calls that you're using if you want to write threadsafe code and then that's it that's the other elected by	thread	280
ok so what's the fix and why did this occur what the answer that we actually have to understand how shar two fifty six works and in fact if we would read the man pages we would discover that we could have passed in a point to some memory and if we made that memory unique to each thread then we would have had threadsafe code so let's look at quick look at the solution here so the solution is to get some space on the stack and remember each thread is going to have its own stack and passed a pointer to that for short two fifty six core and if we do that now we have thread safe code so i guess also takeaway message here is you have to fully understand the syst[em] calls that you're using if you want to write threadsafe code and then that's it that's the other elected by	pointer	494
hi welcome to letter twenty four let's start with the code review case so we're going to do we're going to look at a fixed sized ring buffer and look at an implementation	code	54
and we know the following things about it so first of all it uses counting semaphores and the first one s one is going to be initialized to two fifty six so this is kind of counting the number of free space is	the following	12
or how much capacity is left s two is initialized to zero so that's counting the number of things we've actually got inside the buffer right now and then we've got lots of threads producing things and consuming things as well ok so here's some questions that we might want to ask in sort of code review first of all can we find a way that deadlock can occur in other words when good it actually get stuck and if so under what conditions could it be for example when it gets completely full or completely empty is underflow possible meaning that is it possible for d q to return something even though we don't actually have anything inside the buffer right now in other words it will just return some multivalue that happens to be stored inside the buffer	code	291
or how much capacity is left s two is initialized to zero so that's counting the number of things we've actually got inside the buffer right now and then we've got lots of threads producing things and consuming things as well ok so here's some questions that we might want to ask in sort of code review first of all can we find a way that deadlock can occur in other words when good it actually get stuck and if so under what conditions could it be for example when it gets completely full or completely empty is underflow possible meaning that is it possible for d q to return something even though we don't actually have anything inside the buffer right now in other words it will just return some multivalue that happens to be stored inside the buffer	thread	172
or overwritten some data that we actually do need like an earlier piece of the buffer ok so this actually take a look at the code now and see what we can find right so the first thing i notice is that we're actually calling mutex lock really early on inside nq normally i'd only expect the lock and unlock to be around the actual call of where we change the change the array here and the second thing i notice is ok good so our buffer size is two fifty six and in fact we're going to wrap around after we get to two hundred fifty five	code	125
so what we've got then is kind of long hold of the mutex lock inside my enqueue here so my concern is with this same wait what if i have a thread calling nq another those is produced an item wants to queue it up and we call some weight but i don't have any space left inside my data structure here in other words what if s one is zero we might have a problem here because now	a struct	281
so what we've got then is kind of long hold of the mutex lock inside my enqueue here so my concern is with this same wait what if i have a thread calling nq another those is produced an item wants to queue it up and we call some weight but i don't have any space left inside my data structure here in other words what if s one is zero we might have a problem here because now	a thread	137
so what we've got then is kind of long hold of the mutex lock inside my enqueue here so my concern is with this same wait what if i have a thread calling nq another those is produced an item wants to queue it up and we call some weight but i don't have any space left inside my data structure here in other words what if s one is zero we might have a problem here because now	thread	139
it's gone to sleep it's blocked inside the same weight call but it's still holding on to the mutex lock this is not a condition variable ok it's just a simple counting semaphore oh dear so can we have deadlock well let's find out to what happens on the d q side so on the dq side	block	24
if we also had onto the mutex lock earlier if our musics lock had been one of the first things we've done then yes we would have encountered deadlock because the d q could not have continued it would have waited for that that mutex lock that would have never been never been released definition of deadlock waiting for an event that never happens so we didn't find deadlock just there there we came awfully close right what else can we find out about this code then ok so let's see the same post happens early ok that we're actually increasing the count of the number of items in our buffer before we even changed the buffer values ok so we're basically going to add one to this counter here so if somebody was waiting to extract value in other words if a thread had already called d cube but was waiting here because the count of s two was zero we're going to release them from that early oh yeah so this land sounds like a recipe for	code	456
if we also had onto the mutex lock earlier if our musics lock had been one of the first things we've done then yes we would have encountered deadlock because the d q could not have continued it would have waited for that that mutex lock that would have never been never been released definition of deadlock waiting for an event that never happens so we didn't find deadlock just there there we came awfully close right what else can we find out about this code then ok so let's see the same post happens early ok that we're actually increasing the count of the number of items in our buffer before we even changed the buffer values ok so we're basically going to add one to this counter here so if somebody was waiting to extract value in other words if a thread had already called d cube but was waiting here because the count of s two was zero we're going to release them from that early oh yeah so this land sounds like a recipe for	a thread	754
if we also had onto the mutex lock earlier if our musics lock had been one of the first things we've done then yes we would have encountered deadlock because the d q could not have continued it would have waited for that that mutex lock that would have never been never been released definition of deadlock waiting for an event that never happens so we didn't find deadlock just there there we came awfully close right what else can we find out about this code then ok so let's see the same post happens early ok that we're actually increasing the count of the number of items in our buffer before we even changed the buffer values ok so we're basically going to add one to this counter here so if somebody was waiting to extract value in other words if a thread had already called d cube but was waiting here because the count of s two was zero we're going to release them from that early oh yeah so this land sounds like a recipe for	thread	756
underflow that because we said we've incremented or pizza box by one even though we had actually put anything into the buffer yet right so is underflow possible will actually in this particular implementation no because my dick you cannot complete until the mutex lock is released because it is required before actually touching the buffer if this code tried to be a little bit more performance by giving the nq in the dequeue different mutex locks then we would have run into a problem because then we would have allowed a dq thread to try to read a value from the buffer before we've even put the value in right so better code of course would actually only increment the counting semaphore after we modified the buffer so so this line actually belongs down here so do this later ok and we can do it after we've released a mutex lock ok	code	348
underflow that because we said we've incremented or pizza box by one even though we had actually put anything into the buffer yet right so is underflow possible will actually in this particular implementation no because my dick you cannot complete until the mutex lock is released because it is required before actually touching the buffer if this code tried to be a little bit more performance by giving the nq in the dequeue different mutex locks then we would have run into a problem because then we would have allowed a dq thread to try to read a value from the buffer before we've even put the value in right so better code of course would actually only increment the counting semaphore after we modified the buffer so so this line actually belongs down here so do this later ok and we can do it after we've released a mutex lock ok	a mutex	822
underflow that because we said we've incremented or pizza box by one even though we had actually put anything into the buffer yet right so is underflow possible will actually in this particular implementation no because my dick you cannot complete until the mutex lock is released because it is required before actually touching the buffer if this code tried to be a little bit more performance by giving the nq in the dequeue different mutex locks then we would have run into a problem because then we would have allowed a dq thread to try to read a value from the buffer before we've even put the value in right so better code of course would actually only increment the counting semaphore after we modified the buffer so so this line actually belongs down here so do this later ok and we can do it after we've released a mutex lock ok	thread	527
then my same weight can can decorate that and my same post will cause increment what that so if at this very moment and q event happens then that can that can continue through an override the very value that i'd like to see we still need all that entries inside my buffer but now because i've posted on s one then if an nq thread appears then they can continue we haven't yet got the mutex lock so they get the mutex lock	thread	323
and then they call same way on s one but we've already incremented it's once they get to continue and then post on some post which will never block and now they overwrite their buffers so it's pretty big unhappy space here yes we've seen a problem here of overflow buffer overflow we overrode a value that we actually need we actually managed to put too much stuff into the buffer now the chances of that happening are pretty small is this very small number of microseconds between us calling sam post and then asking for the mutex lock but that is a non zero value also notice it's actually only really going to be a problem when my buffer is actually completely full so perhaps under light testing or if your website doesn't have many customers then you're not going to see this problem it's only when your buffer actually hit capacity do you have exposure to this problem ok so that's kind of fun stuff to think about reasoning about code like this is tricky my advice is to think about kind of the extreme conditions like underflow and the overflow and what happens if you have say two threads appearing at the same time and what would happen if just before you acquire the mutex lock another thread was able to acquire it instead	block	142
and then they call same way on s one but we've already incremented it's once they get to continue and then post on some post which will never block and now they overwrite their buffers so it's pretty big unhappy space here yes we've seen a problem here of overflow buffer overflow we overrode a value that we actually need we actually managed to put too much stuff into the buffer now the chances of that happening are pretty small is this very small number of microseconds between us calling sam post and then asking for the mutex lock but that is a non zero value also notice it's actually only really going to be a problem when my buffer is actually completely full so perhaps under light testing or if your website doesn't have many customers then you're not going to see this problem it's only when your buffer actually hit capacity do you have exposure to this problem ok so that's kind of fun stuff to think about reasoning about code like this is tricky my advice is to think about kind of the extreme conditions like underflow and the overflow and what happens if you have say two threads appearing at the same time and what would happen if just before you acquire the mutex lock another thread was able to acquire it instead	code	937
and then they call same way on s one but we've already incremented it's once they get to continue and then post on some post which will never block and now they overwrite their buffers so it's pretty big unhappy space here yes we've seen a problem here of overflow buffer overflow we overrode a value that we actually need we actually managed to put too much stuff into the buffer now the chances of that happening are pretty small is this very small number of microseconds between us calling sam post and then asking for the mutex lock but that is a non zero value also notice it's actually only really going to be a problem when my buffer is actually completely full so perhaps under light testing or if your website doesn't have many customers then you're not going to see this problem it's only when your buffer actually hit capacity do you have exposure to this problem ok so that's kind of fun stuff to think about reasoning about code like this is tricky my advice is to think about kind of the extreme conditions like underflow and the overflow and what happens if you have say two threads appearing at the same time and what would happen if just before you acquire the mutex lock another thread was able to acquire it instead	thread	1090
ok right so before we dive into actually representing a file and let's talk about some of the things that posix gives for us and review how we can talk about files inside different directories ok so first of all we can get there we go right you've probably seen these before so we can talk about paths and when we talk about path to a file or directory we actually have two kinds a relative path which is relative to the current directory of a process so whether that process is bashur shell or a process that is currently running like a web server that process has idea of the current working directory or the current directory and so if we want to talk about that contradictory we can just write it as a single dot so you've probably seen examples where we were sitting inside bash and we say ok	a process	442
a dot they are there however and you can ask ls to actually list or possible files key so let's get back to our discussion about paths can we simplify the following key right so let's have a look a slash b and then we go into the parent directory so we're back into a and then we go into see and then we stay inside see so this is a path that is actually can be simplified to a slash c so both of these strings	the following	151
a dot they are there however and you can ask ls to actually list or possible files key so let's get back to our discussion about paths can we simplify the following key right so let's have a look a slash b and then we go into the parent directory so we're back into a and then we go into see and then we stay inside see so this is a path that is actually can be simplified to a slash c so both of these strings	string	403
and i might find things like the host name of settings for my web server and other things inside there ok but then i want to go to parent directory and go somewhere else so for example i might want to go into var where you'll find a lot of log files for your system so you'll agree that that is the same as another	system	259
hi welcome to letter twenty four let's start with the code review case so we're going to do we're going to look at a fixed sized ring buffer and look at an implementation	code	54
and we know the following things about it so first of all it uses counting semaphores and the first one s one is going to be initialized to two fifty six so this is kind of counting the number of free space is	the following	12
or how much capacity is left s two is initialized to zero so that's counting the number of things we've actually got inside the buffer right now and then we've got lots of threads producing things and consuming things as well ok so here's some questions that we might want to ask in sort of code review first of all can we find a way that deadlock can occur in other words when good it actually get stuck and if so under what conditions could it be for example when it gets completely full or completely empty is underflow possible meaning that is it possible for d q to return something even though we don't actually have anything inside the buffer right now in other words it will just return some multivalue that happens to be stored inside the buffer	code	291
or how much capacity is left s two is initialized to zero so that's counting the number of things we've actually got inside the buffer right now and then we've got lots of threads producing things and consuming things as well ok so here's some questions that we might want to ask in sort of code review first of all can we find a way that deadlock can occur in other words when good it actually get stuck and if so under what conditions could it be for example when it gets completely full or completely empty is underflow possible meaning that is it possible for d q to return something even though we don't actually have anything inside the buffer right now in other words it will just return some multivalue that happens to be stored inside the buffer	thread	172
or overwritten some data that we actually do need like an earlier piece of the buffer ok so this actually take a look at the code now and see what we can find right so the first thing i notice is that we're actually calling mutex lock really early on inside nq normally i'd only expect the lock and unlock to be around the actual call of where we change the change the array here and the second thing i notice is ok good so our buffer size is two fifty six and in fact we're going to wrap around after we get to two hundred fifty five	code	125
so what we've got then is kind of long hold of the mutex lock inside my enqueue here so my concern is with this same wait what if i have a thread calling nq another those is produced an item wants to queue it up and we call some weight but i don't have any space left inside my data structure here in other words what if s one is zero we might have a problem here because now	a struct	281
so what we've got then is kind of long hold of the mutex lock inside my enqueue here so my concern is with this same wait what if i have a thread calling nq another those is produced an item wants to queue it up and we call some weight but i don't have any space left inside my data structure here in other words what if s one is zero we might have a problem here because now	a thread	137
so what we've got then is kind of long hold of the mutex lock inside my enqueue here so my concern is with this same wait what if i have a thread calling nq another those is produced an item wants to queue it up and we call some weight but i don't have any space left inside my data structure here in other words what if s one is zero we might have a problem here because now	thread	139
it's gone to sleep it's blocked inside the same weight call but it's still holding on to the mutex lock this is not a condition variable ok it's just a simple counting semaphore oh dear so can we have deadlock well let's find out to what happens on the d q side so on the dq side	block	24
if we also had onto the mutex lock earlier if our musics lock had been one of the first things we've done then yes we would have encountered deadlock because the d q could not have continued it would have waited for that that mutex lock that would have never been never been released definition of deadlock waiting for an event that never happens so we didn't find deadlock just there there we came awfully close right what else can we find out about this code then ok so let's see the same post happens early ok that we're actually increasing increasing the count of the number of items in our buffer before we even changed the buffer values ok so we're basically going to add one discounted here so if somebody was waiting to extract value in other words if a thread had already called d cube but was waiting here because the count of s two was zero we're going to release them from that early oh yeah so this land sounds like a recipe for	code	456
if we also had onto the mutex lock earlier if our musics lock had been one of the first things we've done then yes we would have encountered deadlock because the d q could not have continued it would have waited for that that mutex lock that would have never been never been released definition of deadlock waiting for an event that never happens so we didn't find deadlock just there there we came awfully close right what else can we find out about this code then ok so let's see the same post happens early ok that we're actually increasing increasing the count of the number of items in our buffer before we even changed the buffer values ok so we're basically going to add one discounted here so if somebody was waiting to extract value in other words if a thread had already called d cube but was waiting here because the count of s two was zero we're going to release them from that early oh yeah so this land sounds like a recipe for	a thread	760
if we also had onto the mutex lock earlier if our musics lock had been one of the first things we've done then yes we would have encountered deadlock because the d q could not have continued it would have waited for that that mutex lock that would have never been never been released definition of deadlock waiting for an event that never happens so we didn't find deadlock just there there we came awfully close right what else can we find out about this code then ok so let's see the same post happens early ok that we're actually increasing increasing the count of the number of items in our buffer before we even changed the buffer values ok so we're basically going to add one discounted here so if somebody was waiting to extract value in other words if a thread had already called d cube but was waiting here because the count of s two was zero we're going to release them from that early oh yeah so this land sounds like a recipe for	thread	762
underflow that because we said we've incremented or pizza box by one even though we had actually put anything into the buffer yet right so is underflow possible will actually in this particular implementation no because my dick you cannot complete until the mutex lock is released because it is required before actually touching the buffer if this code tried to be a little bit more performance by giving the nq in the dequeue different mutex locks then we would have run into a problem because then we would have allowed a dq thread to try to read a value from the buffer before we've even put the value in right so better code of course would actually only increment the counting semaphore after we modified the buffer so so this line actually belongs down here so do this later ok and we can do it after we've released a mutex lock ok	code	348
underflow that because we said we've incremented or pizza box by one even though we had actually put anything into the buffer yet right so is underflow possible will actually in this particular implementation no because my dick you cannot complete until the mutex lock is released because it is required before actually touching the buffer if this code tried to be a little bit more performance by giving the nq in the dequeue different mutex locks then we would have run into a problem because then we would have allowed a dq thread to try to read a value from the buffer before we've even put the value in right so better code of course would actually only increment the counting semaphore after we modified the buffer so so this line actually belongs down here so do this later ok and we can do it after we've released a mutex lock ok	a mutex	822
underflow that because we said we've incremented or pizza box by one even though we had actually put anything into the buffer yet right so is underflow possible will actually in this particular implementation no because my dick you cannot complete until the mutex lock is released because it is required before actually touching the buffer if this code tried to be a little bit more performance by giving the nq in the dequeue different mutex locks then we would have run into a problem because then we would have allowed a dq thread to try to read a value from the buffer before we've even put the value in right so better code of course would actually only increment the counting semaphore after we modified the buffer so so this line actually belongs down here so do this later ok and we can do it after we've released a mutex lock ok	thread	527
then my same weight can can decorate that and my same post will cause increment what that so if at this very moment and q event happens then that can that can continue through an override the very value that i'd like to see we still need all that entries inside my buffer but now because i've posted on s one then if an nq thread appears then they can continue we haven't yet got the mutex lock so they get the mutex lock	thread	323
and then they call same way on s one but we've already incremented it's once they get to continue and then post on some post which will never block and now they overwrite their buffers so it's pretty big unhappy space here yes we've seen a problem here of overflow buffer overflow we overrode a value that we actually need we actually managed to put too much stuff into the buffer now the chances of that happening are pretty small is this very small number of microseconds between us calling sam post and then asking for the mutex lock but that is a non zero value also notice it's actually only really going to be a problem when my buffer is actually completely full so perhaps under light testing or if your website doesn't have many customers then you're not going to see this problem it's only when your buffer actually hit capacity do you have exposure to this problem ok so that's kind of fun stuff to think about reasoning about code like this is tricky my advice is to think about kind of the extreme conditions like underflow and the overflow and what happens if you have say two threads appearing at the same time and what would happen if just before you acquire the mutex lock another thread was able to acquire it instead	block	142
and then they call same way on s one but we've already incremented it's once they get to continue and then post on some post which will never block and now they overwrite their buffers so it's pretty big unhappy space here yes we've seen a problem here of overflow buffer overflow we overrode a value that we actually need we actually managed to put too much stuff into the buffer now the chances of that happening are pretty small is this very small number of microseconds between us calling sam post and then asking for the mutex lock but that is a non zero value also notice it's actually only really going to be a problem when my buffer is actually completely full so perhaps under light testing or if your website doesn't have many customers then you're not going to see this problem it's only when your buffer actually hit capacity do you have exposure to this problem ok so that's kind of fun stuff to think about reasoning about code like this is tricky my advice is to think about kind of the extreme conditions like underflow and the overflow and what happens if you have say two threads appearing at the same time and what would happen if just before you acquire the mutex lock another thread was able to acquire it instead	code	937
and then they call same way on s one but we've already incremented it's once they get to continue and then post on some post which will never block and now they overwrite their buffers so it's pretty big unhappy space here yes we've seen a problem here of overflow buffer overflow we overrode a value that we actually need we actually managed to put too much stuff into the buffer now the chances of that happening are pretty small is this very small number of microseconds between us calling sam post and then asking for the mutex lock but that is a non zero value also notice it's actually only really going to be a problem when my buffer is actually completely full so perhaps under light testing or if your website doesn't have many customers then you're not going to see this problem it's only when your buffer actually hit capacity do you have exposure to this problem ok so that's kind of fun stuff to think about reasoning about code like this is tricky my advice is to think about kind of the extreme conditions like underflow and the overflow and what happens if you have say two threads appearing at the same time and what would happen if just before you acquire the mutex lock another thread was able to acquire it instead	thread	1090
ok hi right so let's think about lock contention and also how this also relates to discovering race conditions ok so here's the scenario that we're going to think about that i've got a thread that most of the time is not inside the critical section and in fact if we sketch this out you'll see that initially i just got one single thread and only for a short period of time just one millisecond it's actually doing something inside a critical section that we haven't yet protected with any mutex locks but for the other nine hundred and ninety nine milliseconds	a thread	183
ok hi right so let's think about lock contention and also how this also relates to discovering race conditions ok so here's the scenario that we're going to think about that i've got a thread that most of the time is not inside the critical section and in fact if we sketch this out you'll see that initially i just got one single thread and only for a short period of time just one millisecond it's actually doing something inside a critical section that we haven't yet protected with any mutex locks but for the other nine hundred and ninety nine milliseconds	section	241
ok hi right so let's think about lock contention and also how this also relates to discovering race conditions ok so here's the scenario that we're going to think about that i've got a thread that most of the time is not inside the critical section and in fact if we sketch this out you'll see that initially i just got one single thread and only for a short period of time just one millisecond it's actually doing something inside a critical section that we haven't yet protected with any mutex locks but for the other nine hundred and ninety nine milliseconds	thread	185
is doing something else so this thing runs for one second and then it's some random type there's one second ok some random sign inside that just for one day second it goes and visits a critical section may be updates or reads a particular data structure ok so now that's fine but now we have two threads so here's another fit that also is going to run for the same second	type	84
is doing something else so this thing runs for one second and then it's some random type there's one second ok some random sign inside that just for one day second it goes and visits a critical section may be updates or reads a particular data structure ok so now that's fine but now we have two threads so here's another fit that also is going to run for the same second	a struct	242
is doing something else so this thing runs for one second and then it's some random type there's one second ok some random sign inside that just for one day second it goes and visits a critical section may be updates or reads a particular data structure ok so now that's fine but now we have two threads so here's another fit that also is going to run for the same second	section	194
is doing something else so this thing runs for one second and then it's some random type there's one second ok some random sign inside that just for one day second it goes and visits a critical section may be updates or reads a particular data structure ok so now that's fine but now we have two threads so here's another fit that also is going to run for the same second	thread	296
there we go and inside this it also might visit the critical section	section	61
ok of time where is ashley inside the the critical section so as we know everything will find our programs deterministic our program or function as expected provided these two don't meet another words providing they don't actually overlap right so could we estimate this will sure we could set up a full integral and think about how we think about these two random times as a whole bunch of times where they don't overlap and then there's times when they start overlap fully overlap and then only overlap a little bit again and then other times when we don't so we could set it up to set this up as a as a two dimensional integral but we just want to estimate this today so we're not going to worry about things like edge effects where where the very first thread goes into the critical section at the very end so it's not possible to overlap full or very visits critical section at the very end where it's not possible to overlap afterwards so let's not worry about that let's just concentrate on the idea that ninety nine point nine percent of the time my first date is not inside the critical section so we're going to look at the majority case an ignore the edge cases so right i thought and playing battleships with you now so i've thought of one moment in time where it is inside the critical section now you get to think of a number where you get to say ok right i'm going to choose my second thread to be inside this critical section what's the chances that we sunk the battleship what's the chances that they've overlapped	section	51
ok of time where is ashley inside the the critical section so as we know everything will find our programs deterministic our program or function as expected provided these two don't meet another words providing they don't actually overlap right so could we estimate this will sure we could set up a full integral and think about how we think about these two random times as a whole bunch of times where they don't overlap and then there's times when they start overlap fully overlap and then only overlap a little bit again and then other times when we don't so we could set it up to set this up as a as a two dimensional integral but we just want to estimate this today so we're not going to worry about things like edge effects where where the very first thread goes into the critical section at the very end so it's not possible to overlap full or very visits critical section at the very end where it's not possible to overlap afterwards so let's not worry about that let's just concentrate on the idea that ninety nine point nine percent of the time my first date is not inside the critical section so we're going to look at the majority case an ignore the edge cases so right i thought and playing battleships with you now so i've thought of one moment in time where it is inside the critical section now you get to think of a number where you get to say ok right i'm going to choose my second thread to be inside this critical section what's the chances that we sunk the battleship what's the chances that they've overlapped	thread	757
ok right so how can we analyze this i've got a one millisecond air slot here so there is actually a window of just two milliseconds where your choose a different color let's go for say loop again where your timing of your thread might overlap my critical window ok so we might be exactly the same or we might be just afterwards ok so there's just a two millisecond window here alright so how likely is it that you will actually achieve this well remember we said the timing is random so given that you're choosing these times all random you've got a two millisecond out of one out of one second window in other words are roughly about one hundred thousand dollar you want to be a little bit more accurate you might say roughly say one out of five hundred so so i could say	thread	222
right so that sounds actually pretty good or pretty bad depending on whether you truly want to try to discover this problem or you're hoping that your code works so even though we know we gotta race condition even though we know we didn't actually implement the locks we have a problem here which is this two percent chance that all code will fail	code	151
because two threads of enter the critical section at the same time right so if we test our code once twice three times ten times as are very strong chance that we won't notice this effect we've only going to see this one time out of five hundred approximately like i said we didn't do the exact integral but this means that actually make race conditions to occur can be quite hard now we went for figures that said	code	91
because two threads of enter the critical section at the same time right so if we test our code once twice three times ten times as are very strong chance that we won't notice this effect we've only going to see this one time out of five hundred approximately like i said we didn't do the exact integral but this means that actually make race conditions to occur can be quite hard now we went for figures that said	section	42
because two threads of enter the critical section at the same time right so if we test our code once twice three times ten times as are very strong chance that we won't notice this effect we've only going to see this one time out of five hundred approximately like i said we didn't do the exact integral but this means that actually make race conditions to occur can be quite hard now we went for figures that said	thread	12
the race the critical section took one millisecond dirt to run if you're critical section was much smaller than that for example in the code that we've just looked at with the push in the pop or adding another part that might only be orders of say ten microseconds so now the chances of of of threads being inside the critical section is actually slimmer so discovering problems just by testing is hard and that is why we do things like locate don't want it with two threads but when it with four threads now it's much more likely to occur or test it with a brute force loop trying to go into the critical section as often as possible and now you've increased the chances significantly this also applies to the idea of lock contention so lock contention is not a good thing it means that one thread is being forced to wait for another now we did this because we want programs to function correctly	code	136
the race the critical section took one millisecond dirt to run if you're critical section was much smaller than that for example in the code that we've just looked at with the push in the pop or adding another part that might only be orders of say ten microseconds so now the chances of of of threads being inside the critical section is actually slimmer so discovering problems just by testing is hard and that is why we do things like locate don't want it with two threads but when it with four threads now it's much more likely to occur or test it with a brute force loop trying to go into the critical section as often as possible and now you've increased the chances significantly this also applies to the idea of lock contention so lock contention is not a good thing it means that one thread is being forced to wait for another now we did this because we want programs to function correctly	section	22
the race the critical section took one millisecond dirt to run if you're critical section was much smaller than that for example in the code that we've just looked at with the push in the pop or adding another part that might only be orders of say ten microseconds so now the chances of of of threads being inside the critical section is actually slimmer so discovering problems just by testing is hard and that is why we do things like locate don't want it with two threads but when it with four threads now it's much more likely to occur or test it with a brute force loop trying to go into the critical section as often as possible and now you've increased the chances significantly this also applies to the idea of lock contention so lock contention is not a good thing it means that one thread is being forced to wait for another now we did this because we want programs to function correctly	thread	293
but if we held onto a lot for an unnecessarily extended amount of time now we're going to start to see an unwanted and unnecessary performance impact so right now we saw with a little rough back of the envelope calculation calculation there was only one point two percent chance of the two threads asking for the lock at the	thread	290
so one one of the thousand basically so we don't expect the css significant performance impact because of two threads updating this however if our code was different if we had threads which say wanted to update the data structure ten milliseconds out of one hundred million seconds so now there's a one in ten chance that the lock that we asked for is is already in use	the data structure	211
so one one of the thousand basically so we don't expect the css significant performance impact because of two threads updating this however if our code was different if we had threads which say wanted to update the data structure ten milliseconds out of one hundred million seconds so now there's a one in ten chance that the lock that we asked for is is already in use	a struct	218
so one one of the thousand basically so we don't expect the css significant performance impact because of two threads updating this however if our code was different if we had threads which say wanted to update the data structure ten milliseconds out of one hundred million seconds so now there's a one in ten chance that the lock that we asked for is is already in use	code	147
so one one of the thousand basically so we don't expect the css significant performance impact because of two threads updating this however if our code was different if we had threads which say wanted to update the data structure ten milliseconds out of one hundred million seconds so now there's a one in ten chance that the lock that we asked for is is already in use	thread	110
we don't want lock contention but on the other hand we want to be able to discover our race conditions as soon as possible in women during our testing before we put it into production before we start relying on this code to save lives or to move money or to give demos etc 's so race conditions are tricky is the big takeaway message and you could do back of the envelope calculation to see why it's difficult to detect these	code	216
ok right so with that in mind that means that our debugging skills understanding of how code can interleave	code	88
can is important are believed to actually reason about our code is just as important as being up to test	code	59
test it ok so here's here's the code we've got i'd like you to kind of look at this code and tell me what do you think it's going to do right so i've got i've got a couple of threads in a mutex as global variables up here ok	code	32
test it ok so here's here's the code we've got i'd like you to kind of look at this code and tell me what do you think it's going to do right so i've got i've got a couple of threads in a mutex as global variables up here ok	a mutex	186
test it ok so here's here's the code we've got i'd like you to kind of look at this code and tell me what do you think it's going to do right so i've got i've got a couple of threads in a mutex as global variables up here ok	thread	175
right and i've got a public counter global variable you can see i'm incrementing it inside this function and each thread that i'm going to create down here inside my main is going to run this code for a million times right so with that in mind what do you think it's going to do it i will tell you the answer that in the next lecture but why don't you pause this right now and make your prediction by	code	192
right and i've got a public counter global variable you can see i'm incrementing it inside this function and each thread that i'm going to create down here inside my main is going to run this code for a million times right so with that in mind what do you think it's going to do it i will tell you the answer that in the next lecture but why don't you pause this right now and make your prediction by	thread	114
ok so in the beginning the root file system is just a single slash here and beneath that that's we're going to find just everything so we need a way to be able to say you know i want some file systems for my local machine perhaps i got some remote filesystems and i've got some file systems which don't even physically exist as well so how can we do this well the idea is that we can actually set up what are called mount points so for example so i might have a mountpoint say called slash home slash let's call it coffee mugs for example coffee and then i can say on this directory coffee here this i want to connect toa particular file system	system	37
so maybe i'm going to get that particular file system from this mug by asking this piece of hardware to give me a list of files so it won't be empty it will actually i'll have a special piece of hardware that supports the right api to say right stop telling me about the root directories inside my coffee mug ok or maybe i want a file system which is going to be serving all the files that i need for when the machine starts to boot up so i might put them say slash root or maybe i want a file system for just a single forward slash which is the default file system if none of these other filesystems apply or maybe i want a file system just for say home just for my user's directories maybe i want a file system say just for temp for example if i've got lots of ram i might choose to unpack files and actually have a file system where the files themselves are not stored on disk but they're actually just stored in memory so when my machine reboots anything inside slash temp obviously is destroyed because we never actually made	memory	916
so maybe i'm going to get that particular file system from this mug by asking this piece of hardware to give me a list of files so it won't be empty it will actually i'll have a special piece of hardware that supports the right api to say right stop telling me about the root directories inside my coffee mug ok or maybe i want a file system which is going to be serving all the files that i need for when the machine starts to boot up so i might put them say slash root or maybe i want a file system for just a single forward slash which is the default file system if none of these other filesystems apply or maybe i want a file system just for say home just for my user's directories maybe i want a file system say just for temp for example if i've got lots of ram i might choose to unpack files and actually have a file system where the files themselves are not stored on disk but they're actually just stored in memory so when my machine reboots anything inside slash temp obviously is destroyed because we never actually made	system	47
a real copy of those files were just pretending that pretended we did whereas in fact they are stored in memory	memory	105
but how about some file systems which actually don't exist how about some virtual file systems ok so this is really fun stuff any moment of course we've got the kernel running and i wonder how it's doing i wonder what it's doing how can i find out about what my linux kernel or my apple kernel is what it's working on what it's doing with each process and wouldn't it be great if i could somehow talk to it and that is how we use virtual filesystems so think about all these file systems we've just defined for example when you say something like ok list all the files inside a certain directory for example tell me all the files inside slash home slash angrave then	system	24
we need to talk to a file system to say ok i want to read some inodes i want to get a list of files of certain directory basically i have an api so that actual api does not need to be does not need to actually go to any hardware we can fake some answers we can say hey yeah look here's all these directories or here's all these sub directories here's all these files that you could go and explore let me list them out for you and we can make that up on the fly whenever you ask and if you try to open a particular one of these files we can make up an answer and so that's the idea of having a virtual file system is that now we can actually populate imaginary files and imaginary directory create them describe them on the fly so that you can find out what your machine is doing and we'll have some examples of that in another video ok bye!	system	26
ok, so here it is. it behaves a lot like right we give it a file descriptor as usual, we give it a buffer as usual, and the number of bytes we want to write, but we also give it an offset. in other words, we don't care about the current position in a file we just want to explicitly say where to write these bytes. by the way there's a similar call called pv. does well so where this becomes uh it useful is where i have say a whole load of threads which are generating output. suppose, for example, that you run a competition against students from another university and all you have to do is sort some numbers or i want a better color than that. there we go... and write as quickly as possible	thread	441
ok, so maybe you know about threats so great you are able to chunk up the work into different jobs so that each thread is responsible for the output of the total result and so you need each thread to work independently. """great!"" you say. ""i remember those from cs241" "to the rescue."" that now i can tell my first thread to" explicitly write its results into the first part of the file meanwhile the second thread over here is starting to generate results as well and so it can start writing bits of data over here, and we can explicitly say where in the file we want that to go. so yep, there's pee right and there's also period which does a similar thing that you can read from a certain part of the file and directly specify an offset into the file. ok, so they are very useful when you want to do random access and random reads into file but also later inside cs241 we're going to learn how to 'memory map' files directly into memory where we no longer even need to call read and write but we can actually look at the file as if it is actually part of our address space. so that's coming up later inside cs241 and it's the most one of the most far and most powerful features of posix and system programming that you'll see in this course. ok, so the will do what's "a named pipe?"" ok, how do i make a named pipe? for this you" can actually make pipes on your file system. you can just say make vivo because they behave as a little 'first in first out' queue. so "let's call it say ok, and now if you look on the current directory you will see there's something called 'myq.' so here it is. looks a bit like a file right now but let's find out some more information about it. ok and you'll see i've got a magic letter over here that actually it's "a queue"" so i can put stuff into it let's say helico hello" pipe that into my queue.	memory	904
ok, so maybe you know about threats so great you are able to chunk up the work into different jobs so that each thread is responsible for the output of the total result and so you need each thread to work independently. """great!"" you say. ""i remember those from cs241" "to the rescue."" that now i can tell my first thread to" explicitly write its results into the first part of the file meanwhile the second thread over here is starting to generate results as well and so it can start writing bits of data over here, and we can explicitly say where in the file we want that to go. so yep, there's pee right and there's also period which does a similar thing that you can read from a certain part of the file and directly specify an offset into the file. ok, so they are very useful when you want to do random access and random reads into file but also later inside cs241 we're going to learn how to 'memory map' files directly into memory where we no longer even need to call read and write but we can actually look at the file as if it is actually part of our address space. so that's coming up later inside cs241 and it's the most one of the most far and most powerful features of posix and system programming that you'll see in this course. ok, so the will do what's "a named pipe?"" ok, how do i make a named pipe? for this you" can actually make pipes on your file system. you can just say make vivo because they behave as a little 'first in first out' queue. so "let's call it say ok, and now if you look on the current directory you will see there's something called 'myq.' so here it is. looks a bit like a file right now but let's find out some more information about it. ok and you'll see i've got a magic letter over here that actually it's "a queue"" so i can put stuff into it let's say helico hello" pipe that into my queue.	thread	112
ok, so maybe you know about threats so great you are able to chunk up the work into different jobs so that each thread is responsible for the output of the total result and so you need each thread to work independently. """great!"" you say. ""i remember those from cs241" "to the rescue."" that now i can tell my first thread to" explicitly write its results into the first part of the file meanwhile the second thread over here is starting to generate results as well and so it can start writing bits of data over here, and we can explicitly say where in the file we want that to go. so yep, there's pee right and there's also period which does a similar thing that you can read from a certain part of the file and directly specify an offset into the file. ok, so they are very useful when you want to do random access and random reads into file but also later inside cs241 we're going to learn how to 'memory map' files directly into memory where we no longer even need to call read and write but we can actually look at the file as if it is actually part of our address space. so that's coming up later inside cs241 and it's the most one of the most far and most powerful features of posix and system programming that you'll see in this course. ok, so the will do what's "a named pipe?"" ok, how do i make a named pipe? for this you" can actually make pipes on your file system. you can just say make vivo because they behave as a little 'first in first out' queue. so "let's call it say ok, and now if you look on the current directory you will see there's something called 'myq.' so here it is. looks a bit like a file right now but let's find out some more information about it. ok and you'll see i've got a magic letter over here that actually it's "a queue"" so i can put stuff into it let's say helico hello" pipe that into my queue.	address	1065
ok, so maybe you know about threats so great you are able to chunk up the work into different jobs so that each thread is responsible for the output of the total result and so you need each thread to work independently. """great!"" you say. ""i remember those from cs241" "to the rescue."" that now i can tell my first thread to" explicitly write its results into the first part of the file meanwhile the second thread over here is starting to generate results as well and so it can start writing bits of data over here, and we can explicitly say where in the file we want that to go. so yep, there's pee right and there's also period which does a similar thing that you can read from a certain part of the file and directly specify an offset into the file. ok, so they are very useful when you want to do random access and random reads into file but also later inside cs241 we're going to learn how to 'memory map' files directly into memory where we no longer even need to call read and write but we can actually look at the file as if it is actually part of our address space. so that's coming up later inside cs241 and it's the most one of the most far and most powerful features of posix and system programming that you'll see in this course. ok, so the will do what's "a named pipe?"" ok, how do i make a named pipe? for this you" can actually make pipes on your file system. you can just say make vivo because they behave as a little 'first in first out' queue. so "let's call it say ok, and now if you look on the current directory you will see there's something called 'myq.' so here it is. looks a bit like a file right now but let's find out some more information about it. ok and you'll see i've got a magic letter over here that actually it's "a queue"" so i can put stuff into it let's say helico hello" pipe that into my queue.	system	1197
ah right. into my queue there we go ok that is waiting to invite those bites it's blocked why because no one is currently reading from that so to be able to read from this fifo i better set up a new process that can read from this. so i will start a new buffer. let me get out of that because i want to the current directory. so let me grab all that ok run it again and now let's start a new window and we will cd into that directory case so	block	82
my processes. is and how do i get rid of them you can just type 'rm' so goodbye my queue right so there's a very quick introduction into fifo queues. and they exist on the inside inside a directory. ok, so we've talked about these.. we talked about these..	type	59
ok right so before we dive into actually representing a file and let's talk about some of the things that posix gives for us and review how we can talk about files inside different directories ok so first of all we can ok there we go right you've probably seen these before so we can talk about paths and when we talk about path to a file or directory we actually have two kinds a relative path which is relative to the current directory of a process so whether that process is bash or your shell or a process that is currently running like a web server that process has idea of the current working directory or the current directory and so if we want to talk about that kind of directory we can just write it as a single dot so you've probably seen examples where we were sitting inside bash and we say ok	a process	441
a dot they are there however and you can ask ls to actually list all possible files ok so let's get back to our discussion about paths can we simplify the following ok right so let's have a look a slash b and then we go into the parent directory so we're back into a and then we go into c and then we stay inside c so this is a path that is actually can be simplified to a slash c so both of these strings	the following	151
a dot they are there however and you can ask ls to actually list all possible files ok so let's get back to our discussion about paths can we simplify the following ok right so let's have a look a slash b and then we go into the parent directory so we're back into a and then we go into c and then we stay inside c so this is a path that is actually can be simplified to a slash c so both of these strings	string	398
and i might find things like the host name of settings for my web server and other things inside there ok but then i want to go to parent directory and go somewhere else so for example i might want to go into var where you'll find a lot of log files for your system so you'll agree that that is the same as another	system	259
hi right great welcome to lecture thirty seven say let's talk a little bit about rpc protocol buffers and will finish it a little bit with some fun with mmap now if you're taking cs two forty one you've already seen rpc in the lab so my vote today is just to kind of fill in some details about some kind of basic terms and then we'll look at another another obvious implementation by google and maybe compare that with what you see in the lab using rpc jenn ok so great let's get started first of all what is rpc right so you know this stands for remote procedure calls and so rather than thinking about the kind of low level hey let's send bytes let's get my ministrator there ok right procedure calls rather than send thinking about cover network 'cause we're thinking about it more abstract level that i can make what looks like a function call but in fact that function called executes inside a different process possibly even on a different machine	mmap	153
hi right great welcome to lecture thirty seven say let's talk a little bit about rpc protocol buffers and will finish it a little bit with some fun with mmap now if you're taking cs two forty one you've already seen rpc in the lab so my vote today is just to kind of fill in some details about some kind of basic terms and then we'll look at another another obvious implementation by google and maybe compare that with what you see in the lab using rpc jenn ok so great let's get started first of all what is rpc right so you know this stands for remote procedure calls and so rather than thinking about the kind of low level hey let's send bytes let's get my ministrator there ok right procedure calls rather than send thinking about cover network 'cause we're thinking about it more abstract level that i can make what looks like a function call but in fact that function called executes inside a different process possibly even on a different machine	protocol buffers	85
to realize that one thing that process has gives us is a security model we can say that a particular process runs as an effective user id and has access all not to certain system resources so we know for example if i was writing a web server that the web server has to run as root in order to access support that is privileged like a port less than a thousand and twenty four ok so should all my code however run as administrator vernors route maybe not maybe some of it should for example if you're going to work with	code	396
to realize that one thing that process has gives us is a security model we can say that a particular process runs as an effective user id and has access all not to certain system resources so we know for example if i was writing a web server that the web server has to run as root in order to access support that is privileged like a port less than a thousand and twenty four ok so should all my code however run as administrator vernors route maybe not maybe some of it should for example if you're going to work with	resources	179
to realize that one thing that process has gives us is a security model we can say that a particular process runs as an effective user id and has access all not to certain system resources so we know for example if i was writing a web server that the web server has to run as root in order to access support that is privileged like a port less than a thousand and twenty four ok so should all my code however run as administrator vernors route maybe not maybe some of it should for example if you're going to work with	system	172
the file system run in a much more constrained way perhaps i for example should run it under a certain user that only has access to a certain set of directories	system	9
simply with browser today a web browser i've got different parts which can have different different privileges required for example perhaps i need some part that's going to interact with the graphics and the font system i got other parts which might interact with the file system in order for me to cash information and i've got other parts which for example my implement my javascript interpreter or hot spot compiler or something so why don't i run those with different processes so that if a vulnerability is found hopefully we can try to contain any malicious attempts and make it harder for an attacker to escape out of all browser and do bad things ok so that's one big advantage of remote procedure calls in addition to being able to remote stuff is that we can actually separate the privileges of our program and into small world contains units ok right so the next thing is let's talk about the actual code that we write we saw an example of this in the previous lecture where we actually had to write some code that actually turns say like update high school or get some information has to turn it into some information that we're going to send over the network the code that that performs this duty is called stub code and will see two versions versions of this the stub code by itself is usually refers to the code that we write on the client so for example you might have a method called say get name	code	911
simply with browser today a web browser i've got different parts which can have different different privileges required for example perhaps i need some part that's going to interact with the graphics and the font system i got other parts which might interact with the file system in order for me to cash information and i've got other parts which for example my implement my javascript interpreter or hot spot compiler or something so why don't i run those with different processes so that if a vulnerability is found hopefully we can try to contain any malicious attempts and make it harder for an attacker to escape out of all browser and do bad things ok so that's one big advantage of remote procedure calls in addition to being able to remote stuff is that we can actually separate the privileges of our program and into small world contains units ok right so the next thing is let's talk about the actual code that we write we saw an example of this in the previous lecture where we actually had to write some code that actually turns say like update high school or get some information has to turn it into some information that we're going to send over the network the code that that performs this duty is called stub code and will see two versions versions of this the stub code by itself is usually refers to the code that we write on the client so for example you might have a method called say get name	system	213
ok and internally inside that there's going to be a lot of code that we need to write in order to talk to the remote server	code	59
passing returns a string or something the code that we right here is very much wanted boiler code it's very dull to fight and ideally would have a tool to actually generate generate that code for us and in fact in the lab you saw that with tool called rpc jen ok which will automatically generate all that c code forwards but typically what it needs to do is it needs to marshall all the information that we're going to send down the wire across the network to the other side so if you imagine for example a field marshall or marshall in terms of army their responsibility is to get things in order to get them well organized so that we can send everything off in organized fashion so if for example you have a whole load of parameters to send you might have to decide which order to send those parameters or if you had a whole lot of integers dissent	parameter	725
passing returns a string or something the code that we right here is very much wanted boiler code it's very dull to fight and ideally would have a tool to actually generate generate that code for us and in fact in the lab you saw that with tool called rpc jen ok which will automatically generate all that c code forwards but typically what it needs to do is it needs to marshall all the information that we're going to send down the wire across the network to the other side so if you imagine for example a field marshall or marshall in terms of army their responsibility is to get things in order to get them well organized so that we can send everything off in organized fashion so if for example you have a whole load of parameters to send you might have to decide which order to send those parameters or if you had a whole lot of integers dissent	code	42
passing returns a string or something the code that we right here is very much wanted boiler code it's very dull to fight and ideally would have a tool to actually generate generate that code for us and in fact in the lab you saw that with tool called rpc jen ok which will automatically generate all that c code forwards but typically what it needs to do is it needs to marshall all the information that we're going to send down the wire across the network to the other side so if you imagine for example a field marshall or marshall in terms of army their responsibility is to get things in order to get them well organized so that we can send everything off in organized fashion so if for example you have a whole load of parameters to send you might have to decide which order to send those parameters or if you had a whole lot of integers dissent	string	18
you might decide to say send the number of integers followed by their values or if you had a graph you'd have to find a way to turn that graph into some information to send down the wire so all of that idea of marshalling all the information you want is called is called marshaling it may include also some additional information like some session information because you've already authenticated with the other side right so all that happens inside the clients stub code	code	467
on the other side at the on the server we also we need to write some sub some stub code so for every function that we want to implement for example this get name function we need to receive the information from the other side and turn that back into the kind of necessary parameters to actually kind of implement it so this task is called une marshaling	parameter	272
on the other side at the on the server we also we need to write some sub some stub code so for every function that we want to implement for example this get name function we need to receive the information from the other side and turn that back into the kind of necessary parameters to actually kind of implement it so this task is called une marshaling	code	83
which is where we grapple information and turn it back into the parameters ok so within within this let's actually have a girl that's actually kind of right some some code to do this and of course we'll do it in c so let's imagine that will have a little method here called say get name ok	parameter	64
which is where we grapple information and turn it back into the parameters ok so within within this let's actually have a girl that's actually kind of right some some code to do this and of course we'll do it in c so let's imagine that will have a little method here called say get name ok	code	167
we have some kind of key or index to get a particular name ok and we are going to say return a character pointer ok so what might r r code look like for this right so i need to be able to send this key down and i also need to send which function i want to run on the remote side so i've got several choices here perhaps i actually i want to write to the far to script the actual name of the function that i'm trying to call so i could say get name and i could case so let's get name so that's going to be want to kind of seven characters right or perhaps i i want to have the name with some kind of termination character so perhaps the colon here so would send eight characters and i also need to send my parameters so that's easy right now i've just got one parameter but i still need to choose exactly how if i wanted to send it in a binary format i could send the bites at mikey here and of course the size of that data structure	parameter	705
we have some kind of key or index to get a particular name ok and we are going to say return a character pointer ok so what might r r code look like for this right so i need to be able to send this key down and i also need to send which function i want to run on the remote side so i've got several choices here perhaps i actually i want to write to the far to script the actual name of the function that i'm trying to call so i could say get name and i could case so let's get name so that's going to be want to kind of seven characters right or perhaps i i want to have the name with some kind of termination character so perhaps the colon here so would send eight characters and i also need to send my parameters so that's easy right now i've just got one parameter but i still need to choose exactly how if i wanted to send it in a binary format i could send the bites at mikey here and of course the size of that data structure	a struct	921
we have some kind of key or index to get a particular name ok and we are going to say return a character pointer ok so what might r r code look like for this right so i need to be able to send this key down and i also need to send which function i want to run on the remote side so i've got several choices here perhaps i actually i want to write to the far to script the actual name of the function that i'm trying to call so i could say get name and i could case so let's get name so that's going to be want to kind of seven characters right or perhaps i i want to have the name with some kind of termination character so perhaps the colon here so would send eight characters and i also need to send my parameters so that's easy right now i've just got one parameter but i still need to choose exactly how if i wanted to send it in a binary format i could send the bites at mikey here and of course the size of that data structure	code	134
we have some kind of key or index to get a particular name ok and we are going to say return a character pointer ok so what might r r code look like for this right so i need to be able to send this key down and i also need to send which function i want to run on the remote side so i've got several choices here perhaps i actually i want to write to the far to script the actual name of the function that i'm trying to call so i could say get name and i could case so let's get name so that's going to be want to kind of seven characters right or perhaps i i want to have the name with some kind of termination character so perhaps the colon here so would send eight characters and i also need to send my parameters so that's easy right now i've just got one parameter but i still need to choose exactly how if i wanted to send it in a binary format i could send the bites at mikey here and of course the size of that data structure	pointer	105
ok so that's pretty efficient i'm sending hopefully only just kind of four bytes or have a big my integer is the downside of course is that i've immediately declared my protocol to be the same protocol as my cpu representation of their integer and so my code	code	254
and i may need to send other information as well like perhaps i've previously authenticated with this so i'd have to send some kind of session key as well right so i sent all this and then i'm going to get back some data so for example after this let me kind of read from the result so of course this block until it's ready say the number of bytes expected so let me read into my kind of quality kind of length and of course is to be size of then k that tells me that the number of bytes i've got very case so then great i can read into some structure here right so i better call malloc get the right number of bytes ok so will call this late result k and we expect lend bites here and then finally returned results and the caller better actually free up that memory so the last thing we've gotten to do here is to call malloc haircare result i need some bites here	memory	760
and i may need to send other information as well like perhaps i've previously authenticated with this so i'd have to send some kind of session key as well right so i sent all this and then i'm going to get back some data so for example after this let me kind of read from the result so of course this block until it's ready say the number of bytes expected so let me read into my kind of quality kind of length and of course is to be size of then k that tells me that the number of bytes i've got very case so then great i can read into some structure here right so i better call malloc get the right number of bytes ok so will call this late result k and we expect lend bites here and then finally returned results and the caller better actually free up that memory so the last thing we've gotten to do here is to call malloc haircare result i need some bites here	block	301
and however many bytes the other side told me right so what do we think about this code is it secure what problems might be run into well the first thing to notice is that hey where's the where's the error handling we didn't write any we just assumed all my read calls and write calls will work what if the other side say never returned here we're going to block forever here what if the other side mice my server gave me an incomplete result for example it told me hey i'm going to give you a thousand bytes but then didn't give us any so then we do also block is that the desired behavior what if my read calls return negative one what if they only return a partial amount of data so as you can see this is woefully incomplete also we're very trusting we've assumed that the length we're going to get is a valid number of what if instead argue i'm going to actually give you a length of sixteen say billion bytes we're likely to fail with our malakal what if we turn to say in negative number or zero value	block	357
and however many bytes the other side told me right so what do we think about this code is it secure what problems might be run into well the first thing to notice is that hey where's the where's the error handling we didn't write any we just assumed all my read calls and write calls will work what if the other side say never returned here we're going to block forever here what if the other side mice my server gave me an incomplete result for example it told me hey i'm going to give you a thousand bytes but then didn't give us any so then we do also block is that the desired behavior what if my read calls return negative one what if they only return a partial amount of data so as you can see this is woefully incomplete also we're very trusting we've assumed that the length we're going to get is a valid number of what if instead argue i'm going to actually give you a length of sixteen say billion bytes we're likely to fail with our malakal what if we turn to say in negative number or zero value	code	83
and as usual we've assumed that the format of are integers is compatible with a type here and even that the format of our our string incompatible say that it's going to be using ascii it might be using a different kind of character set for example might be using unicode or utf eight etc etc etc so life is never as quite as easy as it appears and as you can see we're doing a lot of work and in fact it's going to be quite slow to call not only making a remote procedure call will also the heat memory as well ok so but that's kind of a feel for why are writing this stuff code is is annoying boilerplate stuff to write ideally we'd have a tool to generate it for us and you've seen one example of that already in the lab with rpc jenn right so this socially now think about how we can kind of marshall all the data that we want to kind of send over the while and how we can une marshall it as well and that's going to be our next video bye	memory	496
and as usual we've assumed that the format of are integers is compatible with a type here and even that the format of our our string incompatible say that it's going to be using ascii it might be using a different kind of character set for example might be using unicode or utf eight etc etc etc so life is never as quite as easy as it appears and as you can see we're doing a lot of work and in fact it's going to be quite slow to call not only making a remote procedure call will also the heat memory as well ok so but that's kind of a feel for why are writing this stuff code is is annoying boilerplate stuff to write ideally we'd have a tool to generate it for us and you've seen one example of that already in the lab with rpc jenn right so this socially now think about how we can kind of marshall all the data that we want to kind of send over the while and how we can une marshall it as well and that's going to be our next video bye	type	80
and as usual we've assumed that the format of are integers is compatible with a type here and even that the format of our our string incompatible say that it's going to be using ascii it might be using a different kind of character set for example might be using unicode or utf eight etc etc etc so life is never as quite as easy as it appears and as you can see we're doing a lot of work and in fact it's going to be quite slow to call not only making a remote procedure call will also the heat memory as well ok so but that's kind of a feel for why are writing this stuff code is is annoying boilerplate stuff to write ideally we'd have a tool to generate it for us and you've seen one example of that already in the lab with rpc jenn right so this socially now think about how we can kind of marshall all the data that we want to kind of send over the while and how we can une marshall it as well and that's going to be our next video bye	code	266
and as usual we've assumed that the format of are integers is compatible with a type here and even that the format of our our string incompatible say that it's going to be using ascii it might be using a different kind of character set for example might be using unicode or utf eight etc etc etc so life is never as quite as easy as it appears and as you can see we're doing a lot of work and in fact it's going to be quite slow to call not only making a remote procedure call will also the heat memory as well ok so but that's kind of a feel for why are writing this stuff code is is annoying boilerplate stuff to write ideally we'd have a tool to generate it for us and you've seen one example of that already in the lab with rpc jenn right so this socially now think about how we can kind of marshall all the data that we want to kind of send over the while and how we can une marshall it as well and that's going to be our next video bye	string	126
ok right so let's talk about our iso images again so remember that if i gave you an iso image perhaps you've downloaded off the internet because you want to install linuxsomewhere you could actually look inside it so the iso image itself is a single file and it adheres to the following standard the so called nine six six oh standard which was a digital format to allow us to use cd roms which of course we designed for audio information but to be able to store digital information on that so so so today of course we barely see any cd roms around but we still use that format because it's sufficiently efficient to be able to distribute complete file systems for example to install some new game or earning complete new operating system right so we used mount in order to mount an ics file using a loop back file system we did that before how can you download things from the command line might have mentioned this before curl is pretty useful cold behaves like cat except rather than specifying file right cull expects http address so you might say ok http something rather right and just like cat it will by default spew all of its contents onto standard output so how can we fix that where you can either redirect it to a file or you can use this minus oh just to say hey figure out a reasonable filename based on the url that we give it here so curl is kind of tremendously useful tool you can even with your web browser	the following	273
ok right so let's talk about our iso images again so remember that if i gave you an iso image perhaps you've downloaded off the internet because you want to install linuxsomewhere you could actually look inside it so the iso image itself is a single file and it adheres to the following standard the so called nine six six oh standard which was a digital format to allow us to use cd roms which of course we designed for audio information but to be able to store digital information on that so so so today of course we barely see any cd roms around but we still use that format because it's sufficiently efficient to be able to distribute complete file systems for example to install some new game or earning complete new operating system right so we used mount in order to mount an ics file using a loop back file system we did that before how can you download things from the command line might have mentioned this before curl is pretty useful cold behaves like cat except rather than specifying file right cull expects http address so you might say ok http something rather right and just like cat it will by default spew all of its contents onto standard output so how can we fix that where you can either redirect it to a file or you can use this minus oh just to say hey figure out a reasonable filename based on the url that we give it here so curl is kind of tremendously useful tool you can even with your web browser	address	1027
ok right so let's talk about our iso images again so remember that if i gave you an iso image perhaps you've downloaded off the internet because you want to install linuxsomewhere you could actually look inside it so the iso image itself is a single file and it adheres to the following standard the so called nine six six oh standard which was a digital format to allow us to use cd roms which of course we designed for audio information but to be able to store digital information on that so so so today of course we barely see any cd roms around but we still use that format because it's sufficiently efficient to be able to distribute complete file systems for example to install some new game or earning complete new operating system right so we used mount in order to mount an ics file using a loop back file system we did that before how can you download things from the command line might have mentioned this before curl is pretty useful cold behaves like cat except rather than specifying file right cull expects http address so you might say ok http something rather right and just like cat it will by default spew all of its contents onto standard output so how can we fix that where you can either redirect it to a file or you can use this minus oh just to say hey figure out a reasonable filename based on the url that we give it here so curl is kind of tremendously useful tool you can even with your web browser	system	653
a way to actually take my iso and say here you go machine boot up using this now i'm not going to try to boot boot up my mac laptop right here using that instead i'm going to boot it up using a virtual machine so a virtual machine the idea is that let's virtualize every single piece of real machine in other words maybe there is a cd rom ok so here it is and a cd rom with an actual cd inside it ok so when it boots up it will actually see the contents of the thing we just the downloaded and in fact the ice image we're going to play with is called damn small linux and it's a fifty megabyte iso file which is a complete little lennox district ok so what else do we need to emulate well we need to emulate more than just a cd rom we need to emulate a complete cpus so for this i'm going to use a fantastic piece of open source code kemu is an emulator an it can emulate entire systems and there's different formats of it for example we could ask it to emulate an amd based cpu system or another kind of cpu but the system that we're going to emulate today is going to be based on a sixty four bit intel architecture so the x eighty six is the kind of original intel format for the cpu and the commands and we are looking at sixty four bit variant so	code	829
a way to actually take my iso and say here you go machine boot up using this now i'm not going to try to boot boot up my mac laptop right here using that instead i'm going to boot it up using a virtual machine so a virtual machine the idea is that let's virtualize every single piece of real machine in other words maybe there is a cd rom ok so here it is and a cd rom with an actual cd inside it ok so when it boots up it will actually see the contents of the thing we just the downloaded and in fact the ice image we're going to play with is called damn small linux and it's a fifty megabyte iso file which is a complete little lennox district ok so what else do we need to emulate well we need to emulate more than just a cd rom we need to emulate a complete cpus so for this i'm going to use a fantastic piece of open source code kemu is an emulator an it can emulate entire systems and there's different formats of it for example we could ask it to emulate an amd based cpu system or another kind of cpu but the system that we're going to emulate today is going to be based on a sixty four bit intel architecture so the x eighty six is the kind of original intel format for the cpu and the commands and we are looking at sixty four bit variant so	system	879
so if i ssh to vm zero one i'm lazy i don't have to keep typing the full host name i wanted to use the following identity file notice i've asked say hey please forward x eleven which is a way to do kind of remote graphics so let's do this great so here we are i'm on this particular machine and we can check the graphics and one way to do that with x is to say let's just run one of the standard little fun things like excise and what i can't open the display oh how annoying right let's try again so let's i want to remember the current working path that we grab that ok so let me exit and do i have so this should work now so ssh v m zero one	the following	99
so now i actually want to run my little qemu command ok so any better find that dsl so i remember it was in a different directory so let me go back to select thirty recursively search there that will find but i can say alright i care about the name in case insensitive minus i name something that ends with i so so great that's what we need right so of course i could actually have a symbolic link 'cause i don't want to keep having to type that so let me just make a symbolic link so l n minus s right and i can call this test dot iso alright so now here i have my test or i so there it is ok	type	436
you could use this then because it's a completely virtual environment is completely emulated this is great for doing things like test builds of a complete lennox system perhaps you want to modify the kernel patch you want to add your own little device driver all you want to try changing the hardware slightly or you don't trust piece of software and you want to isolate it so emulators give you a powerful way to kind of run suspect code in a complete environment	code	434
you could use this then because it's a completely virtual environment is completely emulated this is great for doing things like test builds of a complete lennox system perhaps you want to modify the kernel patch you want to add your own little device driver all you want to try changing the hardware slightly or you don't trust piece of software and you want to isolate it so emulators give you a powerful way to kind of run suspect code in a complete environment	system	162
and for that we really don't need to understand how to work with errors and how to print out errors and how to discover when things don't work so networking is tricky because with things don't work where you actually want to understand what your problem with the client or the server was there a problem in setting up the connection and so dealing with errors becomes quite important areas can be because of code areas we've made but it also can be say because the client has finished the connection before the server had finished saying everything he wanted to say unvoice versa ok so let's start talking about errors that right so	code	408
you want to put out some errors ok so here's first way you've probably seen things like ok i can use p error to print an error to standard error and i can include piece of text here which gets included along with some standard string ok there's also if you prefer a way to get just a simple string and this is it you can say store error and i can ask for a	string	227
the string associated with a particular error number like one two three four five etc etc etc ok but perhaps you want to know what is actually just gone wrong with your program and so if you want to find out the air associated with a recent system call guess what there is something called ever know urdu there we go so i could say please tell me	string	4
the string associated with a particular error number like one two three four five etc etc etc ok but perhaps you want to know what is actually just gone wrong with your program and so if you want to find out the air associated with a recent system call guess what there is something called ever know urdu there we go so i could say please tell me	system	241
the these string associated with the most recent system ever ok so in fact we could re implement pm so if we needed to write kind of piero ourselves we might do something like the following we might say ok so peer error i just want to print out to standard error	the following	176
the these string associated with the most recent system ever ok so in fact we could re implement pm so if we needed to write kind of piero ourselves we might do something like the following we might say ok so peer error i just want to print out to standard error	string	10
the these string associated with the most recent system ever ok so in fact we could re implement pm so if we needed to write kind of piero ourselves we might do something like the following we might say ok so peer error i just want to print out to standard error	system	49
format string to say whatever the user said ok cologne another	string	7
ok and then another string	string	20
right so there's a one big surprising gotcher however with string ever and if the following if we actually read the manpage we discover that let's come back	the following	78
right so there's a one big surprising gotcher however with string ever and if the following if we actually read the manpage we discover that let's come back	string	59
a different color that it is not thread safe	thread	33
video surprise right here we are using this low function inside here and we thought we could do everything we wanted inside our threads it's not thread safe key and if we instead we actually want to write code that is two s dave then	code	205
video surprise right here we are using this low function inside here and we thought we could do everything we wanted inside our threads it's not thread safe key and if we instead we actually want to write code that is two s dave then	thread	128
so the reason for that is that string air itself might return just a hardcoded string literal safer error number one two three four five six etc but if you pass an arbitrary large number it actually constructs	code	73
so the reason for that is that string air itself might return just a hardcoded string literal safer error number one two three four five six etc but if you pass an arbitrary large number it actually constructs	string	31
the string itself and how it might do that well it could call malloc except that stuart air itself doesn't ask you to return anything instead it just returns a pointer so instead internally has some static	string	4
the string itself and how it might do that well it could call malloc except that stuart air itself doesn't ask you to return anything instead it just returns a pointer so instead internally has some static	pointer	160
static memory that it reuses from one call to the next ok so that's our problem that if i'm going to use this in multiple threads i could have one call to store arribe be entered by another call to stuart error	memory	7
static memory that it reuses from one call to the next ok so that's our problem that if i'm going to use this in multiple threads i could have one call to store arribe be entered by another call to stuart error	thread	122
on a different thread an oh dear both of them are now trying to use the same piece of static memory so one hour is going to override the other one right so this kind of common with some of the earlier calls inside posix that they weren't built with with threads in mind and so threat support the ability to work with multiple threads has kind of been reverse engineered back into some of these api calls so stroit error itself with this underscore r will discover actually	memory	93
on a different thread an oh dear both of them are now trying to use the same piece of static memory so one hour is going to override the other one right so this kind of common with some of the earlier calls inside posix that they weren't built with with threads in mind and so threat support the ability to work with multiple threads has kind of been reverse engineered back into some of these api calls so stroit error itself with this underscore r will discover actually	thread	15
doesn't have doesn't take just a simple integer for the integer or no instead you also pass in a pointer to your memory that you would like it to use so here's some memory and typically as well you impasse in how much many as well so we could pull up a terminal window to see the exact order of these things but what i want you to learn yeah there's quite a few of these kind of underscore are variations or variants of existing course and they were added later to posix	memory	113
doesn't have doesn't take just a simple integer for the integer or no instead you also pass in a pointer to your memory that you would like it to use so here's some memory and typically as well you impasse in how much many as well so we could pull up a terminal window to see the exact order of these things but what i want you to learn yeah there's quite a few of these kind of underscore are variations or variants of existing course and they were added later to posix	a terminal	251
doesn't have doesn't take just a simple integer for the integer or no instead you also pass in a pointer to your memory that you would like it to use so here's some memory and typically as well you impasse in how much many as well so we could pull up a terminal window to see the exact order of these things but what i want you to learn yeah there's quite a few of these kind of underscore are variations or variants of existing course and they were added later to posix	pointer	97
in order to make it more thread safe now the last thing you might have been thinking about when i was talking about this is hold on a moment what about earner what is this other thing and wins it set ok so oh no is set by most system calls that can fail so for example read or write set errno to tell you what went wrong so if you call right and it doesn't work	thread	25
in order to make it more thread safe now the last thing you might have been thinking about when i was talking about this is hold on a moment what about earner what is this other thing and wins it set ok so oh no is set by most system calls that can fail so for example read or write set errno to tell you what went wrong so if you call right and it doesn't work	system	227
oh dear it will return negative one but you want to find out more about what went wrong so that information is encoded inside this global variable but wait a moment if i've got a multithreaded program surely it's going to be really hard to figure out which particular thread on which system call caused evernote change	code	113
oh dear it will return negative one but you want to find out more about what went wrong so that information is encoded inside this global variable but wait a moment if i've got a multithreaded program surely it's going to be really hard to figure out which particular thread on which system call caused evernote change	thread	184
oh dear it will return negative one but you want to find out more about what went wrong so that information is encoded inside this global variable but wait a moment if i've got a multithreaded program surely it's going to be really hard to figure out which particular thread on which system call caused evernote change	system	284
yes you are correct and now i'm forced to tell you that actually ok that ever know actually for multithreaded programs	thread	101
is a very special variably behaves like a global variable but actually it's three uses thread local storage which means that each thread gets his own copy thread local storage each thread gets its own copy of error	thread	87
it still behaves like a global variable but the value that each thread reads is actually specific to that thread so now you can confidently say oh yes that most recent call to read	thread	64
or write or say creating a pipe that if it failed then i can read my own value of owner to find out why it fell ok wait so in the next video we're going to talk about what happens when system calls get interrupted i'll see you then bye	system	185
ok let's talk about some malicious attacks against tcp first of all port hijacking so whatever now other malicious user could take over a port so you think you're connecting to our web server but in fact you're connecting to a malicious process listing on the other end pretending to be a web server but in fact just stealing your password etc right so how can we try to prevent this so there's two kind of common mechanisms first of all the idea of privileged ports so as to spell privileged correctly if something like this privileged ports so you know that you need to have root or administrator privileges in order to be able to listen on a port number less than a thousand twenty four ok so you have to have administrative privileges which means that no mere mortal processes can pretend to listen on those ports they already have to be blessed by the administrator of that machine so that's kind of one trust boundary the second is that after you've after a service finishes listening on a port that pause is not immediately available for reuse in fact there's a time out of about two minutes where the you cannot simply start a new server listening on the same port ok so that's the default behavior for tcp under linux and other operating systems we can actually change their behavior so that	system	1247
hi welcome to lecture seven so we're going to look at how to build a shell how to play with signals and how to review some system code so let's start with that here's our first little problem here's some c code and we wanted to see if we can spot any errors in this so let's go through this and see what we see if we can understand how it works what is trying to do and how we might improve it so what do we see ok i get my little pen going right so right i have a our method here main method and i'm checking to see if oxy is not equal to two in other words this little program that expects its own name and some command file to run ok let's find out what that means in a moment and so the usage here is not correct what we wanted was the first string arguments so i could have written argv of zero there	a shell	67
hi welcome to lecture seven so we're going to look at how to build a shell how to play with signals and how to review some system code so let's start with that here's our first little problem here's some c code and we wanted to see if we can spot any errors in this so let's go through this and see what we see if we can understand how it works what is trying to do and how we might improve it so what do we see ok i get my little pen going right so right i have a our method here main method and i'm checking to see if oxy is not equal to two in other words this little program that expects its own name and some command file to run ok let's find out what that means in a moment and so the usage here is not correct what we wanted was the first string arguments so i could have written argv of zero there	code	130
hi welcome to lecture seven so we're going to look at how to build a shell how to play with signals and how to review some system code so let's start with that here's our first little problem here's some c code and we wanted to see if we can spot any errors in this so let's go through this and see what we see if we can understand how it works what is trying to do and how we might improve it so what do we see ok i get my little pen going right so right i have a our method here main method and i'm checking to see if oxy is not equal to two in other words this little program that expects its own name and some command file to run ok let's find out what that means in a moment and so the usage here is not correct what we wanted was the first string arguments so i could have written argv of zero there	string	746
hi welcome to lecture seven so we're going to look at how to build a shell how to play with signals and how to review some system code so let's start with that here's our first little problem here's some c code and we wanted to see if we can spot any errors in this so let's go through this and see what we see if we can understand how it works what is trying to do and how we might improve it so what do we see ok i get my little pen going right so right i have a our method here main method and i'm checking to see if oxy is not equal to two in other words this little program that expects its own name and some command file to run ok let's find out what that means in a moment and so the usage here is not correct what we wanted was the first string arguments so i could have written argv of zero there	system	123
because remember argv itself points to a table of character pointers and then ok good we don't continue we actually call exit all right and we exit with a non zero value not that happy we put all this on one line but it's a good way to be able to show things on just a single screen right now but in production code we would put that on multiple lines so what happens next we sell capacity using this size underscore t so this is unsigned type the great thing about size loyalty is typically a lot larger than just a regular see it anyway we're saying i want to kiss you two hundred	type	439
because remember argv itself points to a table of character pointers and then ok good we don't continue we actually call exit all right and we exit with a non zero value not that happy we put all this on one line but it's a good way to be able to show things on just a single screen right now but in production code we would put that on multiple lines so what happens next we sell capacity using this size underscore t so this is unsigned type the great thing about size loyalty is typically a lot larger than just a regular see it anyway we're saying i want to kiss you two hundred	code	311
because remember argv itself points to a table of character pointers and then ok good we don't continue we actually call exit all right and we exit with a non zero value not that happy we put all this on one line but it's a good way to be able to show things on just a single screen right now but in production code we would put that on multiple lines so what happens next we sell capacity using this size underscore t so this is unsigned type the great thing about size loyalty is typically a lot larger than just a regular see it anyway we're saying i want to kiss you two hundred	pointer	60
and then i malloc that number of bytes ok so if this was production code i would check to see if malloc failed so i would expect here to be some kind of test to see if buffalo was null then print something out and probably exit at that point all right so then we have a signed version of this we're going to use that i'm guessing with get like let's find out in a moment right what do we do next ok now we try to open a file and we use argv of one ok not bad i might have put that inside of variable if i wanted my code with a bit more readable and then we give a hint to the c library that we only want to open this file for reading	code	68
alright so we go around here ok now this is actually kind of common in c code which is just use zero and one for false at times so zero false one for true you could include static ball and use true if you wish ok so get line then we give it the address of our two variables to buffer the capacity and ask it to start reading from a file handle ok and then we put a zero in bytes minus one ok so what's the purpose is what is it trying to do here let's come	code	73
alright so we go around here ok now this is actually kind of common in c code which is just use zero and one for false at times so zero false one for true you could include static ball and use true if you wish ok so get line then we give it the address of our two variables to buffer the capacity and ask it to start reading from a file handle ok and then we put a zero in bytes minus one ok so what's the purpose is what is it trying to do here let's come	address	245
that in a moment for now let's just carry on ok so we do put s which as you know are starts printing out characters until it gets to the end of c string character the null null byte and followed by a newline for us and then we say ok if stricken power so this is going to compare two strings and we pass in two point is the start of the two strings we want to compare and it's going to keep comparing one character at a time from each from the left hand side and the right hand side and either they will be exactly the same in the same length or one of the more finish early so in this case store compare is going to	string	146
that we wanted to actually check to see if this was zero that should be our exit condition to break out of the loop ok so better check in here would be to say look if that is equal to zero alternatively i could have just put an exclamation point in front of store compare this by the way is a common error with stroke compare because we tend to think of it just equals we forget to actually negate the integer output format if the things are different if we did pass into different things it actually returns a integer value which is representative of the ascii difference of where it found the very first difference	the loop	107
ok so will break out of the loop and at this point alarm should be going off because look what we did back here we said ok take that buffer and change the following bytes minus one will say equal to zero and it looks like what the intent here was to try to truncate the string by one byte perhaps to make it a little bit shorter	the following	151
ok so will break out of the loop and at this point alarm should be going off because look what we did back here we said ok take that buffer and change the following bytes minus one will say equal to zero and it looks like what the intent here was to try to truncate the string by one byte perhaps to make it a little bit shorter	the loop	24
ok so will break out of the loop and at this point alarm should be going off because look what we did back here we said ok take that buffer and change the following bytes minus one will say equal to zero and it looks like what the intent here was to try to truncate the string by one byte perhaps to make it a little bit shorter	string	270
oh yeah so this is going to be exciting if bytes is equal to negative one because now we've written into memory that is before the heap area that we were actually using for this so we're program crash maybe will it crash immediately no maybe or crash later when we do some other activities on the heap ok right let's keep on going so what do we do next so now we look at the very first bite of the buffer	memory	105
oh yeah so this is going to be exciting if bytes is equal to negative one because now we've written into memory that is before the heap area that we were actually using for this so we're program crash maybe will it crash immediately no maybe or crash later when we do some other activities on the heap ok right let's keep on going so what do we do next so now we look at the very first bite of the buffer	the heap	127
one piece of code but two process is running and now we can make these two processes start to do different things they have the same history they look behind them all their variables are the same they got the same open files but now we ask each process to evaluate the following if not fork so remember usually if you're the parent when your fault returns you get the parents so the child id but if your child you just get zero as a result so this is where the pound and the child processes are going to diverge going to do different things if you're the child then your return value or fork is zero so this result is true and so the child does the following maybe if we writing production code would actually document that the other quick comment if we were writing better code actually for can return a third value which is negative one to mean an error occured i'm sorry i couldn't make any couldn't clone you i couldn't create hr process perhaps you made too many zombies processes this lying around i just don't have any space right now to make another one	the following	265
one piece of code but two process is running and now we can make these two processes start to do different things they have the same history they look behind them all their variables are the same they got the same open files but now we ask each process to evaluate the following if not fork so remember usually if you're the parent when your fault returns you get the parents so the child id but if your child you just get zero as a result so this is where the pound and the child processes are going to diverge going to do different things if you're the child then your return value or fork is zero so this result is true and so the child does the following maybe if we writing production code would actually document that the other quick comment if we were writing better code actually for can return a third value which is negative one to mean an error occured i'm sorry i couldn't make any couldn't clone you i couldn't create hr process perhaps you made too many zombies processes this lying around i just don't have any space right now to make another one	code	13
but anyway let's to see what let's see what we do for the child so the child calls exec and particular version of held x lp which says look in the path and we're just going to pass in some arguments ok so what do you think about these arguments and what's going on so what we like and what don't we like well first of all we're passing in the following string buffer plus one why are we passing in buffer plus one well if we went back and actually with the read the instructions we discovered that the idea is that if the very first part of the line that we've read has a exclamation point	the following	339
but anyway let's to see what let's see what we do for the child so the child calls exec and particular version of held x lp which says look in the path and we're just going to pass in some arguments ok so what do you think about these arguments and what's going on so what we like and what don't we like well first of all we're passing in the following string buffer plus one why are we passing in buffer plus one well if we went back and actually with the read the instructions we discovered that the idea is that if the very first part of the line that we've read has a exclamation point	string	353
a line of code interpreter line of code for us well not quite here's here's our first mistake that i would like to change here is that remember you have to specify the first thing twice this is the name of the file we'd like to find on the disk on the path somewhere please load that in and give this little child processor head transplant stop running my code in one that instead	code	10
and then we better actually say what the process name is going to be and so typically that's the same thing so typically you would write to bash here as well as you fight it a second time ok now bash might need some arguments to tell it to actually execute that so let's come back to that a little bit and check that ok this is good we are terminating arguments are verbal arguments with null pointer that's a hint to say to exec ok i've got nothing left after this so why do i have the exit one here well remember it could be that i can't actually call exec with bash perhaps bash is not installed on the same system so that could be a reason for exact to fail	system	611
and then we better actually say what the process name is going to be and so typically that's the same thing so typically you would write to bash here as well as you fight it a second time ok now bash might need some arguments to tell it to actually execute that so let's come back to that a little bit and check that ok this is good we are terminating arguments are verbal arguments with null pointer that's a hint to say to exec ok i've got nothing left after this so why do i have the exit one here well remember it could be that i can't actually call exec with bash perhaps bash is not installed on the same system so that could be a reason for exact to fail	pointer	393
and at this point life gets exciting because we're using fork so now i have two processes that will jump out of this little if statement and go back to our while loop so going around again and attempting to read the next line from the file and what will those do well if they call fork then they both of them will end up creating more processes and i would have four processes if i go around again and then you both managed to read another line each i'd now have a processes and sixteen and thirty two and pretty much we have agent smith in the matrix type trying to take over the world ok unfortunately it doesn't take over the world instead he just pretends to bring our poor machine to a grinding halt unable to do anymore work for us ok so let's go back just a couple of things that we skipped over and figure out what we should do with him first of all why was this flush here so this is	type	552
and at this point life gets exciting because we're using fork so now i have two processes that will jump out of this little if statement and go back to our while loop so going around again and attempting to read the next line from the file and what will those do well if they call fork then they both of them will end up creating more processes and i would have four processes if i go around again and then you both managed to read another line each i'd now have a processes and sixteen and thirty two and pretty much we have agent smith in the matrix type trying to take over the world ok unfortunately it doesn't take over the world instead he just pretends to bring our poor machine to a grinding halt unable to do anymore work for us ok so let's go back just a couple of things that we skipped over and figure out what we should do with him first of all why was this flush here so this is	a process	463
they can interact is not necessarily senseable when the child process exits in fact it's worse than just having this line we actually need to do flush on all of our open file handles and so here's another one we better actually call f flush on our input here as well if you had printed some things out and he wanted to make sure that they truly had left the c library you could also use eh flush on any of your output as well but this particular annoying fact right now for two thousand nineteen at least seems to be the best way to ensure that even though my child is running that my prove my parent can successfully continued to read this command file ok so let's get out of this and then we'll start kind of going through and light and running this we had a nice little talk about that so i think yeah so i think the next thing will do is actually kind of have a look at the actual code ok so i've got	code	885
and should be the code we just believe that's hard to read isn't it that's not do that today ok let's use my	code	18
just jump straight into the solution and have a play with this ok so we talked already about the things we want to change oh yeah this is exactly the same so i was sketching out a solution that said rv of zero which you know is actually exactly the same as writing argv plus zero and then dereferencing that that memory ok but we don't need the plus zero so we could be rather cheeky	memory	313
have a look at repeated get line so the first thing we wanted to check was to see if bites was negative one and break out of the loop early before we start modifying anything this second thing is we were actually getting rid of that last line that last character sorry in case it had a new line and that's usually true but doesn't need to be true at the very very last line of text file so we've got a test that bites now should be greater than zero otherwise it doesn't make sense to	the loop	125
ok so now will print it out so we can see what's going on here is our chests test for stroke hump and finally our let's call bash on that the other thing that we've got in our final piece of code here is that we've cleaned up the resources	code	191
ok so now will print it out so we can see what's going on here is our chests test for stroke hump and finally our let's call bash on that the other thing that we've got in our final piece of code here is that we've cleaned up the resources	resources	230
ok so this little demo is actually going to finish pretty quickly but in real production code which doesn't finish quickly it's important to make sure that we released everything that we've asked for from the system so in this case we want to free up the memory that we called we used for getline that will either be the original malloc we called or some new memory get line is used an then don't forget our little file handle as well and if we want to be good citizens we could also change our little file pointer here to be null just so no one could use it after that ok like i said there's a kind of overengineered for this small amount of code but i hope you understand the intent behind it right so can we run this ok let's let's set up some test examples let's see what we have here let's have a look at some little problems little examples scripts i've got here i've got one which	memory	255
ok so this little demo is actually going to finish pretty quickly but in real production code which doesn't finish quickly it's important to make sure that we released everything that we've asked for from the system so in this case we want to free up the memory that we called we used for getline that will either be the original malloc we called or some new memory get line is used an then don't forget our little file handle as well and if we want to be good citizens we could also change our little file pointer here to be null just so no one could use it after that ok like i said there's a kind of overengineered for this small amount of code but i hope you understand the intent behind it right so can we run this ok let's let's set up some test examples let's see what we have here let's have a look at some little problems little examples scripts i've got here i've got one which	code	89
ok so this little demo is actually going to finish pretty quickly but in real production code which doesn't finish quickly it's important to make sure that we released everything that we've asked for from the system so in this case we want to free up the memory that we called we used for getline that will either be the original malloc we called or some new memory get line is used an then don't forget our little file handle as well and if we want to be good citizens we could also change our little file pointer here to be null just so no one could use it after that ok like i said there's a kind of overengineered for this small amount of code but i hope you understand the intent behind it right so can we run this ok let's let's set up some test examples let's see what we have here let's have a look at some little problems little examples scripts i've got here i've got one which	system	209
ok so this little demo is actually going to finish pretty quickly but in real production code which doesn't finish quickly it's important to make sure that we released everything that we've asked for from the system so in this case we want to free up the memory that we called we used for getline that will either be the original malloc we called or some new memory get line is used an then don't forget our little file handle as well and if we want to be good citizens we could also change our little file pointer here to be null just so no one could use it after that ok like i said there's a kind of overengineered for this small amount of code but i hope you understand the intent behind it right so can we run this ok let's let's set up some test examples let's see what we have here let's have a look at some little problems little examples scripts i've got here i've got one which	pointer	507
sorry i'm looking at one thing i was looking at command stop text ok there we go right so this is the text file that we're going to pass to that code so the very first line of this file	code	145
and this is kind of the beginning as well of how i can think about shells and i've got processes which i can start and run concurrently now i can write little c programs which will actually say start multiple compilers at the same time ok so that's kind of put it altogether we've got the ability to read in bits of strings manipulate string memory thinking about forking and exacting and using all this together but of course what do we do here we made some zombies because we never waited on this process is so we're going to have to think about how to fix that in the future and for that we'll need signals	memory	342
and this is kind of the beginning as well of how i can think about shells and i've got processes which i can start and run concurrently now i can write little c programs which will actually say start multiple compilers at the same time ok so that's kind of put it altogether we've got the ability to read in bits of strings manipulate string memory thinking about forking and exacting and using all this together but of course what do we do here we made some zombies because we never waited on this process is so we're going to have to think about how to fix that in the future and for that we'll need signals	string	316
hi ok so let's have a look at how we can write some code which is non deterministic and then fix it up in different ways so here we go let's get started right i've got a little main method down here and i'm going to create ten threads and each time i go to store the address inside my little ray here of thread i ds and then i call pizza at exit so we know that at that point the main thread is done ok but the rest of the process lives on our ten little fence live on ok what do they do case so here's our game plan let's	code	52
hi ok so let's have a look at how we can write some code which is non deterministic and then fix it up in different ways so here we go let's get started right i've got a little main method down here and i'm going to create ten threads and each time i go to store the address inside my little ray here of thread i ds and then i call pizza at exit so we know that at that point the main thread is done ok but the rest of the process lives on our ten little fence live on ok what do they do case so here's our game plan let's	thread	227
hi ok so let's have a look at how we can write some code which is non deterministic and then fix it up in different ways so here we go let's get started right i've got a little main method down here and i'm going to create ten threads and each time i go to store the address inside my little ray here of thread i ds and then i call pizza at exit so we know that at that point the main thread is done ok but the rest of the process lives on our ten little fence live on ok what do they do case so here's our game plan let's	address	267
there's pass in the address of my little iterate available	address	20
so we'll find out its address not as valuable 's address	address	22
and then here's an expression to read that value how does this work ok so we know when finally were assigned a new cpu to start this function that we're given address what do i want to do with that address well i know something is stored there and i know that that's something isn't is just so in fact i want to treat that address as an integer pointer great so now i have that integer pointer i actually want to read whatsapp their contents so let me dereference it with little ass tricks there ok so we've got the value now we've been seeing how we can create p thread i ds	thread	564
and then here's an expression to read that value how does this work ok so we know when finally were assigned a new cpu to start this function that we're given address what do i want to do with that address well i know something is stored there and i know that that's something isn't is just so in fact i want to treat that address as an integer pointer great so now i have that integer pointer i actually want to read whatsapp their contents so let me dereference it with little ass tricks there ok so we've got the value now we've been seeing how we can create p thread i ds	address	159
and then here's an expression to read that value how does this work ok so we know when finally were assigned a new cpu to start this function that we're given address what do i want to do with that address well i know something is stored there and i know that that's something isn't is just so in fact i want to treat that address as an integer pointer great so now i have that integer pointer i actually want to read whatsapp their contents so let me dereference it with little ass tricks there ok so we've got the value now we've been seeing how we can create p thread i ds	pointer	345
every time we call pisode create but what if you wanted to know your own idea what if you said what's my id how would how would i determine that so there should be a way to do this and there is so we say my id is p thread itself so that's the other way of getting a thread id if you want to know who you are something which represents a particular thread then you call peter itself right less for fun printed out which is not normal behaviour normally don't print out these i ds one way to do this we will just treat it as a pointer to some memory so let's say that this id represents some integer type thing which is some address type things or just print it out and now i've got a void pointer i can use percent p to say right treat this doesn't address ok so will pick that up and if we wanted we could play the same trick down here we put this out but	memory	541
every time we call pisode create but what if you wanted to know your own idea what if you said what's my id how would how would i determine that so there should be a way to do this and there is so we say my id is p thread itself so that's the other way of getting a thread id if you want to know who you are something which represents a particular thread then you call peter itself right less for fun printed out which is not normal behaviour normally don't print out these i ds one way to do this we will just treat it as a pointer to some memory so let's say that this id represents some integer type thing which is some address type things or just print it out and now i've got a void pointer i can use percent p to say right treat this doesn't address ok so will pick that up and if we wanted we could play the same trick down here we put this out but	type	598
every time we call pisode create but what if you wanted to know your own idea what if you said what's my id how would how would i determine that so there should be a way to do this and there is so we say my id is p thread itself so that's the other way of getting a thread id if you want to know who you are something which represents a particular thread then you call peter itself right less for fun printed out which is not normal behaviour normally don't print out these i ds one way to do this we will just treat it as a pointer to some memory so let's say that this id represents some integer type thing which is some address type things or just print it out and now i've got a void pointer i can use percent p to say right treat this doesn't address ok so will pick that up and if we wanted we could play the same trick down here we put this out but	a thread	264
every time we call pisode create but what if you wanted to know your own idea what if you said what's my id how would how would i determine that so there should be a way to do this and there is so we say my id is p thread itself so that's the other way of getting a thread id if you want to know who you are something which represents a particular thread then you call peter itself right less for fun printed out which is not normal behaviour normally don't print out these i ds one way to do this we will just treat it as a pointer to some memory so let's say that this id represents some integer type thing which is some address type things or just print it out and now i've got a void pointer i can use percent p to say right treat this doesn't address ok so will pick that up and if we wanted we could play the same trick down here we put this out but	thread	215
every time we call pisode create but what if you wanted to know your own idea what if you said what's my id how would how would i determine that so there should be a way to do this and there is so we say my id is p thread itself so that's the other way of getting a thread id if you want to know who you are something which represents a particular thread then you call peter itself right less for fun printed out which is not normal behaviour normally don't print out these i ds one way to do this we will just treat it as a pointer to some memory so let's say that this id represents some integer type thing which is some address type things or just print it out and now i've got a void pointer i can use percent p to say right treat this doesn't address ok so will pick that up and if we wanted we could play the same trick down here we put this out but	address	623
every time we call pisode create but what if you wanted to know your own idea what if you said what's my id how would how would i determine that so there should be a way to do this and there is so we say my id is p thread itself so that's the other way of getting a thread id if you want to know who you are something which represents a particular thread then you call peter itself right less for fun printed out which is not normal behaviour normally don't print out these i ds one way to do this we will just treat it as a pointer to some memory so let's say that this id represents some integer type thing which is some address type things or just print it out and now i've got a void pointer i can use percent p to say right treat this doesn't address ok so will pick that up and if we wanted we could play the same trick down here we put this out but	pointer	525
ok alright so it looks like it's kind of working but not as well as we hoped we certainly got different thread ideas appearing and they do look like addresses i'll give you that but look at this we've got very strange values over here and even the last value is ten and if i run it again i get different values again if i run it again i get different values again ok so i get in all sorts of values here what is going on clearly we've got a program which is not deterministic we don't know what it's going to print out ok so why did that happen	thread	104
ok alright so it looks like it's kind of working but not as well as we hoped we certainly got different thread ideas appearing and they do look like addresses i'll give you that but look at this we've got very strange values over here and even the last value is ten and if i run it again i get different values again if i run it again i get different values again ok so i get in all sorts of values here what is going on clearly we've got a program which is not deterministic we don't know what it's going to print out ok so why did that happen	address	149
well hopefully you can see that we passed in the address of i and so actually what we have here is called a race condition it depends upon the exact interleaving in time of the instructions that are going to be executed i've got one thread that immediately after calling pete said quit going to create is going to increment the value of i and then test to see if i is less than ten i have not go around again so we've got one thread doing that as fast as it as fast as it can and i got another thread that as soon as it starts will gas that pointer to an end pointer and then try to read it so the value that it sees depends upon the relative timing of these operations and that can change from one run to the next you might be surprised we even saw the value of ten even though our loop says is i lesson ten yes so that's why our threads can start at some point in the future maybe few microseconds but maybe a millisecond maybe much longer and some point we're going to escape how did this this for loop so at that point the value of i will be equal to ten because that was our exit condition	thread	233
well hopefully you can see that we passed in the address of i and so actually what we have here is called a race condition it depends upon the exact interleaving in time of the instructions that are going to be executed i've got one thread that immediately after calling pete said quit going to create is going to increment the value of i and then test to see if i is less than ten i have not go around again so we've got one thread doing that as fast as it as fast as it can and i got another thread that as soon as it starts will gas that pointer to an end pointer and then try to read it so the value that it sees depends upon the relative timing of these operations and that can change from one run to the next you might be surprised we even saw the value of ten even though our loop says is i lesson ten yes so that's why our threads can start at some point in the future maybe few microseconds but maybe a millisecond maybe much longer and some point we're going to escape how did this this for loop so at that point the value of i will be equal to ten because that was our exit condition	address	49
well hopefully you can see that we passed in the address of i and so actually what we have here is called a race condition it depends upon the exact interleaving in time of the instructions that are going to be executed i've got one thread that immediately after calling pete said quit going to create is going to increment the value of i and then test to see if i is less than ten i have not go around again so we've got one thread doing that as fast as it as fast as it can and i got another thread that as soon as it starts will gas that pointer to an end pointer and then try to read it so the value that it sees depends upon the relative timing of these operations and that can change from one run to the next you might be surprised we even saw the value of ten even though our loop says is i lesson ten yes so that's why our threads can start at some point in the future maybe few microseconds but maybe a millisecond maybe much longer and some point we're going to escape how did this this for loop so at that point the value of i will be equal to ten because that was our exit condition	pointer	541
but it gets worse than that because formally the value of this variable is not defined outside of this loop and in fact when we call pizza at exit we don't even need the stack anymore for maine so the memory that we might be reading at that point is no longer really hours to be looking at so we've got a pretty badly formed program here right so how can we fix it we need to address this race condition right will do it in two different ways first of all how about we turn this into a task that we give each one and my task right now is just know the little integer so let's have some memory for each thread so i'll call it say starting values and you can see i'm using a global here right and it will be let's see i'll have ten am ok and i can initialize these which i could do as part of this loop or i could do it earlier ok so you can be let's say hundred plus are you today just so we can prove that we're running this program ok and then i don't want to pass in the address if i instead i want to pass in my pointer to one of these integers i've just created so starting values and i could say take the ice warren i want the address of that but you know that we can also write that is just ok here's the start of the array i want the offset of i please and will use integer arithmetic ok so we've initialized array let's give this ago and off we go so will compile it ok	memory	201
but it gets worse than that because formally the value of this variable is not defined outside of this loop and in fact when we call pizza at exit we don't even need the stack anymore for maine so the memory that we might be reading at that point is no longer really hours to be looking at so we've got a pretty badly formed program here right so how can we fix it we need to address this race condition right will do it in two different ways first of all how about we turn this into a task that we give each one and my task right now is just know the little integer so let's have some memory for each thread so i'll call it say starting values and you can see i'm using a global here right and it will be let's see i'll have ten am ok and i can initialize these which i could do as part of this loop or i could do it earlier ok so you can be let's say hundred plus are you today just so we can prove that we're running this program ok and then i don't want to pass in the address if i instead i want to pass in my pointer to one of these integers i've just created so starting values and i could say take the ice warren i want the address of that but you know that we can also write that is just ok here's the start of the array i want the offset of i please and will use integer arithmetic ok so we've initialized array let's give this ago and off we go so will compile it ok	thread	602
but it gets worse than that because formally the value of this variable is not defined outside of this loop and in fact when we call pizza at exit we don't even need the stack anymore for maine so the memory that we might be reading at that point is no longer really hours to be looking at so we've got a pretty badly formed program here right so how can we fix it we need to address this race condition right will do it in two different ways first of all how about we turn this into a task that we give each one and my task right now is just know the little integer so let's have some memory for each thread so i'll call it say starting values and you can see i'm using a global here right and it will be let's see i'll have ten am ok and i can initialize these which i could do as part of this loop or i could do it earlier ok so you can be let's say hundred plus are you today just so we can prove that we're running this program ok and then i don't want to pass in the address if i instead i want to pass in my pointer to one of these integers i've just created so starting values and i could say take the ice warren i want the address of that but you know that we can also write that is just ok here's the start of the array i want the offset of i please and will use integer arithmetic ok so we've initialized array let's give this ago and off we go so will compile it ok	address	376
but it gets worse than that because formally the value of this variable is not defined outside of this loop and in fact when we call pizza at exit we don't even need the stack anymore for maine so the memory that we might be reading at that point is no longer really hours to be looking at so we've got a pretty badly formed program here right so how can we fix it we need to address this race condition right will do it in two different ways first of all how about we turn this into a task that we give each one and my task right now is just know the little integer so let's have some memory for each thread so i'll call it say starting values and you can see i'm using a global here right and it will be let's see i'll have ten am ok and i can initialize these which i could do as part of this loop or i could do it earlier ok so you can be let's say hundred plus are you today just so we can prove that we're running this program ok and then i don't want to pass in the address if i instead i want to pass in my pointer to one of these integers i've just created so starting values and i could say take the ice warren i want the address of that but you know that we can also write that is just ok here's the start of the array i want the offset of i please and will use integer arithmetic ok so we've initialized array let's give this ago and off we go so will compile it ok	pointer	1015
we know deterministically that we're going to get the values between a hundred and a hundred and nine those threads can run in an arbitrary order so the output is not guaranteed to be in exactly the same app or ordering that we actually defined it inside the code so let's have a look at kind of one more alternative here to make a program completely deterministic here's what i'm going to do i'm going to say p thread	code	259
we know deterministically that we're going to get the values between a hundred and a hundred and nine those threads can run in an arbitrary order so the output is not guaranteed to be in exactly the same app or ordering that we actually defined it inside the code so let's have a look at kind of one more alternative here to make a program completely deterministic here's what i'm going to do i'm going to say p thread	thread	108
join an i want to join on not the address of thread id but the actual value itself and i don't care about the exit value so don't write that anywhere ok alright so what's going to happen now first of all let me run it and then you can tell me why ok so let's clear this clear that's compiled let's run ok and this time i'm extremely confident we're going to see the same same output for the integers and they will be in order why am i so confident	thread	45
join an i want to join on not the address of thread id but the actual value itself and i don't care about the exit value so don't write that anywhere ok alright so what's going to happen now first of all let me run it and then you can tell me why ok so let's clear this clear that's compiled let's run ok and this time i'm extremely confident we're going to see the same same output for the integers and they will be in order why am i so confident	address	34
so let's have a look at the code we vote we created a thread and the main thread can return and carry on there's no requirement for it to wait for that thread to get started but what do we do we immediately say ok now i want to block i want to wait until i'm able to join on the other thread so that means before we get to go around the loop before we add two hundred dollars and go round the when opoly board again right before we get to say i plus plus in his eye lesson ten we have to run and complete the code inside my funk we have to read the value we print out we get the thread id self we print something out and return null and those steps have to occur in order for pizza joint to letters out of jail so we are extremely confident that i know for certain that my funk will finish this execution before we get to use another loop ok so we've made shell program completely terministic but at what cost yes ladies and gentlemen we've written the most complicated version of printing out the numbers from zero to nine by creating threads and each waiting for each thread in turn to finish so now we've lost the performance of having a multi threats because we've only actually ever got one thread doing anything useful at a time either the main thread is running or is created in new thread to do one simple action and then that finishes and back goes the main thread in it or something again and so on so we had this kind of a hand over which is a	the loop	333
so let's have a look at the code we vote we created a thread and the main thread can return and carry on there's no requirement for it to wait for that thread to get started but what do we do we immediately say ok now i want to block i want to wait until i'm able to join on the other thread so that means before we get to go around the loop before we add two hundred dollars and go round the when opoly board again right before we get to say i plus plus in his eye lesson ten we have to run and complete the code inside my funk we have to read the value we print out we get the thread id self we print something out and return null and those steps have to occur in order for pizza joint to letters out of jail so we are extremely confident that i know for certain that my funk will finish this execution before we get to use another loop ok so we've made shell program completely terministic but at what cost yes ladies and gentlemen we've written the most complicated version of printing out the numbers from zero to nine by creating threads and each waiting for each thread in turn to finish so now we've lost the performance of having a multi threats because we've only actually ever got one thread doing anything useful at a time either the main thread is running or is created in new thread to do one simple action and then that finishes and back goes the main thread in it or something again and so on so we had this kind of a hand over which is a	block	228
so let's have a look at the code we vote we created a thread and the main thread can return and carry on there's no requirement for it to wait for that thread to get started but what do we do we immediately say ok now i want to block i want to wait until i'm able to join on the other thread so that means before we get to go around the loop before we add two hundred dollars and go round the when opoly board again right before we get to say i plus plus in his eye lesson ten we have to run and complete the code inside my funk we have to read the value we print out we get the thread id self we print something out and return null and those steps have to occur in order for pizza joint to letters out of jail so we are extremely confident that i know for certain that my funk will finish this execution before we get to use another loop ok so we've made shell program completely terministic but at what cost yes ladies and gentlemen we've written the most complicated version of printing out the numbers from zero to nine by creating threads and each waiting for each thread in turn to finish so now we've lost the performance of having a multi threats because we've only actually ever got one thread doing anything useful at a time either the main thread is running or is created in new thread to do one simple action and then that finishes and back goes the main thread in it or something again and so on so we had this kind of a hand over which is a	code	28
so let's have a look at the code we vote we created a thread and the main thread can return and carry on there's no requirement for it to wait for that thread to get started but what do we do we immediately say ok now i want to block i want to wait until i'm able to join on the other thread so that means before we get to go around the loop before we add two hundred dollars and go round the when opoly board again right before we get to say i plus plus in his eye lesson ten we have to run and complete the code inside my funk we have to read the value we print out we get the thread id self we print something out and return null and those steps have to occur in order for pizza joint to letters out of jail so we are extremely confident that i know for certain that my funk will finish this execution before we get to use another loop ok so we've made shell program completely terministic but at what cost yes ladies and gentlemen we've written the most complicated version of printing out the numbers from zero to nine by creating threads and each waiting for each thread in turn to finish so now we've lost the performance of having a multi threats because we've only actually ever got one thread doing anything useful at a time either the main thread is running or is created in new thread to do one simple action and then that finishes and back goes the main thread in it or something again and so on so we had this kind of a hand over which is a	a thread	52
so let's have a look at the code we vote we created a thread and the main thread can return and carry on there's no requirement for it to wait for that thread to get started but what do we do we immediately say ok now i want to block i want to wait until i'm able to join on the other thread so that means before we get to go around the loop before we add two hundred dollars and go round the when opoly board again right before we get to say i plus plus in his eye lesson ten we have to run and complete the code inside my funk we have to read the value we print out we get the thread id self we print something out and return null and those steps have to occur in order for pizza joint to letters out of jail so we are extremely confident that i know for certain that my funk will finish this execution before we get to use another loop ok so we've made shell program completely terministic but at what cost yes ladies and gentlemen we've written the most complicated version of printing out the numbers from zero to nine by creating threads and each waiting for each thread in turn to finish so now we've lost the performance of having a multi threats because we've only actually ever got one thread doing anything useful at a time either the main thread is running or is created in new thread to do one simple action and then that finishes and back goes the main thread in it or something again and so on so we had this kind of a hand over which is a	thread	54
hi so let's workout with the following piece of code does this is pretty obtuse stuff we wouldn't expect	the following	25
hi so let's workout with the following piece of code does this is pretty obtuse stuff we wouldn't expect	code	48
a programmer that hasn't seen you system programming to understand it so let's break it down and see what's going on right now is actually based on kind of real bits of system code that i've seen ok alright so first thing is close one what is going on here right so you know and i know that by default your little process has three file descriptors little integers start with zero the allow us to read and write and we get by default three stdin stdout stderr<br> and we've just close standard out and immediately we call open so we're asking for a new file descriptor and we are giving it a filename log dot text now we're giving some hints about how we want you want to use this we want to open this we'd invite if it doesn't exist please create it if it does exist then append to the end and if you're going to create a new file is important to give some some permissions about whether the file can be read or written by this user and other people as well if you forget to put this third argument in then open will use whatever value happens to be on the stack at the time and that could be zero meaning that hey in the future you'll have a hard time deleting this file not opening it because you won't have any permissions but we're going to use iruser and iwuser is using meaning that the user has read in my permissions	code	176
a programmer that hasn't seen you system programming to understand it so let's break it down and see what's going on right now is actually based on kind of real bits of system code that i've seen ok alright so first thing is close one what is going on here right so you know and i know that by default your little process has three file descriptors little integers start with zero the allow us to read and write and we get by default three stdin stdout stderr<br> and we've just close standard out and immediately we call open so we're asking for a new file descriptor and we are giving it a filename log dot text now we're giving some hints about how we want you want to use this we want to open this we'd invite if it doesn't exist please create it if it does exist then append to the end and if you're going to create a new file is important to give some some permissions about whether the file can be read or written by this user and other people as well if you forget to put this third argument in then open will use whatever value happens to be on the stack at the time and that could be zero meaning that hey in the future you'll have a hard time deleting this file not opening it because you won't have any permissions but we're going to use iruser and iwuser is using meaning that the user has read in my permissions	system	34
where can you find out all of this stuff the answer is to look at these section two of the man page so you would write man s two	section	72
ok right so we're doing low levels things with file scripters but we've jumped back up into the c library where we say put string in other words print out the following to standard error and	the following	155
ok right so we're doing low levels things with file scripters but we've jumped back up into the c library where we say put string in other words print out the following to standard error and	string	123
with a new line and then call chdir what does chdir do do as a read the man page chdir is being changed current working directory of this process every process has current directory usually it's the current directory where the parent process started but now we want to change it we're going to change it to slash bin so what are we going to do with this and you'll see that we're going to use it in a moment when we talk about the current directory here we're going to call exec next to say please find the following program we've specified it's full path called ls and you can run it under the process name of slash band slash ls and we're just giving it an argument of dot meaning the current directory so this is actually going to run	the following	503
and you'll find on your system under the slash bin directory and so there's a favorite you probably used it before like cp to copy files share more to change some written by permissions on files we can find out our host name we can make directories these actually all just title c programs which will slide in slide being so i could have done example s been and i would have seen the same thing as well ok but wait the moment our little log never actually had the captains log in fact if i look at the first few lines so if i was to look at dog text there's nothing there what happened to it why do you think that the output of running ls made it into my log file	system	24
ok and the answer to this riddle is because we gave it a head transplant is because we call it exec an exact threw away all of the existing memory of our process and inside that memory is	memory	140
the c libraries buffer for standard out it was getting ready to send out captains log it was making a promise in the future to write it out but it never got around to it and before it had a chance to do so we killed all that memory	memory	225
ok right so that's a lot of fun putting a whole load of different system ideas together in our next video	system	66
ok so we didn't need a definition for deadlock and this idea that our our threads are frozen up maybe one thread is waiting for a mutex lock that is never going to be unlocked maybe we're waiting for something from a data structure which is never going to be given to us so here's a general definition for dead log key	a struct	220
ok so we didn't need a definition for deadlock and this idea that our our threads are frozen up maybe one thread is waiting for a mutex lock that is never going to be unlocked maybe we're waiting for something from a data structure which is never going to be given to us so here's a general definition for dead log key	a mutex	128
ok so we didn't need a definition for deadlock and this idea that our our threads are frozen up maybe one thread is waiting for a mutex lock that is never going to be unlocked maybe we're waiting for something from a data structure which is never going to be given to us so here's a general definition for dead log key	thread	74
well ok can i type so i put in some in there ok	type	14
make this thread exit it's never going to happen ok so our poor poor little fair door process is waiting some for an event maybe we're going to signal that event using a variable or some other method and it's just never going to happen so it doesn't get to complete it doesn't get to kind of run its activity or run the code and of course debugging deadlock is tricky it's often there as pairs that i could a thread maybe it's stuck inside p threat condition wait and we don't know why why that event doesn't hasn't hasn't fired hasn't occured	code	320
make this thread exit it's never going to happen ok so our poor poor little fair door process is waiting some for an event maybe we're going to signal that event using a variable or some other method and it's just never going to happen so it doesn't get to complete it doesn't get to kind of run its activity or run the code and of course debugging deadlock is tricky it's often there as pairs that i could a thread maybe it's stuck inside p threat condition wait and we don't know why why that event doesn't hasn't hasn't fired hasn't occured	a thread	407
make this thread exit it's never going to happen ok so our poor poor little fair door process is waiting some for an event maybe we're going to signal that event using a variable or some other method and it's just never going to happen so it doesn't get to complete it doesn't get to kind of run its activity or run the code and of course debugging deadlock is tricky it's often there as pairs that i could a thread maybe it's stuck inside p threat condition wait and we don't know why why that event doesn't hasn't hasn't fired hasn't occured	thread	10
ok so we've got this general definition of deadlock now actually let's see if we can kind of construct some examples where we actually cause it so let's use team mutex locks and two threads to create an example of deadlock ok bye i'm going to actually do this in a text editor ok	thread	182
let's go right do i have so if i've got thread one imagine my thread first red make the coda bigger right has called	thread	40
p thread mutex lock k and we're going to say please lock on this first mutex and then after you've done that please lock on this other mutex right so it will do some work ok do something and then after that we want to at least ok so we will call p thread unlock on both of these mutex is ok	thread	2
so for example maybe we want to take some data out of out of data store one stick it into data structure to ok it doesn't matter particular which order that we released them in just for symmetry i'm going to do it this way but let's let's think about what happens if we lock these in a different sequence inside another thread so i'm going to have now another thread that does the same sequence of operations accept ha we have swapped these around the case so we swap these two lights ok so is this a problem	a struct	93
so for example maybe we want to take some data out of out of data store one stick it into data structure to ok it doesn't matter particular which order that we released them in just for symmetry i'm going to do it this way but let's let's think about what happens if we lock these in a different sequence inside another thread so i'm going to have now another thread that does the same sequence of operations accept ha we have swapped these around the case so we swap these two lights ok so is this a problem	thread	320
like most of the time no most of the time my threads are perfectly happy doing what they need to do until the following happens until one unfortunate day thread one has called preferred mutex lock on get this choose a new color	the following	106
like most of the time no most of the time my threads are perfectly happy doing what they need to do until the following happens until one unfortunate day thread one has called preferred mutex lock on get this choose a new color	thread	45
called prefix lock on the first one case is completed that at the same time my other thread which is curiously called thread one so let's fix that thread	thread	85
so now they were both able to do this but what happens next ok i think we should choose a new color for this let's go for yes it's kinda extreme pinky purple thing let's try that ok right so now what happens thread one says i'd like to lock this mutex but of course what	thread	208
does this do it blocks ok why because another thread has that new texts between you and me we know it's thread two meanwhile thread two tries to look	block	16
does this do it blocks ok why because another thread has that new texts between you and me we know it's thread two meanwhile thread two tries to look	thread	46
it takes one and that of course blocks	block	32
it's not yet available another thread is currently quite that musics lock ok so when will we escape out of this and the answer is never ok we can read the code and see that eventually we're going to release these locks but we're never going to get to that that piece of code that thread one is waiting for thread two and thread two is waiting for thread one so it's kind of stuck for stuck forever	code	155
it's not yet available another thread is currently quite that musics lock ok so when will we escape out of this and the answer is never ok we can read the code and see that eventually we're going to release these locks but we're never going to get to that that piece of code that thread one is waiting for thread two and thread two is waiting for thread one so it's kind of stuck for stuck forever	thread	31
ok i am not occured because we constructed this with the locks being acquired in a different order if they were in the same order it would have been fine let's just kind of quickly sketch that out to see that let's imagine that i had my first thread doing mutex worn and then mute x two and then mutex wanna mutex two down here for thread two then if they both try to acquire mutex in at the same time then we can imagine that thread one would acquire the mutex lock here which would mean thread two will be forced to block	block	518
ok i am not occured because we constructed this with the locks being acquired in a different order if they were in the same order it would have been fine let's just kind of quickly sketch that out to see that let's imagine that i had my first thread doing mutex worn and then mute x two and then mutex wanna mutex two down here for thread two then if they both try to acquire mutex in at the same time then we can imagine that thread one would acquire the mutex lock here which would mean thread two will be forced to block	a mutex	306
ok i am not occured because we constructed this with the locks being acquired in a different order if they were in the same order it would have been fine let's just kind of quickly sketch that out to see that let's imagine that i had my first thread doing mutex worn and then mute x two and then mutex wanna mutex two down here for thread two then if they both try to acquire mutex in at the same time then we can imagine that thread one would acquire the mutex lock here which would mean thread two will be forced to block	thread	243
so it doesn't get to go to step two which means thread one can continue and then when it's finished it will release those locks so now thread two can finish so	thread	48
if we'd actually written our code like this in the same order it would have been impossible to get deadlock	code	29
ok so that was with a mutex lock now that's actually think about could we do something similar with counting semaphores sure ok so let's do something similar with counting semaphores where thread one calls say sam weights on counting center four as well	a mutex	20
ok so that was with a mutex lock now that's actually think about could we do something similar with counting semaphores sure ok so let's do something similar with counting semaphores where thread one calls say sam weights on counting center four as well	thread	189
i'll have another thread that does something similar or key	thread	18
and another thread does something similar ok so do we see any problems right now nope we could imagine that these counting semaphore 's my kind except for has been initialized just account of one ok so same initiate here go let's have one pizza slice in there	thread	12
there's no possibility of deadlock right now that for every same weight called we call assam post ok right so what if we could have made it a little bit more complicated though and we said that same weight here is going to in order to continue i'm going to wait on this thread and then i'm going to post on some samples to an meanwhile thread two i'm going to wait on counting semaphore two and then i'm going to post on counting semaphore three ok and then some weight three i'm going to then post inseminate one ok if all my counties are forced to started off with a value of zero you can see that no one gets to play that all of my threads have got stuck that my first thread is blocked here waiting for the value for sale wanted change well someone will change down here but unfortunately thread three is blocked waiting for the count for sam three is waiting for pizza slice and were able to get that piece of sliced form it is waiting for sam post to be called by thread two but thread two is not going to give it that pizza slice until it gets a piece of slice out of counting semaphores s two and where will i get that only from thread one when thread one finally called stem post but that's not going to happen because thread what is still waiting for the pizza slice from thread three so now you see we've got this love triangle here between our three threads they'll never going to continue that always waiting for an event that's never going to happen so that's all example of deadlock we can construct lots of these varying bits of complexity usually we don't artificial construct them like this usually were scratching go ahead go why did my system come to a grinding halt and the other thing i want you to notice is that	block	682
there's no possibility of deadlock right now that for every same weight called we call assam post ok right so what if we could have made it a little bit more complicated though and we said that same weight here is going to in order to continue i'm going to wait on this thread and then i'm going to post on some samples to an meanwhile thread two i'm going to wait on counting semaphore two and then i'm going to post on counting semaphore three ok and then some weight three i'm going to then post inseminate one ok if all my counties are forced to started off with a value of zero you can see that no one gets to play that all of my threads have got stuck that my first thread is blocked here waiting for the value for sale wanted change well someone will change down here but unfortunately thread three is blocked waiting for the count for sam three is waiting for pizza slice and were able to get that piece of sliced form it is waiting for sam post to be called by thread two but thread two is not going to give it that pizza slice until it gets a piece of slice out of counting semaphores s two and where will i get that only from thread one when thread one finally called stem post but that's not going to happen because thread what is still waiting for the pizza slice from thread three so now you see we've got this love triangle here between our three threads they'll never going to continue that always waiting for an event that's never going to happen so that's all example of deadlock we can construct lots of these varying bits of complexity usually we don't artificial construct them like this usually were scratching go ahead go why did my system come to a grinding halt and the other thing i want you to notice is that	thread	270
there's no possibility of deadlock right now that for every same weight called we call assam post ok right so what if we could have made it a little bit more complicated though and we said that same weight here is going to in order to continue i'm going to wait on this thread and then i'm going to post on some samples to an meanwhile thread two i'm going to wait on counting semaphore two and then i'm going to post on counting semaphore three ok and then some weight three i'm going to then post inseminate one ok if all my counties are forced to started off with a value of zero you can see that no one gets to play that all of my threads have got stuck that my first thread is blocked here waiting for the value for sale wanted change well someone will change down here but unfortunately thread three is blocked waiting for the count for sam three is waiting for pizza slice and were able to get that piece of sliced form it is waiting for sam post to be called by thread two but thread two is not going to give it that pizza slice until it gets a piece of slice out of counting semaphores s two and where will i get that only from thread one when thread one finally called stem post but that's not going to happen because thread what is still waiting for the pizza slice from thread three so now you see we've got this love triangle here between our three threads they'll never going to continue that always waiting for an event that's never going to happen so that's all example of deadlock we can construct lots of these varying bits of complexity usually we don't artificial construct them like this usually were scratching go ahead go why did my system come to a grinding halt and the other thing i want you to notice is that	system	1656
i might have a thread that say forgets to call sam post or for some other forget or some bug causes some event not to occur and then you get all of this fall out where other threads and other processes are unable to continue because they are also waiting for that for that thread or the other process so you'll see this occasionally on your phone or on your laptop where one little issue say with their gui process or gui thread now starts to have cascading problems and your deadlock starts to affect other systems as well because everything else grinds to a halt and there's multiple dependencies between all of our threads and processes ok so that's deadlock what what we'd like to be able to do is ensure	a thread	13
i might have a thread that say forgets to call sam post or for some other forget or some bug causes some event not to occur and then you get all of this fall out where other threads and other processes are unable to continue because they are also waiting for that for that thread or the other process so you'll see this occasionally on your phone or on your laptop where one little issue say with their gui process or gui thread now starts to have cascading problems and your deadlock starts to affect other systems as well because everything else grinds to a halt and there's multiple dependencies between all of our threads and processes ok so that's deadlock what what we'd like to be able to do is ensure	thread	15
i might have a thread that say forgets to call sam post or for some other forget or some bug causes some event not to occur and then you get all of this fall out where other threads and other processes are unable to continue because they are also waiting for that for that thread or the other process so you'll see this occasionally on your phone or on your laptop where one little issue say with their gui process or gui thread now starts to have cascading problems and your deadlock starts to affect other systems as well because everything else grinds to a halt and there's multiple dependencies between all of our threads and processes ok so that's deadlock what what we'd like to be able to do is ensure	system	508
ok so let's talk about why the nation part of the operating system here that is ass break now if we were to look at the manpage of s break you'd read something like the following s break increases the process is data segment by end bites so when you call s break you can give it a number and you can say hey i'd like ten more bytes please alright so what does that actually mean	the following	165
ok so let's talk about why the nation part of the operating system here that is ass break now if we were to look at the manpage of s break you'd read something like the following s break increases the process is data segment by end bites so when you call s break you can give it a number and you can say hey i'd like ten more bytes please alright so what does that actually mean	system	60
ok so between you and me as big is not actually used anymore instead we're going to use some virtual memory tricks of all the slide this did modern c library uses some virtual memory tricks that we haven't learned yet so s breakers are simply mechanism but we will use it for cs two forty one to implement a simple memory allocator ok so remember how i said that the bottom of the memory i've got the text segment which is the program code and string literals and any other constants we've put in here and	memory	101
ok so between you and me as big is not actually used anymore instead we're going to use some virtual memory tricks of all the slide this did modern c library uses some virtual memory tricks that we haven't learned yet so s breakers are simply mechanism but we will use it for cs two forty one to implement a simple memory allocator ok so remember how i said that the bottom of the memory i've got the text segment which is the program code and string literals and any other constants we've put in here and	code	435
ok so between you and me as big is not actually used anymore instead we're going to use some virtual memory tricks of all the slide this did modern c library uses some virtual memory tricks that we haven't learned yet so s breakers are simply mechanism but we will use it for cs two forty one to implement a simple memory allocator ok so remember how i said that the bottom of the memory i've got the text segment which is the program code and string literals and any other constants we've put in here and	string	444
ok we can put any data we like inside there and by default the total amount of memory allocated to this is g asked sufficient for what we need ok but what about the day you call malloc and say hey my malloc i need another four thousand and ninety six bytes please this point we need need to go back to the operating system to the kernel and beg for some more van back for some more real addresses we don't want to talk to the oblivion we don't want to avoid we actually need those memory addresses now to refer to some actual memory and that's the purpose of s break is to say yes i know i've got my heap possibly say zero bytes at the beginning but that's not enough now i need to extend it so i please i'd like to move this watermark upwards say by two hundred fifty six bytes so that now i've got some more addresses i can play with i can use to hold some data so that's one less pack gives you an ability to turn on like a tap some more some more dresses which are valid ok we just keep extending this space here and we can use that then to implement possibly the world 's worst but simplest allocator so let's have a look in a moment then how we could actually use this to implement malloc are you ready are slow you in the next video bye	memory	79
ok we can put any data we like inside there and by default the total amount of memory allocated to this is g asked sufficient for what we need ok but what about the day you call malloc and say hey my malloc i need another four thousand and ninety six bytes please this point we need need to go back to the operating system to the kernel and beg for some more van back for some more real addresses we don't want to talk to the oblivion we don't want to avoid we actually need those memory addresses now to refer to some actual memory and that's the purpose of s break is to say yes i know i've got my heap possibly say zero bytes at the beginning but that's not enough now i need to extend it so i please i'd like to move this watermark upwards say by two hundred fifty six bytes so that now i've got some more addresses i can play with i can use to hold some data so that's one less pack gives you an ability to turn on like a tap some more some more dresses which are valid ok we just keep extending this space here and we can use that then to implement possibly the world 's worst but simplest allocator so let's have a look in a moment then how we could actually use this to implement malloc are you ready are slow you in the next video bye	address	387
ok we can put any data we like inside there and by default the total amount of memory allocated to this is g asked sufficient for what we need ok but what about the day you call malloc and say hey my malloc i need another four thousand and ninety six bytes please this point we need need to go back to the operating system to the kernel and beg for some more van back for some more real addresses we don't want to talk to the oblivion we don't want to avoid we actually need those memory addresses now to refer to some actual memory and that's the purpose of s break is to say yes i know i've got my heap possibly say zero bytes at the beginning but that's not enough now i need to extend it so i please i'd like to move this watermark upwards say by two hundred fifty six bytes so that now i've got some more addresses i can play with i can use to hold some data so that's one less pack gives you an ability to turn on like a tap some more some more dresses which are valid ok we just keep extending this space here and we can use that then to implement possibly the world 's worst but simplest allocator so let's have a look in a moment then how we could actually use this to implement malloc are you ready are slow you in the next video bye	system	316
ok so here's the big idea to make tcp client i actually only need two calls i need a way to escape out of my c code and actually start talking to the network card and for that i need a socket so this is the thing that is going to give me a file descriptor and we can pass some information into this is to say what kind of socket we want do you want a tcp or udp kind of socket in other words do you want to stream based or packet based data ground based kind of socket here so we'll talk about how to fill these pieces of information in airmont but i want you to realize that the result of calling socket is just a file descriptor so this if you like is very similar to calling open or very similar to calling pipe now i've actually got something that i can use	code	111
notice that in both these cases i careful to check the error values ok so this will be a non negative value if it is a valid file descriptor if it returns negative one then we know that my attempt to create a socket failed perhaps i don't have privileges perhaps i've created too many sockets at anyways so let's print out the string of every number and quit exit so network code has to check very carefully whether each system for work but once you've gotta suck it now you can call connect so again let's check to see if this failed if it returned negative one let's find out our value of erno and print out a useful message and quit	code	375
notice that in both these cases i careful to check the error values ok so this will be a non negative value if it is a valid file descriptor if it returns negative one then we know that my attempt to create a socket failed perhaps i don't have privileges perhaps i've created too many sockets at anyways so let's print out the string of every number and quit exit so network code has to check very carefully whether each system for work but once you've gotta suck it now you can call connect so again let's check to see if this failed if it returned negative one let's find out our value of erno and print out a useful message and quit	string	327
notice that in both these cases i careful to check the error values ok so this will be a non negative value if it is a valid file descriptor if it returns negative one then we know that my attempt to create a socket failed perhaps i don't have privileges perhaps i've created too many sockets at anyways so let's print out the string of every number and quit exit so network code has to check very carefully whether each system for work but once you've gotta suck it now you can call connect so again let's check to see if this failed if it returned negative one let's find out our value of erno and print out a useful message and quit	system	421
and let's see what else oh yeah so i can block so if i call reed and i haven't got any lights yet from the server then that recall is going to block forever until i do or an error occurs simply my right call may block until it's able to send those bytes to a buffer	block	41
but are we don't know we should also call close just like you have a file descriptor of the file is time to have free up these resources ok so remember to close it as well	resources	127
right so with this in mind i think it's time to fill in some code here but there's one thing we haven't talked about up here so i said that our tcp server only needs actually two network calls which is true but in practice there's a third one that comes in very very useful and it's the following is this get address info this is a kind of swiss army knife of a call which can do all sorts of useful things for us and in particular is going to allow us to correctly set these kind of four parameters here for the socket and the network connection and also it allows us to not specify ip addresses directly instead we can specify domain names like illinois dot edu and get address info can convert that into an ip for address and even potentially an ip six address as well so we don't need to memorize a whole load of ip four and ip six addresses instead we can use these fully qualified host names and get a drink address info will convert those force	the following	283
right so with this in mind i think it's time to fill in some code here but there's one thing we haven't talked about up here so i said that our tcp server only needs actually two network calls which is true but in practice there's a third one that comes in very very useful and it's the following is this get address info this is a kind of swiss army knife of a call which can do all sorts of useful things for us and in particular is going to allow us to correctly set these kind of four parameters here for the socket and the network connection and also it allows us to not specify ip addresses directly instead we can specify domain names like illinois dot edu and get address info can convert that into an ip for address and even potentially an ip six address as well so we don't need to memorize a whole load of ip four and ip six addresses instead we can use these fully qualified host names and get a drink address info will convert those force	parameter	489
right so with this in mind i think it's time to fill in some code here but there's one thing we haven't talked about up here so i said that our tcp server only needs actually two network calls which is true but in practice there's a third one that comes in very very useful and it's the following is this get address info this is a kind of swiss army knife of a call which can do all sorts of useful things for us and in particular is going to allow us to correctly set these kind of four parameters here for the socket and the network connection and also it allows us to not specify ip addresses directly instead we can specify domain names like illinois dot edu and get address info can convert that into an ip for address and even potentially an ip six address as well so we don't need to memorize a whole load of ip four and ip six addresses instead we can use these fully qualified host names and get a drink address info will convert those force	code	61
right so with this in mind i think it's time to fill in some code here but there's one thing we haven't talked about up here so i said that our tcp server only needs actually two network calls which is true but in practice there's a third one that comes in very very useful and it's the following is this get address info this is a kind of swiss army knife of a call which can do all sorts of useful things for us and in particular is going to allow us to correctly set these kind of four parameters here for the socket and the network connection and also it allows us to not specify ip addresses directly instead we can specify domain names like illinois dot edu and get address info can convert that into an ip for address and even potentially an ip six address as well so we don't need to memorize a whole load of ip four and ip six addresses instead we can use these fully qualified host names and get a drink address info will convert those force	address	309
ok so we need a definition for deadlock and this idea that our our threads are frozen up maybe one thread is waiting for a mutex lock that is never going to be unlocked maybe we're waiting for something from a data structure which is never going to be given to us so here's a general definition for dead log key	a struct	213
ok so we need a definition for deadlock and this idea that our our threads are frozen up maybe one thread is waiting for a mutex lock that is never going to be unlocked maybe we're waiting for something from a data structure which is never going to be given to us so here's a general definition for dead log key	a mutex	121
ok so we need a definition for deadlock and this idea that our our threads are frozen up maybe one thread is waiting for a mutex lock that is never going to be unlocked maybe we're waiting for something from a data structure which is never going to be given to us so here's a general definition for dead log key	thread	67
well ok can i type so i put in some in there ok	type	14
make this thread exit it's never going to happen ok so our poor poor little fair door process is waiting some for an event maybe we're going to signal that event using a variable or some other method and it's just never going to happen so it doesn't get to complete it doesn't get to kind of run its activity or run the code and of course debugging deadlock is tricky it's often there as pairs that i could a thread maybe it's stuck inside p threat condition wait and we don't know why why that event doesn't hasn't hasn't fired hasn't occured	code	320
make this thread exit it's never going to happen ok so our poor poor little fair door process is waiting some for an event maybe we're going to signal that event using a variable or some other method and it's just never going to happen so it doesn't get to complete it doesn't get to kind of run its activity or run the code and of course debugging deadlock is tricky it's often there as pairs that i could a thread maybe it's stuck inside p threat condition wait and we don't know why why that event doesn't hasn't hasn't fired hasn't occured	a thread	407
make this thread exit it's never going to happen ok so our poor poor little fair door process is waiting some for an event maybe we're going to signal that event using a variable or some other method and it's just never going to happen so it doesn't get to complete it doesn't get to kind of run its activity or run the code and of course debugging deadlock is tricky it's often there as pairs that i could a thread maybe it's stuck inside p threat condition wait and we don't know why why that event doesn't hasn't hasn't fired hasn't occured	thread	10
ok so we've got this general definition of deadlock now actually let's see if we can kind of construct some examples where we actually cause it so let's use team mutex locks and two threads to create an example of deadlock ok i'm going to actually do this in a text editor ok	thread	182
let's go right do i have so if i've got thread one imagine my thread first red make the coda bigger right has called	thread	40
p thread mutex lock k and we're going to say please lock on this first mutex and then after you've done that please lock on this other mutex right so it will do some work ok do something and then after that we want to at least ok so we will call p thread unlock on both of these mutex is ok	thread	2
so for example maybe we want to take some data out of out of data store one stick it into data structure to ok it doesn't matter particular which order that we released them in just for symmetry i'm going to do it this way but let's let's think about what happens if we lock these in a different sequence inside another thread so i'm going to have now another thread that does the same sequence of operations accept ha we have swapped these around the case so we swap these two lights ok so is this a problem	a struct	93
so for example maybe we want to take some data out of out of data store one stick it into data structure to ok it doesn't matter particular which order that we released them in just for symmetry i'm going to do it this way but let's let's think about what happens if we lock these in a different sequence inside another thread so i'm going to have now another thread that does the same sequence of operations accept ha we have swapped these around the case so we swap these two lights ok so is this a problem	thread	320
like most of the time no most of the time my threads are perfectly happy doing what they need to do until the following happens until one unfortunate day thread one has called preferred mutex lock on get this choose a new color	the following	106
like most of the time no most of the time my threads are perfectly happy doing what they need to do until the following happens until one unfortunate day thread one has called preferred mutex lock on get this choose a new color	thread	45
called prefix lock on the first one case is completed that at the same time my other thread which is curiously called thread one so let's fix that thread	thread	85
so now they were both able to do this but what happens next ok i think we should choose a new color for this let's go for yes it's kinda extreme pinky purple thing let's try that ok right so now what happens thread one says i'd like to lock this mutex but of course what	thread	208
does this do it blocks ok why because another thread has that new texts between you and me we know it's thread two meanwhile thread two tries to look	block	16
does this do it blocks ok why because another thread has that new texts between you and me we know it's thread two meanwhile thread two tries to look	thread	46
it takes one and that of course blocks	block	32
it's not yet available another thread is currently quite that musics lock ok so when will we escape out of this and the answer is never ok we can read the code and see that eventually we're going to release these locks but we're never going to get to that that piece of code that thread one is waiting for thread two and thread two is waiting for thread one so it's kind of stuck for stuck forever	code	155
it's not yet available another thread is currently quite that musics lock ok so when will we escape out of this and the answer is never ok we can read the code and see that eventually we're going to release these locks but we're never going to get to that that piece of code that thread one is waiting for thread two and thread two is waiting for thread one so it's kind of stuck for stuck forever	thread	31
ok i am not occured because we constructed this with the locks being acquired in a different order if they were in the same order it would have been fine let's just kind of quickly sketch that out to see that let's imagine that i had my first thread doing mutex worn and then mute x two and then mutex wanna mutex two down here for thread two then if they both try to acquire mutex in at the same time then we can imagine that thread one would acquire the mutex lock here which would mean thread two will be forced to block	block	518
ok i am not occured because we constructed this with the locks being acquired in a different order if they were in the same order it would have been fine let's just kind of quickly sketch that out to see that let's imagine that i had my first thread doing mutex worn and then mute x two and then mutex wanna mutex two down here for thread two then if they both try to acquire mutex in at the same time then we can imagine that thread one would acquire the mutex lock here which would mean thread two will be forced to block	a mutex	306
ok i am not occured because we constructed this with the locks being acquired in a different order if they were in the same order it would have been fine let's just kind of quickly sketch that out to see that let's imagine that i had my first thread doing mutex worn and then mute x two and then mutex wanna mutex two down here for thread two then if they both try to acquire mutex in at the same time then we can imagine that thread one would acquire the mutex lock here which would mean thread two will be forced to block	thread	243
so it doesn't get to go to step two which means thread one can continue and then when it's finished it will release those locks so now thread two can finish so	thread	48
if we'd actually written our code like this in the same order it would have been impossible to get deadlock	code	29
ok so that was with a mutex lock now that's actually think about could we do something similar with counting semaphores sure ok so let's do something similar with counting semaphores where thread one calls say sam weights on counting center four as well	a mutex	20
ok so that was with a mutex lock now that's actually think about could we do something similar with counting semaphores sure ok so let's do something similar with counting semaphores where thread one calls say sam weights on counting center four as well	thread	189
i'll have another thread that does something similar or key	thread	18
and another thread does something similar ok so do we see any problems right now nope we could imagine that these counting semaphore 's my kind except for has been initialized just account of one ok so same initiate here go let's have one pizza slice in there	thread	12
there's no possibility of deadlock right now that for every sem_wait called we call assam post ok right so what if we could have made it a little bit more complicated though and we said that same weight here is going to in order to continue i'm going to wait on this thread and then i'm going to post on some samples to an meanwhile thread two i'm going to wait on counting semaphore two and then i'm going to post on counting semaphore three ok and then some weight three i'm going to then post inseminate one ok if all my counties are forced to started off with a value of zero you can see that no one gets to play that all of my threads have got stuck that my first thread is blocked here waiting for the value for sale wanted change well someone will change down here but unfortunately thread three is blocked waiting for the count for sam three is waiting for pizza slice and were able to get that piece of sliced form it is waiting for sam post to be called by thread two but thread two is not going to give it that pizza slice until it gets a piece of slice out of counting semaphores s two and where will i get that only from thread one when thread one finally called stem post but that's not going to happen because thread what is still waiting for the pizza slice from thread three so now you see we've got this love triangle here between our three threads they'll never going to continue that always waiting for an event that's never going to happen so that's all example of deadlock we can construct lots of these varying bits of complexity usually we don't artificial construct them like this usually were scratching go our head going why did my system come to a grinding halt and the other thing i want you to notice is that	block	679
there's no possibility of deadlock right now that for every sem_wait called we call assam post ok right so what if we could have made it a little bit more complicated though and we said that same weight here is going to in order to continue i'm going to wait on this thread and then i'm going to post on some samples to an meanwhile thread two i'm going to wait on counting semaphore two and then i'm going to post on counting semaphore three ok and then some weight three i'm going to then post inseminate one ok if all my counties are forced to started off with a value of zero you can see that no one gets to play that all of my threads have got stuck that my first thread is blocked here waiting for the value for sale wanted change well someone will change down here but unfortunately thread three is blocked waiting for the count for sam three is waiting for pizza slice and were able to get that piece of sliced form it is waiting for sam post to be called by thread two but thread two is not going to give it that pizza slice until it gets a piece of slice out of counting semaphores s two and where will i get that only from thread one when thread one finally called stem post but that's not going to happen because thread what is still waiting for the pizza slice from thread three so now you see we've got this love triangle here between our three threads they'll never going to continue that always waiting for an event that's never going to happen so that's all example of deadlock we can construct lots of these varying bits of complexity usually we don't artificial construct them like this usually were scratching go our head going why did my system come to a grinding halt and the other thing i want you to notice is that	thread	267
there's no possibility of deadlock right now that for every sem_wait called we call assam post ok right so what if we could have made it a little bit more complicated though and we said that same weight here is going to in order to continue i'm going to wait on this thread and then i'm going to post on some samples to an meanwhile thread two i'm going to wait on counting semaphore two and then i'm going to post on counting semaphore three ok and then some weight three i'm going to then post inseminate one ok if all my counties are forced to started off with a value of zero you can see that no one gets to play that all of my threads have got stuck that my first thread is blocked here waiting for the value for sale wanted change well someone will change down here but unfortunately thread three is blocked waiting for the count for sam three is waiting for pizza slice and were able to get that piece of sliced form it is waiting for sam post to be called by thread two but thread two is not going to give it that pizza slice until it gets a piece of slice out of counting semaphores s two and where will i get that only from thread one when thread one finally called stem post but that's not going to happen because thread what is still waiting for the pizza slice from thread three so now you see we've got this love triangle here between our three threads they'll never going to continue that always waiting for an event that's never going to happen so that's all example of deadlock we can construct lots of these varying bits of complexity usually we don't artificial construct them like this usually were scratching go our head going why did my system come to a grinding halt and the other thing i want you to notice is that	system	1659
i might have a thread that say forgets to call sam post or for some other forget or some bug causes some event not to occur and then you get all of this fall out where other threads and other processes are unable to continue because they are also waiting for that for that thread or the other process so you'll see this occasionally on your phone or on your laptop where one little issue say with their gui process or gui thread now starts to have cascading problems and your deadlock starts to affect other systems as well because everything else grinds to a halt and there's multiple dependencies between all of our threads and processes ok so that's deadlock what what we'd like to be able to do is ensure	a thread	13
i might have a thread that say forgets to call sam post or for some other forget or some bug causes some event not to occur and then you get all of this fall out where other threads and other processes are unable to continue because they are also waiting for that for that thread or the other process so you'll see this occasionally on your phone or on your laptop where one little issue say with their gui process or gui thread now starts to have cascading problems and your deadlock starts to affect other systems as well because everything else grinds to a halt and there's multiple dependencies between all of our threads and processes ok so that's deadlock what what we'd like to be able to do is ensure	thread	15
i might have a thread that say forgets to call sam post or for some other forget or some bug causes some event not to occur and then you get all of this fall out where other threads and other processes are unable to continue because they are also waiting for that for that thread or the other process so you'll see this occasionally on your phone or on your laptop where one little issue say with their gui process or gui thread now starts to have cascading problems and your deadlock starts to affect other systems as well because everything else grinds to a halt and there's multiple dependencies between all of our threads and processes ok so that's deadlock what what we'd like to be able to do is ensure	system	508
hi ok so let's have a look at how we can write some code which is non deterministic and then fix it up in different ways so here we go let's get started right i've got a little main method down here and i'm going to create ten threads and each time i go to store the address inside my little ray here of thread i ds and then i call pizza at exit so we know that at that point the main thread is done ok but the rest of the process lives on our ten little fence live on ok what do they do case so here's our game plan let's	code	52
hi ok so let's have a look at how we can write some code which is non deterministic and then fix it up in different ways so here we go let's get started right i've got a little main method down here and i'm going to create ten threads and each time i go to store the address inside my little ray here of thread i ds and then i call pizza at exit so we know that at that point the main thread is done ok but the rest of the process lives on our ten little fence live on ok what do they do case so here's our game plan let's	thread	227
hi ok so let's have a look at how we can write some code which is non deterministic and then fix it up in different ways so here we go let's get started right i've got a little main method down here and i'm going to create ten threads and each time i go to store the address inside my little ray here of thread i ds and then i call pizza at exit so we know that at that point the main thread is done ok but the rest of the process lives on our ten little fence live on ok what do they do case so here's our game plan let's	address	267
there's pass in the address of my little iterate available	address	20
so we'll find out its address not as valuable 's address	address	22
and then here's an expression to read that value how does this work ok so we know when finally were assigned a new cpu to start this function that we're given address what do i want to do with that address well i know something is stored there and i know that that's something isn't is just so in fact i want to treat that address as an integer pointer great so now i have that integer pointer i actually want to read whatsapp their contents so let me dereference it with little ass tricks there ok so we've got the value now we've been seeing how we can create p thread i ds	thread	564
and then here's an expression to read that value how does this work ok so we know when finally were assigned a new cpu to start this function that we're given address what do i want to do with that address well i know something is stored there and i know that that's something isn't is just so in fact i want to treat that address as an integer pointer great so now i have that integer pointer i actually want to read whatsapp their contents so let me dereference it with little ass tricks there ok so we've got the value now we've been seeing how we can create p thread i ds	address	159
and then here's an expression to read that value how does this work ok so we know when finally were assigned a new cpu to start this function that we're given address what do i want to do with that address well i know something is stored there and i know that that's something isn't is just so in fact i want to treat that address as an integer pointer great so now i have that integer pointer i actually want to read whatsapp their contents so let me dereference it with little ass tricks there ok so we've got the value now we've been seeing how we can create p thread i ds	pointer	345
every time we call pisode create but what if you wanted to know your own idea what if you said what's my id how would how would i determine that so there should be a way to do this and there is so we say my id is p thread itself so that's the other way of getting a thread id if you want to know who you are something which represents a particular thread then you call peter itself right less for fun printed out which is not normal behaviour normally don't print out these i ds one way to do this we will just treat it as a pointer to some memory so let's say that this id represents some integer type thing which is some address type things or just print it out and now i've got a void pointer i can use percent p to say right treat this doesn't address ok so will pick that up and if we wanted we could play the same trick down here we put this out but	memory	541
every time we call pisode create but what if you wanted to know your own idea what if you said what's my id how would how would i determine that so there should be a way to do this and there is so we say my id is p thread itself so that's the other way of getting a thread id if you want to know who you are something which represents a particular thread then you call peter itself right less for fun printed out which is not normal behaviour normally don't print out these i ds one way to do this we will just treat it as a pointer to some memory so let's say that this id represents some integer type thing which is some address type things or just print it out and now i've got a void pointer i can use percent p to say right treat this doesn't address ok so will pick that up and if we wanted we could play the same trick down here we put this out but	type	598
every time we call pisode create but what if you wanted to know your own idea what if you said what's my id how would how would i determine that so there should be a way to do this and there is so we say my id is p thread itself so that's the other way of getting a thread id if you want to know who you are something which represents a particular thread then you call peter itself right less for fun printed out which is not normal behaviour normally don't print out these i ds one way to do this we will just treat it as a pointer to some memory so let's say that this id represents some integer type thing which is some address type things or just print it out and now i've got a void pointer i can use percent p to say right treat this doesn't address ok so will pick that up and if we wanted we could play the same trick down here we put this out but	a thread	264
every time we call pisode create but what if you wanted to know your own idea what if you said what's my id how would how would i determine that so there should be a way to do this and there is so we say my id is p thread itself so that's the other way of getting a thread id if you want to know who you are something which represents a particular thread then you call peter itself right less for fun printed out which is not normal behaviour normally don't print out these i ds one way to do this we will just treat it as a pointer to some memory so let's say that this id represents some integer type thing which is some address type things or just print it out and now i've got a void pointer i can use percent p to say right treat this doesn't address ok so will pick that up and if we wanted we could play the same trick down here we put this out but	thread	215
every time we call pisode create but what if you wanted to know your own idea what if you said what's my id how would how would i determine that so there should be a way to do this and there is so we say my id is p thread itself so that's the other way of getting a thread id if you want to know who you are something which represents a particular thread then you call peter itself right less for fun printed out which is not normal behaviour normally don't print out these i ds one way to do this we will just treat it as a pointer to some memory so let's say that this id represents some integer type thing which is some address type things or just print it out and now i've got a void pointer i can use percent p to say right treat this doesn't address ok so will pick that up and if we wanted we could play the same trick down here we put this out but	address	623
every time we call pisode create but what if you wanted to know your own idea what if you said what's my id how would how would i determine that so there should be a way to do this and there is so we say my id is p thread itself so that's the other way of getting a thread id if you want to know who you are something which represents a particular thread then you call peter itself right less for fun printed out which is not normal behaviour normally don't print out these i ds one way to do this we will just treat it as a pointer to some memory so let's say that this id represents some integer type thing which is some address type things or just print it out and now i've got a void pointer i can use percent p to say right treat this doesn't address ok so will pick that up and if we wanted we could play the same trick down here we put this out but	pointer	525
ok alright so it looks like it's kind of working but not as well as we hoped we certainly got different thread ideas appearing and they do look like addresses i'll give you that but look at this we've got very strange values over here and even the last value is ten and if i run it again i get different values again if i run it again i get different values again ok so i get in all sorts of values here what is going on clearly we've got a program which is not deterministic we don't know what it's going to print out ok so why did that happen well hopefully you can see that we passed in the address of i and so actually what we have here is called a race condition it depends upon the exact interleaving in time of the instructions that are going to be executed i've got one thread that immediately after calling pizza it could create is going to increment the value by and then test to see if i is less than ten i have not go around again so we've got one threat doing that as fast as fast as i can and i got another thread that as soon as it starts will gas that pointer to an end pointer and then try to read it so it's a value that it sees depends upon the relative timing of these operations and that can change from one run to the next you might be surprised we even saw the value of ten even though our loop says is i lesson ten yes so that's why our threads can start at some point in the future maybe few microseconds but maybe a millisecond maybe much longer ok and some point we're going to escape out of this for loop so at that point the value of i will be equal to ten because that was our exit condition but it gets worse than that because formally the value of this variable is not defined outside of this loop and in fact when we call pizza at exit we don't even need the stack anymore for maine so the memory that we might be reading at that point is no longer really hours to be looking at so we've got a pretty badly formed program here	memory	1823
ok alright so it looks like it's kind of working but not as well as we hoped we certainly got different thread ideas appearing and they do look like addresses i'll give you that but look at this we've got very strange values over here and even the last value is ten and if i run it again i get different values again if i run it again i get different values again ok so i get in all sorts of values here what is going on clearly we've got a program which is not deterministic we don't know what it's going to print out ok so why did that happen well hopefully you can see that we passed in the address of i and so actually what we have here is called a race condition it depends upon the exact interleaving in time of the instructions that are going to be executed i've got one thread that immediately after calling pizza it could create is going to increment the value by and then test to see if i is less than ten i have not go around again so we've got one threat doing that as fast as fast as i can and i got another thread that as soon as it starts will gas that pointer to an end pointer and then try to read it so it's a value that it sees depends upon the relative timing of these operations and that can change from one run to the next you might be surprised we even saw the value of ten even though our loop says is i lesson ten yes so that's why our threads can start at some point in the future maybe few microseconds but maybe a millisecond maybe much longer ok and some point we're going to escape out of this for loop so at that point the value of i will be equal to ten because that was our exit condition but it gets worse than that because formally the value of this variable is not defined outside of this loop and in fact when we call pizza at exit we don't even need the stack anymore for maine so the memory that we might be reading at that point is no longer really hours to be looking at so we've got a pretty badly formed program here	thread	104
ok alright so it looks like it's kind of working but not as well as we hoped we certainly got different thread ideas appearing and they do look like addresses i'll give you that but look at this we've got very strange values over here and even the last value is ten and if i run it again i get different values again if i run it again i get different values again ok so i get in all sorts of values here what is going on clearly we've got a program which is not deterministic we don't know what it's going to print out ok so why did that happen well hopefully you can see that we passed in the address of i and so actually what we have here is called a race condition it depends upon the exact interleaving in time of the instructions that are going to be executed i've got one thread that immediately after calling pizza it could create is going to increment the value by and then test to see if i is less than ten i have not go around again so we've got one threat doing that as fast as fast as i can and i got another thread that as soon as it starts will gas that pointer to an end pointer and then try to read it so it's a value that it sees depends upon the relative timing of these operations and that can change from one run to the next you might be surprised we even saw the value of ten even though our loop says is i lesson ten yes so that's why our threads can start at some point in the future maybe few microseconds but maybe a millisecond maybe much longer ok and some point we're going to escape out of this for loop so at that point the value of i will be equal to ten because that was our exit condition but it gets worse than that because formally the value of this variable is not defined outside of this loop and in fact when we call pizza at exit we don't even need the stack anymore for maine so the memory that we might be reading at that point is no longer really hours to be looking at so we've got a pretty badly formed program here	address	149
ok alright so it looks like it's kind of working but not as well as we hoped we certainly got different thread ideas appearing and they do look like addresses i'll give you that but look at this we've got very strange values over here and even the last value is ten and if i run it again i get different values again if i run it again i get different values again ok so i get in all sorts of values here what is going on clearly we've got a program which is not deterministic we don't know what it's going to print out ok so why did that happen well hopefully you can see that we passed in the address of i and so actually what we have here is called a race condition it depends upon the exact interleaving in time of the instructions that are going to be executed i've got one thread that immediately after calling pizza it could create is going to increment the value by and then test to see if i is less than ten i have not go around again so we've got one threat doing that as fast as fast as i can and i got another thread that as soon as it starts will gas that pointer to an end pointer and then try to read it so it's a value that it sees depends upon the relative timing of these operations and that can change from one run to the next you might be surprised we even saw the value of ten even though our loop says is i lesson ten yes so that's why our threads can start at some point in the future maybe few microseconds but maybe a millisecond maybe much longer ok and some point we're going to escape out of this for loop so at that point the value of i will be equal to ten because that was our exit condition but it gets worse than that because formally the value of this variable is not defined outside of this loop and in fact when we call pizza at exit we don't even need the stack anymore for maine so the memory that we might be reading at that point is no longer really hours to be looking at so we've got a pretty badly formed program here	pointer	1068
right so how can we fix it we need to address this race condition but will do it in two different ways first of all how about we turn this into a task that we give each one and my task right now is just no little integer so let's have some memory for each thread so i'll call it say starting values and you can see i'm using a global here right and it will be let's see i'll have ten am and i can initialize these which i could do as part of this loop or i could do it earlier ok so you can be let's say hundred plus i today just so we can prove that we're running this program ok	memory	240
right so how can we fix it we need to address this race condition but will do it in two different ways first of all how about we turn this into a task that we give each one and my task right now is just no little integer so let's have some memory for each thread so i'll call it say starting values and you can see i'm using a global here right and it will be let's see i'll have ten am and i can initialize these which i could do as part of this loop or i could do it earlier ok so you can be let's say hundred plus i today just so we can prove that we're running this program ok	thread	256
right so how can we fix it we need to address this race condition but will do it in two different ways first of all how about we turn this into a task that we give each one and my task right now is just no little integer so let's have some memory for each thread so i'll call it say starting values and you can see i'm using a global here right and it will be let's see i'll have ten am and i can initialize these which i could do as part of this loop or i could do it earlier ok so you can be let's say hundred plus i today just so we can prove that we're running this program ok	address	38
and then i don't want to pass in the address if i instead i want to pass in my pointer to one of these you introduce i've just created so starting values and i could say take the ice warren i want the address of that but you know that we can also write that is just ok here's the start of the array i want the offset of ips and will use integer arithmetic ok so we've initialized array let's give this ago and off we go so will compile it ok	address	37
and then i don't want to pass in the address if i instead i want to pass in my pointer to one of these you introduce i've just created so starting values and i could say take the ice warren i want the address of that but you know that we can also write that is just ok here's the start of the array i want the offset of ips and will use integer arithmetic ok so we've initialized array let's give this ago and off we go so will compile it ok	pointer	79
we know deterministically that we're going to get the values between a hundred and a hundred and nine those threads can run in an arbitrary order so the output is not guaranteed to be in exactly the same app or ordering that we actually defined it inside the code so let's have a look at kind of one more alternative here to make a program completely deterministic here's what i'm going to do i'm going to say p thread	code	259
we know deterministically that we're going to get the values between a hundred and a hundred and nine those threads can run in an arbitrary order so the output is not guaranteed to be in exactly the same app or ordering that we actually defined it inside the code so let's have a look at kind of one more alternative here to make a program completely deterministic here's what i'm going to do i'm going to say p thread	thread	108
join an i want to join on not the address of thread id but the actual value itself and i don't care about the exit value so don't write that anywhere ok alright so what's going to happen now first of all let me run it and then you can tell me why ok so let's clear this clear that's compiled let's run ok and this time i'm extremely confident we're going to see the same same output for the integers and they will be in order why am i so confident	thread	45
join an i want to join on not the address of thread id but the actual value itself and i don't care about the exit value so don't write that anywhere ok alright so what's going to happen now first of all let me run it and then you can tell me why ok so let's clear this clear that's compiled let's run ok and this time i'm extremely confident we're going to see the same same output for the integers and they will be in order why am i so confident	address	34
so let's have a look at the code we vote we created a thread and the main thread can return and carry on there's no requirement for it to wait for that thread to get started but what do we do we immediately say ok now i want to block i want to wait until i'm able to join on the other thread so that means before we get to go around the loop before we add two hundred dollars and go round the when opoly board again right before we get to say i plus plus in his eye lesson ten we have to run and complete the code inside my funk we have to read the value we print out we get the thread id self we print something out and return null and those steps have to occur in order for pizza joint to letters out of jail so we are extremely confident that i know for certain that my funk will finish this execution before we get to use another loop ok so we've made shell program completely terministic but at what cost yes ladies and gentlemen we've written the most complicated version of printing out the numbers from zero to nine by creating threads and each waiting for each thread in turn to finish so now we've lost the performance of having a multi threats because we've only actually ever got one thread doing anything useful at a time either the main thread is running or is created in new thread to do one simple action and then that finishes and back goes the main thread in it or something again and so on so we had this kind of a hand over which is a	the loop	333
so let's have a look at the code we vote we created a thread and the main thread can return and carry on there's no requirement for it to wait for that thread to get started but what do we do we immediately say ok now i want to block i want to wait until i'm able to join on the other thread so that means before we get to go around the loop before we add two hundred dollars and go round the when opoly board again right before we get to say i plus plus in his eye lesson ten we have to run and complete the code inside my funk we have to read the value we print out we get the thread id self we print something out and return null and those steps have to occur in order for pizza joint to letters out of jail so we are extremely confident that i know for certain that my funk will finish this execution before we get to use another loop ok so we've made shell program completely terministic but at what cost yes ladies and gentlemen we've written the most complicated version of printing out the numbers from zero to nine by creating threads and each waiting for each thread in turn to finish so now we've lost the performance of having a multi threats because we've only actually ever got one thread doing anything useful at a time either the main thread is running or is created in new thread to do one simple action and then that finishes and back goes the main thread in it or something again and so on so we had this kind of a hand over which is a	block	228
so let's have a look at the code we vote we created a thread and the main thread can return and carry on there's no requirement for it to wait for that thread to get started but what do we do we immediately say ok now i want to block i want to wait until i'm able to join on the other thread so that means before we get to go around the loop before we add two hundred dollars and go round the when opoly board again right before we get to say i plus plus in his eye lesson ten we have to run and complete the code inside my funk we have to read the value we print out we get the thread id self we print something out and return null and those steps have to occur in order for pizza joint to letters out of jail so we are extremely confident that i know for certain that my funk will finish this execution before we get to use another loop ok so we've made shell program completely terministic but at what cost yes ladies and gentlemen we've written the most complicated version of printing out the numbers from zero to nine by creating threads and each waiting for each thread in turn to finish so now we've lost the performance of having a multi threats because we've only actually ever got one thread doing anything useful at a time either the main thread is running or is created in new thread to do one simple action and then that finishes and back goes the main thread in it or something again and so on so we had this kind of a hand over which is a	code	28
so let's have a look at the code we vote we created a thread and the main thread can return and carry on there's no requirement for it to wait for that thread to get started but what do we do we immediately say ok now i want to block i want to wait until i'm able to join on the other thread so that means before we get to go around the loop before we add two hundred dollars and go round the when opoly board again right before we get to say i plus plus in his eye lesson ten we have to run and complete the code inside my funk we have to read the value we print out we get the thread id self we print something out and return null and those steps have to occur in order for pizza joint to letters out of jail so we are extremely confident that i know for certain that my funk will finish this execution before we get to use another loop ok so we've made shell program completely terministic but at what cost yes ladies and gentlemen we've written the most complicated version of printing out the numbers from zero to nine by creating threads and each waiting for each thread in turn to finish so now we've lost the performance of having a multi threats because we've only actually ever got one thread doing anything useful at a time either the main thread is running or is created in new thread to do one simple action and then that finishes and back goes the main thread in it or something again and so on so we had this kind of a hand over which is a	a thread	52
so let's have a look at the code we vote we created a thread and the main thread can return and carry on there's no requirement for it to wait for that thread to get started but what do we do we immediately say ok now i want to block i want to wait until i'm able to join on the other thread so that means before we get to go around the loop before we add two hundred dollars and go round the when opoly board again right before we get to say i plus plus in his eye lesson ten we have to run and complete the code inside my funk we have to read the value we print out we get the thread id self we print something out and return null and those steps have to occur in order for pizza joint to letters out of jail so we are extremely confident that i know for certain that my funk will finish this execution before we get to use another loop ok so we've made shell program completely terministic but at what cost yes ladies and gentlemen we've written the most complicated version of printing out the numbers from zero to nine by creating threads and each waiting for each thread in turn to finish so now we've lost the performance of having a multi threats because we've only actually ever got one thread doing anything useful at a time either the main thread is running or is created in new thread to do one simple action and then that finishes and back goes the main thread in it or something again and so on so we had this kind of a hand over which is a	thread	54
ok so i've got a little surprise for you so next time you bump into a student taking a data structures class in c++ why don't you ask them the following right so i got a little piece of code very easy what's it going to print as you can see we initialize this little value here one two three four five and we print it out no new line and why did you say that i give you ten bucks if you can tell me exactly what this is going to print ok so little do they know that you've taken cs two forty one so let's see what	the following	139
ok so i've got a little surprise for you so next time you bump into a student taking a data structures class in c++ why don't you ask them the following right so i got a little piece of code very easy what's it going to print as you can see we initialize this little value here one two three four five and we print it out no new line and why did you say that i give you ten bucks if you can tell me exactly what this is going to print ok so little do they know that you've taken cs two forty one so let's see what	a struct	90
ok so i've got a little surprise for you so next time you bump into a student taking a data structures class in c++ why don't you ask them the following right so i got a little piece of code very easy what's it going to print as you can see we initialize this little value here one two three four five and we print it out no new line and why did you say that i give you ten bucks if you can tell me exactly what this is going to print ok so little do they know that you've taken cs two forty one so let's see what	code	186
we started adding zeros in front of numbers but it comes in useful when we actually want to start making directories and changing the mode bits so let's do this now let's actually have a look at some code key right where you see i'm going to use this trick you see to write it octal because i want to make a whole lot of directories i gotta make directory called d i one and i want it permissions to be re divide execute for me and no access for any group or anybody else ok and simile as well for subdirectory as well then i'm going to make a second directory with these permissions and a subdirectory	code	200
and we are pointing to the subdirectory hopefully we managed to make earlier and then the new path so this could actually be a subdirectory wanted but this is where the link is going to be created so we're going to end up with three links called quick one quick two quick three right so pause for a moment and figure out which of the following will be created ok i'm going to try to make three symlinks and six subdirectory 's can you see any that you think will fail	the following	330
here we go so now i gotta file that anybody can write anybody can execute anybody could read and it's owned by this mysterious user code five five five ok alright let's i think i tried to reset this so let's put it back to be owned by me k surprise dot c and i need ownership	code	132
hi ok so let's take a look at some code that i found on the internet that claims to solve their dining philosophers and we will analyze it and see what we think ok so here we go it uses all the good stuff that we now understand	code	35
we've got a little structure here called philosopher and you can see it's going to be typed deft so that we can just say philosopher later on inside that i'm going to have a pointer to the left fork and the right fork and of course a philosopher has a name	type	86
we've got a little structure here called philosopher and you can see it's going to be typed deft so that we can just say philosopher later on inside that i'm going to have a pointer to the left fork and the right fork and of course a philosopher has a name	pointer	174
and associated with it ap thread and some output variable say whether it failed or not ok we have a global variable to see whether this program should keep running or not ok and let's have a look see how things get initialized	thread	26
ok so we've got a new way of character pointers and that's just a name of five philosophers would like today we're going to have five mutex locks they're going to be our forks and five philosophers ok so	pointer	39
my philosophers so that's just a simple stack away it's ok to do this on inside the main threat because we'll see all of my threads which are going to run	thread	124
finish before we exit made right so great let's get myself a philosopher will get the i th one will initialize its name will initialize it left hand and right hand fork to be one of my five mutex locks look i'm using modulo arithmetic so that the fifth philosopher wraps around and gets to zero for kids game right after setting that all up let's start off threats will call preferred create will make a note of the thread id and will ask it to actually run some multithreaded code which will look at at the moment and then the rest of my main thread doesn't do much it sleeps with forty seconds then changes running and now just waits for those five threads to finish	code	477
finish before we exit made right so great let's get myself a philosopher will get the i th one will initialize its name will initialize it left hand and right hand fork to be one of my five mutex locks look i'm using modulo arithmetic so that the fifth philosopher wraps around and gets to zero for kids game right after setting that all up let's start off threats will call preferred create will make a note of the thread id and will ask it to actually run some multithreaded code which will look at at the moment and then the rest of my main thread doesn't do much it sleeps with forty seconds then changes running and now just waits for those five threads to finish	thread	416
otherwise will exit ok so that's my main threat now let's let's have a look at the code that we get that is run by each philosopher oh yes and here's my source	code	83
ok so each philosopher is going to be given a pointer to its little struct there ok so each plus is going to get its own unique name etc right so we also have some local stack variables which mirror what we find inside the the struct you'll see why in a moment so let's see what	pointer	46
my little threads going to do here so for forty seconds until that global variable is changed the first thing that my my philosophy does is sleep in other words thanks a bit so will print out his name then will sleep for and amount of time so in this case let's sleep for say some two one and eight seconds alright and then the philosopher goes to pick up the two folks	thread	10
let's see all chill at the moment ok so we're going to get out of there were going to take this check this after you run through this code once i know notice it is frayed i apologize the logic as given incorrect let's have a look see what it does first of all philosopher waist to pick up the fork on the left ok so that's only going to proceed once you get exclusive access to that particular fork alright and then it's going to change this local variable failed to based on on what happens when it tries to pick up the the fork on the right so notice that initial value of tries left is too so actually it's going to call this function called trilok which we haven't seen before trilok never blocks instead rather than blocking if it's unable to acquire this mutex	block	694
let's see all chill at the moment ok so we're going to get out of there were going to take this check this after you run through this code once i know notice it is frayed i apologize the logic as given incorrect let's have a look see what it does first of all philosopher waist to pick up the fork on the left ok so that's only going to proceed once you get exclusive access to that particular fork alright and then it's going to change this local variable failed to based on on what happens when it tries to pick up the the fork on the right so notice that initial value of tries left is too so actually it's going to call this function called trilok which we haven't seen before trilok never blocks instead rather than blocking if it's unable to acquire this mutex	code	134
it just returns an error numbers returns a non zero value so the very first time that we running this code with twice left equal to two if we caught acquire that second log we just say we failed so what do we do if we failed we immediately unlock the left hand thread	code	102
it just returns an error numbers returns a non zero value so the very first time that we running this code with twice left equal to two if we caught acquire that second log we just say we failed so what do we do if we failed we immediately unlock the left hand thread	thread	261
great you say this looks a lot like we're not going to implement holding wait we're not holding onto the fork on the left we are definitely releasing it so then what does this code do well it	code	176
and then we release both looks ok then we go round the loop we keep going until we've hdr forty seconds is up so what do you think about that is that code correct does	the loop	51
and then we release both looks ok then we go round the loop we keep going until we've hdr forty seconds is up so what do you think about that is that code correct does	code	150
for the fork on the right in other words they all get blocked so yes there is a chance that all my possibles will will deadlock because all waiting for resource it is never going to be released so oh dear this apparent code on the internet is not smart enough to solve this problem so yes ladies and gentlemen as a series two forty one	block	54
for the fork on the right in other words they all get blocked so yes there is a chance that all my possibles will will deadlock because all waiting for resource it is never going to be released so oh dear this apparent code on the internet is not smart enough to solve this problem so yes ladies and gentlemen as a series two forty one	code	219
student now smarter than the internet ok so we can prove we can show the circumstances in which deadlock is can occur this actually see if we can actually see that occur if we actually run this code in practice so here's here's the same code that i prepared earlier i wanted to get out of this and go to handouts but code	code	194
there we go right go to code	code	24
but i need cs two forty one lectures code right	code	37
p thread	thread	2
ok finally great let's ok off they go oh alright look at this we've run into deadlock where all five were hungry at exactly the same time so in practice causing this is actually actually difficult let me just run it one more time will see if we can generate it so you can see no expense spared on the graphics we've got five philosophers going through the states of either hungry eating or sleeping and yes we run into deadlock again this actually kind of take a look at this code because i want to show you that i actually had to work a little bit hard to make deadlock occur here so i want to reset my group right and let's	code	476
threads word acquire the left hand lock that was interesting is that right now i'm recording this so one of my cpu cores is busy capturing the lecture content the video content so i was actually surprised that so quickly run into deadlock the other thing that i did to try to make it more likely is i'm using micro sleeps too actually sure that we have an opportunity for deadlock many many many more times in the original provider coded only tested this with sleeps for eight seconds or so over forty second window so opportunity for deadlock is is only handful of times order of ten times or so we would like it to be much higher alright so yes i have i can run it in slow motion let's see how we do that	code	432
threads word acquire the left hand lock that was interesting is that right now i'm recording this so one of my cpu cores is busy capturing the lecture content the video content so i was actually surprised that so quickly run into deadlock the other thing that i did to try to make it more likely is i'm using micro sleeps too actually sure that we have an opportunity for deadlock many many many more times in the original provider coded only tested this with sleeps for eight seconds or so over forty second window so opportunity for deadlock is is only handful of times order of ten times or so we would like it to be much higher alright so yes i have i can run it in slow motion let's see how we do that	thread	0
all right so let's go and actually have a play with the first one let's go and see how we can converse a directory or navigate into it so for that i will need a terminal here right so right now are we east remember when playing with symbolic links here so let's get back out of here perhaps if we want to know key tell it off there we go right so perhaps we want to go to a particular directory like pet parent directory ok we could also find out our apps canonical path on	a terminal	159
right so that's kind of cute little demo in our next video i'm going to talk about the fact that a process	a process	97
hey actually i remembered i've gota little demo with epoll so let's do that instead ok so first of all i've actually got before we look at epoll a little program that can make pipes and send data so kind of here we go it's called pipe writer and it might send down a pipe i the message ella island or noise ok so for this we're going to use some named pipes so it in my file system i'm going to make pipe one and pipe two here it is and let me actually kind of make these pipes in now i actually want to actually start sending data to them so for this i'm going to have two file descriptors here we go ok so using this this is going to be my test little test program where i can send data to one pipe or the other pipe and then the other side will use epoll so all i'm going to do is you press one or two and send the right message to the right pipe ok so that's just my little pipe writer	system	375
right so again here's my little epoll demo i'm going to make some pipes on this side as well and i'm going to have two file scripters where i'm listening now on these pipe objects but i'm today to make it more interesting not only my file descriptor is going to be read only i'm going to say please don't block ok so that means that my calls to read and write won't stop instead they'll just	block	305
simply return negative one and set errno if they are unable to do anything useful for us right now ok so remember that because instead we're going to use equal to do all of our work for us by making it non blocking also known as asynchronous we can now make sure that just one thread of our process can actually handle multiple connections multiple pipes	block	206
simply return negative one and set errno if they are unable to do anything useful for us right now ok so remember that because instead we're going to use equal to do all of our work for us by making it non blocking also known as asynchronous we can now make sure that just one thread of our process can actually handle multiple connections multiple pipes	thread	277
people that i care about are going to be when some data has arrived windows data into my my process here and i can set some data upon this as well so let's set up the files got to one and five script at two so we're going to have two different events corresponding to my two different types	type	285
by the way this data over here that is for user data for us to be able to easily associate a particular event with a particular file descriptor but we could also please set of pointers as well so we set this up for both file script awarded five script two and now we can start listing right so i mentioned that equal uses an one method to tell us about what's happened here's what happens here's how it does is how it does that	pointer	176
and so people will block potentially forever or we could specify a time out so for for example i can specify a time out of a thousand milliseconds here	block	19
yeah he right that we had a equal in event k and we got some characters now look at this we kind of got two two two different returns here i think it's because i set up my code to only grab them say two characters of time i forget exactly why ok so i could send some more	code	172
just by using epoll ok so that's enough of a demo you can see this demo i committed itself lecture code you'll be writing similar kind of code but for tcp connections right bye for now	code	99
really useful little thing here we have scanf which is a lot like printf so if you've learned printf you can now do the opposite you can say i want to read from standard input and here's what i expect to see and it takes a format string just like printf does but now it we're using in reverse we're using it to say please parse the input and i expect to see you say a number and a comma and then	printf	66
really useful little thing here we have scanf which is a lot like printf so if you've learned printf you can now do the opposite you can say i want to read from standard input and here's what i expect to see and it takes a format string just like printf does but now it we're using in reverse we're using it to say please parse the input and i expect to see you say a number and a comma and then	string	230
two numbers per line today right so that could be my format now what happens to these numbers we need to give some memory locations of where to write them and so because i've given a hint scan after i'm expecting integers	memory	115
it's going to write four byte integers so let me for example say here's the address of my first integer k available here's the address of another integer variable ok there we go	address	76
so scanf behaves a lot like printf there's a little	printf	28
or multiple characters ie a string if you ask it to read a string it's actually going to tokenize the input looking for white space so so don't act so unlike printf if you say hey please give me a whole line skype is not going to do that for you it's going to give you basically one word and the last thing down here is i want to point value	printf	158
or multiple characters ie a string if you ask it to read a string it's actually going to tokenize the input looking for white space so so don't act so unlike printf if you say hey please give me a whole line skype is not going to do that for you it's going to give you basically one word and the last thing down here is i want to point value	string	28
so robust code will take that return value from scanf and	code	10
check that truly matter to change are all the variables we expected because here's the big story yes we're giving the address of our variables but scanf it's only going to write into our variables if it successfully passed the input line so if it fails the value of our variables will be whatever was there before so that would be very fragile code if we just simply assumed that those variables have been changed alright so let's get to it if a little marks here	code	344
check that truly matter to change are all the variables we expected because here's the big story yes we're giving the address of our variables but scanf it's only going to write into our variables if it successfully passed the input line so if it fails the value of our variables will be whatever was there before so that would be very fragile code if we just simply assumed that those variables have been changed alright so let's get to it if a little marks here	address	118
scan if and will say ok percent d percent d for the comet in between here's the address of x here's the address of why	address	80
ok and will say here's a value of x and y so notice wizard lift difference here that uh with scan if i needed the address of my variables because i'm going to change the contents of them ok right and let's return zero	address	114
ok so now let me run my little program and if i type let's say sixty seventy	type	48
great let's successfully read that from the input if i type to sixty in a comma it's actually going to wait until i type more because it's treating newlines as spaces so let me put seven hundred in here ok it read	type	55
ok you'll notice that x has been changed but why does not why still hold its original value that we initialized it to inside the code so that's why we wanted to actually	code	129
then the high priority jobs if they keep on arriving will never allow low priority jobs to run by the way when i say jobs that's the classic operating system description of processes and items which actually need cpu time but you can i'm sure generalize to the idea of this applying to individual threads insider multithreaded program	thread	297
then the high priority jobs if they keep on arriving will never allow low priority jobs to run by the way when i say jobs that's the classic operating system description of processes and items which actually need cpu time but you can i'm sure generalize to the idea of this applying to individual threads insider multithreaded program	system	151
ok so anything that has some kind of prioritization can suffer from starvation right which schedule is appropriate for batch jobs well the answer here is it it depends are typically fast jobs you care about throughput so you might decide to use shortest job first for example you might decide to use a round robin because you would like to see some output from all jobs it depends very much upon the io use of your jobs for example it might be that if you try to run all of your jobs at the same time then you stressed your io system and actually i o throughput	system	527
right what about interactive jobs well we've seen that round robin is great because we don't need to wait for other peoples processes to finish and if we select a time quanta which is sufficiently short but not too short then it can appear to each person that they really do have a cpu available even when the rest of the system is busy of course if there are enough people with enough processes which are actually running then our processes will appear to be a bit sluggish our compile compilation step will take ten seconds not five seconds because we're on average say we're only getting fifty percent of the cpu but at least it will be appear to be continuing ok right so	system	322
we have talked a little bit about page tables and the idea that inside my virtual addresses i can map to a particular piece of memory and i do this on a per page basis and then we've discussed how actually we can page out parts of our memory	memory	127
we have talked a little bit about page tables and the idea that inside my virtual addresses i can map to a particular piece of memory and i do this on a per page basis and then we've discussed how actually we can page out parts of our memory	address	82
to disk ok so when i don't need something or if there's pressure to get more memory for another process or something else we can take parts of our memory and say you know well let's just copy it to disk or maybe it already is on disk in which case if the dirty bit is not set then i know that i don't need to do much because i've already got a copy of the data on the disk somewhere right so i've got all this wonderful machinery to page out and page in disk blocks back into ram let's use that for a different purpose wouldn't it be cool if i could have a file like alice perhaps you've read alice through the looking glass so	memory	77
to disk ok so when i don't need something or if there's pressure to get more memory for another process or something else we can take parts of our memory and say you know well let's just copy it to disk or maybe it already is on disk in which case if the dirty bit is not set then i know that i don't need to do much because i've already got a copy of the data on the disk somewhere right so i've got all this wonderful machinery to page out and page in disk blocks back into ram let's use that for a different purpose wouldn't it be cool if i could have a file like alice perhaps you've read alice through the looking glass so	block	459
here's my little file here wouldn't it be cool if the contents of this file so here it is let's kind of sketch it out as some holodisc blocks if we could actually map those directly into some memory ok so let's kind of copy them in and then those pieces of memory can be directly part of the address space of a process and that's what nmap is going to allow us to do this idea that we can kind of make as one the address space of our process and things on the disk it allows us to do a bit more than that but let's kind of just start there ok alright so let's see what we can do with this so here's a map here is here is your high poly reference you know the most powerful ones that we're going to play with today that we say i want to map some memory and i want to map it to a file now we don't give a file name instead we just give a file descriptor so for example we have	memory	192
here's my little file here wouldn't it be cool if the contents of this file so here it is let's kind of sketch it out as some holodisc blocks if we could actually map those directly into some memory ok so let's kind of copy them in and then those pieces of memory can be directly part of the address space of a process and that's what nmap is going to allow us to do this idea that we can kind of make as one the address space of our process and things on the disk it allows us to do a bit more than that but let's kind of just start there ok alright so let's see what we can do with this so here's a map here is here is your high poly reference you know the most powerful ones that we're going to play with today that we say i want to map some memory and i want to map it to a file now we don't give a file name instead we just give a file descriptor so for example we have	block	135
here's my little file here wouldn't it be cool if the contents of this file so here it is let's kind of sketch it out as some holodisc blocks if we could actually map those directly into some memory ok so let's kind of copy them in and then those pieces of memory can be directly part of the address space of a process and that's what nmap is going to allow us to do this idea that we can kind of make as one the address space of our process and things on the disk it allows us to do a bit more than that but let's kind of just start there ok alright so let's see what we can do with this so here's a map here is here is your high poly reference you know the most powerful ones that we're going to play with today that we say i want to map some memory and i want to map it to a file now we don't give a file name instead we just give a file descriptor so for example we have	a process	309
here's my little file here wouldn't it be cool if the contents of this file so here it is let's kind of sketch it out as some holodisc blocks if we could actually map those directly into some memory ok so let's kind of copy them in and then those pieces of memory can be directly part of the address space of a process and that's what nmap is going to allow us to do this idea that we can kind of make as one the address space of our process and things on the disk it allows us to do a bit more than that but let's kind of just start there ok alright so let's see what we can do with this so here's a map here is here is your high poly reference you know the most powerful ones that we're going to play with today that we say i want to map some memory and i want to map it to a file now we don't give a file name instead we just give a file descriptor so for example we have	address	292
now some things you can do with this you could specify a particular dress you like or alternatively you could just say you know i don't care map you find a good place in my address based for this you don't need to say how many bytes that you'd like so this could be a fixed number like hey i just want a thousand twenty four or maybe you've already stated the same file so for example	address	173
if you just want to load the whole file if you want to map the whole file then maybe you could say something like ok stat tell me the size of the file and that will be the space in my virtual address space i'd like to use	address	192
ok so the next two things can cause a little bit of confusion they do different things here so remember when we talked about our virtual memory four pieces of actual physical memory inside our page tables we cared about whether you could read or write or execute them and why do we do this again for security so for example i might have pages in my stack which are read and writable but not executable or i might have pages which is for the library or my code which i want to be read an executable but not writable ok so we get to choose we get to say what page protections would like here so for example if i just want to read my file then i only need read so there's others as well	memory	137
ok so the next two things can cause a little bit of confusion they do different things here so remember when we talked about our virtual memory four pieces of actual physical memory inside our page tables we cared about whether you could read or write or execute them and why do we do this again for security so for example i might have pages in my stack which are read and writable but not executable or i might have pages which is for the library or my code which i want to be read an executable but not writable ok so we get to choose we get to say what page protections would like here so for example if i just want to read my file then i only need read so there's others as well	code	455
the flags allow us to say things like if you make a change to the file ok so right now we can't do that because we said we want to make say just read access but let's suppose we'd asked for right let's suppose you would change some bites here then how private is that change for example should changes be actually written directly back into the file at some point and also what if someone else is also memory mapping the same file should they see your changes	memory	402
that sounds really useful if you want to communicate between two different process is less useful if you just want to make quick changes to the memory version of the file in order to make it efficient so you can kind of read things etc so that allows you to say how much sharing you want in whether you want to share your changes with any other process ok so the last thing in here maybe you don't want to start your mapping at the beginning of the file maybe you wanted to specify an offset	memory	144
ok so let's have sloppy look at a version of this and so before we do that this kind of quickly review in order to use mmap then you want to say what kind of memory protection do you want do you want to be able to make changes will it be backed by a file or do you just want it to be an anonymous mapping well cinemas mapping you ask is so so how you could have made the malloc mp really easy so rather than calling sbrk you could just say directly to the system hey bring it all and give me a gigabyte of mapped man me please so that's kind of them apple i to do that directly	memory	158
ok so let's have sloppy look at a version of this and so before we do that this kind of quickly review in order to use mmap then you want to say what kind of memory protection do you want do you want to be able to make changes will it be backed by a file or do you just want it to be an anonymous mapping well cinemas mapping you ask is so so how you could have made the malloc mp really easy so rather than calling sbrk you could just say directly to the system hey bring it all and give me a gigabyte of mapped man me please so that's kind of them apple i to do that directly	mmap	119
ok so let's have sloppy look at a version of this and so before we do that this kind of quickly review in order to use mmap then you want to say what kind of memory protection do you want do you want to be able to make changes will it be backed by a file or do you just want it to be an anonymous mapping well cinemas mapping you ask is so so how you could have made the malloc mp really easy so rather than calling sbrk you could just say directly to the system hey bring it all and give me a gigabyte of mapped man me please so that's kind of them apple i to do that directly	system	456
right the reason for that is that the file system has a strong assumption that the file directory structure is a tree and has no cycles if you as a mere mortal user could make hard links from the deep part of the tree back out of the tree then it's possible that the kernel itself could follow those hard links forever and in fact even if you're root you cannot make hard links to directories it will refuse to do that ok so that's the first thing is it has to be to an existing file you cannot make any hard link to a nonexistent file why because remember what we're doing is that we're adding a new entry into a directory and increasing the reference count versus a symbolic link ok we can actually make symbolic links add the o just up there symbolic links to nonexistent files so we can say i can make a link to something which doesn't even exist	system	43
it can cross file system boundaries	system	18
so remember that because a symbolic link is basically just some text we could talk about files which exist on a completely different file system for example maybe your files exist on a usb stick and so your symbolic link would just contain the text say for example slash	system	138
and so i can talk about a symbolic link i can talk about so creating a symbolic link to a file on a totally different file system and i could store this inside my say my user directory right which one do you think has better performance	system	123
ok hi welcome to lecture thirty nine the last recorded lecture ok so here we go we're going to cover some different things today i wanted to tell you some stuff about let's see docker and containers or go over maybe some ideas about some of you questions and also will talk a little bit about the critical section problem ok right so let's get started let's have some fun first of all with containers so off we go let's make this a little larger here ok alright so here's the idea is that we want to be able to have some kind of security model where i can want to run a process and this process can't see my files it can't even see what other processes are running and it can't find out much about anything about say the network cards or anything else i have basically we're running this poor little process it feels like a virtual machine except it's a lot lighter we're going to cheat rather than say emulating a complete cpu and a disk drive and having a virtual copy of every piece of hardware we want here's how we're going to cheat we're going to put our process inside a container and this container is essentially comprised of what's called namespaces so imagine you could only talk to people called smith or some variant of smith then your world becomes a lot smaller imagine if you looked out the window and you said tell me about all the files just outside so i could kind of open and we lied to you we said actually these are the only mount points that exist there not the real map points but you don't know that so this poor we're going to lie to this little process and so it's going to behave as inside of virtual machine	a container	1076
ok hi welcome to lecture thirty nine the last recorded lecture ok so here we go we're going to cover some different things today i wanted to tell you some stuff about let's see docker and containers or go over maybe some ideas about some of you questions and also will talk a little bit about the critical section problem ok right so let's get started let's have some fun first of all with containers so off we go let's make this a little larger here ok alright so here's the idea is that we want to be able to have some kind of security model where i can want to run a process and this process can't see my files it can't even see what other processes are running and it can't find out much about anything about say the network cards or anything else i have basically we're running this poor little process it feels like a virtual machine except it's a lot lighter we're going to cheat rather than say emulating a complete cpu and a disk drive and having a virtual copy of every piece of hardware we want here's how we're going to cheat we're going to put our process inside a container and this container is essentially comprised of what's called namespaces so imagine you could only talk to people called smith or some variant of smith then your world becomes a lot smaller imagine if you looked out the window and you said tell me about all the files just outside so i could kind of open and we lied to you we said actually these are the only mount points that exist there not the real map points but you don't know that so this poor we're going to lie to this little process and so it's going to behave as inside of virtual machine	a process	568
ok hi welcome to lecture thirty nine the last recorded lecture ok so here we go we're going to cover some different things today i wanted to tell you some stuff about let's see docker and containers or go over maybe some ideas about some of you questions and also will talk a little bit about the critical section problem ok right so let's get started let's have some fun first of all with containers so off we go let's make this a little larger here ok alright so here's the idea is that we want to be able to have some kind of security model where i can want to run a process and this process can't see my files it can't even see what other processes are running and it can't find out much about anything about say the network cards or anything else i have basically we're running this poor little process it feels like a virtual machine except it's a lot lighter we're going to cheat rather than say emulating a complete cpu and a disk drive and having a virtual copy of every piece of hardware we want here's how we're going to cheat we're going to put our process inside a container and this container is essentially comprised of what's called namespaces so imagine you could only talk to people called smith or some variant of smith then your world becomes a lot smaller imagine if you looked out the window and you said tell me about all the files just outside so i could kind of open and we lied to you we said actually these are the only mount points that exist there not the real map points but you don't know that so this poor we're going to lie to this little process and so it's going to behave as inside of virtual machine	section	306
it's not quite as secure as a real virtual machine but there are lots of advantages for example it's much faster to create we can create one of these containers in the order of microseconds or milliseconds versus if i create a virtual machine a virtual machine is going to take at least several seconds to start up secondly on a virtual machines take up a lot of ram a lot of memory and in fact that is the limiting resource so next time you ask your friend for another virtual machine they're going to check how much spare ram they have before deciding whether to say yes or no versus these small containers are very lightweight there not much heavier than just creating another process	memory	376
here we go little example i'm going to run in a moment so dark it does several things it makes it easy for me to create these images and to share them in fact if you think of it as a bit like a github where i can create image and then post it from other people posted for people to use secondly what doctor does is it has a special kind of set of file systems where i can use what's called an overlay technique meaning that i might start say with unbuntu image complete image of a working copy of emblem two and then say well ok on top of that i want to delete this directory i want to add this other directory with these files and darker maintains a delta the difference between these so as you can see it's car is currently downloading various kind of file system images one of these will be a version of a bunch of that is built upon an in a moment when it's finished we go we've got the complete set of images that create down my little well say demo and the well site demo itself is basically kind of hello world that you can get from docker and as you can see it's created all it does is it runs a single process it doesn't do much apart from prints out this wonderful ascii diagram and if i say instead of boo i say cs two forty one here we go it runs again and now the whale says something else so great we just check that docker ruts so dockers kind of very powerful we use it for class transcribed so that it doesn't matter whether you're running on windows or linux	system	352
i can give you a complete development environment ready to go you can test your code etc and it's a weight as well to deploy everything so once we've got class transcribed ready to run on a server we can create a docker image and then i can give it to someone else to run and i don't have to worry about then installing all of the dependencies instead all the things that we depend on all the third party libraries we need for the website can all be bundled up into this single image so it makes circle operations much much simpler and like i said it did you some security advantages that inside this process it's not easy for this process to see the rest of your system	code	80
i can give you a complete development environment ready to go you can test your code etc and it's a weight as well to deploy everything so once we've got class transcribed ready to run on a server we can create a docker image and then i can give it to someone else to run and i don't have to worry about then installing all of the dependencies instead all the things that we depend on all the third party libraries we need for the website can all be bundled up into this single image so it makes circle operations much much simpler and like i said it did you some security advantages that inside this process it's not easy for this process to see the rest of your system	system	664
kernel code that doctor uses it has a kernel module runs with complete colonel privileges so if i can find a vulnerability inside that docker code or if i can find a vulnerability inside a standard kind of kernel module like say a file system driver then	code	7
kernel code that doctor uses it has a kernel module runs with complete colonel privileges so if i can find a vulnerability inside that docker code or if i can find a vulnerability inside a standard kind of kernel module like say a file system driver then	system	236
all bets are off now i can have complete access all of the memory of the real machine so it's not perfect it's not perfect security right stalker i'm sure that you will come across it in your kind of future future working it's kind of very popular tool today one last other thing i'm not going to mention but just point out and see if i can find doctor up here here it is you might also hear about something called communities in kubernetes is is a way to define how to create many many many working virtual machines or docker images and containers and run many of them at the same time so for example if i wanted to make my website work with say five different five instances of node js and i wanted to scale it up to have say ten back end databases then i would use kubernetes to be able to define how to scale up and use all of those different containers alright so cute like i said is also kind of great powerful tool if you get into this stuff it's very very easy to play with this stuff and docker has made it very easy lots of great examples so after cs two forty one final exams after you finished saying hi to your friends and your parents and etc and putting away the semester why don't you have a play with this i'm sure it would be kind of useful skills to learn ok so let's stop there and next video will go back to cs two forty want content which we do ask about on exam ok bye for now	memory	59
ok right so let's run through some simulations of purposes obtaining some resources case so what do we have here right so first of all let's not confuse deadlock with dreadlocks ok both of those can get you into trouble on the high seas so but we are looking at nazi code today but just a simulation of process is requesting obtaining resources and releasing them ok so what do we got right	code	267
ok right so let's run through some simulations of purposes obtaining some resources case so what do we have here right so first of all let's not confuse deadlock with dreadlocks ok both of those can get you into trouble on the high seas so but we are looking at nazi code today but just a simulation of process is requesting obtaining resources and releasing them ok so what do we got right	resources	74
ok so here's the here's the game that assume processes require locks in the order specified and really sources resources only when finished ok so we're going to use what's called a resource allocation graph to determine if and when there is deadlock so we could sketch out the order in which processes or obtain these locks and there's a possible order maybe that will lead to deadlock ok so	resources	111
and then it will then it will continue ok so i went to process wait for resources will quite an exclusive lock called resource as soon as no other processes have text message block ok and will assume the locks affair so in the general case with the period mutex locks we could set oarlocks up to a give processes with the highest priority access to exclusive log but in general the sequence of which the locks are assigned to up process is arbitrary	block	175
and then it will then it will continue ok so i went to process wait for resources will quite an exclusive lock called resource as soon as no other processes have text message block ok and will assume the locks affair so in the general case with the period mutex locks we could set oarlocks up to a give processes with the highest priority access to exclusive log but in general the sequence of which the locks are assigned to up process is arbitrary	resources	72
ok right so how do we write these resource allocation graphs well first of all let's write down our resources of different types so	type	123
ok right so how do we write these resource allocation graphs well first of all let's write down our resources of different types so	resources	100
here we go right i've got different resources down here here's my resource of type a b and c ok so you might imagine for example these are pieces of hardware maybe it's exclusive access to the screen i want to go and put my computer into a kind of full screen mode so only i can actually kind of right to the screen or maybe it's a piece of hardware maybe i want exclusive access to the firmware or to storage device or maybe it's a database table and i now need to make sure that only i can access it	type	78
here we go right i've got different resources down here here's my resource of type a b and c ok so you might imagine for example these are pieces of hardware maybe it's exclusive access to the screen i want to go and put my computer into a kind of full screen mode so only i can actually kind of right to the screen or maybe it's a piece of hardware maybe i want exclusive access to the firmware or to storage device or maybe it's a database table and i now need to make sure that only i can access it	resources	36
or maybe it's some data structure but whatever it is we have this idea that only one process or thread at a time can access it now i'm going to use the word process that's kind of historical reference in the sense that we thought about these things even with four threads exist but you could imagine how we could set up identical situations to multiple threads running inside just one process so it's the concept is the theory which is the most important idea here ok so what do i got in question one i've got my first process p one requests and obtains resource a and then resource be ok so let's set up process one here ok process one	a struct	22
or maybe it's some data structure but whatever it is we have this idea that only one process or thread at a time can access it now i'm going to use the word process that's kind of historical reference in the sense that we thought about these things even with four threads exist but you could imagine how we could set up identical situations to multiple threads running inside just one process so it's the concept is the theory which is the most important idea here ok so what do i got in question one i've got my first process p one requests and obtains resource a and then resource be ok so let's set up process one here ok process one	thread	96
right we done no so the next thing and in our timeline here is process two requests see ok so let me choose a different color for a process to ok right so process two first requests see ok so it gets see fine it's holding on to that got screws have access to that resource but then it would like be unfortunately it can't right now be is currently being held by process one so it's going to look longingly is hand is outstretched	a process	130
wanting to touch be but no it's stuck on the outside looking at this box can i really want this but i'm being forced to wait because process one has exclusive access ok so that's the beginnings of a resource allocation graph or rag right and you can see the process to cannot continue right now it doesn't have everything it needs and we can actually say oh look it's stuck because it's waiting for resource be and the reason we can't get it is because process one is still running right so do we have deadlock well no we don't because we can see that process one isn't actually waiting for any resources yeah sure it's being a bit slow and finishing up but there's no reason for it to actually run forever so at some point it's going to finish and when it does so it can release these resources ok so delete that line and we delete that line so we can now see that process too and no longer needs to be waiting for the mystery source be and so we could raise the at and turn that back into a line that's looking at it and say ok great now process to has everything it needs it can continue so if we were writing code you can imagine our call to peter mutex lock has finally completed or access to the reader writer data structures finally given 's ability to read that so great we can continue right so eventually process too because it has all the resources it needs can continue as well we don't care how long it's going to take all we can say is for sure is that there is no deadlock ok so in this case no and no alright so that was an easy one join me in the next video when i look at a more complicated one alright see you then	a struct	1219
wanting to touch be but no it's stuck on the outside looking at this box can i really want this but i'm being forced to wait because process one has exclusive access ok so that's the beginnings of a resource allocation graph or rag right and you can see the process to cannot continue right now it doesn't have everything it needs and we can actually say oh look it's stuck because it's waiting for resource be and the reason we can't get it is because process one is still running right so do we have deadlock well no we don't because we can see that process one isn't actually waiting for any resources yeah sure it's being a bit slow and finishing up but there's no reason for it to actually run forever so at some point it's going to finish and when it does so it can release these resources ok so delete that line and we delete that line so we can now see that process too and no longer needs to be waiting for the mystery source be and so we could raise the at and turn that back into a line that's looking at it and say ok great now process to has everything it needs it can continue so if we were writing code you can imagine our call to peter mutex lock has finally completed or access to the reader writer data structures finally given 's ability to read that so great we can continue right so eventually process too because it has all the resources it needs can continue as well we don't care how long it's going to take all we can say is for sure is that there is no deadlock ok so in this case no and no alright so that was an easy one join me in the next video when i look at a more complicated one alright see you then	code	1113
wanting to touch be but no it's stuck on the outside looking at this box can i really want this but i'm being forced to wait because process one has exclusive access ok so that's the beginnings of a resource allocation graph or rag right and you can see the process to cannot continue right now it doesn't have everything it needs and we can actually say oh look it's stuck because it's waiting for resource be and the reason we can't get it is because process one is still running right so do we have deadlock well no we don't because we can see that process one isn't actually waiting for any resources yeah sure it's being a bit slow and finishing up but there's no reason for it to actually run forever so at some point it's going to finish and when it does so it can release these resources ok so delete that line and we delete that line so we can now see that process too and no longer needs to be waiting for the mystery source be and so we could raise the at and turn that back into a line that's looking at it and say ok great now process to has everything it needs it can continue so if we were writing code you can imagine our call to peter mutex lock has finally completed or access to the reader writer data structures finally given 's ability to read that so great we can continue right so eventually process too because it has all the resources it needs can continue as well we don't care how long it's going to take all we can say is for sure is that there is no deadlock ok so in this case no and no alright so that was an easy one join me in the next video when i look at a more complicated one alright see you then	resources	595
hi ok so we both through five different examples of where we sought deadlock or not no deadlock and fundamentally it was the request sequence that determines whether we actually ran into deadlock or not so what can we do to prevent deadlock and one algorithm that our system could use is something called the bankers algorithm so if the operating system knew in advance what resources particular process wanted so if we knew an example example for example the process one is going to need let's say eight aa whatever azar and say three bees whatever bees are but no season dies	resources	375
hi ok so we both through five different examples of where we sought deadlock or not no deadlock and fundamentally it was the request sequence that determines whether we actually ran into deadlock or not so what can we do to prevent deadlock and one algorithm that our system could use is something called the bankers algorithm so if the operating system knew in advance what resources particular process wanted so if we knew an example example for example the process one is going to need let's say eight aa whatever azar and say three bees whatever bees are but no season dies	system	268
then the bank side my bankers algorithm can ensure that the bank never goes into an overdraft right and never we never allow our process is to continue so that so that there's a possibility that that i would resource i would exhaust the resources for certain type so for example if i have one hundred days and i know that my process two and my process three and so on only ever going to	type	259
then the bank side my bankers algorithm can ensure that the bank never goes into an overdraft right and never we never allow our process is to continue so that so that there's a possibility that that i would resource i would exhaust the resources for certain type so for example if i have one hundred days and i know that my process two and my process three and so on only ever going to	resources	237
ten then the moment that p three comes along and request these if i grant that request so if i've given all of my resources of type a to process three then we can immediately reason that any future requests by these other processes will	type	127
ten then the moment that p three comes along and request these if i grant that request so if i've given all of my resources of type a to process three then we can immediately reason that any future requests by these other processes will	resources	114
will potentially get stuck and potentially we can run into deadlock so the bankers algorithm which we're not going to go into a detailed today is this idea that i can keep if i know in advance and that is the crux but if i know in advance the maximum number of requests for each resource type then i can ensure that the sequence of that we allow our process is to be given exclusive access to our resource types we can ensure that will never going to have an overdraft and we can never therefore go into a deadlock alright so this is an example of kind of deadlock avoidance and you can read about bankers algorithm on wikipedia etc but i instead i want to spend a little bit i'm talking about the linux and windows strategy for avoiding deadlock	type	288
ok so first of all some theory and i'll ask you to guess which guess which what lennox in windows uses ok so here's an idea we could actually think about our process is in some kind of conceptual space so let me just think about say two processes about how they advanced through this space so my process runs through different states so for example it might be that it requires a mutex one and then later it acquires mutex too ok then it does some things and then it releases mutex server two and one ok so over here right but you can see the idea that my first process is going to slowly advance along my access here and i could do the same thing for another process i could talk about the state of my second process and	a mutex	378
the sequence of operations in my system as a whole represents a little walk through this state of spaces where the actual walk depends upon the sequence in which my process one or processed to acquire the mutex locks or some other exclusive access to some other resource ok so look at this my process one is acquired	system	33
so we could actually think about the state that positions in this state space of possible states my two processes which actually correspond to when things get stuck in other words when do they correspond with circle cycles in my weight for graph and what we would discover is that they all interior points on this particular graph right so if example process one didn't do anything but process two acquired all of the resources and then release them and then process want acquired all of the resources it needed and then release them we've gone around the edges where says if i interleaved my two process process the two processor or thread operations then i'm trying to take a more dangerous path through the middle of this and some of these points i'm going to get stuck at i cannot continue ok so what does the lyrics do does it attempt to kind of look at what states in this state space	thread	634
so we could actually think about the state that positions in this state space of possible states my two processes which actually correspond to when things get stuck in other words when do they correspond with circle cycles in my weight for graph and what we would discover is that they all interior points on this particular graph right so if example process one didn't do anything but process two acquired all of the resources and then release them and then process want acquired all of the resources it needed and then release them we've gone around the edges where says if i interleaved my two process process the two processor or thread operations then i'm trying to take a more dangerous path through the middle of this and some of these points i'm going to get stuck at i cannot continue ok so what does the lyrics do does it attempt to kind of look at what states in this state space	resources	418
ok and finally it had stuck in the ground yes it's called the ostrich algorithm which is that uh if it's look scary quick stick your head in the sand and don't look so the lyrics of windows strategy for deadlock avoidance is called let's just hope for the best which the ostriches algorithm is basically let's pretend it's not our problem their system is going to let you write code that can cause deadlock it's up to you the system programmer to make sure that deadlock cannot occur so the system does not prevent you from causing deadlock so good luck you're on your own on this one and that's why it's important to make sure that we don't enter possible deadlock which brings us to our final little point which is how can we possibly do this ok so here's the secret source here's the most important part of this lecture because now i've shown you that we can simulate deadlock we could see it occur inside the resource allocation graph but we actually want to prevent it here's the secret	code	378
ok and finally it had stuck in the ground yes it's called the ostrich algorithm which is that uh if it's look scary quick stick your head in the sand and don't look so the lyrics of windows strategy for deadlock avoidance is called let's just hope for the best which the ostriches algorithm is basically let's pretend it's not our problem their system is going to let you write code that can cause deadlock it's up to you the system programmer to make sure that deadlock cannot occur so the system does not prevent you from causing deadlock so good luck you're on your own on this one and that's why it's important to make sure that we don't enter possible deadlock which brings us to our final little point which is how can we possibly do this ok so here's the secret source here's the most important part of this lecture because now i've shown you that we can simulate deadlock we could see it occur inside the resource allocation graph but we actually want to prevent it here's the secret	system	345
let's make sure that our all of our threads or processes always require resources in the same order so will have a meeting with all of our programmers and say look here's the things which you are saying a quiet calling peter mutex lock on abc and d we just need you to always acquire them in agreed apon order so for	thread	36
let's make sure that our all of our threads or processes always require resources in the same order so will have a meeting with all of our programmers and say look here's the things which you are saying a quiet calling peter mutex lock on abc and d we just need you to always acquire them in agreed apon order so for	resources	72
example if you're going to acquire a lock in order to access a then get this lot first before getting be and if you going to acquire a lock be then acquire lock be before accessing see and then if you get the idea so we need to rank order or resources so another was given some kind of simple mapping to integers here ok so on and so on and so on and so on and if you acquire something when exclusive access if we always agree to acquire them in small integer to large integer order then deadlock is impossible	resources	242
acquire in the same order i can never generate the case where i've got a process to which has now acquired this but then also goes backwards and create awaiting condition on an earlier resource all of my lines which correspond to it waiting for resources must be to the right i cannot generate that cycle in the wakeful graph which pictorially always kind of looks like a bow tie where i've ended up with weights on resources which are both before and after in my resource order so all of my weights i'm going to be to the right and therefore is always possible for the earlier resources to be complete my process is complete so therefore i cannot set up a chain or between my process is where i end up say with process three waiting for process one and process one waiting for process doing ok so that is the secret source it's always make sure that we get resources in the same order so i want you to think about how you would implement that suppose for example you had a set of integers say they might be under a one of a link list and each one of those integers has a mutex lock so m one m two m three m four m five etc how can i make sure that if i need to lock let's say two or three mutex locks in order to modify those integers how can i ensure that all of my code always locks the necessary integers in the same order case how would you do that and answers that will be in a future lecture video bye for now	code	1268
acquire in the same order i can never generate the case where i've got a process to which has now acquired this but then also goes backwards and create awaiting condition on an earlier resource all of my lines which correspond to it waiting for resources must be to the right i cannot generate that cycle in the wakeful graph which pictorially always kind of looks like a bow tie where i've ended up with weights on resources which are both before and after in my resource order so all of my weights i'm going to be to the right and therefore is always possible for the earlier resources to be complete my process is complete so therefore i cannot set up a chain or between my process is where i end up say with process three waiting for process one and process one waiting for process doing ok so that is the secret source it's always make sure that we get resources in the same order so i want you to think about how you would implement that suppose for example you had a set of integers say they might be under a one of a link list and each one of those integers has a mutex lock so m one m two m three m four m five etc how can i make sure that if i need to lock let's say two or three mutex locks in order to modify those integers how can i ensure that all of my code always locks the necessary integers in the same order case how would you do that and answers that will be in a future lecture video bye for now	a mutex	1070
acquire in the same order i can never generate the case where i've got a process to which has now acquired this but then also goes backwards and create awaiting condition on an earlier resource all of my lines which correspond to it waiting for resources must be to the right i cannot generate that cycle in the wakeful graph which pictorially always kind of looks like a bow tie where i've ended up with weights on resources which are both before and after in my resource order so all of my weights i'm going to be to the right and therefore is always possible for the earlier resources to be complete my process is complete so therefore i cannot set up a chain or between my process is where i end up say with process three waiting for process one and process one waiting for process doing ok so that is the secret source it's always make sure that we get resources in the same order so i want you to think about how you would implement that suppose for example you had a set of integers say they might be under a one of a link list and each one of those integers has a mutex lock so m one m two m three m four m five etc how can i make sure that if i need to lock let's say two or three mutex locks in order to modify those integers how can i ensure that all of my code always locks the necessary integers in the same order case how would you do that and answers that will be in a future lecture video bye for now	a process	71
acquire in the same order i can never generate the case where i've got a process to which has now acquired this but then also goes backwards and create awaiting condition on an earlier resource all of my lines which correspond to it waiting for resources must be to the right i cannot generate that cycle in the wakeful graph which pictorially always kind of looks like a bow tie where i've ended up with weights on resources which are both before and after in my resource order so all of my weights i'm going to be to the right and therefore is always possible for the earlier resources to be complete my process is complete so therefore i cannot set up a chain or between my process is where i end up say with process three waiting for process one and process one waiting for process doing ok so that is the secret source it's always make sure that we get resources in the same order so i want you to think about how you would implement that suppose for example you had a set of integers say they might be under a one of a link list and each one of those integers has a mutex lock so m one m two m three m four m five etc how can i make sure that if i need to lock let's say two or three mutex locks in order to modify those integers how can i ensure that all of my code always locks the necessary integers in the same order case how would you do that and answers that will be in a future lecture video bye for now	resources	245
ok so let's do a producer consumer again a very kind of standard exam question but also something that you might expect inside an interview so first of all in an interview there say ok what is the producer consumer problem and the idea that i've got one or more process is producing things so for example that might be i'm reading off the file system it might be a server socket that's receiving things might be a pipe it doesn't matter the point is i've got a stream of stuff being sent to me and rather than having just a simple data structure	a struct	534
ok so let's do a producer consumer again a very kind of standard exam question but also something that you might expect inside an interview so first of all in an interview there say ok what is the producer consumer problem and the idea that i've got one or more process is producing things so for example that might be i'm reading off the file system it might be a server socket that's receiving things might be a pipe it doesn't matter the point is i've got a stream of stuff being sent to me and rather than having just a simple data structure	system	344
where i just allow it to grow to an infinite size which order real system is not that great instead i want to be able to connect this producer up to some consumers	system	67
and these consumers there might be more of them and i want to be able to make sure that i don't accidentally get the same what item to two different consumers and i want to make sure that my producers block if there's no spare space right now as someone i want to make sure my consumers will block if there's no new items for them and finally let's make sure that the way that we implement this has it has a fixed size so that i don't waste unnecessary memory just us holding everything that the that the producers want to give me right now ok so this is all going to do let's implement the producer consumer problem using a fixed capacity multithreaded producer consumer and this will have some admin remove methods but we want to make sure that we don't allow more than one hundred items to be in the queue and similar we don't want to be able to move things from the queue	memory	453
and these consumers there might be more of them and i want to be able to make sure that i don't accidentally get the same what item to two different consumers and i want to make sure that my producers block if there's no spare space right now as someone i want to make sure my consumers will block if there's no new items for them and finally let's make sure that the way that we implement this has it has a fixed size so that i don't waste unnecessary memory just us holding everything that the that the producers want to give me right now ok so this is all going to do let's implement the producer consumer problem using a fixed capacity multithreaded producer consumer and this will have some admin remove methods but we want to make sure that we don't allow more than one hundred items to be in the queue and similar we don't want to be able to move things from the queue	block	201
and these consumers there might be more of them and i want to be able to make sure that i don't accidentally get the same what item to two different consumers and i want to make sure that my producers block if there's no spare space right now as someone i want to make sure my consumers will block if there's no new items for them and finally let's make sure that the way that we implement this has it has a fixed size so that i don't waste unnecessary memory just us holding everything that the that the producers want to give me right now ok so this is all going to do let's implement the producer consumer problem using a fixed capacity multithreaded producer consumer and this will have some admin remove methods but we want to make sure that we don't allow more than one hundred items to be in the queue and similar we don't want to be able to move things from the queue	thread	645
so today we're not actually going to write the code	code	47
to remove things will add things that low level code you can assume you've already written inside cs two twenty five or for example in my store inside a database so you might store it say inside of a message queue or whatever point is to be able to block the producers and consumers so for this we're going to use counting so for and mutex right so let's have a mutex which represents let's have a better colored mutex ok there we go let's have mutex that represents say the number of items	block	249
to remove things will add things that low level code you can assume you've already written inside cs two twenty five or for example in my store inside a database so you might store it say inside of a message queue or whatever point is to be able to block the producers and consumers so for this we're going to use counting so for and mutex right so let's have a mutex which represents let's have a better colored mutex ok there we go let's have mutex that represents say the number of items	code	48
to remove things will add things that low level code you can assume you've already written inside cs two twenty five or for example in my store inside a database so you might store it say inside of a message queue or whatever point is to be able to block the producers and consumers so for this we're going to use counting so for and mutex right so let's have a mutex which represents let's have a better colored mutex ok there we go let's have mutex that represents say the number of items	a mutex	360
right ok so when we when a producer wants to add something else to add a value if we can continue we are just going to call this ad war method with that value but we only want to get that far if there's space so for this what a plan then is to go to our pizza box our space pizza box and remove a slice and we know that's going to block if we've decorated that value down to one hundred	block	331
my pizza box here so in space and that would normally just carry on straight away but if we're down to zero pizza slices that will block at this point let's now call add war	block	131
right so great so that's our code for the add further remove it's going to be very similar but by symmetry we swap things around so when we actually want to remove	code	29
implement remove we're going to see some very similar code except that of course you swap the use of these two counting semaphores around and we're going to call add a remove roar method or something the last thing we need to think about is how we want to initialize these things so the space we want to initialize to one hundred and the number of items you want to initialize to zero how do you do that we can use ammunition so for example for the space you would be writing seminar shit ok	code	54
right so are we almost there yes except that our code won't work if i've got more than two two threads calling add at the same time i want to make sure that	code	49
right so are we almost there yes except that our code won't work if i've got more than two two threads calling add at the same time i want to make sure that	thread	95
that that this ad roar is a critical section so how do i protect that answer is where they mutex locks so just before calling add war we're going to call our mutex lock and then just afterwards we can call our mutex unlock and as usual don't forget to initialize your mutex and you can do that with two ways you could either call p thread mutex initial or you can use that magic value the kind of piv it mutex initializer value either one of those will work ok so right so elastic with a producer consumer and i will see you in the next video bye	section	37
that that this ad roar is a critical section so how do i protect that answer is where they mutex locks so just before calling add war we're going to call our mutex lock and then just afterwards we can call our mutex unlock and as usual don't forget to initialize your mutex and you can do that with two ways you could either call p thread mutex initial or you can use that magic value the kind of piv it mutex initializer value either one of those will work ok so right so elastic with a producer consumer and i will see you in the next video bye	thread	332
hi welcome to like twenty four we're going to start with a quick code review let's see look at this attempted waiting a fixed sized ring buffer and we'll see if we can figure out how it might go wrong ok so some of the things that we want to ask are is deadlock possible in other words could get stuck so that's never able to continue is underflow possible in other words could it be that we attempt to write so attempt to read some data that's not actually inside the ring buffer so will just be reading back some garbage information or perhaps overflow as possible which means that we're able to put more data into my buffer then it can actually hold so presumably we were going to corrupt something possibly value that we have not yet written out so what do we got here we have	code	65
two counting semaphores and will see the s one is initialized to two hundred and fifty six so this smells to me like some kind of capacity counting thing which is going to go down as we started add things and as two is initialized to zero so s two sounds to me like it's going to be counting the number of items in ok let's touch you have a look at the code then for my enqueue and dequeue or nq and deck so i see i'm going to move text lock ok so that's good so that only one thread at the time can be actually inside this code and in fact for this particular implementation is chosen to use the same mutex lock for both the nq in the dequeue ok but i do notice inside this implementation is that normally what do we do normally send post so the same way it happens first and we normally only have the mutex lock that wraps the buffer call as well so yeah	code	353
two counting semaphores and will see the s one is initialized to two hundred and fifty six so this smells to me like some kind of capacity counting thing which is going to go down as we started add things and as two is initialized to zero so s two sounds to me like it's going to be counting the number of items in ok let's touch you have a look at the code then for my enqueue and dequeue or nq and deck so i see i'm going to move text lock ok so that's good so that only one thread at the time can be actually inside this code and in fact for this particular implementation is chosen to use the same mutex lock for both the nq in the dequeue ok but i do notice inside this implementation is that normally what do we do normally send post so the same way it happens first and we normally only have the mutex lock that wraps the buffer call as well so yeah	thread	477
ok hi so we're going to start thinking about creating tasks now perhaps you ever seen insider back of a kitchen where i've gotten multiple short order cooks preparing meals and there's a little circular wheel where the next cook runs up and pulls the next thing to cook off this second we'll the next order right and this is actually shared between multiple threads that is eventually where we'd like to get to but for now let's just think about individual tasks and we've got an example here for amanda block problem but i want you to think of this conceptually as applying to kind of other things that we want to use with multiple threads so i wanted to clear a little job a little thing that i want my thread to do so so i care about it starting x and y position and ending x there n d y in other words i'm going to declare that i want you to work on this tiny little piece of the picture not just now a whole long row but just a small tile ok so that would be my task and because i don't want to keep waiting struct on the name i want to areas that just typedef so i'm going to say typedef all of this in the future i'm just going to wait as task underscore t ok great so now let me make sure i can make enough tasks for my whole picture now in this easy problem we can actually workout in advance exactly how many tiles though is how many tasks i'm going to take to complete the whole picture if i divide up my picture into	block	504
ok hi so we're going to start thinking about creating tasks now perhaps you ever seen insider back of a kitchen where i've gotten multiple short order cooks preparing meals and there's a little circular wheel where the next cook runs up and pulls the next thing to cook off this second we'll the next order right and this is actually shared between multiple threads that is eventually where we'd like to get to but for now let's just think about individual tasks and we've got an example here for amanda block problem but i want you to think of this conceptually as applying to kind of other things that we want to use with multiple threads so i wanted to clear a little job a little thing that i want my thread to do so so i care about it starting x and y position and ending x there n d y in other words i'm going to declare that i want you to work on this tiny little piece of the picture not just now a whole long row but just a small tile ok so that would be my task and because i don't want to keep waiting struct on the name i want to areas that just typedef so i'm going to say typedef all of this in the future i'm just going to wait as task underscore t ok great so now let me make sure i can make enough tasks for my whole picture now in this easy problem we can actually workout in advance exactly how many tiles though is how many tasks i'm going to take to complete the whole picture if i divide up my picture into	type	1058
ok hi so we're going to start thinking about creating tasks now perhaps you ever seen insider back of a kitchen where i've gotten multiple short order cooks preparing meals and there's a little circular wheel where the next cook runs up and pulls the next thing to cook off this second we'll the next order right and this is actually shared between multiple threads that is eventually where we'd like to get to but for now let's just think about individual tasks and we've got an example here for amanda block problem but i want you to think of this conceptually as applying to kind of other things that we want to use with multiple threads so i wanted to clear a little job a little thing that i want my thread to do so so i care about it starting x and y position and ending x there n d y in other words i'm going to declare that i want you to work on this tiny little piece of the picture not just now a whole long row but just a small tile ok so that would be my task and because i don't want to keep waiting struct on the name i want to areas that just typedef so i'm going to say typedef all of this in the future i'm just going to wait as task underscore t ok great so now let me make sure i can make enough tasks for my whole picture now in this easy problem we can actually workout in advance exactly how many tiles though is how many tasks i'm going to take to complete the whole picture if i divide up my picture into	thread	358
little blocks of sixty four by sixty four pixels then the number of tiles i need i'll need to round up so i can use the following formula let me kind of add sixty three to ever true height i have and similar to the width as well so that if you give me a height like sixty seven i know that i have to make at least two tiles in that direction	the following	116
little blocks of sixty four by sixty four pixels then the number of tiles i need i'll need to round up so i can use the following formula let me kind of add sixty three to ever true height i have and similar to the width as well so that if you give me a height like sixty seven i know that i have to make at least two tiles in that direction	block	7
ok so with that in mind i can now make memory structure which will hold all of my tasks i've calculated how many and each entry inside my heat will be the size of my task struct remember i'm not using task pointer here i actually want to hold an actual task inside that memory and will assign that to my variable tasks ok wait so now i can start filling up that memory ok so off we go here it is here's my code to now walkthrough filling up those memories i just have to be a little bit careful that the ones at the very end may not be as large as the others so i have to make sure that i limit the ending value of x and y so that they don't actually go past the end of my true image otherwise when i actually come to calculate this i'll be writing into some invalid memory alright so that's not the purpose of of this limit here is to make sure that we can deal correctly with width and height which are not some multiple of sixty	memory	39
ok so with that in mind i can now make memory structure which will hold all of my tasks i've calculated how many and each entry inside my heat will be the size of my task struct remember i'm not using task pointer here i actually want to hold an actual task inside that memory and will assign that to my variable tasks ok wait so now i can start filling up that memory ok so off we go here it is here's my code to now walkthrough filling up those memories i just have to be a little bit careful that the ones at the very end may not be as large as the others so i have to make sure that i limit the ending value of x and y so that they don't actually go past the end of my true image otherwise when i actually come to calculate this i'll be writing into some invalid memory alright so that's not the purpose of of this limit here is to make sure that we can deal correctly with width and height which are not some multiple of sixty	code	406
ok so with that in mind i can now make memory structure which will hold all of my tasks i've calculated how many and each entry inside my heat will be the size of my task struct remember i'm not using task pointer here i actually want to hold an actual task inside that memory and will assign that to my variable tasks ok wait so now i can start filling up that memory ok so off we go here it is here's my code to now walkthrough filling up those memories i just have to be a little bit careful that the ones at the very end may not be as large as the others so i have to make sure that i limit the ending value of x and y so that they don't actually go past the end of my true image otherwise when i actually come to calculate this i'll be writing into some invalid memory alright so that's not the purpose of of this limit here is to make sure that we can deal correctly with width and height which are not some multiple of sixty	pointer	206
four and each time around the loop these two loops i'm incrementing my little i here ok so now let's actually have a look at how we use this right then	the loop	26
so i'm written this code as two different functions in the real code but i've tried to make it short here they see if we can understand this so we wanted to be able to run all these little tiles here these little tasks we made it but we don't try to make that many threads so let's have a look at this second attempt to parallelize r code so great i'm calling peter create an eye potentially got like ten thousand tasks here but we weren't just create ten thousand tasks all in one go so here's what we'll do is we will store the thread id and we're going to keep track of the total number of threads that we've got running right now in each time we're going to add one to my thread count here and	code	20
so i'm written this code as two different functions in the real code but i've tried to make it short here they see if we can understand this so we wanted to be able to run all these little tiles here these little tasks we made it but we don't try to make that many threads so let's have a look at this second attempt to parallelize r code so great i'm calling peter create an eye potentially got like ten thousand tasks here but we weren't just create ten thousand tasks all in one go so here's what we'll do is we will store the thread id and we're going to keep track of the total number of threads that we've got running right now in each time we're going to add one to my thread count here and	thread	265
each thread we create is going to be given a different task so we're looking into that array were pulling out a different entry that we just created earlier and here's my lookout three ok so how do i actually limit the number of threads running at anyone time ok so when this thread count reaches a maximum let's say sixty or whatever but when it's equal to sixteen here we're not going to create any more threads instead we're going to run through the sixteen threads that we've created so far using their third ideas are going to join on each one so we're not going to be able to escape out of this for loop until all sixteen or however many threads have all finished if some finished early great is some finished late great we will block until they have finished but at some point finally all of those save sixteen threads will finish a which point will reset our thread count back to zero and that's update update the gui so we can see what's happened so far	block	735
each thread we create is going to be given a different task so we're looking into that array were pulling out a different entry that we just created earlier and here's my lookout three ok so how do i actually limit the number of threads running at anyone time ok so when this thread count reaches a maximum let's say sixty or whatever but when it's equal to sixteen here we're not going to create any more threads instead we're going to run through the sixteen threads that we've created so far using their third ideas are going to join on each one so we're not going to be able to escape out of this for loop until all sixteen or however many threads have all finished if some finished early great is some finished late great we will block until they have finished but at some point finally all of those save sixteen threads will finish a which point will reset our thread count back to zero and that's update update the gui so we can see what's happened so far	thread	5
individual tiles being creative they look a little bit larger than sixty four they really sixty four let's just check the actual code here right so we've got mental task	code	129
ok so it's it's a little bit more efficient sense we're trying to limit the number of threads now so now we could say make the number of threads equal to the actual true number of cpu cores that we have but still some of those threads might still be running a little bit and completing a little bit faster than the others	thread	86
where's my there we go where i could now start defining tasks involved with different parts of the picture and i could even make animations where i'm displaying one frame and then as you would choose to explore a different area of this i can in the background start already start creating a picture perhaps i create a picture at a low resolution and watched you looking at that i'm already creating a version of the report which is at a higher resolution also we are starting to think away that is similar to gpu programming where the gpu doesn't have just four or eight or or twelve or sixteen cpu cores but something like three hundred or so cpu cores already to run in parallel there are lot simpler than regular cpu but the fact that so many of them means that we can get teraflop behavior out of relatively cheap piece of hardware today which is just amazing the fact that you and i can have a teraflop of performance setting underneath your desk	background	249
so what do we got here how much memory does a two level page table require assuming the data segment requires two pages and the stack requires two pages ok right so we'll pretend water thirty two bit system so i've got my four thousand ninety six bytes for each page	memory	32
so what do we got here how much memory does a two level page table require assuming the data segment requires two pages and the stack requires two pages ok right so we'll pretend water thirty two bit system so i've got my four thousand ninety six bytes for each page	system	200
in other words i'm running a very small program here maybe it is e m v or cats or something like that ok so very small about the stack very small amount of program and so if i should actually look at the amount of memory that my program is actually using i'm just using two pages down here ok and two pages at the top here now in practice it real example it might be a little bit more complicated than that but let's let's work with this very very simple example	memory	214
and the point realize is that i'm going to need one page of memory to hold the top level page part my page table so there it is ok with it's a thousand twenty four entries did you do ok in other words the top level the top ten bits of feeding into that in order for us to use that but most of my memory space is not	memory	60
so you can see that i've now going to need three three pieces of memory three pages inside my physical memory to hold all of this so that's the overhead of my page table system so what does that mean right	memory	65
so you can see that i've now going to need three three pieces of memory three pages inside my physical memory to hold all of this so that's the overhead of my page table system so what does that mean right	system	170
here we go this is my two entries and also two inches down here for the data segment and if you access any of these but we have to do it will tell you where inside memory as the actual data where the actual program	memory	164
code is or where the actual stack is ok please go to memory over there right	memory	53
code is or where the actual stack is ok please go to memory over there right	code	0
so let's not worry about the actual memory used by my program let's just look at the overhead actually requiring virtual memory annual see now i needed to find space inside my actual physical ram for three pages of memory in other words my overhead is twelve megabytes ok i'd say we've done pretty good at the beginning of this lecture we had a system that required multiple gigabytes and then we went to a single level page table which required four megabytes wait a moment i've got my phone minutes here and now we've got three pages each one is a four four kilobytes oh we've got twelve kb there we go that's much better so the overhead now each process is potentially very very small right so the next thing i want to talk about is	memory	36
so let's not worry about the actual memory used by my program let's just look at the overhead actually requiring virtual memory annual see now i needed to find space inside my actual physical ram for three pages of memory in other words my overhead is twelve megabytes ok i'd say we've done pretty good at the beginning of this lecture we had a system that required multiple gigabytes and then we went to a single level page table which required four megabytes wait a moment i've got my phone minutes here and now we've got three pages each one is a four four kilobytes oh we've got twelve kb there we go that's much better so the overhead now each process is potentially very very small right so the next thing i want to talk about is	system	345
blueish thing here ok we will say for example scrub that out will make it so that this points to nothing okayed it does not actually refer to any valid memory but if my process actually at some point needs that we can regenerate in the future so let's talk about that in the next video bye	memory	152
see will see that process so that the other type rate will look at is when process for arrives at the same time to another process is finished and will assume that to be most fair that will put process for ahead on the ready queue so let's see this so we'll get started and we've got a round robin where that i'm content of ten milliseconds every ten milliseconds hardware time is going to go off	type	44
and after ten milliseconds we say ok process one jump out of the hot seat out the cpu because i'm going to run a different process process four is also appeared on the scene so my ready queue would actually look like now that process two is running my queue would look like a process three in the hot seat will be next so process four has arrived and process one is at very back in the ready queue waiting ok so that would be my queue waiting to go right after ten minutes seconds	a process	274
because it only arrived ten minutes after ten milliseconds so it's wait time with these two blocks here so it's totaled wait time was twenty milliseconds	block	92
so we could actually calculate the total wait time of my system so here's the earlier time that we spent twiddling our fingers waiting for our different choices to finish an if we add up all of these will see we've got total wait time of one hundred milliseconds hundred sixty milliseconds which is an average of forty milliseconds	system	57
ok so hopefully i've convinced you the total wait time changes based on their scheduler and also it just a feeling of hey these schedulers do impact the actual performance to running performance of the system so the last thing we need to talk about will be the convoy effect so we'll talk about that in the last video by	system	202
ok sir in the beginning of the course we had a very simple idea about what processes we just said hey let's to start off with the program will load it into memory will assign a cpu and off we go and that memory is going to contain the code that we've loaded from disk some space for the heap and the stack etc right now we are always so model now is a lot more sophisticated let's just quickly review all the things that we now understand	memory	156
ok sir in the beginning of the course we had a very simple idea about what processes we just said hey let's to start off with the program will load it into memory will assign a cpu and off we go and that memory is going to contain the code that we've loaded from disk some space for the heap and the stack etc right now we are always so model now is a lot more sophisticated let's just quickly review all the things that we now understand	the heap	283
ok sir in the beginning of the course we had a very simple idea about what processes we just said hey let's to start off with the program will load it into memory will assign a cpu and off we go and that memory is going to contain the code that we've loaded from disk some space for the heap and the stack etc right now we are always so model now is a lot more sophisticated let's just quickly review all the things that we now understand	code	235
that comprises a process first of all we now know that the memory that we are working with the process is actually virtual memory and the mapping from that using page tables to the actual physical ram and that that mapping can change overtime so we might need more memory but we might also page out some of our memory in order to reuse that ram for other processes	memory	59
that comprises a process first of all we now know that the memory that we are working with the process is actually virtual memory and the mapping from that using page tables to the actual physical ram and that that mapping can change overtime so we might need more memory but we might also page out some of our memory in order to reuse that ram for other processes	a process	15
we've also realize that hey my process can have more than one cpu and more more than one thread of execution we also realize there's a hierarchy of processes so each process has its own id and apparent as well	thread	89
of the user the original user that is sitting behind the keyboard the user id here just a number but then what can this program actually do when it's running as a process that is governed by the effective user id and we saw how using things like the sticky bit we could actually run as a different user with different privileges our process also contains a present working directory and we're going to need this and use this anytime that we are working with relative paths because they are relative to the current directory and we know that we can change this by using things like chi hdr tudor	a process	161
used by the process and also possibly the amount of cpu time that is used in more recently is perhaps the last kind of time segment also process may be running or not perhaps we've temporarily paused it for example we running inside the debugger or we sent it a signal to stop it well we finished so we have a process a state diagram that we can describe how the running status of all processes change then we got things like constraints which is part of our security model to make sure that one process can't take over all of the resources inside our system and you can often modify any of these constraints using you limits so for example we might want to limit the amount of processes we can create for particular user or the amount of memory that our process can have that kind of thing or even the number of file descriptors we also have meta information about whether we care a lot about a particular process or thread we can give them different priorities so if you have a thread whose goal is to keep the steering wheels pointed in the right direction that's probably a pretty high priority thread and it should be given a cpu in priority compared to say something which is going to download an update off the internet	memory	739
used by the process and also possibly the amount of cpu time that is used in more recently is perhaps the last kind of time segment also process may be running or not perhaps we've temporarily paused it for example we running inside the debugger or we sent it a signal to stop it well we finished so we have a process a state diagram that we can describe how the running status of all processes change then we got things like constraints which is part of our security model to make sure that one process can't take over all of the resources inside our system and you can often modify any of these constraints using you limits so for example we might want to limit the amount of processes we can create for particular user or the amount of memory that our process can have that kind of thing or even the number of file descriptors we also have meta information about whether we care a lot about a particular process or thread we can give them different priorities so if you have a thread whose goal is to keep the steering wheels pointed in the right direction that's probably a pretty high priority thread and it should be given a cpu in priority compared to say something which is going to download an update off the internet	a thread	978
used by the process and also possibly the amount of cpu time that is used in more recently is perhaps the last kind of time segment also process may be running or not perhaps we've temporarily paused it for example we running inside the debugger or we sent it a signal to stop it well we finished so we have a process a state diagram that we can describe how the running status of all processes change then we got things like constraints which is part of our security model to make sure that one process can't take over all of the resources inside our system and you can often modify any of these constraints using you limits so for example we might want to limit the amount of processes we can create for particular user or the amount of memory that our process can have that kind of thing or even the number of file descriptors we also have meta information about whether we care a lot about a particular process or thread we can give them different priorities so if you have a thread whose goal is to keep the steering wheels pointed in the right direction that's probably a pretty high priority thread and it should be given a cpu in priority compared to say something which is going to download an update off the internet	a process	308
used by the process and also possibly the amount of cpu time that is used in more recently is perhaps the last kind of time segment also process may be running or not perhaps we've temporarily paused it for example we running inside the debugger or we sent it a signal to stop it well we finished so we have a process a state diagram that we can describe how the running status of all processes change then we got things like constraints which is part of our security model to make sure that one process can't take over all of the resources inside our system and you can often modify any of these constraints using you limits so for example we might want to limit the amount of processes we can create for particular user or the amount of memory that our process can have that kind of thing or even the number of file descriptors we also have meta information about whether we care a lot about a particular process or thread we can give them different priorities so if you have a thread whose goal is to keep the steering wheels pointed in the right direction that's probably a pretty high priority thread and it should be given a cpu in priority compared to say something which is going to download an update off the internet	thread	918
used by the process and also possibly the amount of cpu time that is used in more recently is perhaps the last kind of time segment also process may be running or not perhaps we've temporarily paused it for example we running inside the debugger or we sent it a signal to stop it well we finished so we have a process a state diagram that we can describe how the running status of all processes change then we got things like constraints which is part of our security model to make sure that one process can't take over all of the resources inside our system and you can often modify any of these constraints using you limits so for example we might want to limit the amount of processes we can create for particular user or the amount of memory that our process can have that kind of thing or even the number of file descriptors we also have meta information about whether we care a lot about a particular process or thread we can give them different priorities so if you have a thread whose goal is to keep the steering wheels pointed in the right direction that's probably a pretty high priority thread and it should be given a cpu in priority compared to say something which is going to download an update off the internet	resources	531
used by the process and also possibly the amount of cpu time that is used in more recently is perhaps the last kind of time segment also process may be running or not perhaps we've temporarily paused it for example we running inside the debugger or we sent it a signal to stop it well we finished so we have a process a state diagram that we can describe how the running status of all processes change then we got things like constraints which is part of our security model to make sure that one process can't take over all of the resources inside our system and you can often modify any of these constraints using you limits so for example we might want to limit the amount of processes we can create for particular user or the amount of memory that our process can have that kind of thing or even the number of file descriptors we also have meta information about whether we care a lot about a particular process or thread we can give them different priorities so if you have a thread whose goal is to keep the steering wheels pointed in the right direction that's probably a pretty high priority thread and it should be given a cpu in priority compared to say something which is going to download an update off the internet	system	552
and the last thing will have it set up process which will talk about any future lecture is this concept of umask which is going to be used when we create new threads sorry knew files and new directories but more about new mask in the future	thread	158
in other words if you're the code that cares about to say the cat jpeg you shouldn't need to care about whether the whole javascript have another libi has been finished loading no we just want to be able to	code	29
stuff bites into our tcp connection as fast as possible maybe they may not even be complete resources so if you like it's a bit like saying look i've got a kind of conveyor belt here and i've got amazon workers on this side ok here we go taking boxes and packages as quickly as possible stuffing them onto the conveyor belt and then the other side we've got another little worker that as things appear they distribute them into the right channel so oh look here's some more bites for the jpeg image here some more bytes for one javascript library is some of the css s so we're using this pipe as if it can actually support multiple streams at the same time in other words we've lifted it to a new level of abstraction as if there's multiple connections to the same server whereas in fact it's all running over a single tcp connection but we are hiding that from the higher part of the web browser so that is http you there's one last kind of really fun feature which is server side push that when you request the picture of so the website of your favorite cats dot com you the server already knows the resources that you're likely to want it already knows that you're in the future as soon as you decode this web page that you're going to be asking for a cat say the react javascript library and maybe the custom css s so why doesn't the server actually say hey have these resources i know you haven't even asked for them yet but i know that you're going to want them in the future so it's a bit like the way to say hey have this have this soul all this bread or idea or all these beings i know that you haven't even finished your order yet but i have a sneaking suspicion that you're going to be happy that i already started for filling your table and pulling these things on it before you even ask to it so this is what's called server side push	code	1199
stuff bites into our tcp connection as fast as possible maybe they may not even be complete resources so if you like it's a bit like saying look i've got a kind of conveyor belt here and i've got amazon workers on this side ok here we go taking boxes and packages as quickly as possible stuffing them onto the conveyor belt and then the other side we've got another little worker that as things appear they distribute them into the right channel so oh look here's some more bites for the jpeg image here some more bytes for one javascript library is some of the css s so we're using this pipe as if it can actually support multiple streams at the same time in other words we've lifted it to a new level of abstraction as if there's multiple connections to the same server whereas in fact it's all running over a single tcp connection but we are hiding that from the higher part of the web browser so that is http you there's one last kind of really fun feature which is server side push that when you request the picture of so the website of your favorite cats dot com you the server already knows the resources that you're likely to want it already knows that you're in the future as soon as you decode this web page that you're going to be asking for a cat say the react javascript library and maybe the custom css s so why doesn't the server actually say hey have these resources i know you haven't even asked for them yet but i know that you're going to want them in the future so it's a bit like the way to say hey have this have this soul all this bread or idea or all these beings i know that you haven't even finished your order yet but i have a sneaking suspicion that you're going to be happy that i already started for filling your table and pulling these things on it before you even ask to it so this is what's called server side push	resources	92
hi welcome to lecture twenty one so let's get started with a bit of a code review suppose you were given the following code asked to review it, ok what do we think of the following so how can we improve it and what's its purpose so it's called acquire and for gravity to fit onto this slide i've said pmt for p thread mutex if this truly was in the code i might say why we doing why do we have this typedef let's just stick with the regular types but anyway so we get two pointers too	the following	105
hi welcome to lecture twenty one so let's get started with a bit of a code review suppose you were given the following code asked to review it, ok what do we think of the following so how can we improve it and what's its purpose so it's called acquire and for gravity to fit onto this slide i've said pmt for p thread mutex if this truly was in the code i might say why we doing why do we have this typedef let's just stick with the regular types but anyway so we get two pointers too	type	399
hi welcome to lecture twenty one so let's get started with a bit of a code review suppose you were given the following code asked to review it, ok what do we think of the following so how can we improve it and what's its purpose so it's called acquire and for gravity to fit onto this slide i've said pmt for p thread mutex if this truly was in the code i might say why we doing why do we have this typedef let's just stick with the regular types but anyway so we get two pointers too	code	70
hi welcome to lecture twenty one so let's get started with a bit of a code review suppose you were given the following code asked to review it, ok what do we think of the following so how can we improve it and what's its purpose so it's called acquire and for gravity to fit onto this slide i've said pmt for p thread mutex if this truly was in the code i might say why we doing why do we have this typedef let's just stick with the regular types but anyway so we get two pointers too	thread	311
hi welcome to lecture twenty one so let's get started with a bit of a code review suppose you were given the following code asked to review it, ok what do we think of the following so how can we improve it and what's its purpose so it's called acquire and for gravity to fit onto this slide i've said pmt for p thread mutex if this truly was in the code i might say why we doing why do we have this typedef let's just stick with the regular types but anyway so we get two pointers too	pointer	472
mutex a and b alright so one thing i do like is that we're using asserts right so this checks that the a pointer and b pointer are non null so they're going to point hopefully to valid objects and that they are not equal alright so that's good i'm glad that we're using asserts i personally might have put these on separate lines so that if it does fail then we would have actually dissert would've told us which line it failed and therefore which actually which condition caused	pointer	105
desertion to fire right so what does it do next it says if he takes a zombie then lock hey there not be and then log a ok so what is this code trying to do i'll give you a few seconds to read this and see if you can figure it out you ready go	code	138
alright so let's see what are we doing here right we're saying if a is less than be now these are pointers in other words were actually comparing the address of these two objects here and if a is smaller hello address then will lock that first then will not be	address	150
alright so let's see what are we doing here right we're saying if a is less than be now these are pointers in other words were actually comparing the address of these two objects here and if a is smaller hello address then will lock that first then will not be	pointer	98
and then if it turns out that be was actually a smaller address then finally we lock a so turns about code review well i personally would like to see some squiggly braces around here a little bit safer and maybe if we could put on two separate lines as well but what's the purpose of this code will eventually wheelock a and b but we always look at any specific order we always lock the mutex which has the smallest address first why why is that important	code	102
and then if it turns out that be was actually a smaller address then finally we lock a so turns about code review well i personally would like to see some squiggly braces around here a little bit safer and maybe if we could put on two separate lines as well but what's the purpose of this code will eventually wheelock a and b but we always look at any specific order we always lock the mutex which has the smallest address first why why is that important	address	56
if this purpose of this code is simply to end up locking too mutex locks why change you order depending on their address	code	24
if this purpose of this code is simply to end up locking too mutex locks why change you order depending on their address	address	113
ok so hopefully some neurons are firing at this point and you remember what we talked about deadlock we have those four necessary and sufficient conditions to coffman conditions and one of them was that if we have a cycle in the resource allocation graph then log is possible so this code is a stepping stone to making sure that we can't get cycles why because we are going to acquire mutex locks always in the same order in other words we've given them a rank ordering and their ordering is based on the memory location of the actual object in memory so great so providing all of our code which is going to lock mutex is always follows the same convention or cause this method then we can agree that deadlock is impossible right so providing always we get our mutex locks with the smallest first we here with impossible to get a cycle in the resource allocation graph alright so that's the purpose of this code you can invent a similar ideas but often if you got pointers just use the pointer value as as a way to order the items that you need to acquire for exclusive access right in the next video we can start talking about how we can actually implement virtual memory so by understanding how virtual memory works uh we can understand some of the tradeoffs that occured some of its performance characteristics and then later will be used in this machinery to do things like memory mapped files but	memory	505
ok so hopefully some neurons are firing at this point and you remember what we talked about deadlock we have those four necessary and sufficient conditions to coffman conditions and one of them was that if we have a cycle in the resource allocation graph then log is possible so this code is a stepping stone to making sure that we can't get cycles why because we are going to acquire mutex locks always in the same order in other words we've given them a rank ordering and their ordering is based on the memory location of the actual object in memory so great so providing all of our code which is going to lock mutex is always follows the same convention or cause this method then we can agree that deadlock is impossible right so providing always we get our mutex locks with the smallest first we here with impossible to get a cycle in the resource allocation graph alright so that's the purpose of this code you can invent a similar ideas but often if you got pointers just use the pointer value as as a way to order the items that you need to acquire for exclusive access right in the next video we can start talking about how we can actually implement virtual memory so by understanding how virtual memory works uh we can understand some of the tradeoffs that occured some of its performance characteristics and then later will be used in this machinery to do things like memory mapped files but	code	284
ok so hopefully some neurons are firing at this point and you remember what we talked about deadlock we have those four necessary and sufficient conditions to coffman conditions and one of them was that if we have a cycle in the resource allocation graph then log is possible so this code is a stepping stone to making sure that we can't get cycles why because we are going to acquire mutex locks always in the same order in other words we've given them a rank ordering and their ordering is based on the memory location of the actual object in memory so great so providing all of our code which is going to lock mutex is always follows the same convention or cause this method then we can agree that deadlock is impossible right so providing always we get our mutex locks with the smallest first we here with impossible to get a cycle in the resource allocation graph alright so that's the purpose of this code you can invent a similar ideas but often if you got pointers just use the pointer value as as a way to order the items that you need to acquire for exclusive access right in the next video we can start talking about how we can actually implement virtual memory so by understanding how virtual memory works uh we can understand some of the tradeoffs that occured some of its performance characteristics and then later will be used in this machinery to do things like memory mapped files but	pointer	964
that's here we go let's talk about selecting people have a case remember select came first and so one good reason for using select is when you care about writing something we just cross platform in other words you wanted to make it work on say mac as well or bsd you want to make it work on windows even then selects is has been around the longest and is the simplest to use so if you just want to write some very simple code where a single thread	code	421
that's here we go let's talk about selecting people have a case remember select came first and so one good reason for using select is when you care about writing something we just cross platform in other words you wanted to make it work on say mac as well or bsd you want to make it work on windows even then selects is has been around the longest and is the simplest to use so if you just want to write some very simple code where a single thread	thread	441
then you select and the amount of code you need to write will be smaller and it's much simpler to use ok but if your goal on linux is to write a high performance server then epoll should be your answer ok so epoll is obviously like i said linux specific it's also event based meaning that we can find out in an array	code	34
an object which is simply a simple set of integers which is the file descriptors say here go equal here's all the file descriptors that we care about now please block until there's at least one event happening on these and then when you return don't return just one event give us an array of all events that we should work through to process	block	161
how you write your code depends on on which version of these you use there's a couple of advantages to kind of both approaches arguably for level detection it's a little bit simpler code because you're now you can just simply say ok lyrics thank you for telling me all the file descripters which need need processing and if for some strange reason i don't say to get to a particular one then it doesn't matter because the next time i call epoll i have something to be done equals going to tell me about it	code	19
life with edge to edge detection one advantage here is if you actually got multiple threads then by being told about this event only once then you can ensure that a single thread that called epoll is assigned that duty is assigned the problem of working with that particular file descriptor because if other threads now call epoll they're not going to be told about it they're not going to be not decide this file descriptor a task because he's kinda being used it's common it's been assigned to a different file descriptor sort different thread	thread	84
hi welcome to lecture fourteen so let's dive in and have a look at some threads unlocked are you ready ok so let's get started right so take a look at this crazy code here and this work out what's going to happen on a sixty four bit machine and thirty two bit machine so your first comment is how could this possibly compile hello is not an int ok so what do we have here well of course we have a string literal so this is going to behave as an array but can also decay into just a pointer point being the memory address of this first entry the age ok so that memory address could be treated as an int right which we then store into this variable and then later we say ok take that in value and pass it so and change its type backed into a character pointer	memory	506
hi welcome to lecture fourteen so let's dive in and have a look at some threads unlocked are you ready ok so let's get started right so take a look at this crazy code here and this work out what's going to happen on a sixty four bit machine and thirty two bit machine so your first comment is how could this possibly compile hello is not an int ok so what do we have here well of course we have a string literal so this is going to behave as an array but can also decay into just a pointer point being the memory address of this first entry the age ok so that memory address could be treated as an int right which we then store into this variable and then later we say ok take that in value and pass it so and change its type backed into a character pointer	type	721
hi welcome to lecture fourteen so let's dive in and have a look at some threads unlocked are you ready ok so let's get started right so take a look at this crazy code here and this work out what's going to happen on a sixty four bit machine and thirty two bit machine so your first comment is how could this possibly compile hello is not an int ok so what do we have here well of course we have a string literal so this is going to behave as an array but can also decay into just a pointer point being the memory address of this first entry the age ok so that memory address could be treated as an int right which we then store into this variable and then later we say ok take that in value and pass it so and change its type backed into a character pointer	code	162
hi welcome to lecture fourteen so let's dive in and have a look at some threads unlocked are you ready ok so let's get started right so take a look at this crazy code here and this work out what's going to happen on a sixty four bit machine and thirty two bit machine so your first comment is how could this possibly compile hello is not an int ok so what do we have here well of course we have a string literal so this is going to behave as an array but can also decay into just a pointer point being the memory address of this first entry the age ok so that memory address could be treated as an int right which we then store into this variable and then later we say ok take that in value and pass it so and change its type backed into a character pointer	string	397
hi welcome to lecture fourteen so let's dive in and have a look at some threads unlocked are you ready ok so let's get started right so take a look at this crazy code here and this work out what's going to happen on a sixty four bit machine and thirty two bit machine so your first comment is how could this possibly compile hello is not an int ok so what do we have here well of course we have a string literal so this is going to behave as an array but can also decay into just a pointer point being the memory address of this first entry the age ok so that memory address could be treated as an int right which we then store into this variable and then later we say ok take that in value and pass it so and change its type backed into a character pointer	thread	72
hi welcome to lecture fourteen so let's dive in and have a look at some threads unlocked are you ready ok so let's get started right so take a look at this crazy code here and this work out what's going to happen on a sixty four bit machine and thirty two bit machine so your first comment is how could this possibly compile hello is not an int ok so what do we have here well of course we have a string literal so this is going to behave as an array but can also decay into just a pointer point being the memory address of this first entry the age ok so that memory address could be treated as an int right which we then store into this variable and then later we say ok take that in value and pass it so and change its type backed into a character pointer	address	513
hi welcome to lecture fourteen so let's dive in and have a look at some threads unlocked are you ready ok so let's get started right so take a look at this crazy code here and this work out what's going to happen on a sixty four bit machine and thirty two bit machine so your first comment is how could this possibly compile hello is not an int ok so what do we have here well of course we have a string literal so this is going to behave as an array but can also decay into just a pointer point being the memory address of this first entry the age ok so that memory address could be treated as an int right which we then store into this variable and then later we say ok take that in value and pass it so and change its type backed into a character pointer	pointer	482
right so this gives me shivers down my spine here will it work one of the question is do we feel lucky there is a chance that the memory address of hello because it's a little in a memory will be in a low address so there's a chance that we could actually represent that using a c type int let's think about this for a moment so we could be on a thirty two bit machine where the integers for example might be thirty two bits and the pointers are thirty two bits in which case great everything is fine so there's a very strong chance it work despite i was going oh that doesn't seem like compliant code yes so in practice we wouldn't want to write this but on a thirty two bit machine it stands a high chance of working and in fact plenty of code used to be written like this where there was a spare spare parameter or a struct like a user parameter it was just an in so people will just throw pointers in there ok that worked for many years until the day that we decided to try to compile this code onto a sixty four bit machine now let's see what happens about when you do this trick on a sixty four bit machine so now my integers are only going to be thirty two bit still	memory	130
right so this gives me shivers down my spine here will it work one of the question is do we feel lucky there is a chance that the memory address of hello because it's a little in a memory will be in a low address so there's a chance that we could actually represent that using a c type int let's think about this for a moment so we could be on a thirty two bit machine where the integers for example might be thirty two bits and the pointers are thirty two bits in which case great everything is fine so there's a very strong chance it work despite i was going oh that doesn't seem like compliant code yes so in practice we wouldn't want to write this but on a thirty two bit machine it stands a high chance of working and in fact plenty of code used to be written like this where there was a spare spare parameter or a struct like a user parameter it was just an in so people will just throw pointers in there ok that worked for many years until the day that we decided to try to compile this code onto a sixty four bit machine now let's see what happens about when you do this trick on a sixty four bit machine so now my integers are only going to be thirty two bit still	type	281
right so this gives me shivers down my spine here will it work one of the question is do we feel lucky there is a chance that the memory address of hello because it's a little in a memory will be in a low address so there's a chance that we could actually represent that using a c type int let's think about this for a moment so we could be on a thirty two bit machine where the integers for example might be thirty two bits and the pointers are thirty two bits in which case great everything is fine so there's a very strong chance it work despite i was going oh that doesn't seem like compliant code yes so in practice we wouldn't want to write this but on a thirty two bit machine it stands a high chance of working and in fact plenty of code used to be written like this where there was a spare spare parameter or a struct like a user parameter it was just an in so people will just throw pointers in there ok that worked for many years until the day that we decided to try to compile this code onto a sixty four bit machine now let's see what happens about when you do this trick on a sixty four bit machine so now my integers are only going to be thirty two bit still	parameter	805
right so this gives me shivers down my spine here will it work one of the question is do we feel lucky there is a chance that the memory address of hello because it's a little in a memory will be in a low address so there's a chance that we could actually represent that using a c type int let's think about this for a moment so we could be on a thirty two bit machine where the integers for example might be thirty two bits and the pointers are thirty two bits in which case great everything is fine so there's a very strong chance it work despite i was going oh that doesn't seem like compliant code yes so in practice we wouldn't want to write this but on a thirty two bit machine it stands a high chance of working and in fact plenty of code used to be written like this where there was a spare spare parameter or a struct like a user parameter it was just an in so people will just throw pointers in there ok that worked for many years until the day that we decided to try to compile this code onto a sixty four bit machine now let's see what happens about when you do this trick on a sixty four bit machine so now my integers are only going to be thirty two bit still	a struct	818
right so this gives me shivers down my spine here will it work one of the question is do we feel lucky there is a chance that the memory address of hello because it's a little in a memory will be in a low address so there's a chance that we could actually represent that using a c type int let's think about this for a moment so we could be on a thirty two bit machine where the integers for example might be thirty two bits and the pointers are thirty two bits in which case great everything is fine so there's a very strong chance it work despite i was going oh that doesn't seem like compliant code yes so in practice we wouldn't want to write this but on a thirty two bit machine it stands a high chance of working and in fact plenty of code used to be written like this where there was a spare spare parameter or a struct like a user parameter it was just an in so people will just throw pointers in there ok that worked for many years until the day that we decided to try to compile this code onto a sixty four bit machine now let's see what happens about when you do this trick on a sixty four bit machine so now my integers are only going to be thirty two bit still	code	597
right so this gives me shivers down my spine here will it work one of the question is do we feel lucky there is a chance that the memory address of hello because it's a little in a memory will be in a low address so there's a chance that we could actually represent that using a c type int let's think about this for a moment so we could be on a thirty two bit machine where the integers for example might be thirty two bits and the pointers are thirty two bits in which case great everything is fine so there's a very strong chance it work despite i was going oh that doesn't seem like compliant code yes so in practice we wouldn't want to write this but on a thirty two bit machine it stands a high chance of working and in fact plenty of code used to be written like this where there was a spare spare parameter or a struct like a user parameter it was just an in so people will just throw pointers in there ok that worked for many years until the day that we decided to try to compile this code onto a sixty four bit machine now let's see what happens about when you do this trick on a sixty four bit machine so now my integers are only going to be thirty two bit still	address	137
right so this gives me shivers down my spine here will it work one of the question is do we feel lucky there is a chance that the memory address of hello because it's a little in a memory will be in a low address so there's a chance that we could actually represent that using a c type int let's think about this for a moment so we could be on a thirty two bit machine where the integers for example might be thirty two bits and the pointers are thirty two bits in which case great everything is fine so there's a very strong chance it work despite i was going oh that doesn't seem like compliant code yes so in practice we wouldn't want to write this but on a thirty two bit machine it stands a high chance of working and in fact plenty of code used to be written like this where there was a spare spare parameter or a struct like a user parameter it was just an in so people will just throw pointers in there ok that worked for many years until the day that we decided to try to compile this code onto a sixty four bit machine now let's see what happens about when you do this trick on a sixty four bit machine so now my integers are only going to be thirty two bit still	pointer	433
but my point is can be much larger they have a much larger space of numbers now address space now sixty four bits so in practice what's going to happen here we're going to truncate the value only going to take the lowest thirty two bits the bits that actually can be represented by the end oh dear so are we going to be lucky is it going to be the upper thirty two bits are all zero well maybe maybe in this specific example because we're testing it with a string literal and we know that's likely to be in a low part of memory but in general if this is say appointed to malloc it's unlikely to work once we start having values greater than what see about four gigabytes or so so so yes don't do this if you're going to avoid it it's not safe so that was fun but don't be surprised to see this kind of ugly code in old c code and hopefully now understand why it might work in some systems and might fail miserably in others by	memory	521
but my point is can be much larger they have a much larger space of numbers now address space now sixty four bits so in practice what's going to happen here we're going to truncate the value only going to take the lowest thirty two bits the bits that actually can be represented by the end oh dear so are we going to be lucky is it going to be the upper thirty two bits are all zero well maybe maybe in this specific example because we're testing it with a string literal and we know that's likely to be in a low part of memory but in general if this is say appointed to malloc it's unlikely to work once we start having values greater than what see about four gigabytes or so so so yes don't do this if you're going to avoid it it's not safe so that was fun but don't be surprised to see this kind of ugly code in old c code and hopefully now understand why it might work in some systems and might fail miserably in others by	code	807
but my point is can be much larger they have a much larger space of numbers now address space now sixty four bits so in practice what's going to happen here we're going to truncate the value only going to take the lowest thirty two bits the bits that actually can be represented by the end oh dear so are we going to be lucky is it going to be the upper thirty two bits are all zero well maybe maybe in this specific example because we're testing it with a string literal and we know that's likely to be in a low part of memory but in general if this is say appointed to malloc it's unlikely to work once we start having values greater than what see about four gigabytes or so so so yes don't do this if you're going to avoid it it's not safe so that was fun but don't be surprised to see this kind of ugly code in old c code and hopefully now understand why it might work in some systems and might fail miserably in others by	string	457
but my point is can be much larger they have a much larger space of numbers now address space now sixty four bits so in practice what's going to happen here we're going to truncate the value only going to take the lowest thirty two bits the bits that actually can be represented by the end oh dear so are we going to be lucky is it going to be the upper thirty two bits are all zero well maybe maybe in this specific example because we're testing it with a string literal and we know that's likely to be in a low part of memory but in general if this is say appointed to malloc it's unlikely to work once we start having values greater than what see about four gigabytes or so so so yes don't do this if you're going to avoid it it's not safe so that was fun but don't be surprised to see this kind of ugly code in old c code and hopefully now understand why it might work in some systems and might fail miserably in others by	address	80
but my point is can be much larger they have a much larger space of numbers now address space now sixty four bits so in practice what's going to happen here we're going to truncate the value only going to take the lowest thirty two bits the bits that actually can be represented by the end oh dear so are we going to be lucky is it going to be the upper thirty two bits are all zero well maybe maybe in this specific example because we're testing it with a string literal and we know that's likely to be in a low part of memory but in general if this is say appointed to malloc it's unlikely to work once we start having values greater than what see about four gigabytes or so so so yes don't do this if you're going to avoid it it's not safe so that was fun but don't be surprised to see this kind of ugly code in old c code and hopefully now understand why it might work in some systems and might fail miserably in others by	system	881
hi so let's workout how we can use real path to actually test something about our directory structure and for example whether a file is truly inside the directory that we care about alright so first of all let's have a quick play with it directly so here is real path and will see that we're going to pass in the following relative directory so that's relative to the current path of my program the current path associated with this process and we are not going to give it any memory to write the result into so real path internally is actually going to call malloc is going to get some heap memory for the result which is why at the very end we are going to free it so you'll notice i put a little bit of logic in here to see whether it	the following	309
hi so let's workout how we can use real path to actually test something about our directory structure and for example whether a file is truly inside the directory that we care about alright so first of all let's have a quick play with it directly so here is real path and will see that we're going to pass in the following relative directory so that's relative to the current path of my program the current path associated with this process and we are not going to give it any memory to write the result into so real path internally is actually going to call malloc is going to get some heap memory for the result which is why at the very end we are going to free it so you'll notice i put a little bit of logic in here to see whether it	heap memory	587
hi so let's workout how we can use real path to actually test something about our directory structure and for example whether a file is truly inside the directory that we care about alright so first of all let's have a quick play with it directly so here is real path and will see that we're going to pass in the following relative directory so that's relative to the current path of my program the current path associated with this process and we are not going to give it any memory to write the result into so real path internally is actually going to call malloc is going to get some heap memory for the result which is why at the very end we are going to free it so you'll notice i put a little bit of logic in here to see whether it	memory	477
i want to compile this ok so we had real path demo give it a second so we've gone missing semicolon so to fix that ok right so what is it down it's given me a path which is the absolute path but as you can see it's dropped two directories as we've dropped slash code slash lec27 at the top which makes probably says because we went to the parent directory twice so what about this suppose we went into some subdirectory	code	262
ok run it again and this time it is no such path so real path is doing more than just simple string manipulation is actually testing to see whether each part that path element exists or not so in order for it to actually find that directory we actually have to go and make those places we have to make sub one sub two so let's do that we can say make this one and then make do a sub one sub too if i wanted to do that in one go i could have actually said minus p and that would have made all	string	93
so now those exist so now when we run it it gives us a non null path it went into sub one went into sub two and then i said ok now i need to find a parent now you find that so great is given me canonical paths let's start talking about how we can use this for something like a file server so which is part of a web server how can i make sure that i only serve content from my web directory i don't want to start this happily sending the contents of arbitrary files ok so for this i'm going to make use of two other things i'm going to use asprintf and also strcmp but not only strcmp but strncmp so we'll see how these are useful so remember that if you call sprintf nothing is going to appear instead you give it some memory you say ok here's some memory on the heap that i've already malloced and please write the string into their so for example if i wanted to construct path like i might say ok look at percent s percent s and this might be say the the root of where i'm storing all my files and the request from the user of to what particular resource they want that's great but i better make sure that this string that i construct is no bigger than the heap memory that i required perhaps i just want to be lazy and say hey printf can't you	heap memory	1159
so now those exist so now when we run it it gives us a non null path it went into sub one went into sub two and then i said ok now i need to find a parent now you find that so great is given me canonical paths let's start talking about how we can use this for something like a file server so which is part of a web server how can i make sure that i only serve content from my web directory i don't want to start this happily sending the contents of arbitrary files ok so for this i'm going to make use of two other things i'm going to use asprintf and also strcmp but not only strcmp but strncmp so we'll see how these are useful so remember that if you call sprintf nothing is going to appear instead you give it some memory you say ok here's some memory on the heap that i've already malloced and please write the string into their so for example if i wanted to construct path like i might say ok look at percent s percent s and this might be say the the root of where i'm storing all my files and the request from the user of to what particular resource they want that's great but i better make sure that this string that i construct is no bigger than the heap memory that i required perhaps i just want to be lazy and say hey printf can't you	memory	719
so now those exist so now when we run it it gives us a non null path it went into sub one went into sub two and then i said ok now i need to find a parent now you find that so great is given me canonical paths let's start talking about how we can use this for something like a file server so which is part of a web server how can i make sure that i only serve content from my web directory i don't want to start this happily sending the contents of arbitrary files ok so for this i'm going to make use of two other things i'm going to use asprintf and also strcmp but not only strcmp but strncmp so we'll see how these are useful so remember that if you call sprintf nothing is going to appear instead you give it some memory you say ok here's some memory on the heap that i've already malloced and please write the string into their so for example if i wanted to construct path like i might say ok look at percent s percent s and this might be say the the root of where i'm storing all my files and the request from the user of to what particular resource they want that's great but i better make sure that this string that i construct is no bigger than the heap memory that i required perhaps i just want to be lazy and say hey printf can't you	the heap	759
so now those exist so now when we run it it gives us a non null path it went into sub one went into sub two and then i said ok now i need to find a parent now you find that so great is given me canonical paths let's start talking about how we can use this for something like a file server so which is part of a web server how can i make sure that i only serve content from my web directory i don't want to start this happily sending the contents of arbitrary files ok so for this i'm going to make use of two other things i'm going to use asprintf and also strcmp but not only strcmp but strncmp so we'll see how these are useful so remember that if you call sprintf nothing is going to appear instead you give it some memory you say ok here's some memory on the heap that i've already malloced and please write the string into their so for example if i wanted to construct path like i might say ok look at percent s percent s and this might be say the the root of where i'm storing all my files and the request from the user of to what particular resource they want that's great but i better make sure that this string that i construct is no bigger than the heap memory that i required perhaps i just want to be lazy and say hey printf can't you	printf	541
so now those exist so now when we run it it gives us a non null path it went into sub one went into sub two and then i said ok now i need to find a parent now you find that so great is given me canonical paths let's start talking about how we can use this for something like a file server so which is part of a web server how can i make sure that i only serve content from my web directory i don't want to start this happily sending the contents of arbitrary files ok so for this i'm going to make use of two other things i'm going to use asprintf and also strcmp but not only strcmp but strncmp so we'll see how these are useful so remember that if you call sprintf nothing is going to appear instead you give it some memory you say ok here's some memory on the heap that i've already malloced and please write the string into their so for example if i wanted to construct path like i might say ok look at percent s percent s and this might be say the the root of where i'm storing all my files and the request from the user of to what particular resource they want that's great but i better make sure that this string that i construct is no bigger than the heap memory that i required perhaps i just want to be lazy and say hey printf can't you	string	816
just get some heap memory automatically for me and that is the purpose of asprintf which will automatically	heap memory	14
just get some heap memory automatically for me and that is the purpose of asprintf which will automatically	memory	19
just get some heap memory automatically for me and that is the purpose of asprintf which will automatically	printf	76
reserve some memory on the heap and return a pointer that ok so we just have to put in asprintf keep going down here here it is you'll see that it takes a pointer to a pointer so now with asprintf we actually say ok here's the result my result variable and	memory	13
reserve some memory on the heap and return a pointer that ok so we just have to put in asprintf keep going down here here it is you'll see that it takes a pointer to a pointer so now with asprintf we actually say ok here's the result my result variable and	the heap	23
reserve some memory on the heap and return a pointer that ok so we just have to put in asprintf keep going down here here it is you'll see that it takes a pointer to a pointer so now with asprintf we actually say ok here's the result my result variable and	printf	89
reserve some memory on the heap and return a pointer that ok so we just have to put in asprintf keep going down here here it is you'll see that it takes a pointer to a pointer so now with asprintf we actually say ok here's the result my result variable and	pointer	45
i want it i want its address because i'm going to change it so so i actually have a little result for example that and that's going to be changed and then later don't forget to free it as well so let's be good zero	address	21
so we could check to see if it really worked if we wanted to write really robust code ok so let's say where am i going to store my files let's say that all the files i want to serve our inside	code	81
and you notice that we've got two strings now on the heap ok so let's just make that cat right so i can touch files sub one sub to cat dot jpeg and touch does two things it creates a file if it doesn't exist obviously with zero bytes and also we've just going to change the modification time to just now so touch even if the file exists is modifying the meta information about when the while was last changed when it was last modified ok so let's give this a shot let's actually try this and see whether we get a valid path so let's clear this	the heap	49
and you notice that we've got two strings now on the heap ok so let's just make that cat right so i can touch files sub one sub to cat dot jpeg and touch does two things it creates a file if it doesn't exist obviously with zero bytes and also we've just going to change the modification time to just now so touch even if the file exists is modifying the meta information about when the while was last changed when it was last modified ok so let's give this a shot let's actually try this and see whether we get a valid path so let's clear this	string	34
everything that we are sending is a subdirectory of the following in other words the canonical path should always start with the following characters that i've highlighted if there was a malicious user requesting resources for example they might request dot dot slash dot dot slash dot dot slash dot dot slash	the following	52
everything that we are sending is a subdirectory of the following in other words the canonical path should always start with the following characters that i've highlighted if there was a malicious user requesting resources for example they might request dot dot slash dot dot slash dot dot slash dot dot slash	resources	213
two paths and now i just want to see if they are valid so for this i want to say ok let's compare the first n characters so let's have a look at the path of what you'd like versus the base path and we'll see if they start the same so those are the two strings i want to compare but i do want to compare all of the letters and you want to compare up to the length of the base path ok so if they're the same then great i now know that i'm looking inside that subdirectory	string	252
ok oh wait i need to include strncmp so i haven't included string.h yet ok fine let's get string.h each	string	59
ok so off you go run it again and great so now the request the file that we're going to serve over our web server looks like a valid resource ok sure you can i think we've talked about most things well talk about 'cause i've got this is another little demo over here where i take the base path and i look at different requests by using the argument but that is just repeat of the demo i've just given again where we use asprintf and we use real path twice ok so that's kind of quick introduction to real path it's very useful on	printf	422
hi ok so we just started to see that we can actually run things in the background i can actually run multiple things at the same time from the same shell so just a quick breakdown of what you can do ok so let's get started we've seen ampersand so this means don't wait for the can't command to finish i've got other things to do ps gives me a list of processes like ls extent stop instead of listing from a directory is giving your process list	background	71
and i can control that output i can see where the process is obvious i can see a even other processes from other users now if i would care about all the jobs i've been running in the background i can type jobs and then i can refer to specific jobs later by doing things like percent one percent two percent three to talk about my other jobs running the background i can send jobs from the foreground to the background i can temporarily start and stop them so for example if i send sigstop signal i can then send that process off to run in the background and by the way if you press ctrl z	type	200
and i can control that output i can see where the process is obvious i can see a even other processes from other users now if i would care about all the jobs i've been running in the background i can type jobs and then i can refer to specific jobs later by doing things like percent one percent two percent three to talk about my other jobs running the background i can send jobs from the foreground to the background i can temporarily start and stop them so for example if i send sigstop signal i can then send that process off to run in the background and by the way if you press ctrl z	background	183
then you temporarily stop a program and you can either then at that point we started again send it into the foreground by just typing fg in bash or bg to send it into the background	background	171
and whatever you want you want something to keep running after you log out then here's the way to do it you say no hub and then the program that will try to run and then let's run it in the background so now when you quit out of ssh your program do something can continue running and here's how this little program called no hub doesn't do much all it does is just eats up another signal called c cup so that which which by default would kill your process	background	190
so we can do lots of interesting things with this but i ask you to kind of be respectful of ad environment as you know energii use caused contributes to global warming climate change and be the university resources that these are shared resources don't try to mine coins on these you'll be discovered you'll be found out and it's not appropriate use so but let me show you a real example use of this is that now i	resources	205
and i had a whole lot of different files to analyze so i quickly wrote the following little script where you can see i ran all these different little programs in parallel i didn't need to wait for them all and then afterwards i called weight in order to set ok before i continue i want for these processes to finish so this is all under the idea of kind of job control very very easy to do and very powerful if you want to start to kind of work on bigger problems the last thing we haven't talked about is redirection and pipes so	the following	71
counts up the number of characters words and lines in each program ok so now rather than sending it to stand out i can say please please go to say daily dot text but i can also do some other things here i can take that output and for example i can print a little program as its standard input called sort so hey sort why don't you give me that and sort it numerically so now the output is sorted with the number of lights so you can see my parallel solution actually had the most number of lines and maybe i could type take the output of that and pipe it into a less to allow me to view it one page at a time ok so that's going to the basics of these little programs if you've probably seen things like grab ls are they can be very powerful once you understand how to chain them together with redirection and with pipes	type	514
ok so as a very quick little demo we can talk more about that in the future next video we will look at trying to spot some errors in the following code by	the following	133
ok so as a very quick little demo we can talk more about that in the future next video we will look at trying to spot some errors in the following code by	code	147
hi welcome to lecture twenty so let's have a code review where we're going to talk about a little bit of code that uses condition variables are you ready ok so my little application is very simple it's just got two threads one thread some point is going to modify this value of x and then call signal another thread is waiting for x d b positive so we can think of this basically like a latch and only after it's become positive do we continue right so what do we think about this code	code	45
hi welcome to lecture twenty so let's have a code review where we're going to talk about a little bit of code that uses condition variables are you ready ok so my little application is very simple it's just got two threads one thread some point is going to modify this value of x and then call signal another thread is waiting for x d b positive so we can think of this basically like a latch and only after it's become positive do we continue right so what do we think about this code	thread	215
right so what do we notice first of all that my code over here on the right really does need a mutex lock before we change value of x and we signal ok let's see why the problem occurs is when we call change at the same time that our second thread is actually called in this wait for positive x let's see where the problem could occur	code	48
right so what do we notice first of all that my code over here on the right really does need a mutex lock before we change value of x and we signal ok let's see why the problem occurs is when we call change at the same time that our second thread is actually called in this wait for positive x let's see where the problem could occur	a mutex	93
right so what do we notice first of all that my code over here on the right really does need a mutex lock before we change value of x and we signal ok let's see why the problem occurs is when we call change at the same time that our second thread is actually called in this wait for positive x let's see where the problem could occur	thread	240
we've got this test here and then later maybe a few nanoseconds later but it might be a bit longer eventually by calling peter condition wait my thread is going to block so here's the problem scenario what if we had an interleaving of these operations such that changing the value of x here happens after this test	block	164
we've got this test here and then later maybe a few nanoseconds later but it might be a bit longer eventually by calling peter condition wait my thread is going to block so here's the problem scenario what if we had an interleaving of these operations such that changing the value of x here happens after this test	thread	145
and calling peter condition signal happens before the thread blocks and waits for signals ok so now what's happened our second thread is going to deadlock it's now waiting for a signal that is never going to happen	block	61
and calling peter condition signal happens before the thread blocks and waits for signals ok so now what's happened our second thread is going to deadlock it's now waiting for a signal that is never going to happen	thread	54
so right now yes we have a small opportunity a chance that our second thread will deadlock how do we fix it by locking on the same mutex because then the only way that you can continue is after the threat has acquired the mutex so another thread will have to wait so now if we do that it becomes impossible to be executing these two lines of code at the same time that these two lines are being executed	code	342
so right now yes we have a small opportunity a chance that our second thread will deadlock how do we fix it by locking on the same mutex because then the only way that you can continue is after the threat has acquired the mutex so another thread will have to wait so now if we do that it becomes impossible to be executing these two lines of code at the same time that these two lines are being executed	thread	70
right the second thing that we'd like to change is this if inside here so in practice this can bite you in two different ways first of all maybe in other applications you have multiple threads calling this and we really just want to ensure their x really is positive before we continue and other things may change value x the second problem with this code is the actual deep condition wait is occasionally may suffer from what's called a spurious wake up it never truly went to sleep ok right so why does that occur well let's let's go back and talk about the implications for how conditioned weight is actually implemented right so we've just seen this problem of change in value of x and then signaling too early before they thread is actually blocking and waiting for that signal to arrive so in practice what does this mean it means that unlocking the mutex	block	746
right the second thing that we'd like to change is this if inside here so in practice this can bite you in two different ways first of all maybe in other applications you have multiple threads calling this and we really just want to ensure their x really is positive before we continue and other things may change value x the second problem with this code is the actual deep condition wait is occasionally may suffer from what's called a spurious wake up it never truly went to sleep ok right so why does that occur well let's let's go back and talk about the implications for how conditioned weight is actually implemented right so we've just seen this problem of change in value of x and then signaling too early before they thread is actually blocking and waiting for that signal to arrive so in practice what does this mean it means that unlocking the mutex	code	351
right the second thing that we'd like to change is this if inside here so in practice this can bite you in two different ways first of all maybe in other applications you have multiple threads calling this and we really just want to ensure their x really is positive before we continue and other things may change value x the second problem with this code is the actual deep condition wait is occasionally may suffer from what's called a spurious wake up it never truly went to sleep ok right so why does that occur well let's let's go back and talk about the implications for how conditioned weight is actually implemented right so we've just seen this problem of change in value of x and then signaling too early before they thread is actually blocking and waiting for that signal to arrive so in practice what does this mean it means that unlocking the mutex	thread	185
blocking a waiting for that signal has to be it has to behave as if it is an a single atomic operation in other words there is no clock cycle no moment in time between between these two events otherwise the very same argument that we just gave here about these two operations happening just within that now window would apply to all of our cause to p three condition wait ok so we have to ensure that these behave can instantaneously together now in practice that may be impossible there could be a very narrow window between when we unlock the window unlock the mutex and block so in practice if that may occur for example because i really do have multiple cpus running on different pieces of silicon then what will happen is rather than blocking forever rp threat condition variable instead will suffer a spurious wake up to say i'm sorry maybe i missed a signal maybe it just happened so that is why we always need to write this using a while so that	block	0
we can only continue if condition is met in this case the taxes become positive ok right so that's it for code review in next video let's talk about life lock by	code	106
hi ! ok,&nbsp; so imagine you want to construct a string perhaps you want to take some numbers and some other stuff and put it all together before actually sending out to disk or perhaps you want to send it to a pipe or perhaps you want to send it to a network but for some reason do you actually want to construct the string while this is just sending it out so for that here's this kind of cool little function we can use called asprintf and let me change the laptop mode there we go alright so let's have a look at this it looks a lot like printf	printf	433
hi ! ok,&nbsp; so imagine you want to construct a string perhaps you want to take some numbers and some other stuff and put it all together before actually sending out to disk or perhaps you want to send it to a pipe or perhaps you want to send it to a network but for some reason do you actually want to construct the string while this is just sending it out so for that here's this kind of cool little function we can use called asprintf and let me change the laptop mode there we go alright so let's have a look at this it looks a lot like printf	string	50
in a sense that we are going to pass in a format string and then some variables that we want to use with their format string so inside that former string perhaps you have percent s&nbsp; percent d for an integer or percent something else four percent p for example for to print out pointer is a hexadecimal that all that good stuff ok but rather than actually sending out to anywhere instead we're going to pass in another variable here so let's just kind of blindly guess to see what we should do and will just make it compile ok and then we'll find out how to actually do this correctly ok so here's some code that we wrote earlier let's have a look at kind of question eight let's see ok there we go right i better fix this up question eight dot	code	607
in a sense that we are going to pass in a format string and then some variables that we want to use with their format string so inside that former string perhaps you have percent s&nbsp; percent d for an integer or percent something else four percent p for example for to print out pointer is a hexadecimal that all that good stuff ok but rather than actually sending out to anywhere instead we're going to pass in another variable here so let's just kind of blindly guess to see what we should do and will just make it compile ok and then we'll find out how to actually do this correctly ok so here's some code that we wrote earlier let's have a look at kind of question eight let's see ok there we go right i better fix this up question eight dot	string	49
in a sense that we are going to pass in a format string and then some variables that we want to use with their format string so inside that former string perhaps you have percent s&nbsp; percent d for an integer or percent something else four percent p for example for to print out pointer is a hexadecimal that all that good stuff ok but rather than actually sending out to anywhere instead we're going to pass in another variable here so let's just kind of blindly guess to see what we should do and will just make it compile ok and then we'll find out how to actually do this correctly ok so here's some code that we wrote earlier let's have a look at kind of question eight let's see ok there we go right i better fix this up question eight dot	pointer	282
c so what do we want to do inside my little main method here i need a variable so we know i know that a s printf takes a variable	printf	106
and will pass in pointer 'cause i know that aspect takes a pointer to a pointer to a car car so let me just try that see what happens you notice that for my format specifier i've got couple of strings and an integer and indeed the remaining variables are two strings in an integer ok so let's	string	193
and will pass in pointer 'cause i know that aspect takes a pointer to a pointer to a car car so let me just try that see what happens you notice that for my format specifier i've got couple of strings and an integer and indeed the remaining variables are two strings in an integer ok so let's	pointer	17
like this and compile it gcc and it great it compiles without error because i got the type correct of errors printf	type	86
like this and compile it gcc and it great it compiles without error because i got the type correct of errors printf	printf	109
a case but when i run it it crashes ok so what's going on here well first of all we just blindly guest and changed our code and tell it compiled but instead maybe we get better understand what her sprint efron does and so if i still read the man pages about this	code	119
we discover actually what as printf does is it's going to allocate some memory forwards and that memory is on the heap and then change the variable that we provide it so actually the code that we should have written is to have a pointer	memory	72
we discover actually what as printf does is it's going to allocate some memory forwards and that memory is on the heap and then change the variable that we provide it so actually the code that we should have written is to have a pointer	the heap	110
we discover actually what as printf does is it's going to allocate some memory forwards and that memory is on the heap and then change the variable that we provide it so actually the code that we should have written is to have a pointer	code	183
we discover actually what as printf does is it's going to allocate some memory forwards and that memory is on the heap and then change the variable that we provide it so actually the code that we should have written is to have a pointer	printf	29
we discover actually what as printf does is it's going to allocate some memory forwards and that memory is on the heap and then change the variable that we provide it so actually the code that we should have written is to have a pointer	pointer	229
ok so a pointer to a character	pointer	8
ok we're pointing at one character but you and i know that actually we're going to point one memory address for the character but then the remaining characters then remaining bytes can be used for more characters we have whole c string and rather than just passing where that pointer points to we very sneakily are going to say hey tell me the address of this variable because i'm going to change this address to actually	memory	93
ok we're pointing at one character but you and i know that actually we're going to point one memory address for the character but then the remaining characters then remaining bytes can be used for more characters we have whole c string and rather than just passing where that pointer points to we very sneakily are going to say hey tell me the address of this variable because i'm going to change this address to actually	string	229
ok we're pointing at one character but you and i know that actually we're going to point one memory address for the character but then the remaining characters then remaining bytes can be used for more characters we have whole c string and rather than just passing where that pointer points to we very sneakily are going to say hey tell me the address of this variable because i'm going to change this address to actually	address	100
ok we're pointing at one character but you and i know that actually we're going to point one memory address for the character but then the remaining characters then remaining bytes can be used for more characters we have whole c string and rather than just passing where that pointer points to we very sneakily are going to say hey tell me the address of this variable because i'm going to change this address to actually	pointer	276
i want my variable to be changed by aprintf so that's exactly what error is going to do is going to call malloc	printf	37
is going to construct the string in memory and then it's going to change our pointer to now point to that we could prove this let's have a look let's initialize are pointed to be something like null	memory	36
is going to construct the string in memory and then it's going to change our pointer to now point to that we could prove this let's have a look let's initialize are pointed to be something like null	string	26
is going to construct the string in memory and then it's going to change our pointer to now point to that we could prove this let's have a look let's initialize are pointed to be something like null	pointer	77
and then after airs printf was run let's print the value of our pointer so pointer is now a more printer as a hexadecimal pointer value and k and at and at that location we will	printf	20
and then after airs printf was run let's print the value of our pointer so pointer is now a more printer as a hexadecimal pointer value and k and at and at that location we will	pointer	64
use it as a string ok so i want my pointer and also i want my pointer again ok	string	12
use it as a string ok so i want my pointer and also i want my pointer again ok	pointer	35
ok and now you see look my point has been changed to another address and the contents of that location o x seven eights etc is now the kind of the following output	the following	143
ok and now you see look my point has been changed to another address and the contents of that location o x seven eights etc is now the kind of the following output	address	61
that memory i can call free on that location	memory	5
ok i don't want to free my address of my variable i want to free the value of my ptr variable in other words what it's actually looking at ok so let's compile this free we better include the right libraries lights how can i discover what that library is let's use the main page and we discover that i need hash standard lib ok so	address	27
skip back and put that in my code now compile and off we go alright so there's aspirins have very useful when you want to construct strings formatted strings in memory and	memory	161
skip back and put that in my code now compile and off we go alright so there's aspirins have very useful when you want to construct strings formatted strings in memory and	code	29
skip back and put that in my code now compile and off we go alright so there's aspirins have very useful when you want to construct strings formatted strings in memory and	string	132
and our next video we will talk about point arithmetic and how we can implement the following bye	the following	80
hi, so let's think about how we can implement a version of strcat. in other words, we want to concatenate one string onto another. so okay, do i have a pointer, okay, great. so i want to take	string	110
hi, so let's think about how we can implement a version of strcat. in other words, we want to concatenate one string onto another. so okay, do i have a pointer, okay, great. so i want to take	pointer	152
two pointers here. i'm going to give a hint to the compiler that my second pointer to a character is actually a pointer to constant characters. in other words, i promise the following code will not actually change or modify those bytes. so, as usual, we read this backwards. src source is a pointer to a constant character. yes, it's just pointing at a single character, but by offsets, by either moving that pointer or by using the	the following	170
two pointers here. i'm going to give a hint to the compiler that my second pointer to a character is actually a pointer to constant characters. in other words, i promise the following code will not actually change or modify those bytes. so, as usual, we read this backwards. src source is a pointer to a constant character. yes, it's just pointing at a single character, but by offsets, by either moving that pointer or by using the	code	184
two pointers here. i'm going to give a hint to the compiler that my second pointer to a character is actually a pointer to constant characters. in other words, i promise the following code will not actually change or modify those bytes. so, as usual, we read this backwards. src source is a pointer to a constant character. yes, it's just pointing at a single character, but by offsets, by either moving that pointer or by using the	pointer	4
array index or point arithmetic, i can actually look at the bytes after that address.	address	77
ok, so let's have a look at the code that's currently being given. i have a feeling there might be a mistake or two. right, so while asterisks pointer, in other words, follow that variable. let's have a go and look at what's actually inside that memory. this is very common with pointers. what do we want to do? we actually want to go and see what they're pointing at. so this looks like it's trying to check to see if there's a zero byte there, because if we get to the zero byte, great! we know that we've reached the end of this c string. [indistinct words] the reasonable request. ok, what's going on here? inside this loop, destination equals source. wait a moment! that is just copying the value inside these variables. in other words, we're not reaching out to that memory. instead, we are just changing dest	memory	246
ok, so let's have a look at the code that's currently being given. i have a feeling there might be a mistake or two. right, so while asterisks pointer, in other words, follow that variable. let's have a go and look at what's actually inside that memory. this is very common with pointers. what do we want to do? we actually want to go and see what they're pointing at. so this looks like it's trying to check to see if there's a zero byte there, because if we get to the zero byte, great! we know that we've reached the end of this c string. [indistinct words] the reasonable request. ok, what's going on here? inside this loop, destination equals source. wait a moment! that is just copying the value inside these variables. in other words, we're not reaching out to that memory. instead, we are just changing dest	code	32
ok, so let's have a look at the code that's currently being given. i have a feeling there might be a mistake or two. right, so while asterisks pointer, in other words, follow that variable. let's have a go and look at what's actually inside that memory. this is very common with pointers. what do we want to do? we actually want to go and see what they're pointing at. so this looks like it's trying to check to see if there's a zero byte there, because if we get to the zero byte, great! we know that we've reached the end of this c string. [indistinct words] the reasonable request. ok, what's going on here? inside this loop, destination equals source. wait a moment! that is just copying the value inside these variables. in other words, we're not reaching out to that memory. instead, we are just changing dest	string	534
ok, so let's have a look at the code that's currently being given. i have a feeling there might be a mistake or two. right, so while asterisks pointer, in other words, follow that variable. let's have a go and look at what's actually inside that memory. this is very common with pointers. what do we want to do? we actually want to go and see what they're pointing at. so this looks like it's trying to check to see if there's a zero byte there, because if we get to the zero byte, great! we know that we've reached the end of this c string. [indistinct words] the reasonable request. ok, what's going on here? inside this loop, destination equals source. wait a moment! that is just copying the value inside these variables. in other words, we're not reaching out to that memory. instead, we are just changing dest	pointer	143
to be equal to the same value of src. in other words, great, now i've got two pointers that both happen to be looking at the original string. that's not what i wanted to do at all! i wanted to be copying some bytes. i wanted to be actually copying one byte at a time from the source into the destination. so what's missing here is the idea of actually following the pointer. ok, how can i do that? well, what's missing here is the referencing	string	134
to be equal to the same value of src. in other words, great, now i've got two pointers that both happen to be looking at the original string. that's not what i wanted to do at all! i wanted to be copying some bytes. i wanted to be actually copying one byte at a time from the source into the destination. so what's missing here is the idea of actually following the pointer. ok, how can i do that? well, what's missing here is the referencing	pointer	78
pointer. that's actually going to look at the memory that the pointer's looking at and similarly on the destination site. so i should have thrown in some more asterisks here. ok, so i've copied a single byte.	memory	46
pointer. that's actually going to look at the memory that the pointer's looking at and similarly on the destination site. so i should have thrown in some more asterisks here. ok, so i've copied a single byte.	pointer	0
to look at the next byte in both cases. ok, our code is looking a lot better. right. except we've got a couple of problems here. first of all, we were supposed to be implementing strcat. the idea of strcat is to advance beyond the end of the existing string	code	48
to look at the next byte in both cases. ok, our code is looking a lot better. right. except we've got a couple of problems here. first of all, we were supposed to be implementing strcat. the idea of strcat is to advance beyond the end of the existing string	string	251
at destination. so how could i do that? how could i modify dest to no longer be looking at the beginning of the string, but to actually move it forward. so with that, let's get ourselves a	string	112
a destination and another pointer to	pointer	26
"please take the source byte.""" ok, and then i was incrementing it. now i actually want to move the pointers themselves. i don't want to change the value inside each of those memory locations. i'm just moving the pointers to look at different bytes. ok, so what do you think of that? have we got a reasonable implementation of strcat? so	memory	176
"please take the source byte.""" ok, and then i was incrementing it. now i actually want to move the pointers themselves. i don't want to change the value inside each of those memory locations. i'm just moving the pointers to look at different bytes. ok, so what do you think of that? have we got a reasonable implementation of strcat? so	pointer	101
argvalues. ok, so how about the following? i have a	the following	28
for to the destination from the source, and then we'll try printing it out. ok, so today let's use printf result is, and i need to give it a	printf	99
and let's finish. ok, so did you decide what errors are inside here, and, hint, i may have deliberately "implemented another error. ok, perhaps you said, ""hold" on a moment, you're actually, on lines four and six, you are actually trying to move to the end of the string "at twice."" yes, i agree that's a bit silly. would it actually" cause a problem? well no, because right now if i've moved to the end of the string, then strlen will immediately find that zero byte. so it would actually just return zero. so it would actually become just a zero operation if i've actually implemented-- if i did both of these operations. so let me pick one, i'm having fun with pointers today, so let's just comment out the strlen version. and	string	265
and let's finish. ok, so did you decide what errors are inside here, and, hint, i may have deliberately "implemented another error. ok, perhaps you said, ""hold" on a moment, you're actually, on lines four and six, you are actually trying to move to the end of the string "at twice."" yes, i agree that's a bit silly. would it actually" cause a problem? well no, because right now if i've moved to the end of the string, then strlen will immediately find that zero byte. so it would actually just return zero. so it would actually become just a zero operation if i've actually implemented-- if i did both of these operations. so let me pick one, i'm having fun with pointers today, so let's just comment out the strlen version. and	pointer	666
right, and here's my little test. so i'm going to try and test my programs here. i've got two pointers: destination source, and let's first of all try running this, but perhaps you can guess what's going to happen. so ok, we'll quit this. let's compile it, mystrcat, and we'll	pointer	94
but did we initialize it? no! and it's a stack variable, so its value could be anything. i'm going to guess, between you and me, that it's probably pointing at nothing just because we're dealing with a fresh process here, because my stack is probably going to have some zero bytes in that memory, but that was just purely by chance purely just what happened to be in memory at the time. so we should set it equal to something. you might try abc etc here, but we've got a problem here. that's going to be read only memory. i better actually get myself some memory that i can change. how can i do that? well i got a couple of options. i could have some heap memory. so here we go, let's have a hundred and twenty three bytes here. let me initialize the first bytes to some characters. or maybe i actually want to have an array. so let's have an array of, say, sixteen bytes. here we go, and we will set the first bytes to be let's say, a little x character, and i better set my little string to finish to be something else. ok so i need a zero byte here. i could also have just written "zero, but i'm choosing, instead, a way to say, ""ok as to zero,"	heap memory	651
but did we initialize it? no! and it's a stack variable, so its value could be anything. i'm going to guess, between you and me, that it's probably pointing at nothing just because we're dealing with a fresh process here, because my stack is probably going to have some zero bytes in that memory, but that was just purely by chance purely just what happened to be in memory at the time. so we should set it equal to something. you might try abc etc here, but we've got a problem here. that's going to be read only memory. i better actually get myself some memory that i can change. how can i do that? well i got a couple of options. i could have some heap memory. so here we go, let's have a hundred and twenty three bytes here. let me initialize the first bytes to some characters. or maybe i actually want to have an array. so let's have an array of, say, sixteen bytes. here we go, and we will set the first bytes to be let's say, a little x character, and i better set my little string to finish to be something else. ok so i need a zero byte here. i could also have just written "zero, but i'm choosing, instead, a way to say, ""ok as to zero,"	memory	289
but did we initialize it? no! and it's a stack variable, so its value could be anything. i'm going to guess, between you and me, that it's probably pointing at nothing just because we're dealing with a fresh process here, because my stack is probably going to have some zero bytes in that memory, but that was just purely by chance purely just what happened to be in memory at the time. so we should set it equal to something. you might try abc etc here, but we've got a problem here. that's going to be read only memory. i better actually get myself some memory that i can change. how can i do that? well i got a couple of options. i could have some heap memory. so here we go, let's have a hundred and twenty three bytes here. let me initialize the first bytes to some characters. or maybe i actually want to have an array. so let's have an array of, say, sixteen bytes. here we go, and we will set the first bytes to be let's say, a little x character, and i better set my little string to finish to be something else. ok so i need a zero byte here. i could also have just written "zero, but i'm choosing, instead, a way to say, ""ok as to zero,"	string	983
now let's actually try running my little code here. ok so will run it, we'll compile it, and we'll run it. and oh look! it appears to work, but is my code correct? yes, it certainly appended abc, but did you notice any problems? ok so, the thing i was hoping you'd say is	code	41
"now, some of you might be asking, ""can mystrcat know" "if it exceeds the sixteen bytes that we assigned?""" and the answer is no. the little function just has to take it on trust that bytes that it's going write into are of valid location. so that's why c programming can be exciting. we've actually got to make sure that we think carefully about our memory locations. it is up to us to wield this power and this fire correctly. so only set fire to things which are supposed to be on fire. alright, so with that i'll commit this, and let's go back to the little example here. ok,	memory	353
yes, i do! ok, right so, we can look back at our code and imagine that if i've passed in a source, the following memory location and a destination at two thousand, we could actually kind of evaluate what actually our process does. so let me set up a little example here where, in my source, i've got the following, and in other locations, i've got the following. so now let's actually look at our code. here did you go ok and	the following	99
yes, i do! ok, right so, we can look back at our code and imagine that if i've passed in a source, the following memory location and a destination at two thousand, we could actually kind of evaluate what actually our process does. so let me set up a little example here where, in my source, i've got the following, and in other locations, i've got the following. so now let's actually look at our code. here did you go ok and	memory	113
yes, i do! ok, right so, we can look back at our code and imagine that if i've passed in a source, the following memory location and a destination at two thousand, we could actually kind of evaluate what actually our process does. so let me set up a little example here where, in my source, i've got the following, and in other locations, i've got the following. so now let's actually look at our code. here did you go ok and	code	49
the one thousand and my destination is holding two thousand. right, so our code on line four	code	75
that initial line-- that initial while loop. right, so then with our destination pointing at address two thousand and three, we start copying in bytes. so, we're going to copy the exclamation point into not two thousand four, but two thousand three. so we're going to overwrite that exclamation point. so we end up with,	address	93
where we talk about duplicating a string, how can we actually start off with a string in memory and create a new valid string. are you ready? let's go!	memory	89
where we talk about duplicating a string, how can we actually start off with a string in memory and create a new valid string. are you ready? let's go!	string	34
new requests that web server will be used the new configuration that you've just described so that's kind of pretty cool also java next time you've got java processes maybe kind of out of control or stuck	a process	155
what it's hip is and also what the threats are doing so this is kind of a cute little trick if you're ever doing an internship but for example a place it uses java you can actually go in and see exactly what's happening and plus you get to scare people on a production server when you say oh don't worry i'm just going to send them send sig quit to my java process that is handling all of your millions of dollars so let's see what happens ok so here is a little program that i made earlier	a process	355
the bit i want to show you is that my job of program is multithreaded it's got a concept of threads and in java you override the run method so all this is going to do is keep looking at the day of a file in fact looking	thread	61
at the data itself you should have its source code so just to check to see if you don't touch it right so it will find the date of when this file was last modified	code	46
and if it changes it will send her a warning message out ok so it's going to be busy keep going around inside this loop checking the date as fast as it possibly can right so that's the code we know and also we set the name of the thread to hal nine thousand hope you know the movie reference and then let's start that running through it ok so i want to run this i'm going to say write java please run my app and i went in the background now if i was running on lenox this would actually print out the process id why because here i'm opening a special file called slash proc slash self and that is normally a symbolic link in lenox to the process numbers so then i could get the real path and get its name however i'm running on a mac so that did not tell me the proces name right so what are we going to do about that well fortunately i could do several things i can for example use ps and that would be a huge list of all processes there's even a version with java however there's just prints out to java processes so there we go we found out they process id of the currently running program so now great i can send a signal let's do sig quit to eighteen seventy	code	185
and if it changes it will send her a warning message out ok so it's going to be busy keep going around inside this loop checking the date as fast as it possibly can right so that's the code we know and also we set the name of the thread to hal nine thousand hope you know the movie reference and then let's start that running through it ok so i want to run this i'm going to say write java please run my app and i went in the background now if i was running on lenox this would actually print out the process id why because here i'm opening a special file called slash proc slash self and that is normally a symbolic link in lenox to the process numbers so then i could get the real path and get its name however i'm running on a mac so that did not tell me the proces name right so what are we going to do about that well fortunately i could do several things i can for example use ps and that would be a huge list of all processes there's even a version with java however there's just prints out to java processes so there we go we found out they process id of the currently running program so now great i can send a signal let's do sig quit to eighteen seventy	a process	1004
and if it changes it will send her a warning message out ok so it's going to be busy keep going around inside this loop checking the date as fast as it possibly can right so that's the code we know and also we set the name of the thread to hal nine thousand hope you know the movie reference and then let's start that running through it ok so i want to run this i'm going to say write java please run my app and i went in the background now if i was running on lenox this would actually print out the process id why because here i'm opening a special file called slash proc slash self and that is normally a symbolic link in lenox to the process numbers so then i could get the real path and get its name however i'm running on a mac so that did not tell me the proces name right so what are we going to do about that well fortunately i could do several things i can for example use ps and that would be a huge list of all processes there's even a version with java however there's just prints out to java processes so there we go we found out they process id of the currently running program so now great i can send a signal let's do sig quit to eighteen seventy	thread	230
and if it changes it will send her a warning message out ok so it's going to be busy keep going around inside this loop checking the date as fast as it possibly can right so that's the code we know and also we set the name of the thread to hal nine thousand hope you know the movie reference and then let's start that running through it ok so i want to run this i'm going to say write java please run my app and i went in the background now if i was running on lenox this would actually print out the process id why because here i'm opening a special file called slash proc slash self and that is normally a symbolic link in lenox to the process numbers so then i could get the real path and get its name however i'm running on a mac so that did not tell me the proces name right so what are we going to do about that well fortunately i could do several things i can for example use ps and that would be a huge list of all processes there's even a version with java however there's just prints out to java processes so there we go we found out they process id of the currently running program so now great i can send a signal let's do sig quit to eighteen seventy	background	426
and it will print out a whole load of stuff let's see if we can make it a bit smaller and see what it's doing ok right so we've got stuff about the heap how big it is java sleep is a much more complicated model because it it tries to tries to put objects are trying to live for a short period of time versus a long period time in different parts of memory we can see all the different threads it's got four threads just dedicated to being a parallel garbage collector	memory	349
and it will print out a whole load of stuff let's see if we can make it a bit smaller and see what it's doing ok right so we've got stuff about the heap how big it is java sleep is a much more complicated model because it it tries to tries to put objects are trying to live for a short period of time versus a long period time in different parts of memory we can see all the different threads it's got four threads just dedicated to being a parallel garbage collector	the heap	144
and it will print out a whole load of stuff let's see if we can make it a bit smaller and see what it's doing ok right so we've got stuff about the heap how big it is java sleep is a much more complicated model because it it tries to tries to put objects are trying to live for a short period of time versus a long period time in different parts of memory we can see all the different threads it's got four threads just dedicated to being a parallel garbage collector	thread	385
i've got a main thread here that is sleeping and i've got another thread reference handler finalizers all look here's a signal dispatcher that i mentioned so somebody wrote the code to handle signals for that i've got more compilation threads i got service dates but finally here's that health read the code that we wrote and you'll see that we can see a stack trace so this is pretty cool next time your java program deadlock so is just using a hundred percent cpu time you can see where it is at that last moment and you can see it was actually currently spending its time inside the system here getting that last modified time alright	code	177
i've got a main thread here that is sleeping and i've got another thread reference handler finalizers all look here's a signal dispatcher that i mentioned so somebody wrote the code to handle signals for that i've got more compilation threads i got service dates but finally here's that health read the code that we wrote and you'll see that we can see a stack trace so this is pretty cool next time your java program deadlock so is just using a hundred percent cpu time you can see where it is at that last moment and you can see it was actually currently spending its time inside the system here getting that last modified time alright	thread	16
i've got a main thread here that is sleeping and i've got another thread reference handler finalizers all look here's a signal dispatcher that i mentioned so somebody wrote the code to handle signals for that i've got more compilation threads i got service dates but finally here's that health read the code that we wrote and you'll see that we can see a stack trace so this is pretty cool next time your java program deadlock so is just using a hundred percent cpu time you can see where it is at that last moment and you can see it was actually currently spending its time inside the system here getting that last modified time alright	system	586
we want to make sure that we actually kill this thing so let's now my java process ok gotcha so java ps great that's the end of that one right so that's kind of signals another kind of quick comment is	a process	73
in terms of working with production systems here's some advice on how to delete your entire company so	system	36
have a have a variable like this perhaps you wrote this inside a script or maybe you downloaded an installation script an inside that script or what you type there is a typo ok so here we go i've got an extra are here so what is bash do hear it tries to expand this variable but this variable does not exist so this variable	type	153
pass before you start randomly deleting things right and their last video we're going to talk about how not to write c code and maybe why you should think twice before stepping in front of a car alright i'll see you then bye	code	119
ok so let's start talking about how we can use our man pages and the idea that the man page is actually divided into separate sections. right, so for example, you happen to know that there's something called, a really useful function, called stat that will tell you a lot more about a file. you can find out, for example, who can access it, who owns it, how big it is, so let's go find out about stat. right so let's try this. and i type man stat and, this time, i actually don't get what i was looking for. actually, it turns out there's not just function called stat that i could use inside my programs. there's actually something that's part that i can call for my command line called [stat?stats?]. so if i get up off edit mode here, lets quit that, right, so for example, if i say stat on the command line, i can find out some information about the current directory, and i could have given it another file as well. so that's what the manpage was telling me about. similarly if i typed kind of open, then it would tell me about the bsd opening manager i could run from the command line. that's not what i want. ok so let me stop that and "instead say, ""ok hey man, i want you to look inside a certain" "place."" perhaps i actually care about section two which" is the system calls	type	433
ok so let's start talking about how we can use our man pages and the idea that the man page is actually divided into separate sections. right, so for example, you happen to know that there's something called, a really useful function, called stat that will tell you a lot more about a file. you can find out, for example, who can access it, who owns it, how big it is, so let's go find out about stat. right so let's try this. and i type man stat and, this time, i actually don't get what i was looking for. actually, it turns out there's not just function called stat that i could use inside my programs. there's actually something that's part that i can call for my command line called [stat?stats?]. so if i get up off edit mode here, lets quit that, right, so for example, if i say stat on the command line, i can find out some information about the current directory, and i could have given it another file as well. so that's what the manpage was telling me about. similarly if i typed kind of open, then it would tell me about the bsd opening manager i could run from the command line. that's not what i want. ok so let me stop that and "instead say, ""ok hey man, i want you to look inside a certain" "place."" perhaps i actually care about section two which" is the system calls	section	126
ok so let's start talking about how we can use our man pages and the idea that the man page is actually divided into separate sections. right, so for example, you happen to know that there's something called, a really useful function, called stat that will tell you a lot more about a file. you can find out, for example, who can access it, who owns it, how big it is, so let's go find out about stat. right so let's try this. and i type man stat and, this time, i actually don't get what i was looking for. actually, it turns out there's not just function called stat that i could use inside my programs. there's actually something that's part that i can call for my command line called [stat?stats?]. so if i get up off edit mode here, lets quit that, right, so for example, if i say stat on the command line, i can find out some information about the current directory, and i could have given it another file as well. so that's what the manpage was telling me about. similarly if i typed kind of open, then it would tell me about the bsd opening manager i could run from the command line. that's not what i want. ok so let me stop that and "instead say, ""ok hey man, i want you to look inside a certain" "place."" perhaps i actually care about section two which" is the system calls	system	1274
and now i've got, great, the actual information i wanted to do with system call that i can make called open. or i want to know about the stat, and great, i've got all the versions of stat that i can now use on my apple system here. so section two is reserved for kind of system calls. what about strlen? so if i ask for strlen, there is no manual entry for strlen inside section two. why not? strlen not a system call. we do not need to go back to the kernel "and say, ""hey excuse me, kernel, please look at my memory" "to figure out how long my c string is."" i don't need" to invoke the whole operating system for that. i can do that directly inside my process's memory. so for things which are part of the c library, i just need to go to section three. and so that's where we'll find strlen and other things like strcmp to compare two strings, or say strcat. so [indistinct word] up to specify the system area, sorry, the	memory	512
and now i've got, great, the actual information i wanted to do with system call that i can make called open. or i want to know about the stat, and great, i've got all the versions of stat that i can now use on my apple system here. so section two is reserved for kind of system calls. what about strlen? so if i ask for strlen, there is no manual entry for strlen inside section two. why not? strlen not a system call. we do not need to go back to the kernel "and say, ""hey excuse me, kernel, please look at my memory" "to figure out how long my c string is."" i don't need" to invoke the whole operating system for that. i can do that directly inside my process's memory. so for things which are part of the c library, i just need to go to section three. and so that's where we'll find strlen and other things like strcmp to compare two strings, or say strcat. so [indistinct word] up to specify the system area, sorry, the	string	549
and now i've got, great, the actual information i wanted to do with system call that i can make called open. or i want to know about the stat, and great, i've got all the versions of stat that i can now use on my apple system here. so section two is reserved for kind of system calls. what about strlen? so if i ask for strlen, there is no manual entry for strlen inside section two. why not? strlen not a system call. we do not need to go back to the kernel "and say, ""hey excuse me, kernel, please look at my memory" "to figure out how long my c string is."" i don't need" to invoke the whole operating system for that. i can do that directly inside my process's memory. so for things which are part of the c library, i just need to go to section three. and so that's where we'll find strlen and other things like strcmp to compare two strings, or say strcat. so [indistinct word] up to specify the system area, sorry, the	section	235
and now i've got, great, the actual information i wanted to do with system call that i can make called open. or i want to know about the stat, and great, i've got all the versions of stat that i can now use on my apple system here. so section two is reserved for kind of system calls. what about strlen? so if i ask for strlen, there is no manual entry for strlen inside section two. why not? strlen not a system call. we do not need to go back to the kernel "and say, ""hey excuse me, kernel, please look at my memory" "to figure out how long my c string is."" i don't need" to invoke the whole operating system for that. i can do that directly inside my process's memory. so for things which are part of the c library, i just need to go to section three. and so that's where we'll find strlen and other things like strcmp to compare two strings, or say strcat. so [indistinct word] up to specify the system area, sorry, the	a system call	404
and now i've got, great, the actual information i wanted to do with system call that i can make called open. or i want to know about the stat, and great, i've got all the versions of stat that i can now use on my apple system here. so section two is reserved for kind of system calls. what about strlen? so if i ask for strlen, there is no manual entry for strlen inside section two. why not? strlen not a system call. we do not need to go back to the kernel "and say, ""hey excuse me, kernel, please look at my memory" "to figure out how long my c string is."" i don't need" to invoke the whole operating system for that. i can do that directly inside my process's memory. so for things which are part of the c library, i just need to go to section three. and so that's where we'll find strlen and other things like strcmp to compare two strings, or say strcat. so [indistinct word] up to specify the system area, sorry, the	system	68
manpage area of the section is useful when there's multiple entries. there's one other entry that you'll see sometime in the future which is section seven. that's for longer articles. and we'll discover things, like p threads and signals, actually have much longer articles which is part of section seven. so we can make a note of this here, right. so let's get my little pen working here. right, so if i want to talk about, if i want to find out about stat, i would do something like man	section	20
manpage area of the section is useful when there's multiple entries. there's one other entry that you'll see sometime in the future which is section seven. that's for longer articles. and we'll discover things, like p threads and signals, actually have much longer articles which is part of section seven. so we can make a note of this here, right. so let's get my little pen working here. right, so if i want to talk about, if i want to find out about stat, i would do something like man	thread	218
i'm going to have to learn how to write better with this little tablet thing. ok so what have we got? a section two that is for the system calls.	section	104
i'm going to have to learn how to write better with this little tablet thing. ok so what have we got? a section two that is for the system calls.	system	132
we're going to see section three for our c library,	section	19
and section seven for longer articles. we'll see those in the future when you get to	section	4
threads and signals.	thread	0
so, i'll see you in the next video when we start talking about the memory allocator. ok bye.	memory	67
ok right so signal disposition is per process it describes what we should do with the signal do we want to just ignore it do we want to terminate the process or do we want to run special some special signal handler that we that we have installed ok so that's kind of basically our options or some kind of handler	disposition	19
and so the signal disposition is preserved when you fork in other words if you said hey i don't care about this alarm signal i don't care about the c child then or say sigpipe then that will also be true for your child when you exec you also maintain some of the signal disposition except what do you think has been reset yeah so when your exact any handlers that you have	disposition	18
defined they're going to need to disappear because that code for that handling no longer exists we've replaced the entire process image so instead for these special cases the signal disposition for those signals are just reset back to the default behavior maybe that's district dormant maybe that's to terminate the process etc right so you're six position is basically what is going to happen when a signal is delivered ok but we want to be able to block signals so how do i do that ok well to block a signal you can use	block	450
defined they're going to need to disappear because that code for that handling no longer exists we've replaced the entire process image so instead for these special cases the signal disposition for those signals are just reset back to the default behavior maybe that's district dormant maybe that's to terminate the process etc right so you're six position is basically what is going to happen when a signal is delivered ok but we want to be able to block signals so how do i do that ok well to block a signal you can use	disposition	182
defined they're going to need to disappear because that code for that handling no longer exists we've replaced the entire process image so instead for these special cases the signal disposition for those signals are just reset back to the default behavior maybe that's district dormant maybe that's to terminate the process etc right so you're six position is basically what is going to happen when a signal is delivered ok but we want to be able to block signals so how do i do that ok well to block a signal you can use	code	56
signal mask masking so this is basically your shields to say hey don't tell me about singing right now and there's two variations of this if you're writing a multithreaded program then use p thread sigma ask if you are not ready going multithreaded program then there's sig park mask but they both work the same way which is that we can turn on and off individual bits corresponding to different signals so they'll be a bit associated with sigint for example right now what do you think will happen then if i'm in a multithreaded program an i set the sig mask so that	thread	163
any sigint events in other words someone trying to press ctrl c are blocked on threads numbers say two and four out of my four threads one two three and four what will happen now if someone really does press control c and generate a signet which thread will get that signal so we blocked it on two and four which means it might be delivered to thread number one or thread three we don't get to say i guess it's a bit late saying you've got a fortress you've pulled up most of the drawbridge maybe in most of the windows are shuttered but you left open the windows one and three so zombie attacks can happen it either of those windows there zombie my enter through window one or enter through window three now in this case cause we're not talking about actual zombies are attacking our code we instead we're talking about signals being delivered and when i deliver a signal and i run a signal handler like ok i'm going to process sigint that means i'm temporarily going to steal the cpu away from whatever that thread was doing perhaps it was executing your really important little for loop to calculate something well i'm sorry i'm going to steal those cpu cycles right now just a little moment to run that piece of code that signal handler code so this is why the signal mass can be very very useful i can say that you know i've got some threads which i do not want to actually process any signals so i can send a signal mass to say hey do not deliver the signal to this particular particular thread if i've got more than one thread that has not set their signal mask for a particular signal then which one that actually receives the signal is arbitrary	block	68
any sigint events in other words someone trying to press ctrl c are blocked on threads numbers say two and four out of my four threads one two three and four what will happen now if someone really does press control c and generate a signet which thread will get that signal so we blocked it on two and four which means it might be delivered to thread number one or thread three we don't get to say i guess it's a bit late saying you've got a fortress you've pulled up most of the drawbridge maybe in most of the windows are shuttered but you left open the windows one and three so zombie attacks can happen it either of those windows there zombie my enter through window one or enter through window three now in this case cause we're not talking about actual zombies are attacking our code we instead we're talking about signals being delivered and when i deliver a signal and i run a signal handler like ok i'm going to process sigint that means i'm temporarily going to steal the cpu away from whatever that thread was doing perhaps it was executing your really important little for loop to calculate something well i'm sorry i'm going to steal those cpu cycles right now just a little moment to run that piece of code that signal handler code so this is why the signal mass can be very very useful i can say that you know i've got some threads which i do not want to actually process any signals so i can send a signal mass to say hey do not deliver the signal to this particular particular thread if i've got more than one thread that has not set their signal mask for a particular signal then which one that actually receives the signal is arbitrary	code	785
any sigint events in other words someone trying to press ctrl c are blocked on threads numbers say two and four out of my four threads one two three and four what will happen now if someone really does press control c and generate a signet which thread will get that signal so we blocked it on two and four which means it might be delivered to thread number one or thread three we don't get to say i guess it's a bit late saying you've got a fortress you've pulled up most of the drawbridge maybe in most of the windows are shuttered but you left open the windows one and three so zombie attacks can happen it either of those windows there zombie my enter through window one or enter through window three now in this case cause we're not talking about actual zombies are attacking our code we instead we're talking about signals being delivered and when i deliver a signal and i run a signal handler like ok i'm going to process sigint that means i'm temporarily going to steal the cpu away from whatever that thread was doing perhaps it was executing your really important little for loop to calculate something well i'm sorry i'm going to steal those cpu cycles right now just a little moment to run that piece of code that signal handler code so this is why the signal mass can be very very useful i can say that you know i've got some threads which i do not want to actually process any signals so i can send a signal mass to say hey do not deliver the signal to this particular particular thread if i've got more than one thread that has not set their signal mask for a particular signal then which one that actually receives the signal is arbitrary	thread	79
and then when you first create a thread it will inherit the signal mask of of the creating threat basically if you like his parent thread that created the feather called preferred create so it's pretty common to see multithreaded code first of all set the signal mask to say hey just block all signals i don't want to know about them right now then create all the threads that needs and then inside say one thread start changing the signal mass to say ok this is the thread that i want to be interrupted in order to process in order to run the signal handlers	block	284
and then when you first create a thread it will inherit the signal mask of of the creating threat basically if you like his parent thread that created the feather called preferred create so it's pretty common to see multithreaded code first of all set the signal mask to say hey just block all signals i don't want to know about them right now then create all the threads that needs and then inside say one thread start changing the signal mass to say ok this is the thread that i want to be interrupted in order to process in order to run the signal handlers	code	230
and then when you first create a thread it will inherit the signal mask of of the creating threat basically if you like his parent thread that created the feather called preferred create so it's pretty common to see multithreaded code first of all set the signal mask to say hey just block all signals i don't want to know about them right now then create all the threads that needs and then inside say one thread start changing the signal mass to say ok this is the thread that i want to be interrupted in order to process in order to run the signal handlers	a thread	31
and then when you first create a thread it will inherit the signal mask of of the creating threat basically if you like his parent thread that created the feather called preferred create so it's pretty common to see multithreaded code first of all set the signal mask to say hey just block all signals i don't want to know about them right now then create all the threads that needs and then inside say one thread start changing the signal mass to say ok this is the thread that i want to be interrupted in order to process in order to run the signal handlers	thread	33
ok so first of all to send a signal his several calls that you maybe you seen already so first of all here's one you've probably seen kill where we could specify a process possibly ourselves by calling get pid and the signal number and then we have raised right what does raise do that calls kill on ourselves so so raise is equivalent to calling kill but with get pid so it's just a shorthand to say hey send a signal to myself to the current process	a process	162
ok then there's also a version where we can send a signal using a specific thread as well so there's the peace roadkill variation which you might want to use any multithreaded program ok now what about actually catching signals there's	thread	75
ok this several interesting things can kind of know about this first of all you've seen signal of which allows us to install a signal handler ok so one downside of signal is that it's exact behavior is not precisely specified and actually varies from operating system to auto operating system for example what should happen if you're in the middle of a signal handler and in other signal is is delivered is allowed to be delivered it should we remain pending different operating systems have interpreted signal in different ways secondly a signal is not actually supported in multithreaded programs though in practice in linux it does work because people tend to do that	thread	581
ok this several interesting things can kind of know about this first of all you've seen signal of which allows us to install a signal handler ok so one downside of signal is that it's exact behavior is not precisely specified and actually varies from operating system to auto operating system for example what should happen if you're in the middle of a signal handler and in other signal is is delivered is allowed to be delivered it should we remain pending different operating systems have interpreted signal in different ways secondly a signal is not actually supported in multithreaded programs though in practice in linux it does work because people tend to do that	system	261
flexible and it kind of interesting interface to use we can do a lot more with the action ok right now so that allows us to install an asynchronous signal handler in other words no matter what my code is doing when that signal is delivered these two calls allow me to run some code at that moment asynchronously there's some other ways to work with signals however	code	196
but he's a more interesting way to do it you could actually get a file descriptor whose only job is to tell you about signals which have been delivered so you can set up your own special thread just service delivered signals and the advantage of doing this is that we no longer have to worry so much about all of the potential race conditions and asynchronous thread safety	thread	187
problems we have with the code that we write using signal handlers with signal handlers of this is tricky because we're basically going to interrupt our normal code at any moment it might be deep inside malloch it might be inside printf and with stealing that cpu in order to do something else and most programs most storied libra calls for malloc to print jeff and not reentrant were not allowed to in the same thread restart recall these things because we're inside a signal handler so instead signal fda allows us to write a loop and pull when we wish one signal at a time and just therefore treat it like just any old another kind of another thread we've reduced the complexity of our program significantly ok right	code	26
problems we have with the code that we write using signal handlers with signal handlers of this is tricky because we're basically going to interrupt our normal code at any moment it might be deep inside malloch it might be inside printf and with stealing that cpu in order to do something else and most programs most storied libra calls for malloc to print jeff and not reentrant were not allowed to in the same thread restart recall these things because we're inside a signal handler so instead signal fda allows us to write a loop and pull when we wish one signal at a time and just therefore treat it like just any old another kind of another thread we've reduced the complexity of our program significantly ok right	printf	230
problems we have with the code that we write using signal handlers with signal handlers of this is tricky because we're basically going to interrupt our normal code at any moment it might be deep inside malloch it might be inside printf and with stealing that cpu in order to do something else and most programs most storied libra calls for malloc to print jeff and not reentrant were not allowed to in the same thread restart recall these things because we're inside a signal handler so instead signal fda allows us to write a loop and pull when we wish one signal at a time and just therefore treat it like just any old another kind of another thread we've reduced the complexity of our program significantly ok right	thread	412
we can do a little demo then of blocking signals with a cig pop mask and i'll do that in the next video bye	block	32
hi ok so let's take a look at some code that i found on the internet that claims to solve their dining philosophers and we will analyze it and see what we think ok so here we go it uses all the good stuff that we now understand	code	35
we've got a little structure here called philosopher and you can see it's going to be typed deft so that we can just say philosopher later on inside that i'm going to have a pointer to the left fork and the right fork and of course a philosopher has a name	type	86
we've got a little structure here called philosopher and you can see it's going to be typed deft so that we can just say philosopher later on inside that i'm going to have a pointer to the left fork and the right fork and of course a philosopher has a name	pointer	174
and associated with it ap thread and some output variable say whether it failed or not ok we have a global variable to see whether this program should keep running or not ok and let's have a look see how things get initialized	thread	26
ok so we've got a new way of character pointers and that's just a name of five philosophers would like today we're going to have five mutex locks they're going to be our forks and five philosophers ok so	pointer	39
my philosophers so that's just a simple stack away it's ok to do this on inside the main threat because we'll see all of my threads which are going to run	thread	124
finish before we exit made right so great let's get myself a philosopher will get the i th one will initialize its name will initialize it left hand and right hand fork to be one of my five mutex locks look i'm using modulo arithmetic so that the fifth philosopher wraps around and gets to zero for kids game right after setting that all up let's start off threats will call preferred create will make a note of the thread id and will ask it to actually run some multithreaded code which will look at in a moment i learned the rest of my main thread doesn't do much it sleeps with forty seconds then changes running and now just wait for those five threats to finish	code	477
finish before we exit made right so great let's get myself a philosopher will get the i th one will initialize its name will initialize it left hand and right hand fork to be one of my five mutex locks look i'm using modulo arithmetic so that the fifth philosopher wraps around and gets to zero for kids game right after setting that all up let's start off threats will call preferred create will make a note of the thread id and will ask it to actually run some multithreaded code which will look at in a moment i learned the rest of my main thread doesn't do much it sleeps with forty seconds then changes running and now just wait for those five threats to finish	thread	416
otherwise will exit ok so that's my main threat now let's let's have a look at the code that we get that is run by each philosopher oh yes and here's my source	code	83
ok so each philosopher is going to be given a pointer to its little struct there ok so each plus is going to get its own unique name etc right so we also have some local stack variables which mirror what we find inside the the struct you'll see why in a moment so let's see what	pointer	46
my little threads going to do here so for forty seconds until that global variable is changed the first thing that my my philosophy does is sleep in other words thanks a bit so will print out his name then will sleep for and amount of time so in this case let's sleep for say some two one and eight seconds alright and then the philosopher goes to pick up the two folks	thread	10
let's see all chill at the moment ok so we're going to get out of there were going to take this check this after you run through this code once i know notice it is frayed i apologize the logic as given incorrect let's have a look see what it does first of all philosopher waist to pick up the fork on the left ok so that's only going to proceed once you get exclusive access to that particular fork alright and then it's going to change this local variable failed to based on on what happens when it tries to pick up the the fork on the right so notice that initial value of tries left is too so actually it's going to call this function called trilok which we haven't seen before trilok never blocks instead rather than blocking if it's unable to acquire this mutex	block	694
let's see all chill at the moment ok so we're going to get out of there were going to take this check this after you run through this code once i know notice it is frayed i apologize the logic as given incorrect let's have a look see what it does first of all philosopher waist to pick up the fork on the left ok so that's only going to proceed once you get exclusive access to that particular fork alright and then it's going to change this local variable failed to based on on what happens when it tries to pick up the the fork on the right so notice that initial value of tries left is too so actually it's going to call this function called trilok which we haven't seen before trilok never blocks instead rather than blocking if it's unable to acquire this mutex	code	134
it just returns an error numbers returns a non zero value so the very first time that we running this code with twice left equal to two if we caught acquire that second log we just say we failed so what do we do if we failed we immediately unlock the left hand thread	code	102
it just returns an error numbers returns a non zero value so the very first time that we running this code with twice left equal to two if we caught acquire that second log we just say we failed so what do we do if we failed we immediately unlock the left hand thread	thread	261
great you say this looks a lot like we're not going to implement holding wait we're not holding onto the fork on the left we are definitely releasing it so then what does this code do well it	code	176
and then we release both looks ok then we go round the loop we keep going until we've hdr forty seconds is up so what do you think about that is that code correct does	the loop	51
and then we release both looks ok then we go round the loop we keep going until we've hdr forty seconds is up so what do you think about that is that code correct does	code	150
for the fork on the right in other words they all get blocked so yes there is a chance that all my possibles will will deadlock because all waiting for resource it is never going to be released so oh dear this apparent code on the internet is not smart enough to solve this problem so yes ladies and gentlemen as a series two forty one	block	54
for the fork on the right in other words they all get blocked so yes there is a chance that all my possibles will will deadlock because all waiting for resource it is never going to be released so oh dear this apparent code on the internet is not smart enough to solve this problem so yes ladies and gentlemen as a series two forty one	code	219
student now smarter than the internet ok so we can prove we can show the circumstances in which deadlock is can occur this actually see if we can actually see that occur if we actually run this code in practice so here's here's the same code that i prepared earlier i wanted to get out of this and go to handouts but code	code	194
there we go right go to code	code	24
but i need cs two forty one lectures code right	code	37
p thread	thread	2
ok finally great let's ok off they go oh alright look at this we've run into deadlock where all five were hungry at exactly the same time so in practice causing this is actually actually difficult let me just run it one more time will see if we can generate it so you can see no expense spared on the graphics we've got five philosophers going through the states of either hungry eating or sleeping and yes we run into deadlock again this actually kind of take a look at this code because i want to show you that i actually had to work a little bit hard to make deadlock occur here so i want to reset my group right and let's	code	476
threads word acquire the left hand lock that was interesting is that right now i'm recording this so one of my cpu cores is busy capturing the lecture content the video content so i was actually surprised that so quickly run into deadlock the other thing that i did to try to make it more likely is i'm using micro sleeps too actually sure that we have an opportunity for deadlock many many many more times in the original provider coded only tested this with sleeps for eight seconds or so over forty second window so opportunity for deadlock is is only handful of times order of ten times or so we would like it to be much higher alright so yes i have i can run it in slow motion let's see how we do that	code	432
threads word acquire the left hand lock that was interesting is that right now i'm recording this so one of my cpu cores is busy capturing the lecture content the video content so i was actually surprised that so quickly run into deadlock the other thing that i did to try to make it more likely is i'm using micro sleeps too actually sure that we have an opportunity for deadlock many many many more times in the original provider coded only tested this with sleeps for eight seconds or so over forty second window so opportunity for deadlock is is only handful of times order of ten times or so we would like it to be much higher alright so yes i have i can run it in slow motion let's see how we do that	thread	0
ok, good morning, and good afternoon, and good evening whenever you're watching this video. so welcome to the second recorded video, that's lecture three of cs 241 let's get started where today we are going to look at a day at the c side, so if you wish you can look at the hand out and the code examples or my cs241 lectures repository. so my first little puzzle for you is the following: what do you think the result or the value of this expression will be? and my clue is that p is a character pointer and it initialized to point to the following. so, take five seconds to have a guess, and i'll tell you the answer in a moment	the following	375
ok, good morning, and good afternoon, and good evening whenever you're watching this video. so welcome to the second recorded video, that's lecture three of cs 241 let's get started where today we are going to look at a day at the c side, so if you wish you can look at the hand out and the code examples or my cs241 lectures repository. so my first little puzzle for you is the following: what do you think the result or the value of this expression will be? and my clue is that p is a character pointer and it initialized to point to the following. so, take five seconds to have a guess, and i'll tell you the answer in a moment	code	291
ok, good morning, and good afternoon, and good evening whenever you're watching this video. so welcome to the second recorded video, that's lecture three of cs 241 let's get started where today we are going to look at a day at the c side, so if you wish you can look at the hand out and the code examples or my cs241 lectures repository. so my first little puzzle for you is the following: what do you think the result or the value of this expression will be? and my clue is that p is a character pointer and it initialized to point to the following. so, take five seconds to have a guess, and i'll tell you the answer in a moment	pointer	497
ok, so p is holding the memory location of that string literal, that constant, and inside that memory, we know that actually there's going to be four bytes, the capital s "y, the s,  and the zero byte to say, ""hey, no more bytes please""." this is the end of the c string. so what does this actually going to evaluate to? well, when we pass a strlen in this memory location that's held by p,	memory	24
ok, so p is holding the memory location of that string literal, that constant, and inside that memory, we know that actually there's going to be four bytes, the capital s "y, the s,  and the zero byte to say, ""hey, no more bytes please""." this is the end of the c string. so what does this actually going to evaluate to? well, when we pass a strlen in this memory location that's held by p,	string	48
strlen is going to walk along, reading a byte at a time, until it gets to that zero byte, and then report to us how far it went, and in other words, how many characters are actually in the string. so in this case, it's going to read the s , y, the s, and then the zero byte, and it's going "to say, ""actually i had to read three characters."" so strlen"  is going to evaluate to three. so what is the result of calling p of three? well, in this case, that means that we're going to advance	string	189
to that zero byte at the end. ok, so the result of that expression is zero!  and of course, this is going to be true for most strings, providing we pass strlen a valid memory location, so in other words, if p is a valid pointer to a string. right, so have a think about this. i want to delete my little marks, there we go. right, so let's think about how strlen might work in some different situations.	memory	168
to that zero byte at the end. ok, so the result of that expression is zero!  and of course, this is going to be true for most strings, providing we pass strlen a valid memory location, so in other words, if p is a valid pointer to a string. right, so have a think about this. i want to delete my little marks, there we go. right, so let's think about how strlen might work in some different situations.	string	126
to that zero byte at the end. ok, so the result of that expression is zero!  and of course, this is going to be true for most strings, providing we pass strlen a valid memory location, so in other words, if p is a valid pointer to a string. right, so have a think about this. i want to delete my little marks, there we go. right, so let's think about how strlen might work in some different situations.	pointer	220
if i call strlen with an empty string that still going to be a valid memory location. it's just at the	memory	69
if i call strlen with an empty string that still going to be a valid memory location. it's just at the	string	31
"if i call strlen with an ""at"", then that, of course," "will work, and it says, ""i'm a string of length one,"" and" actually that string of course as you now know takes two bytes. but isn't always going to work. if we pass it an invalid memory location, and here's one that everybody knows for example, null, which is implemented as address zero, then our program will crash. this is not a fault of strlen. if we actually knew about strlen, we would know that it's only guaranteed to work if we pass in a valid location. so strlen isn't broken, it was our incorrect use of strlen, and in this case, strlen attempted to "read a byte, but our processor said, ""hold on a moment," "there is no valid memory at that location,"" and of course" our process will fail.	memory	240
"if i call strlen with an ""at"", then that, of course," "will work, and it says, ""i'm a string of length one,"" and" actually that string of course as you now know takes two bytes. but isn't always going to work. if we pass it an invalid memory location, and here's one that everybody knows for example, null, which is implemented as address zero, then our program will crash. this is not a fault of strlen. if we actually knew about strlen, we would know that it's only guaranteed to work if we pass in a valid location. so strlen isn't broken, it was our incorrect use of strlen, and in this case, strlen attempted to "read a byte, but our processor said, ""hold on a moment," "there is no valid memory at that location,"" and of course" our process will fail.	string	90
"if i call strlen with an ""at"", then that, of course," "will work, and it says, ""i'm a string of length one,"" and" actually that string of course as you now know takes two bytes. but isn't always going to work. if we pass it an invalid memory location, and here's one that everybody knows for example, null, which is implemented as address zero, then our program will crash. this is not a fault of strlen. if we actually knew about strlen, we would know that it's only guaranteed to work if we pass in a valid location. so strlen isn't broken, it was our incorrect use of strlen, and in this case, strlen attempted to "read a byte, but our processor said, ""hold on a moment," "there is no valid memory at that location,"" and of course" our process will fail.	address	336
so how do we find out more about the functions that we want to use inside our functions inside our programs? for example strlen or something else, at which point "i say, ""ok to get the scoop on the actual specification" "of how things are supposed to work, use the man pages!""" and we can access them from the command line on kind of any normal unix system. so for example, let's go have a look at the man pages of strlen.	system	352
there we go right so let's go and have a look will type man of strlen sewing finding the man page of votes and here we are on my mac system, so	type	51
there we go right so let's go and have a look will type man of strlen sewing finding the man page of votes and here we are on my mac system, so	system	133
ok sir let's have a quick review of using kind of file metadata how can we implement the following so that we can check to see if the abc at the current directory is a directory or not so of course we're going to use the static or for that system call for that and here's a directory and we want its result to be put inside that struct	the following	85
ok sir let's have a quick review of using kind of file metadata how can we implement the following so that we can check to see if the abc at the current directory is a directory or not so of course we're going to use the static or for that system call for that and here's a directory and we want its result to be put inside that struct	system	240
the stats dot so the first thing we might want to do is the following why i want to say ok so clearly inside here we want to say let's have a look at the mode bits case so s t mode	the following	56
personally i would put the ok at the beginning as a test before diving in and check values or but you'll see a lot of system code do is actually take that stat and put it directly inside the expression rather than assign it to a local variable ok but if you do that's then great this will work now tell me what would happen if abc was a symbolic link to a directory where the code that we've got right now will report that abc is a directory why because we used just a regular kind of stat and that will follow symbolic links automatically if we actually wanted to find something about the actual symbolic link then we would do things like else tap for example to actually look at the original link and then we could also do things like ass is what is it physical it looks something like is lnk there we go	code	125
personally i would put the ok at the beginning as a test before diving in and check values or but you'll see a lot of system code do is actually take that stat and put it directly inside the expression rather than assign it to a local variable ok but if you do that's then great this will work now tell me what would happen if abc was a symbolic link to a directory where the code that we've got right now will report that abc is a directory why because we used just a regular kind of stat and that will follow symbolic links automatically if we actually wanted to find something about the actual symbolic link then we would do things like else tap for example to actually look at the original link and then we could also do things like ass is what is it physical it looks something like is lnk there we go	system	118
ok right so that's the metadata there what do we got some next what q oh i've just answered the following question right so yeah if i want to find out if it's a symbolic link yet we should use l stat and also let's take all of that and stick it in here so will check to see if that is equal to zero for succeeded and also	the following	92
keep calling open there and never call close there what will you run out of so that's the kind of question where in real code you'll see it working in like testing but the moment you put into production seems to work and then you go home three o'clock in the morning it suddenly starts to fail what's our problem here our problem is that eventually you will run out of file descriptors so feildes right are file descriptors that your process has a limited number of them which is actually by designed to ensure that one process can't take down the whole system let's only give you kind of so many so eventually if we do this then future calls to open door open will fail because there are no spare file scripters and nowhere in the process file descriptor table	code	121
keep calling open there and never call close there what will you run out of so that's the kind of question where in real code you'll see it working in like testing but the moment you put into production seems to work and then you go home three o'clock in the morning it suddenly starts to fail what's our problem here our problem is that eventually you will run out of file descriptors so feildes right are file descriptors that your process has a limited number of them which is actually by designed to ensure that one process can't take down the whole system let's only give you kind of so many so eventually if we do this then future calls to open door open will fail because there are no spare file scripters and nowhere in the process file descriptor table	system	554
to store any new information about new open files ok so this is a standard problem in real programs that we don't release resources and in code reviews make sure that you're not only releasing resources when everything goes fine but also that you're releasing resources when everything does not go fine when there's a say an error occurs and you cannot continue down the normal path make sure that you've released all the resources that	code	139
to store any new information about new open files ok so this is a standard problem in real programs that we don't release resources and in code reviews make sure that you're not only releasing resources when everything goes fine but also that you're releasing resources when everything does not go fine when there's a say an error occurs and you cannot continue down the normal path make sure that you've released all the resources that	resources	122
just so that we can start thinking about how to write good multithreaded code now of course the ideas here can actually be generalized to multiple processes or even multiple machines running on different networks so anyway let's jump in and see what we've got all right so the story so far this does check i'm on laptop mode yet good write the story so far	code	73
just so that we can start thinking about how to write good multithreaded code now of course the ideas here can actually be generalized to multiple processes or even multiple machines running on different networks so anyway let's jump in and see what we've got all right so the story so far this does check i'm on laptop mode yet good write the story so far	thread	64
i'm going to put a new value into my buffer but as i'm only using the sixteen lowest slots here i have to make sure that it blocks is there's no space	block	124
same idea that i've got a separate counter out here to keep track of where i should read the next value from an i'm going to loop around again by playing this bit masking trip trick so that i use the lowest four bits ok so what do we got to actually make sure that we block well in the case that my fix sized ring buffer is full i want my call to send wait here	block	268
to block in other words i'm going to use a counting semaphore for remember that's like a pizza box to actually keep track of how much space is left right and every time we call sam wait we're stealing a slice of pizza ok so this is going to represent the number of free slots or the number of spaces we have left inside our data structure so once that gets down to zero you know that that call will block until it becomes a positive number again in which case great it can scale a pizza slice and then continue	block	3
to block in other words i'm going to use a counting semaphore for remember that's like a pizza box to actually keep track of how much space is left right and every time we call sam wait we're stealing a slice of pizza ok so this is going to represent the number of free slots or the number of spaces we have left inside our data structure so once that gets down to zero you know that that call will block until it becomes a positive number again in which case great it can scale a pizza slice and then continue	a struct	327
after we removed something we are going to increment this this variable by one ok simile let's have a look at the remove side we want to remove to block if there's nothing in there so let's have another counting semaphore another pizza box and this is going to represent then the number of items in my data structure	block	147
after we removed something we are going to increment this this variable by one ok simile let's have a look at the remove side we want to remove to block if there's nothing in there so let's have another counting semaphore another pizza box and this is going to represent then the number of items in my data structure	a struct	305
ok so if that's zero then some weight will block in other words to thread calling that will go to sleep	block	43
ok so if that's zero then some weight will block in other words to thread calling that will go to sleep	thread	67
in other words very first called to remove will block	block	48
hope he said yes the difference however is that you could only our store seven items in before you able before before trying to add anymore was blocked so visually you could imagine that would be a bit like a little train here let me kind of sketch out my circular memory here to do pdq right so i'm pudding values in	memory	265
hope he said yes the difference however is that you could only our store seven items in before you able before before trying to add anymore was blocked so visually you could imagine that would be a bit like a little train here let me kind of sketch out my circular memory here to do pdq right so i'm pudding values in	block	144
if i try to put more than that in ok i'm blocked at this point but at some point i start calling remove so remove will read back that first value and change the out index to be pointing to the next one and of course adds one to the pizza box so now if i've got a thread waiting to add new value it can continue so we have this little train running around where the front of the train is never more than seven items in front of the end	block	41
if i try to put more than that in ok i'm blocked at this point but at some point i start calling remove so remove will read back that first value and change the out index to be pointing to the next one and of course adds one to the pizza box so now if i've got a thread waiting to add new value it can continue so we have this little train running around where the front of the train is never more than seven items in front of the end	a thread	261
if i try to put more than that in ok i'm blocked at this point but at some point i start calling remove so remove will read back that first value and change the out index to be pointing to the next one and of course adds one to the pizza box so now if i've got a thread waiting to add new value it can continue so we have this little train running around where the front of the train is never more than seven items in front of the end	thread	263
ok right so can you tell me what's missing from this code	code	53
right hopefully is hopefully you remember that last time we did this code we put some mutex locks in	code	69
two values to occur at different points inside my ring buffer in other words line three here represents a critical section	section	115
right so i can't have two threads running this line at the same time ok so if i'm going to have two threads trying to add at the same time then i better make sure that one happens	thread	26
the pizza box does not prevent two threads from trying to insert things at the same time it's only purpose is to make sure that there's going to be at least enough space to add those so if i have two threads calling out at the same time and there's two slices pizza left inside my number spaces both threads get to continue if there was just one thread so i only one slice left then one thread would win and the other thread would go hungry and therefore block	block	455
the pizza box does not prevent two threads from trying to insert things at the same time it's only purpose is to make sure that there's going to be at least enough space to add those so if i have two threads calling out at the same time and there's two slices pizza left inside my number spaces both threads get to continue if there was just one thread so i only one slice left then one thread would win and the other thread would go hungry and therefore block	thread	35
some weight does not block at all for either thread and both threads were tried to insert at the same time so they both for example might see the same value of in or this plus plus is not atomic so we may not successfully increment the value correctly so we need to make sure that only one third of the time runs out and the perfect answer that it's a mutex ok and similar over here i can't have two threads trying to remove at the same time so if i cared about performance might actually use two different mutex locks here so this is my pthread mutex lock and simply over here i can use a different lock because these actually are going to occur different parts of my data structure so i've actually got two different kinds of concurrency things i'm worried about here one is the size of my buffer and i'm using the the counting semaphores for that and the other is a critical section and i'm using a mutex locks to protect that	block	21
some weight does not block at all for either thread and both threads were tried to insert at the same time so they both for example might see the same value of in or this plus plus is not atomic so we may not successfully increment the value correctly so we need to make sure that only one third of the time runs out and the perfect answer that it's a mutex ok and similar over here i can't have two threads trying to remove at the same time so if i cared about performance might actually use two different mutex locks here so this is my pthread mutex lock and simply over here i can use a different lock because these actually are going to occur different parts of my data structure so i've actually got two different kinds of concurrency things i'm worried about here one is the size of my buffer and i'm using the the counting semaphores for that and the other is a critical section and i'm using a mutex locks to protect that	a struct	672
some weight does not block at all for either thread and both threads were tried to insert at the same time so they both for example might see the same value of in or this plus plus is not atomic so we may not successfully increment the value correctly so we need to make sure that only one third of the time runs out and the perfect answer that it's a mutex ok and similar over here i can't have two threads trying to remove at the same time so if i cared about performance might actually use two different mutex locks here so this is my pthread mutex lock and simply over here i can use a different lock because these actually are going to occur different parts of my data structure so i've actually got two different kinds of concurrency things i'm worried about here one is the size of my buffer and i'm using the the counting semaphores for that and the other is a critical section and i'm using a mutex locks to protect that	a mutex	350
some weight does not block at all for either thread and both threads were tried to insert at the same time so they both for example might see the same value of in or this plus plus is not atomic so we may not successfully increment the value correctly so we need to make sure that only one third of the time runs out and the perfect answer that it's a mutex ok and similar over here i can't have two threads trying to remove at the same time so if i cared about performance might actually use two different mutex locks here so this is my pthread mutex lock and simply over here i can use a different lock because these actually are going to occur different parts of my data structure so i've actually got two different kinds of concurrency things i'm worried about here one is the size of my buffer and i'm using the the counting semaphores for that and the other is a critical section and i'm using a mutex locks to protect that	section	878
some weight does not block at all for either thread and both threads were tried to insert at the same time so they both for example might see the same value of in or this plus plus is not atomic so we may not successfully increment the value correctly so we need to make sure that only one third of the time runs out and the perfect answer that it's a mutex ok and similar over here i can't have two threads trying to remove at the same time so if i cared about performance might actually use two different mutex locks here so this is my pthread mutex lock and simply over here i can use a different lock because these actually are going to occur different parts of my data structure so i've actually got two different kinds of concurrency things i'm worried about here one is the size of my buffer and i'm using the the counting semaphores for that and the other is a critical section and i'm using a mutex locks to protect that	thread	45
what about condition variables suppose you wanted to make this work on a mac as well could we do it with condition variables and the answer is yes so of course we can so condition variables are more general purpose than counting semaphores and we would replace this same weight with the kind of code that we saw with our cookie eat a code where we check this value safe is equal to zero and if it was we would be calling p three condition wait so are some weight becomes peter condition wait and i'll send post well we'd be using things like broadcast in order to wake up the right condition variable ok right so that's it for question one let's have a look at question two, bye	code	295
say like media slash hollywood and i can put all of my favorite disney films inside here for example ok right so i can very easily talk about other directores on my system and as we saw there's no limits to actually kind of then trying to follow this forever right so that's the idea of of a symbolic link how does the system know that it should treat this piece of text as a symbolic link as opposed to just a regular text file and the answer to that is there's a mode bit there's a mode bit that says this file is actually a symbolic link so you've seen how we made one so from the shell you say ok i want to make a link i want to make a symbolic link and you start off with the target where it should end up so for example if you had a whole load of android sdk 's you might say for example alright so i've got somewhere on my machine say like an install directory and i've got say an android sdk and i may have a whole load of them i might have some things on my home directory called say latest sdk	system	165
and ok and of course i can keep going easter for as long as i want ok so my current directory is changing and each time i look inside the current directory i can see a bunch of files and one of them happens to be a symbolic link ok so how can i detect symbolic links from c code clearly ls can do it it's giving me some hints about these different files so let's do all again there you go you can see that	code	274
ok so we've kind of talked a little bit about this idea before so it could i implement p thread mutex lock just by disabling interrupts on on the cpu so the idea here is that if my code is running on the cpu if i disable interrupts then i cannot be stopped become agent smith out of the matrix that now i own the cpu so no one else can can take it for me so one of the limitations of this first of all that yes we can ensure that we're the only ones going into the critical section if one there is only one cpu	code	181
ok so we've kind of talked a little bit about this idea before so it could i implement p thread mutex lock just by disabling interrupts on on the cpu so the idea here is that if my code is running on the cpu if i disable interrupts then i cannot be stopped become agent smith out of the matrix that now i own the cpu so no one else can can take it for me so one of the limitations of this first of all that yes we can ensure that we're the only ones going into the critical section if one there is only one cpu	section	474
ok so we've kind of talked a little bit about this idea before so it could i implement p thread mutex lock just by disabling interrupts on on the cpu so the idea here is that if my code is running on the cpu if i disable interrupts then i cannot be stopped become agent smith out of the matrix that now i own the cpu so no one else can can take it for me so one of the limitations of this first of all that yes we can ensure that we're the only ones going into the critical section if one there is only one cpu	thread	89
ok so if i control the one and only cpu and i cannot be interrupted then i get to do everything inside the critical section until i give up the cpu ok so providing i don't make any system calls providing i'm just updating my data structure no one can stop me because i disabled into apps	a struct	228
ok so if i control the one and only cpu and i cannot be interrupted then i get to do everything inside the critical section until i give up the cpu ok so providing i don't make any system calls providing i'm just updating my data structure no one can stop me because i disabled into apps	section	116
ok so if i control the one and only cpu and i cannot be interrupted then i get to do everything inside the critical section until i give up the cpu ok so providing i don't make any system calls providing i'm just updating my data structure no one can stop me because i disabled into apps	system	181
ok the second is that i require an here's a big problem here is that actually require sufficient privileges to disable the interrupts and because this is such a powerful operation by default that is disabled for normal user programs we need interrupts in order to make a cpu stop running one thread and start running another in order to handle hardware interrupt you too do to devices iot devices being ready to either take data from the system or give data from the system for example the network card might report that her new packages arrived and here's some data or a disk or solid state disk might report hey i've now finally got the data you can now read this into memory or gpu might ask for more memory more data so there's lots	memory	671
ok the second is that i require an here's a big problem here is that actually require sufficient privileges to disable the interrupts and because this is such a powerful operation by default that is disabled for normal user programs we need interrupts in order to make a cpu stop running one thread and start running another in order to handle hardware interrupt you too do to devices iot devices being ready to either take data from the system or give data from the system for example the network card might report that her new packages arrived and here's some data or a disk or solid state disk might report hey i've now finally got the data you can now read this into memory or gpu might ask for more memory more data so there's lots	thread	292
ok the second is that i require an here's a big problem here is that actually require sufficient privileges to disable the interrupts and because this is such a powerful operation by default that is disabled for normal user programs we need interrupts in order to make a cpu stop running one thread and start running another in order to handle hardware interrupt you too do to devices iot devices being ready to either take data from the system or give data from the system for example the network card might report that her new packages arrived and here's some data or a disk or solid state disk might report hey i've now finally got the data you can now read this into memory or gpu might ask for more memory more data so there's lots	system	438
of reasons why we in over a normal complex system we cannot just disable disable interrupts ok so this	system	43
is one solution to the critical section but like i said it's not a generally useful solution to the critical section we need to find a way to be able to kind of implement these correctly and will talk about some algorithmic concerns about that in the future instead now is what i've got a real challenge for you which is i want to implement a barrier in fact i'm going to give you all the code that you need here it is i just want to implement a barrier that will wait until five threads call this method called this function and i've got to keep track of how many there we go and all i'm going to give you is the following code which uses a counting semaphore so you get to choose how what you would like to implement what you'd like to to initialize is counting semaphore with and all you have to do is rearrange these lines enter the correct order so that's my challenge to you pause this video and see if you can work it out i'll give you the solution next video but before you do that make some brain new brain cell connections and actually think about how you're going to rearrange this code to the actually works by	the following	610
is one solution to the critical section but like i said it's not a generally useful solution to the critical section we need to find a way to be able to kind of implement these correctly and will talk about some algorithmic concerns about that in the future instead now is what i've got a real challenge for you which is i want to implement a barrier in fact i'm going to give you all the code that you need here it is i just want to implement a barrier that will wait until five threads call this method called this function and i've got to keep track of how many there we go and all i'm going to give you is the following code which uses a counting semaphore so you get to choose how what you would like to implement what you'd like to to initialize is counting semaphore with and all you have to do is rearrange these lines enter the correct order so that's my challenge to you pause this video and see if you can work it out i'll give you the solution next video but before you do that make some brain new brain cell connections and actually think about how you're going to rearrange this code to the actually works by	code	389
is one solution to the critical section but like i said it's not a generally useful solution to the critical section we need to find a way to be able to kind of implement these correctly and will talk about some algorithmic concerns about that in the future instead now is what i've got a real challenge for you which is i want to implement a barrier in fact i'm going to give you all the code that you need here it is i just want to implement a barrier that will wait until five threads call this method called this function and i've got to keep track of how many there we go and all i'm going to give you is the following code which uses a counting semaphore so you get to choose how what you would like to implement what you'd like to to initialize is counting semaphore with and all you have to do is rearrange these lines enter the correct order so that's my challenge to you pause this video and see if you can work it out i'll give you the solution next video but before you do that make some brain new brain cell connections and actually think about how you're going to rearrange this code to the actually works by	section	32
is one solution to the critical section but like i said it's not a generally useful solution to the critical section we need to find a way to be able to kind of implement these correctly and will talk about some algorithmic concerns about that in the future instead now is what i've got a real challenge for you which is i want to implement a barrier in fact i'm going to give you all the code that you need here it is i just want to implement a barrier that will wait until five threads call this method called this function and i've got to keep track of how many there we go and all i'm going to give you is the following code which uses a counting semaphore so you get to choose how what you would like to implement what you'd like to to initialize is counting semaphore with and all you have to do is rearrange these lines enter the correct order so that's my challenge to you pause this video and see if you can work it out i'll give you the solution next video but before you do that make some brain new brain cell connections and actually think about how you're going to rearrange this code to the actually works by	thread	480
ok so let's play with race conditions and then fixing with blocks right so what do you think the following code is going to print here we have a counter variable which is global as you can see anybody can reach into it and read it or write it and in fact like a little function here that is going to loop looks like a million times and each time around the loop we're going to implement that counter now the value of eyes a stack variable which means i can create a whole load of threads and each one is going to get his own value of i but they are all picking at this global variable this countered so they're going to share access to that that variable right and then i've got some code on here peter create peter create and then two p thread joins so out of the two p thread joins we print out the value of counter right so what do you think about this code what's it going to print let's give it ago so i need to compile it ok i've compiled it off we go right it did not print out of course two million it we run it it just happy prints out different values each and every time so why do you think that is a key so actually there's two reasons the first one is because it the value that we get depends upon the actual interleaving of my two threads to how they do this increment so even though we plus plus hear	the following	93
ok so let's play with race conditions and then fixing with blocks right so what do you think the following code is going to print here we have a counter variable which is global as you can see anybody can reach into it and read it or write it and in fact like a little function here that is going to loop looks like a million times and each time around the loop we're going to implement that counter now the value of eyes a stack variable which means i can create a whole load of threads and each one is going to get his own value of i but they are all picking at this global variable this countered so they're going to share access to that that variable right and then i've got some code on here peter create peter create and then two p thread joins so out of the two p thread joins we print out the value of counter right so what do you think about this code what's it going to print let's give it ago so i need to compile it ok i've compiled it off we go right it did not print out of course two million it we run it it just happy prints out different values each and every time so why do you think that is a key so actually there's two reasons the first one is because it the value that we get depends upon the actual interleaving of my two threads to how they do this increment so even though we plus plus hear	the loop	353
ok so let's play with race conditions and then fixing with blocks right so what do you think the following code is going to print here we have a counter variable which is global as you can see anybody can reach into it and read it or write it and in fact like a little function here that is going to loop looks like a million times and each time around the loop we're going to implement that counter now the value of eyes a stack variable which means i can create a whole load of threads and each one is going to get his own value of i but they are all picking at this global variable this countered so they're going to share access to that that variable right and then i've got some code on here peter create peter create and then two p thread joins so out of the two p thread joins we print out the value of counter right so what do you think about this code what's it going to print let's give it ago so i need to compile it ok i've compiled it off we go right it did not print out of course two million it we run it it just happy prints out different values each and every time so why do you think that is a key so actually there's two reasons the first one is because it the value that we get depends upon the actual interleaving of my two threads to how they do this increment so even though we plus plus hear	block	59
ok so let's play with race conditions and then fixing with blocks right so what do you think the following code is going to print here we have a counter variable which is global as you can see anybody can reach into it and read it or write it and in fact like a little function here that is going to loop looks like a million times and each time around the loop we're going to implement that counter now the value of eyes a stack variable which means i can create a whole load of threads and each one is going to get his own value of i but they are all picking at this global variable this countered so they're going to share access to that that variable right and then i've got some code on here peter create peter create and then two p thread joins so out of the two p thread joins we print out the value of counter right so what do you think about this code what's it going to print let's give it ago so i need to compile it ok i've compiled it off we go right it did not print out of course two million it we run it it just happy prints out different values each and every time so why do you think that is a key so actually there's two reasons the first one is because it the value that we get depends upon the actual interleaving of my two threads to how they do this increment so even though we plus plus hear	code	107
ok so let's play with race conditions and then fixing with blocks right so what do you think the following code is going to print here we have a counter variable which is global as you can see anybody can reach into it and read it or write it and in fact like a little function here that is going to loop looks like a million times and each time around the loop we're going to implement that counter now the value of eyes a stack variable which means i can create a whole load of threads and each one is going to get his own value of i but they are all picking at this global variable this countered so they're going to share access to that that variable right and then i've got some code on here peter create peter create and then two p thread joins so out of the two p thread joins we print out the value of counter right so what do you think about this code what's it going to print let's give it ago so i need to compile it ok i've compiled it off we go right it did not print out of course two million it we run it it just happy prints out different values each and every time so why do you think that is a key so actually there's two reasons the first one is because it the value that we get depends upon the actual interleaving of my two threads to how they do this increment so even though we plus plus hear	thread	480
the big news flash is that this is not an atomic operation so what we mean by atomic well you enough uranium together no we don't mean that what we mean by atomic here is it is that an atomic operation it behaves as if it completes as one complete operation but that's not true not for plus plus here so instead what is going on we're saying ok read the value of counter add one to it and then right back into memory so there's three distinct stages here	memory	410
we go over to main memory you will see he may maybe i need to read the following four bytes please ok we pull that into a cpu register then we invoke the arithmetic logic unit to add one to our register ok so we've recalculated new value and then we take that bit pattern and we throw it back towards memory here you go memory have a new value the adding one is extremely fast writing to main memory is extremely slow compared to what the cpu can do so of course practice we have levels of cash operating but let's	the following	67
we go over to main memory you will see he may maybe i need to read the following four bytes please ok we pull that into a cpu register then we invoke the arithmetic logic unit to add one to our register ok so we've recalculated new value and then we take that bit pattern and we throw it back towards memory here you go memory have a new value the adding one is extremely fast writing to main memory is extremely slow compared to what the cpu can do so of course practice we have levels of cash operating but let's	memory	19
alright so that's the kind of first idea is that i've got two chefs two threads running as fast as possible really from memory adding on writing it back	memory	120
alright so that's the kind of first idea is that i've got two chefs two threads running as fast as possible really from memory adding on writing it back	thread	72
life would be fine if they did this carefully synchronized but instead you could imagine that are two threads go over and read the same value and then they add one at about the same time and then they write back their new values so instead of increasing the value by two we've only increased it by one you can imagine more extreme variations where one thread is running a bit slow perhaps my cpu keeps on being interrupted because it's being asked to transcode some videos as as i as i'm talking to you and so now the other thread is able to run forward a bit so imagine the following one thread reaches in grabs the number	the following	571
life would be fine if they did this carefully synchronized but instead you could imagine that are two threads go over and read the same value and then they add one at about the same time and then they write back their new values so instead of increasing the value by two we've only increased it by one you can imagine more extreme variations where one thread is running a bit slow perhaps my cpu keeps on being interrupted because it's being asked to transcode some videos as as i as i'm talking to you and so now the other thread is able to run forward a bit so imagine the following one thread reaches in grabs the number	code	456
life would be fine if they did this carefully synchronized but instead you could imagine that are two threads go over and read the same value and then they add one at about the same time and then they write back their new values so instead of increasing the value by two we've only increased it by one you can imagine more extreme variations where one thread is running a bit slow perhaps my cpu keeps on being interrupted because it's being asked to transcode some videos as as i as i'm talking to you and so now the other thread is able to run forward a bit so imagine the following one thread reaches in grabs the number	thread	102
i know it's doing the calculation or at least it's going to get to the calculations soon meanwhile the other thread reaches in grabs the number add one send it back breaches in addison number as well and send it back which anson does like like a million times then our first red wakes up again a few i got cpu again fantastic what was i doing oh yes i was adding one at one right it back so it's just managed to write over all of those results taking years back to a really low number so that is kind of the problem of just letting our threads run without any kind of proper synchronization so i mentioned there were two bugs the other one actually is just an insidious copy paste bug did you spot it ok so we call pthread create here	thread	109
or with the same id address here which means that our second thread id here is actually was never initialized	thread	61
or with the same id address here which means that our second thread id here is actually was never initialized	address	20
so we never actually truly going to wait for that second thread to actually complete case so so we should fix that let's make sure that we are writing into two different two different variables	thread	57
right so i promise we start using p thread mutex locks so here we go let's figure out how we can fix this program alright so xm ideas we can try here first of all let's get our self lock will make it a global so all my programs can see it if i didn't use globals i'd have to pass it around or least pass a pointer around to it right so p three edit musics type i'm going to call it a duck i want to imagine little duck quack quack that's very important little lock and today i'll use the the magic value piece red mutex initializer	type	356
right so i promise we start using p thread mutex locks so here we go let's figure out how we can fix this program alright so xm ideas we can try here first of all let's get our self lock will make it a global so all my programs can see it if i didn't use globals i'd have to pass it around or least pass a pointer around to it right so p three edit musics type i'm going to call it a duck i want to imagine little duck quack quack that's very important little lock and today i'll use the the magic value piece red mutex initializer	thread	36
right so i promise we start using p thread mutex locks so here we go let's figure out how we can fix this program alright so xm ideas we can try here first of all let's get our self lock will make it a global so all my programs can see it if i didn't use globals i'd have to pass it around or least pass a pointer around to it right so p three edit musics type i'm going to call it a duck i want to imagine little duck quack quack that's very important little lock and today i'll use the the magic value piece red mutex initializer	pointer	306
ok how do you feel about this so before doing any work in my data structure i'm going to grab the duck here so how do i do that as a pthread mutex lock and here's the address of my variable	a struct	64
ok how do you feel about this so before doing any work in my data structure i'm going to grab the duck here so how do i do that as a pthread mutex lock and here's the address of my variable	thread	134
ok how do you feel about this so before doing any work in my data structure i'm going to grab the duck here so how do i do that as a pthread mutex lock and here's the address of my variable	address	167
but we never let it go so when the second thread starts and calls preferred mutex locked it's going to be waiting for a very long time an infinite amount of time it never gets that duck that duck has been stolen by the first red and never returned so as a result the second thread will never finish so as a result rp so join in maine will never complete so as a result will never put the counter ok i think we better fix that let's put in their pthread mutex unlock there you go after i finished in my surgery on the data structure i'm going to give the duck back at which point is this anybody else waiting for the duck they too can grab the duck and then carry on	the data structure	513
but we never let it go so when the second thread starts and calls preferred mutex locked it's going to be waiting for a very long time an infinite amount of time it never gets that duck that duck has been stolen by the first red and never returned so as a result the second thread will never finish so as a result rp so join in maine will never complete so as a result will never put the counter ok i think we better fix that let's put in their pthread mutex unlock there you go after i finished in my surgery on the data structure i'm going to give the duck back at which point is this anybody else waiting for the duck they too can grab the duck and then carry on	a struct	520
but we never let it go so when the second thread starts and calls preferred mutex locked it's going to be waiting for a very long time an infinite amount of time it never gets that duck that duck has been stolen by the first red and never returned so as a result the second thread will never finish so as a result rp so join in maine will never complete so as a result will never put the counter ok i think we better fix that let's put in their pthread mutex unlock there you go after i finished in my surgery on the data structure i'm going to give the duck back at which point is this anybody else waiting for the duck they too can grab the duck and then carry on	thread	42
ok and ha who've are yes guess gratulation 's we've managed to make another finished lee complicated program to add up to two million by using now kind of three for threads the main thread which doesn't do much it just delegates like a manager doesn't actually do any work and then two threads which are independently adding up a million but you did notice that actually we don't actually do any of the work in parallel first a thread probably the probably thread one but who knows actual add a million and then when it's finished it releases the duck and so the other thread gets to continue it requires a duck carries on adds a million to it and then unlock the duck ok so	a thread	426
ok and ha who've are yes guess gratulation 's we've managed to make another finished lee complicated program to add up to two million by using now kind of three for threads the main thread which doesn't do much it just delegates like a manager doesn't actually do any work and then two threads which are independently adding up a million but you did notice that actually we don't actually do any of the work in parallel first a thread probably the probably thread one but who knows actual add a million and then when it's finished it releases the duck and so the other thread gets to continue it requires a duck carries on adds a million to it and then unlock the duck ok so	thread	165
maybe we should allow our threads to work in smaller units so what we think we could try here is k let's make a version three right well now i'm going to only acquire my doc for a very short period of time ok so now i'm going to rap each call navigate to before i change the counter	thread	26
k von function three so for a million times we acquire the lock we had wanted to counter and then we unlock the duck ok so let's compile this run it ok it gave us a correct answer and will always give us a correct answer but is now actually a little bit slower do you know why well in this contrived example adding one to a variable is an extremely fast operation compared to a typical program where we've got thousand instructions to do and in a typical program we only want to access this data structure this shared data structure occasionally so we've just managed to modify our original program	a struct	494
which would just increment the counter to now accessing the mutex changing the counter unlocking the mutex so we've actually added a lot more complexity in terms of number of structures that have to be executed for each iteration vanderloop ok so that wasn't didn't make a program any faster and in fact it slowed it down a bit just because we're using their lock in such a fine grained manner but it didn't sure that are two threads could actually carry carry on now and finish it about the same time so now we've got an interleaving of our two threads but we've ensured that the actual change of the data structure only happens in one thread or the other thread at a time	the data structure	598
which would just increment the counter to now accessing the mutex changing the counter unlocking the mutex so we've actually added a lot more complexity in terms of number of structures that have to be executed for each iteration vanderloop ok so that wasn't didn't make a program any faster and in fact it slowed it down a bit just because we're using their lock in such a fine grained manner but it didn't sure that are two threads could actually carry carry on now and finish it about the same time so now we've got an interleaving of our two threads but we've ensured that the actual change of the data structure only happens in one thread or the other thread at a time	a struct	605
which would just increment the counter to now accessing the mutex changing the counter unlocking the mutex so we've actually added a lot more complexity in terms of number of structures that have to be executed for each iteration vanderloop ok so that wasn't didn't make a program any faster and in fact it slowed it down a bit just because we're using their lock in such a fine grained manner but it didn't sure that are two threads could actually carry carry on now and finish it about the same time so now we've got an interleaving of our two threads but we've ensured that the actual change of the data structure only happens in one thread or the other thread at a time	thread	426
my i've got two threads two cpus actually trying to read a right to the same piece piece of memory what if that value was cached or the good news actually is depleted mutex lock takes care of that as well for us that if this cpu supports some caching mechanisms peter mutex lock will ensure that that values are flushed out to main memory if any other cpu wants to read these	memory	92
my i've got two threads two cpus actually trying to read a right to the same piece piece of memory what if that value was cached or the good news actually is depleted mutex lock takes care of that as well for us that if this cpu supports some caching mechanisms peter mutex lock will ensure that that values are flushed out to main memory if any other cpu wants to read these	thread	16
magnets so technically it's called memory fence what memory barrier	memory	35
we're not going to write code that does not explicitly instead we're just kind of allowing the factor period mutex lock makes our world saying again makes our programs be equal to all the process is i've actually	code	25
running at least that's what it appears to be like that the values in memory other values that we expect to see in memory ok with some of course slight slight loss in performance when we do that ok so that's our first example of of contrived example of using petered mutex lock	memory	70
hi ok let's get started and have a look at a little macro problem here so i'm going to macro after called it max takes two parameters and it supposed to calculate the maximum value of a or be alright it uses the ternary operator as lesson be there we turn a oh wait that's not right ok so let's fix this we can see that actually we've got items over the longer route so we could for example swap this to be if is	parameter	123
great is greater than be then we want a otherwise be great so we defined a macro now let's use it perhaps you can tell me what's going to go wrong with this code here i am using it down here with a maximum of ten and five and after that add one so what's the problem here i'll give you five seconds ready go	code	157
in parentheses and in fact we could go further unwrap each potential parameter expansion with parentheses just to make sure that we don't access that the presidents	parameter	69
sorry simple http server and in both these cases you can specify a port number so if we wanted to comment that one up if we wanted to specify a port then i could specify a different part number here so let's choose for example if i try to do a low port number like poor eighty it won't be very happy we got permission denied because i'm not root right now on this system and so port numbers less than a thousand and twenty four restricted they're privileged ports so you have to be an administrative built to listen on those ports so let's not connect on let's not listen on port eighty let's list on say port eighty eighty ok great and off it goes again so now again i can make a connection using my favorite web browser and off we go and see the contents again wait and you'll see this particular	system	364
web browser also prints out who's connecting to it and when and what resources they're requesting so another useful tool is called netcat let's have a look at that case so	resources	69
or mac ports install on a lennox system you might be doing things like a pt install you just need to find a quick google look up will find it anyway so let's look at netcat so netcat behaves a bit like cat except rather than concatenating from files we can send stuff to and from a network connection and by default all we need is a host name airport and after that you can start to describe where you want to make it to listen on a port where they wanted to use tcp or udp etc etc etc so let's try this i will do netcat	system	33
her case so great we've connected i don't have the prompt anymore let me just send some garbage blah blah blah to the server that's listening on that port alright and you'll see that my little web server over here in pythons did not like my message here is is hey bad request and response to my request it sent the following it said ok you i did like you you're as an error code of four hundred	the following	311
her case so great we've connected i don't have the prompt anymore let me just send some garbage blah blah blah to the server that's listening on that port alright and you'll see that my little web server over here in pythons did not like my message here is is hey bad request and response to my request it sent the following it said ok you i did like you you're as an error code of four hundred	code	374
and the protocol that i'd like to use today is http	the protocol	4
have a blank line and there we go ok so this is what the server replied is there's right yeah yes i have that resource for you so it's ok so status code two hundred	code	148
tells me a little bit about itself the date and the contents it's giving back is just plain text that's a mime type and there's going to be twenty one bytes case so after they had as a complete after we see this black line we expect to have twenty one more lights we get twenty one bytes we know we got the whole file so there it is once upon a time	type	111
you'll see that great it's now given me a content type	type	50
subnet can sniff our packets ok so that's a problem they'll be able to sniff your password ok so telnet is barely used today there's a few cases of embedded hardware that might offer a very very simple telnet interface say just for debugging purposes but today tell netizen not installed by default on most machines you have to install it yourself let me show you one still fine example use of telnet and that's not following that there is a telnet server running on the following ip address so let's try connecting to it ok right and off it goes and rather than giving your password prompt and asking me what i'd like to do instead it serves characters with a few delays in	the following	467
subnet can sniff our packets ok so that's a problem they'll be able to sniff your password ok so telnet is barely used today there's a few cases of embedded hardware that might offer a very very simple telnet interface say just for debugging purposes but today tell netizen not installed by default on most machines you have to install it yourself let me show you one still fine example use of telnet and that's not following that there is a telnet server running on the following ip address so let's try connecting to it ok right and off it goes and rather than giving your password prompt and asking me what i'd like to do instead it serves characters with a few delays in	address	484
tcp will automatically assemble any packets will wait for lost packets to be re sent so we just have a nice stream a data stream ok so how do we set one up right so if we're setting up a client all i need to do is first of all i'm going to be lazy and call get address info this does a lot of heavy lifting for me to actually figure out the correct parameters i'm going to send into my next two calls so technically this is not formally required but it does make my life a lot easier the two things which are definitely required is of course ideas a socket then a socket is there abstract object owned by the kernel which allows my code to talk to the outside world to be able to talk to other sockets maybe on this machine but maybe not ok so once i've made a socket and for a client all i need to do is ask it to connect so let's	parameter	349
tcp will automatically assemble any packets will wait for lost packets to be re sent so we just have a nice stream a data stream ok so how do we set one up right so if we're setting up a client all i need to do is first of all i'm going to be lazy and call get address info this does a lot of heavy lifting for me to actually figure out the correct parameters i'm going to send into my next two calls so technically this is not formally required but it does make my life a lot easier the two things which are definitely required is of course ideas a socket then a socket is there abstract object owned by the kernel which allows my code to talk to the outside world to be able to talk to other sockets maybe on this machine but maybe not ok so once i've made a socket and for a client all i need to do is ask it to connect so let's	code	632
tcp will automatically assemble any packets will wait for lost packets to be re sent so we just have a nice stream a data stream ok so how do we set one up right so if we're setting up a client all i need to do is first of all i'm going to be lazy and call get address info this does a lot of heavy lifting for me to actually figure out the correct parameters i'm going to send into my next two calls so technically this is not formally required but it does make my life a lot easier the two things which are definitely required is of course ideas a socket then a socket is there abstract object owned by the kernel which allows my code to talk to the outside world to be able to talk to other sockets maybe on this machine but maybe not ok so once i've made a socket and for a client all i need to do is ask it to connect so let's	address	261
cool connect him ok and again with the socket and connect calls the parameters i need for here are going to come from whatever get address info returns	parameter	68
cool connect him ok and again with the socket and connect calls the parameters i need for here are going to come from whatever get address info returns	address	131
now we might see a little bit of traffic actual packets leaving machine my machine first of all when you call get address info because it's going to convert say a host name to an ip address and of course we'll see packets leaving when we call connect handshake is required between tcp client and server and so the moment you could connect we are going to send out a packet to that server to say hi please will you connect me let's do a handshake let's do our tcp handshake	address	114
right now one surprising thing about get address info is that it can return zero one or more results	address	41
the last entry is actually linked list and trees have my next pointer and that will be no so if you're writing kind of code very lazily or just wanted short simple demo code we can ignore the fact that it returns multiple entries but if you want to write robust code then realize that there may be more than one way to connect to the server for example perhaps the server upper offers an ip four address and an ip six address so you might try both you might try one after another all you might create a whole lot of threads and do it asynchronously and see which one actually kinda connect faster ok so let's	code	119
the last entry is actually linked list and trees have my next pointer and that will be no so if you're writing kind of code very lazily or just wanted short simple demo code we can ignore the fact that it returns multiple entries but if you want to write robust code then realize that there may be more than one way to connect to the server for example perhaps the server upper offers an ip four address and an ip six address so you might try both you might try one after another all you might create a whole lot of threads and do it asynchronously and see which one actually kinda connect faster ok so let's	thread	516
the last entry is actually linked list and trees have my next pointer and that will be no so if you're writing kind of code very lazily or just wanted short simple demo code we can ignore the fact that it returns multiple entries but if you want to write robust code then realize that there may be more than one way to connect to the server for example perhaps the server upper offers an ip four address and an ip six address so you might try both you might try one after another all you might create a whole lot of threads and do it asynchronously and see which one actually kinda connect faster ok so let's	address	396
the last entry is actually linked list and trees have my next pointer and that will be no so if you're writing kind of code very lazily or just wanted short simple demo code we can ignore the fact that it returns multiple entries but if you want to write robust code then realize that there may be more than one way to connect to the server for example perhaps the server upper offers an ip four address and an ip six address so you might try both you might try one after another all you might create a whole lot of threads and do it asynchronously and see which one actually kinda connect faster ok so let's	pointer	62
let's just remind ourselves about what what the entries are ok so our flags is a hint to get address info is to what kind of connection we want do you want ip four ip six or some mixture do we wanted to do something else for us we had there dressed family so that's do we care about excuse me i before versus ib six we have the socket type which is do we care about stream based socket or a datagram another packet light socket the protocol is usually left zero we don't know	type	335
let's just remind ourselves about what what the entries are ok so our flags is a hint to get address info is to what kind of connection we want do you want ip four ip six or some mixture do we wanted to do something else for us we had there dressed family so that's do we care about excuse me i before versus ib six we have the socket type which is do we care about stream based socket or a datagram another packet light socket the protocol is usually left zero we don't know	the protocol	428
let's just remind ourselves about what what the entries are ok so our flags is a hint to get address info is to what kind of connection we want do you want ip four ip six or some mixture do we wanted to do something else for us we had there dressed family so that's do we care about excuse me i before versus ib six we have the socket type which is do we care about stream based socket or a datagram another packet light socket the protocol is usually left zero we don't know	address	93
correctly set up socket address which is going to be great for calls to either connect or blind however see does not allow us to use inheritance so this strat here this socket address address is the simplest kind of socket address and	address	24
and for different kinds for example ip six we can actually have a different kind of a socket structure so that's why we need also to pass in how big is socket address	address	159
so that's why i will see all under casting to this very simple type of struct and also we need to pass just how big are real struct is just as a kind of a way to verify that we're reading the reading and writing bytes correctly in a valid struct	type	63
get address info is a complicated beast it's quite long but it itself doesn't because it calls many other calls including doing their dns look up to convert host name to an ip address it actually has a special way of returning errors rather than returning something with errno it actually returns a non zero value	address	4
ok there's something like gi a great address info	address	37
store error and that gives us a string ok so we'll be seeing that in the actual code that we write also realize that if it returns a non zero value then it means it never actually found as a way to connect and so that result pointer probably hasn't been changed so just assume that it doesn't point to anything valid right ok some other things you need to know so i mentioned ip four or thirty two bit addressing scheme that today if you were to pick up a random packet would discover it's an ip for based packet but we're trying to transition over to a more flexible addressing scheme which is much larger so today we would like to use ip six but is not fully supported by all routers yet so	code	80
store error and that gives us a string ok so we'll be seeing that in the actual code that we write also realize that if it returns a non zero value then it means it never actually found as a way to connect and so that result pointer probably hasn't been changed so just assume that it doesn't point to anything valid right ok some other things you need to know so i mentioned ip four or thirty two bit addressing scheme that today if you were to pick up a random packet would discover it's an ip for based packet but we're trying to transition over to a more flexible addressing scheme which is much larger so today we would like to use ip six but is not fully supported by all routers yet so	string	32
store error and that gives us a string ok so we'll be seeing that in the actual code that we write also realize that if it returns a non zero value then it means it never actually found as a way to connect and so that result pointer probably hasn't been changed so just assume that it doesn't point to anything valid right ok some other things you need to know so i mentioned ip four or thirty two bit addressing scheme that today if you were to pick up a random packet would discover it's an ip for based packet but we're trying to transition over to a more flexible addressing scheme which is much larger so today we would like to use ip six but is not fully supported by all routers yet so	address	402
store error and that gives us a string ok so we'll be seeing that in the actual code that we write also realize that if it returns a non zero value then it means it never actually found as a way to connect and so that result pointer probably hasn't been changed so just assume that it doesn't point to anything valid right ok some other things you need to know so i mentioned ip four or thirty two bit addressing scheme that today if you were to pick up a random packet would discover it's an ip for based packet but we're trying to transition over to a more flexible addressing scheme which is much larger so today we would like to use ip six but is not fully supported by all routers yet so	pointer	225
an invite that like this version six is that it's addressing scheme uses one hundred and twenty eight bits for addressing so that should be big enough for everybody to to one hundred and twenty eight is a lot better than just two to the thirty two which is all we have for ip four ok so in code how do we specify that i'd like an ip for ip six address answer just use this constant constant for the address family if you truly want to just an ip four address then you can just say underscore on it for i p i before ok that's colored out there because he let's try ip six	code	290
an invite that like this version six is that it's addressing scheme uses one hundred and twenty eight bits for addressing so that should be big enough for everybody to to one hundred and twenty eight is a lot better than just two to the thirty two which is all we have for ip four ok so in code how do we specify that i'd like an ip for ip six address answer just use this constant constant for the address family if you truly want to just an ip four address then you can just say underscore on it for i p i before ok that's colored out there because he let's try ip six	address	50
right now speak if ip six addresses here's one which is very useful it's your home address ok say here is your notice	address	26
that it's behaves a lot like a hundred and twenty seven point zero point zero point one this is special ip six address that if you send packets to this address it's not leaving your machine is defined to be your local machine right so let's put this together now let's actually set up a tcp client case so	address	111
i'm going to just quickly review how do you get address info right and i want to	address	48
k just fix this this is actually not going to be a client this is going to be a server right ok and just remind ourselves how we do this so we're going to set up our hints object to say everything we like about this connection but what is important is to remember that there are many fields in that structure that we're not going to touch so let's initialize them all to zero here's one way to do that we can say right memset let's take the address of that struct it is and set multi zero like and how many bytes would you like to set to zero gay so if we use the pointer here that would be incorrect we actually want the size of the whole struct so i could write struct address info	address	441
k just fix this this is actually not going to be a client this is going to be a server right ok and just remind ourselves how we do this so we're going to set up our hints object to say everything we like about this connection but what is important is to remember that there are many fields in that structure that we're not going to touch so let's initialize them all to zero here's one way to do that we can say right memset let's take the address of that struct it is and set multi zero like and how many bytes would you like to set to zero gay so if we use the pointer here that would be incorrect we actually want the size of the whole struct so i could write struct address info	pointer	564
like that all i could just say size of hints so great i've said all to zero now i can start initializing the fields that you actually care about right so we wanted ip four so inside here we can say address family inet by the way there is an inet any which means so if any which means i'll take ip for ip six i just want to serve i don't care about the	address	198
exact mechanism of the ip addresses but today in this problem we care about dinette four so let's use that	address	26
and the socket type well i want stream based so let's specify are correct socket type that's sock stream	type	15
anyway so we've set up request here now i need to go get address info so let's do that right will call get address info and just confusing i only have two results here so we will call this one	address	57
two that's not very large still like this get address	address	46
what so what do we need to hear well first of all we need the ip address i can specify that a string either as	string	94
what so what do we need to hear well first of all we need the ip address i can specify that a string either as	address	65
an actual string like this or i can specify it as a host name so for example like illinois dot edu ok if i do this then there's probably going to be a packet leaving my machine in the next moment to say hey we need to figure out the ip address of this host name can you help me please	string	10
an actual string like this or i can specify it as a host name so for example like illinois dot edu ok if i do this then there's probably going to be a packet leaving my machine in the next moment to say hey we need to figure out the ip address of this host name can you help me please	address	236
now we need the hints so here's the address of my hints	address	36
and finally we need here's the address of that pointer please change this please and it will do so if it successfully manage is to take the information we gave and figure out a way to connect to that server ok so what would we do for each entry here ok so for each entry i would call that i want to suck it and then i'm going to try to connect and i would use the results inside each of these result objects to that list to	address	31
and finally we need here's the address of that pointer please change this please and it will do so if it successfully manage is to take the information we gave and figure out a way to connect to that server ok so what would we do for each entry here ok so for each entry i would call that i want to suck it and then i'm going to try to connect and i would use the results inside each of these result objects to that list to	pointer	47
excuse me do make use of error messages when you get them and do remember to zero out everything inside the hints object otherwise get address info will be scratching his head going i don't understand what you're asking for ok because you're giving me information which just happened to be on the stack and you never set to zero so with that i think it's time for part two in another video by	address	135
ok so let's have a look at this and the first thing we need to notice that it's more complicated but the second thing is that it's kind of similar that we are going to each each of us will have a little flag to say whether we actually want to be inside the critical section so this is the moment where we actually going to start modifying data structures etc when we better be assured that we are the only further process inside that piece of code and so all of our logic to make sure that occurs occurs up here and then notice we've got this shared turn based variable again which will act as our tiebreaker decide who wins now i like to think of the deck a solution as kind of a vapor light english solution because we move the flag up and down and quite a bit and we say look first of all i'm going to express my intent to be inside the critical section but if i see that your flag is also raised then one of us is going to have to be a gentleman and if this turn based variable is currently set to your id then i'm going to defer to you ok so let's learn my flag and will wait while you're doing your stuff	a struct	342
ok so let's have a look at this and the first thing we need to notice that it's more complicated but the second thing is that it's kind of similar that we are going to each each of us will have a little flag to say whether we actually want to be inside the critical section so this is the moment where we actually going to start modifying data structures etc when we better be assured that we are the only further process inside that piece of code and so all of our logic to make sure that occurs occurs up here and then notice we've got this shared turn based variable again which will act as our tiebreaker decide who wins now i like to think of the deck a solution as kind of a vapor light english solution because we move the flag up and down and quite a bit and we say look first of all i'm going to express my intent to be inside the critical section but if i see that your flag is also raised then one of us is going to have to be a gentleman and if this turn based variable is currently set to your id then i'm going to defer to you ok so let's learn my flag and will wait while you're doing your stuff	code	443
ok so let's have a look at this and the first thing we need to notice that it's more complicated but the second thing is that it's kind of similar that we are going to each each of us will have a little flag to say whether we actually want to be inside the critical section so this is the moment where we actually going to start modifying data structures etc when we better be assured that we are the only further process inside that piece of code and so all of our logic to make sure that occurs occurs up here and then notice we've got this shared turn based variable again which will act as our tiebreaker decide who wins now i like to think of the deck a solution as kind of a vapor light english solution because we move the flag up and down and quite a bit and we say look first of all i'm going to express my intent to be inside the critical section but if i see that your flag is also raised then one of us is going to have to be a gentleman and if this turn based variable is currently set to your id then i'm going to defer to you ok so let's learn my flag and will wait while you're doing your stuff	section	266
ok so we're going to keep waiting eventually you'll leave the critical section and then we will raise my flag to say ok i really want to be inside this critical section ok so next time around the loop however even if your flag is raised now it'll be my turn to win that term based variable has been set to me	the loop	192
ok so we're going to keep waiting eventually you'll leave the critical section and then we will raise my flag to say ok i really want to be inside this critical section ok so next time around the loop however even if your flag is raised now it'll be my turn to win that term based variable has been set to me	section	71
so great i can be inside the critical section after i finished i'm going to change this term based variable to point to you meaning that if there is a tie breaker then you get to go forward an i get to wait so do you see how we've satisfied mutual exclusion meaning that only one of us can actually be inside the critical section to the time we've got bounded weight meaning that i don't have to wait for you a fixed number of times	section	38
before i'm allowed to be inside the critical section	section	45
so basically after you've been inside a critical session you become the gentleman you allowed the other thread to go first and finally we have progress meaning that if i'm the only one around that wants to be inside the critical section i don't need to wait	section	229
so basically after you've been inside a critical session you become the gentleman you allowed the other thread to go first and finally we have progress meaning that if i'm the only one around that wants to be inside the critical section i don't need to wait	thread	104
i can go straight in this previous one is important in cases where say i've got one thread or process that needs to be inside the critical section a lot so it might come through this code many many times	code	183
i can go straight in this previous one is important in cases where say i've got one thread or process that needs to be inside the critical section a lot so it might come through this code many many times	section	139
i can go straight in this previous one is important in cases where say i've got one thread or process that needs to be inside the critical section a lot so it might come through this code many many times	thread	84
hundreds or thousands of times and will never see the other process between though these all of these updates so we have to be able to spin through this quickly and get into the critical section without having to wait for the other process to be to want to be inside the critical section so that's decker solution you do not need to remember the exact solution you should be able to recognize it however you don't need to necessary drive it for cs two forty one but you should be able to in an interview situation kind of be able to argue about the purpose and why this exists and how you evaluate these different solutions the last thing i want to talk about is that	section	187
though i mentioned that software implementations of these don't necessarily work because you've got to fight the compiler and you gotta fight the cpu besides the cpu today has instructions like exchange for example	exchange	194
and inside our main method we're going to do we're going to create a whole load of pizza it's ok and make a note of their thread i ds pass in the firework function ok and then after we've done that we will set fireworks equal to one and then will call preconditions signals so we know that is going to wake up one thread	thread	122
now we want to wait for all threads to finish here so i could write a for loop to call p thread join on all of my thread i ds but i could also be lazy in to say ok pthread less exit the main thread	thread	28
so that we never returned from maine so i could call p thread exit here key	thread	55
right so great we've implemented that now actually let's have to think about how we can implement the firework right so what does r firework do k right well we acquire the mutex lock i might impede here just for for sure had so we've got we've got the mutex lock and all threads that run this code again to acquire the same lock	code	293
right so great we've implemented that now actually let's have to think about how we can implement the firework right so what does r firework do k right well we acquire the mutex lock i might impede here just for for sure had so we've got we've got the mutex lock and all threads that run this code again to acquire the same lock	thread	271
and then we say well while fireworks is zero corporate recognition weight in other words if my firework thread starts up here and it starts up early then we're just going to block it for but we're going to ask it to release the mutex lock and lock inside here so go back to the kind of first code remember we created all of the threads initially back when are fireworks variable with zero it's only after we've created all five	block	174
and then we say well while fireworks is zero corporate recognition weight in other words if my firework thread starts up here and it starts up early then we're just going to block it for but we're going to ask it to release the mutex lock and lock inside here so go back to the kind of first code remember we created all of the threads initially back when are fireworks variable with zero it's only after we've created all five	code	292
and then we say well while fireworks is zero corporate recognition weight in other words if my firework thread starts up here and it starts up early then we're just going to block it for but we're going to ask it to release the mutex lock and lock inside here so go back to the kind of first code remember we created all of the threads initially back when are fireworks variable with zero it's only after we've created all five	thread	104
ok so let's get down here ok right so what do we do after this point ok when we escape out of here where a scaping out of here because fireworks is no longer no longer zero and the very first thing we do is call p three condition broadcast in other words ring that fire bell wake everybody up in this might be sleeping inside this condition variable ok so now all five of my threads	thread	375
definitely working up ok so i implement increment the value of fireworks i print out oh and that value and then i decrement it ok so what's going to be the largest value this code will print one two three four five six what do you think so just as a reminder i've got five threads running this and the only way they can escape out of this code is after fireworks is no longer zero so what's the maximum possible value that we might see from this first to run this hundred or thousand to a million times what's the largest integer that would expect here ok so think about that pause this video and make your choice and then we'll see if you're correct ok so we think about this for five seconds and then we'll review the answers	code	175
definitely working up ok so i implement increment the value of fireworks i print out oh and that value and then i decrement it ok so what's going to be the largest value this code will print one two three four five six what do you think so just as a reminder i've got five threads running this and the only way they can escape out of this code is after fireworks is no longer zero so what's the maximum possible value that we might see from this first to run this hundred or thousand to a million times what's the largest integer that would expect here ok so think about that pause this video and make your choice and then we'll see if you're correct ok so we think about this for five seconds and then we'll review the answers	thread	273
ok wait times up so let's let's have a look at the key key detail here the key detail is a mutex lock our mutex lock allows us to reason strongly about the number of threads which are actually running in this code	code	209
ok wait times up so let's let's have a look at the key key detail here the key detail is a mutex lock our mutex lock allows us to reason strongly about the number of threads which are actually running in this code	a mutex	89
ok wait times up so let's let's have a look at the key key detail here the key detail is a mutex lock our mutex lock allows us to reason strongly about the number of threads which are actually running in this code	thread	166
because we've acquired mutex lock means that any other threads that want to run have to also require it so all of these lines of code can only be run by one thread at a time	code	129
because we've acquired mutex lock means that any other threads that want to run have to also require it so all of these lines of code can only be run by one thread at a time	thread	55
if the threads have gone to sleep inside p thread condition wait there only allowed to escape out of that after they reacquired the mutex log so that's the key idea that only one third of the time can be running this piece of code and it allows us to actually reason about this so we know that when we escape out of here the very first thread will see of fireworks value of one because we changed it upstairs in the main method so we implement so we increment it to two case of wig the first escapes out of here will	code	226
if the threads have gone to sleep inside p thread condition wait there only allowed to escape out of that after they reacquired the mutex log so that's the key idea that only one third of the time can be running this piece of code and it allows us to actually reason about this so we know that when we escape out of here the very first thread will see of fireworks value of one because we changed it upstairs in the main method so we implement so we increment it to two case of wig the first escapes out of here will	thread	7
will print out too and then we decrement it down to one again and then we unlock the mutex ok so the next step that comes out of here will only escape out of p three condition wait after we've unlock the mutex so it will also see a value of fireworks of one it also does a big forecast waking everybody up and most are too and so it will print out the value of two etc right and so on the next thread will come out check the condition for the while loop ok that is no longer true so it comes to an does the same thing increments it from one to two and then two to one and then unlocks the mutex which allows the next set to escape it checks the value and so on and so on so right so let's just kind of run this just to kind of prove it right so we have ok compiled it	thread	394
why is my machine slow ok there we go he got out all right and we see every firework every thread wanna see the value of two and we could do that through this strong reasoning thanks to the mutex log	thread	91
that these two lines of code here	code	24
between us deciding the value of fireworks is zero and then calling peter condition wait so if it happened right inside there if that just that moment in time then what's going to happen we've actually called preconditions signal but no thread was yet sleeping no thread was yet blocked inside condition wait ok so was to fix for that and the answer is to actually log on the same mutex here so if i call pete said mutex lock here	block	279
between us deciding the value of fireworks is zero and then calling peter condition wait so if it happened right inside there if that just that moment in time then what's going to happen we've actually called preconditions signal but no thread was yet sleeping no thread was yet blocked inside condition wait ok so was to fix for that and the answer is to actually log on the same mutex here so if i call pete said mutex lock here	thread	237
another thread is acquired mutex or after the all the threads have called pizza hut	thread	8
another thing this code is kind of highlights is that	code	19
that you can create threads but peter create doesn't wait for them to actually start so this this code is an attempt to say ok let's create all these threads and actually we're going to make our own barrier	code	98
that you can create threads but peter create doesn't wait for them to actually start so this this code is an attempt to say ok let's create all these threads and actually we're going to make our own barrier	thread	20
inside here so we won't let anybody go until we've actually created or five threads and also kind of starting up so but this line of actually changing the fireworks to one here could still actually technically occur before this five threads of actually started all we've just simply say is to say ok create them and at some point in the future please run alright so lots of interesting interleavings details there and as you can see this stuff is tricky	thread	76
ok right so this is a fun little challenge what do you think these two lines do ok what's the difference here so i'm copying files and i'm using shell globbing to say ok shell go into the parent directory find me all files that match anything providing it ends with kind of dot c o k the difference between these two lines is the first one creates includes a little at the end so as you know a little bit by itself just means the current directory so what does this code do it copies all of the source code from the parent to my current directory great what about this one ok so what does this do this i've just got two files for example this might expand to dot dot file one dot c and dot dot file two dot su congratulations i've just managed to overwrite file two with the contents of file one so be careful this little got sure has been people in the past and it will bite people again in the future	code	466
right but with that let's change tax actually have a look at a new version of something fun we can do with mmap which is guess what you can use mmap without even having a file to write into so	mmap	107
it's kind of see this here it is right so here's my kind of main method today instead of using with mmap to say hey here's my file descriptor please map this into memory we're going to say actually i want anonymous mapping meaning that it doesn't actually map to any file at all so why might i do this because i can create some shared memory between a child process an apparent process gets so for example let's have four thousand ninety six bytes case that this is going to be the number of bytes we want let's decide how we want to use these bites so we don't need to execute any code here but we do want to be able to read and write to this page of memory and lastly because we're going to fork we do care about changes that i make inside this file to be seen by my child process as well so	memory	163
it's kind of see this here it is right so here's my kind of main method today instead of using with mmap to say hey here's my file descriptor please map this into memory we're going to say actually i want anonymous mapping meaning that it doesn't actually map to any file at all so why might i do this because i can create some shared memory between a child process an apparent process gets so for example let's have four thousand ninety six bytes case that this is going to be the number of bytes we want let's decide how we want to use these bites so we don't need to execute any code here but we do want to be able to read and write to this page of memory and lastly because we're going to fork we do care about changes that i make inside this file to be seen by my child process as well so	code	582
it's kind of see this here it is right so here's my kind of main method today instead of using with mmap to say hey here's my file descriptor please map this into memory we're going to say actually i want anonymous mapping meaning that it doesn't actually map to any file at all so why might i do this because i can create some shared memory between a child process an apparent process gets so for example let's have four thousand ninety six bytes case that this is going to be the number of bytes we want let's decide how we want to use these bites so we don't need to execute any code here but we do want to be able to read and write to this page of memory and lastly because we're going to fork we do care about changes that i make inside this file to be seen by my child process as well so	mmap	100
let's ask nmap for shared memory as well ok so first thing will do with steel quick error check if this returns negative we know we don't have any bytes there now we can actually use this to communicate between the parent and the child so here we go let's call my two two pieces of code here i've got child and parent and see how that works and	memory	26
let's ask nmap for shared memory as well ok so first thing will do with steel quick error check if this returns negative we know we don't have any bytes there now we can actually use this to communicate between the parent and the child so here we go let's call my two two pieces of code here i've got child and parent and see how that works and	code	282
i can directly right into this memory from the child and from the parent i can directly read from it and in this case i'm going to consume each message so all i'm going to do is just after i read from if there is a valid string there that's non there's more than one character then let's print it up and otherwise let's put the termination character right at the very beginning so that i go around this loop 's pass fast as possible every second	memory	31
i can directly right into this memory from the child and from the parent i can directly read from it and in this case i'm going to consume each message so all i'm going to do is just after i read from if there is a valid string there that's non there's more than one character then let's print it up and otherwise let's put the termination character right at the very beginning so that i go around this loop 's pass fast as possible every second	string	221
and soon as i see a message i'm going to print it out so as you can see remote procedure calls i could could be based on top of this mapping if i wished as a way to share share information between a child and a process	a process	209
and also i hope you can see that using nmap i could implement a very easy version of malloc in fact there are debugging versions of malloc where every call to malloc it generates a call to mmap and if we do that we can actually space out all of our different malloc calls just to check to see if the bad code was accidentally writing into two memory outside of the actual the true requested memory region for each model call right so mmap is great have fun with it it's i think one of the coolest things you'll have to play with inside cs two forty one and why that it with that at the end of this lecture by	memory	343
and also i hope you can see that using nmap i could implement a very easy version of malloc in fact there are debugging versions of malloc where every call to malloc it generates a call to mmap and if we do that we can actually space out all of our different malloc calls just to check to see if the bad code was accidentally writing into two memory outside of the actual the true requested memory region for each model call right so mmap is great have fun with it it's i think one of the coolest things you'll have to play with inside cs two forty one and why that it with that at the end of this lecture by	code	304
and also i hope you can see that using nmap i could implement a very easy version of malloc in fact there are debugging versions of malloc where every call to malloc it generates a call to mmap and if we do that we can actually space out all of our different malloc calls just to check to see if the bad code was accidentally writing into two memory outside of the actual the true requested memory region for each model call right so mmap is great have fun with it it's i think one of the coolest things you'll have to play with inside cs two forty one and why that it with that at the end of this lecture by	mmap	189
